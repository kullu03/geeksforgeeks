<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
       <title>Function to check if a singly linked list is palindrome - GeeksforGeeks</title>
       <style type="text/css" media="screen">
          @import url('http://d2o58evtke57tz.cloudfront.net/wp-content/themes/minimoo/style.css');
    </style>
      <link href="http://d2o58evtke57tz.cloudfront.net/wp-content/themes/minimoo/favicon.ico" rel="shortcut icon" />    
    
<!-- This site is optimized with the Yoast WordPress SEO plugin v1.7.1 - https://yoast.com/wordpress/plugins/seo/ -->
<link rel="canonical" href="http://www.geeksforgeeks.org/function-to-check-if-a-singly-linked-list-is-palindrome/" />
<meta property="og:locale" content="en_US" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Function to check if a singly linked list is palindrome - GeeksforGeeks" />
<meta property="og:description" content="Given a singly linked list of characters, write a function that returns true if the given list is palindrome, else false. METHOD 1 (Use a Stack) A simple solution is to use a stack of list nodes. This mainly involves three steps. 1) Traverse the given list from head to tail and push every visited &hellip;" />
<meta property="og:url" content="http://www.geeksforgeeks.org/function-to-check-if-a-singly-linked-list-is-palindrome/" />
<meta property="og:site_name" content="GeeksforGeeks" />
<meta property="article:section" content="Linked Lists" />
<meta property="article:published_time" content="2009-08-13T02:26:29+00:00" />
<meta property="article:modified_time" content="2014-08-05T10:36:47+00:00" />
<meta property="og:updated_time" content="2014-08-05T10:36:47+00:00" />
<meta property="og:image" content="http://geeksforgeeks.org/wp-content/uploads/2009/08/Palindrome-Linked-List.gif" />
<!-- / Yoast WordPress SEO plugin. -->

<link rel='stylesheet' id='wp-quicklatex-format-css'  href='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/wp-quicklatex/css/quicklatex-format.css?ver=4.0.1' type='text/css' media='all' />
<link rel='stylesheet' id='bbp-default-css'  href='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/bbpress/templates/default/css/bbpress.css?ver=2.5.4-5380' type='text/css' media='screen' />
<link rel='stylesheet' id='wp-pagenavi-css'  href='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/wp-pagenavi/pagenavi-css.css?ver=2.70' type='text/css' media='all' />
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-includes/js/jquery/jquery.js?ver=1.11.1'></script>
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-includes/js/jquery/jquery-migrate.min.js?ver=1.2.1'></script>
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/wp-quicklatex/js/wp-quicklatex-frontend.js?ver=1.0'></script>

<!-- Bad Behavior 2.2.16 run time: 1.581 ms -->
<script type="text/javascript">
<!--
function bb2_addLoadEvent(func) {
	var oldonload = window.onload;
	if (typeof window.onload != 'function') {
		window.onload = func;
	} else {
		window.onload = function() {
			oldonload();
			func();
		}
	}
}

bb2_addLoadEvent(function() {
	for ( i=0; i < document.forms.length; i++ ) {
		if (document.forms[i].method == 'post') {
			var myElement = document.createElement('input');
			myElement.setAttribute('type', 'hidden');
			myElement.name = 'bb2_screener_';
			myElement.value = '1417674610 59.108.60.58';
			document.forms[i].appendChild(myElement);
		}
	}
});
// --></script>
		<style type="text/css" id="syntaxhighlighteranchor"></style>
   <meta name="google-site-verification" content="rHK2v8_zzuAZQY8JHAzbllDN8u-aQxcn2Kqnp67Old0" />
</head>

<body>
<!-- o4dI0sCXUgoSONabbd8mbZ4SA3E -->    
    <div id="wrapper">
        <div class="blog-info">
                <h1 class="blog-title">
                <a href="http://www.geeksforgeeks.org" title="GeeksforGeeks">GeeksforGeeks</a>
            </h1>
       
            <div class="blog-description">
                A computer science portal for geeks            </div>
        </div>
        <b><p>  <h2 align="right"> <a href="http://geeksquiz.com/">GeeksQuiz</a></h2> 
   <a href="http://www.geeksforgeeks.org/wp-login.php">Login</a> 
         </p></b>  
         
         <div class="clear"></div>         
              
                     
            <div id="menu">   
                 <ul>
 <li><a href="http://www.geeksforgeeks.org">Home</a></li>
  <li><a href="http://www.geeksforgeeks.org/fundamentals-of-algorithms/">Algorithms</a></li>
 <li><a href="http://www.geeksforgeeks.org/data-structures/">DS</a></li>
  <li><a href="http://www.geeksforgeeks.org/gate-corner/">GATE</a></li>
  <li><a href="http://www.geeksforgeeks.org/about/interview-corner/">Interview Corner</a></li>
  <li><a href="http://www.geeksforgeeks.org/forums/">Q&A</a></li>
  <li><a href="http://www.geeksforgeeks.org/c/">C</a></li>
  <li><a href="http://www.geeksforgeeks.org/c-plus-plus/">C++</a></li>
  <li><a href="http://www.geeksforgeeks.org/java/">Java</a></li>
  <li><a href="http://www.geeksforgeeks.org/books/">Books</a></li>
  <li><a href="http://www.geeksforgeeks.org/contribute/">Contribute</a></li>
  <li><a href="http://www.geeksforgeeks.org/contribute/ask-a-question/">Ask a Q</a></li>
  <li><a href="http://www.geeksforgeeks.org/about/">About</a></li>
            </ul>

               
            <div class="clear"></div>     
        </div>
             <div id="navmenu">
				<ul id="menu" style="padding:0; margin:0;">
						<li class="cat-item cat-item-3"><a href="http://www.geeksforgeeks.org/category/c-arrays/" title="Questions regarding Arrays">Array</a>
</li>	

	<li class="cat-item cat-item-17"><a href="http://www.geeksforgeeks.org/category/bit-magic/" title="View all posts filed under Bit Magic">Bit Magic</a>
</li>
	<li class="cat-item cat-item-14"><a href="http://www.geeksforgeeks.org/category/c-puzzles/" title="View all posts filed under C/C++ Puzzles">C/C++</a>
</li>

<li class="cat-item cat-item-18"><a href="http://www.geeksforgeeks.org/category/articles/" title="View all posts filed under Articles">Articles</a>
</li>

	<li class="cat-item cat-item-67"><a href="http://www.geeksforgeeks.org/category/gfact/" title="View all posts filed under GFacts">GFacts</a>
</li>
	<li class="cat-item cat-item-8"><a href="http://www.geeksforgeeks.org/category/linked-list/" title="Linked List problems">Linked List</a>
</li>
	<li class="cat-item cat-item-66"><a href="http://www.geeksforgeeks.org/category/multiple-choice-question/" title="View all posts filed under MCQ">MCQ</a>

</li>
	<li class="cat-item cat-item-4"><a href="http://www.geeksforgeeks.org/category/c-programs/" title="Miscellaneous">Misc</a>
</li>
	<li class="cat-item cat-item-5"><a href="http://www.geeksforgeeks.org/category/program-output/" title="View all posts filed under Output">Output</a>
</li>
	<li class="cat-item cat-item-7"><a href="http://www.geeksforgeeks.org/category/c-strings/" title="Questions related to strings">String</a>
</li>
	<li class="cat-item cat-item-19"><a href="http://www.geeksforgeeks.org/category/tree/" title="View all posts filed under Trees">Tree</a>
</li>
	<li class="cat-item cat-item-19"><a href="http://www.geeksforgeeks.org/category/graph/" title="View all posts filed under Graph">Graph</a>
</li>
</ul>
        </div>
             <div id="content">	   	
	<div class="post" id="post">
							<div class="post-info">			
					<div class="post-title-info">
						<h2 class="post-title">Function to check if a singly linked list is palindrome</h2>
					</div>			
					<div class="clear"></div>				  
				<div class="post-content" id="post-content">
					<p>Given a singly linked list of characters, write a function that returns true if the given list is palindrome, else false.</p>
<p><img src="http://geeksforgeeks.org/wp-content/uploads/2009/08/Palindrome-Linked-List.gif" alt="Palindrome Linked List" title="Palindrome Linked List" width="450" height="150" class="aligncenter size-full wp-image-1090" /></p>
<p><strong>METHOD 1 (Use a Stack)</strong><br />
A simple solution is to use a stack of list nodes.  This mainly involves three steps.<br />
<strong>1) </strong>Traverse the given list from head to tail and push every visited node to stack.<br />
<strong>2)</strong> Traverse the list again. For every visited node, pop a node from stack and compare data of popped node with currently visited node.<br />
<strong>3)</strong> If all nodes matched, then return true, else false.</p>
<p>Time complexity of above method is O(n), but it requires O(n) extra space.  Following methods solve this with constant extra space.</p>
<p><strong><br />
METHOD 2 (By reversing the list)</strong><br />
This method takes O(n) time and O(1) extra space.<br />
<strong>1)</strong>  Get the middle of the linked list.<br />
<strong>2) </strong> Reverse the second half of the linked list.<br />
<strong>3)</strong>  Check if the first half and second half are identical.<br />
<strong>4) </strong> Construct the original linked list by reversing the second half again and attaching it back to the first half</p>
<p>To divide the list in two halves, method 2 of <a href="http://www.geeksforgeeks.org/write-a-c-function-to-print-the-middle-of-the-linked-list/" target="_blank">this </a>post is used.<br />
When number of nodes are even, the first and second half contain exactly half nodes. The challenging thing in this method is to handle the case when number of nodes are odd.  We don&#8217;t want the middle node as part of any of the lists as we are going to compare them for equality.  For odd case, we use a separate variable &#8216;midnode&#8217;.  </p>
<pre class="brush: cpp; highlight: [16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68]; title: ; notranslate" title="">
/* Program to check if a linked list is palindrome */
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;stdbool.h&gt;

/* Link list node */
struct node
{
    char data;
    struct node* next;
};

void reverse(struct node**);
bool compareLists(struct node*, struct node *);

/* Function to check if given linked list is
  palindrome or not */
bool isPalindrome(struct node *head)
{
    struct node *slow_ptr = head, *fast_ptr = head;
    struct node *second_half, *prev_of_slow_ptr = head;
    struct node *midnode = NULL;  // To handle odd size list
    bool res = true; // initialize result

    if (head!=NULL &amp;&amp; head-&gt;next!=NULL)
    {
        /* Get the middle of the list. Move slow_ptr by 1
          and fast_ptrr by 2, slow_ptr will have the middle
          node */
        while (fast_ptr != NULL &amp;&amp; fast_ptr-&gt;next != NULL)
        {
            fast_ptr = fast_ptr-&gt;next-&gt;next;

            /*We need previous of the slow_ptr for
             linked lists  with odd elements */
            prev_of_slow_ptr = slow_ptr;
            slow_ptr = slow_ptr-&gt;next;
        }


        /* fast_ptr would become NULL when there are even elements in list. 
           And not NULL for odd elements. We need to skip the middle node 
           for odd case and store it somewhere so that we can restore the
           original list*/
        if (fast_ptr != NULL)
        {
            midnode = slow_ptr;
            slow_ptr = slow_ptr-&gt;next;
        }

        // Now reverse the second half and compare it with first half
        second_half = slow_ptr;
        prev_of_slow_ptr-&gt;next = NULL; // NULL terminate first half
        reverse(&amp;second_half);  // Reverse the second half
        res = compareLists(head, second_half); // compare

        /* Construct the original list back */
         reverse(&amp;second_half); // Reverse the second half again
         if (midnode != NULL)  // If there was a mid node (odd size case) which                                                         
                               // was not part of either first half or second half.
         {
            prev_of_slow_ptr-&gt;next = midnode;
            midnode-&gt;next = second_half;
         }
         else  prev_of_slow_ptr-&gt;next = second_half;
    }
    return res;
}

/* Function to reverse the linked list  Note that this
    function may change the head */
void reverse(struct node** head_ref)
{
    struct node* prev   = NULL;
    struct node* current = *head_ref;
    struct node* next;
    while (current != NULL)
    {
        next  = current-&gt;next;
        current-&gt;next = prev;
        prev = current;
        current = next;
    }
    *head_ref = prev;
}

/* Function to check if two input lists have same data*/
bool compareLists(struct node* head1, struct node *head2)
{
    struct node* temp1 = head1;
    struct node* temp2 = head2;

    while (temp1 &amp;&amp; temp2)
    {
        if (temp1-&gt;data == temp2-&gt;data)
        {
            temp1 = temp1-&gt;next;
            temp2 = temp2-&gt;next;
        }
        else return 0;
    }

    /* Both are empty reurn 1*/
    if (temp1 == NULL &amp;&amp; temp2 == NULL)
        return 1;

    /* Will reach here when one is NULL
      and other is not */
    return 0;
}

/* Push a node to linked list. Note that this function
  changes the head */
void push(struct node** head_ref, char new_data)
{
    /* allocate node */
    struct node* new_node =
        (struct node*) malloc(sizeof(struct node));

    /* put in the data  */
    new_node-&gt;data  = new_data;

    /* link the old list off the new node */
    new_node-&gt;next = (*head_ref);

    /* move the head to pochar to the new node */
    (*head_ref)    = new_node;
}

// A utility function to print a given linked list
void printList(struct node *ptr)
{
    while (ptr != NULL)
    {
        printf(&quot;%c-&gt;&quot;, ptr-&gt;data);
        ptr = ptr-&gt;next;
    }
    printf(&quot;NULL\n&quot;);
}


/* Drier program to test above function*/
int main()
{
    /* Start with the empty list */
    struct node* head = NULL;
    char str[] = &quot;abacaba&quot;;
    int i;

    for (i = 0; str[i] != '&#92;&#48;'; i++)
    {
       push(&amp;head, str[i]);
       printList(head);
       isPalindrome(head)? printf(&quot;Is Palindrome\n\n&quot;):
                           printf(&quot;Not Palindrome\n\n&quot;);
    }

    return 0;
}
</pre>
<p>Output:
<pre>a->NULL
Palindrome

b->a->NULL
Not Palindrome

a->b->a->NULL
Is Palindrome

c->a->b->a->NULL
Not Palindrome

a->c->a->b->a->NULL
Not Palindrome

b->a->c->a->b->a->NULL
Not Palindrome

a->b->a->c->a->b->a->NULL
Is Palindrome</pre>
<p>Time Complexity O(n)<br />
Auxiliary Space: O(1)</p>
<p></br><br />
<strong>METHOD 3 (Using Recursion)</strong><br />
Use two pointers left and right. Move right and left using recursion and check for following in each recursive call.<br />
1) Sub-list is palindrome.<br />
2) Value at current left and right are matching.</p>
<p>If both above conditions are true then return true.</p>
<p>The idea is to use function call stack as container. Recursively traverse till the end of list. When we return from last NULL, we will be at last node. The last node to be compared with first node of list.</p>
<p>In order to access first node of list, we need list head to be available in the last call of recursion. Hence we pass head also to the recursive function. If they both match we need to compare (2, n-2) nodes. Again when recursion falls back to (n-2)nd node, we need reference to 2nd node from head. We advance the head pointer in previous call, to refer to next node in the list.</p>
<p>However, the trick in identifying double pointer. Passing single pointer is as good as pass-by-value, and we will pass the same pointer again and again. We need to pass the address of head pointer for reflecting the changes in parent recursive calls.</p>
<p>Thanks to <a href="http://geeksforgeeks.org/?p=1072#comment-864">Sharad Chandra</a> for suggesting this approach.</p>
<pre class="brush: cpp; highlight: [13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39]; title: ; notranslate" title="">
// Recursive program to check if a given linked list is palindrome
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;

/* Link list node */
struct node
{
    char data;
    struct node* next;
};

// Initial parameters to this function are &amp;head and head
bool isPalindromeUtil(struct node **left, struct  node *right)
{
   /* stop recursion when right becomes NULL */
   if (right == NULL)
      return true;

   /* If sub-list is not palindrome then no need to
       check for current left and right, return false */
   bool isp = isPalindromeUtil(left, right-&gt;next);
   if (isp == false)
      return false;

   /* Check values at current left and right */
   bool isp1 = (right-&gt;data == (*left)-&gt;data);

   /* Move left to next node */
   *left = (*left)-&gt;next;

   return isp1;
}

// A wrapper over isPalindromeUtil()
bool isPalindrome(struct node *head)
{
   isPalindromeUtil(&amp;head, head);
}

/* Push a node to linked list. Note that this function
  changes the head */
void push(struct node** head_ref, char new_data)
{
    /* allocate node */
    struct node* new_node =
            (struct node*) malloc(sizeof(struct node));

    /* put in the data  */
    new_node-&gt;data  = new_data;

    /* link the old list off the new node */
    new_node-&gt;next = (*head_ref);

    /* move the head to pochar to the new node */
    (*head_ref)    = new_node;
}

// A utility function to print a given linked list
void printList(struct node *ptr)
{
    while (ptr != NULL)
    {
        printf(&quot;%c-&gt;&quot;, ptr-&gt;data);
        ptr = ptr-&gt;next;
    }
    printf(&quot;NULL\n&quot;);
}

/* Drier program to test above function*/
int main()
{
    /* Start with the empty list */
    struct node* head = NULL;
    char str[] = &quot;abacaba&quot;;
    int i;

    for (i = 0; str[i] != '&#92;&#48;'; i++)
    {
       push(&amp;head, str[i]);
       printList(head);
       isPalindrome(head)? printf(&quot;Is Palindrome\n\n&quot;):
                           printf(&quot;Not Palindrome\n\n&quot;);
    }

    return 0;
}
</pre>
<p>Output:
<pre>a->NULL
Not Palindrome

b->a->NULL
Not Palindrome

a->b->a->NULL
Is Palindrome

c->a->b->a->NULL
Not Palindrome

a->c->a->b->a->NULL
Not Palindrome

b->a->c->a->b->a->NULL
Not Palindrome

a->b->a->c->a->b->a->NULL
Is Palindrome</pre>
<p>Time Complexity: O(n)<br />
Auxiliary Space: O(n) if Function Call Stack size is considered, otherwise O(1).</p>
<p>Please comment if you find any bug in the programs/algorithms or a better way to do the same. </p>
		
&nbsp;
&nbsp;
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle"
     style="display:inline-block;width:336px;height:280px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="4061219431"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>



&nbsp;
&nbsp;
&nbsp;
<h3>Related Topics:</h3><ul><li><a href="http://www.geeksforgeeks.org/maximum-sum-linked-list-two-sorted-linked-lists-common-nodes/" title="Construct a Maximum Sum Linked List out of two Sorted Linked Lists having some Common nodes">Construct a Maximum Sum Linked List out of two Sorted Linked Lists having some Common nodes</a></li><li><a href="http://www.geeksforgeeks.org/given-linked-list-reverse-alternate-nodes-append-end/" title="Given a linked list, reverse alternate nodes and append at the end">Given a linked list, reverse alternate nodes and append at the end</a></li><li><a href="http://www.geeksforgeeks.org/pairwise-swap-elements-of-a-given-linked-list-by-changing-links/" title="Pairwise swap elements of a given linked list by changing links">Pairwise swap elements of a given linked list by changing links</a></li><li><a href="http://www.geeksforgeeks.org/self-organizing-list-set-1-introduction/" title="Self Organizing List | Set 1 (Introduction)">Self Organizing List | Set 1 (Introduction)</a></li><li><a href="http://www.geeksforgeeks.org/merge-a-linked-list-into-another-linked-list-at-alternate-positions/" title="Merge a linked list into another linked list at alternate positions">Merge a linked list into another linked list at alternate positions</a></li><li><a href="http://www.geeksforgeeks.org/quicksort-on-singly-linked-list/" title="QuickSort on Singly Linked List">QuickSort on Singly Linked List</a></li><li><a href="http://www.geeksforgeeks.org/delete-n-nodes-after-m-nodes-of-a-linked-list/" title="Delete N nodes after M nodes of a linked list">Delete N nodes after M nodes of a linked list</a></li><li><a href="http://www.geeksforgeeks.org/design-a-stack-with-find-middle-operation/" title="Design a stack with operations on middle element">Design a stack with operations on middle element</a></li></ul>
<p></p> 
<div>
<iframe src="http://www.facebook.com/plugins/like.php?href=http%3A%2F%2Fwww.geeksforgeeks.org%2Ffunction-to-check-if-a-singly-linked-list-is-palindrome%2F&layout=button_count&show_faces=false&width=90&action=like&colorscheme=light" scrolling="no" frameborder="0" allowTransparency="true" style="border:none; overflow:hidden; width:90px; height:20px"></iframe>
<a href="http://twitter.com/share" class="twitter-share-button" data-url="http://www.geeksforgeeks.org/function-to-check-if-a-singly-linked-list-is-palindrome/" data-text="Function to check if a singly linked list is palindrome" data-count="horizontal" data-via="jakerutter">Tweet</a><script type="text/javascript" src="http://platform.twitter.com/widgets.js"></script>
<g:plusone size="medium" href="http://www.geeksforgeeks.org/function-to-check-if-a-singly-linked-list-is-palindrome/"></g:plusone>
<!-- Place this render call where appropriate -->
<script type="text/javascript">
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script></div>





				</div>		  
			</div> <!-- end post main -->					
			<div class="post-meta">
				<div class="left"></div>				
				<div class="clear"></div>
			</div>			
        
			<div class="comments-main">		
 <b>Writing code in comment?</b> Please use <b><a href="http://ideone.com/">ideone.com</a></b> and share the link here.
				
<div id="disqus_thread">
            <div id="dsq-content">


            <ul id="dsq-comments">
                    <li class="comment even thread-even depth-1" id="dsq-comment-34836">
        <div id="dsq-comment-header-34836" class="dsq-comment-header">
            <cite id="dsq-cite-34836">
https://www.facebook.com/?q=#/jambotkar?ref=tn_tnmn                <span id="dsq-author-user-34836">AMIT JAMBOTKAR</span>
            </cite>
        </div>
        <div id="dsq-comment-body-34836" class="dsq-comment-body">
            <div id="dsq-comment-message-34836" class="dsq-comment-message"><p>METHOD 1:JAVA IMPLEMENTATION</p>
<p>public class LinkedList implements Cloneable{</p>
<p>	Node head = null;</p>
<p>	Node top=null;</p>
<p>	  class Node {</p>
<p>	T value;</p>
<p>	Node nextReference;</p>
<p>	public Node(T value) {</p>
<p>		this.value = value;</p>
<p>		this.nextReference = null;</p>
<p>	}</p>
<p>	public Node(T value, Node ref) {</p>
<p>		this.value = value;</p>
<p>		this.nextReference = ref;</p>
<p>	}</p>
<p>	public Node() {</p>
<p>		// TODO Auto-generated constructor stub</p>
<p>	}</p>
<p>	public T getValue() {</p>
<p>		return value;</p>
<p>	}</p>
<p>	public void setValue(T value) {</p>
<p>		this.value = value;</p>
<p>	}</p>
<p>	public Node getNextReference() {</p>
<p>		return nextReference;</p>
<p>	}</p>
<p>	public void setNextReference(Node nextReference) {</p>
<p>		this.nextReference = nextReference;</p>
<p>	}</p>
<p>}</p>
<p>	 void push(E value){</p>
<p>		if(top==null){</p>
<p>			top=new Node(value);</p>
<p>			return;</p>
<p>		}  </p>
<p>		top=new Node(value,top);</p>
<p>	  }</p>
<p>	 public  Node pop(){</p>
<p>		 Node ref=null;</p>
<p>			if(top==null){</p>
<p>				return null;</p>
<p>			}  </p>
<p>			ref=top;</p>
<p>			top=top.getNextReference();</p>
<p>			return ref;</p>
<p>		  } </p>
<p>	 void addAtlast(E value){</p>
<p>		 Node node=head;</p>
<p>			if(head==null){</p>
<p>				head=new Node(value);</p>
<p>				return;</p>
<p>			}</p>
<p>			while(node.getNextReference()!=null){</p>
<p>				node=node.getNextReference();</p>
<p>			}</p>
<p>			node.setNextReference(new Node(value));</p>
<p>		  }</p>
<p>	  public boolean checkPalindromeUsingStack(){</p>
<p>			 LinkedList stack=new   LinkedList ();</p>
<p>			 Node node=head;</p>
<p>			 Node node1=head;</p>
<p>			 while(node!=null){</p>
<p>				 stack.push(node.getValue());</p>
<p>				 node=node.getNextReference();	 </p>
<p>			 }</p>
<p>			 while(node1!=null ){</p>
<p>				 E value=stack.pop().value;</p>
<p>				 System.out.println(value);</p>
<p>				if(!value.equals(node1.getValue())) {</p>
<p>					return false;</p>
<p>				}</p>
<p>				 node1=node1.getNextReference();	 </p>
<p>			 } </p>
<p>			 if(node==null &amp;&amp; stack.top==null){</p>
<p>				 return true;	 </p>
<p>			 }</p>
<p>			 return false;</p>
<p>		 }</p>
<p>	public static void main(String[] args) {</p>
<p>		LinkedList linkedList = new LinkedList();</p>
<p>		linkedList.addAtlast(&#8220;1&#8243;);</p>
<p>		linkedList.addAtlast(&#8220;1&#8243;);</p>
<p>		linkedList.addAtlast(&#8220;1&#8243;);</p>
<p>		linkedList.addAtlast(&#8220;5&#8243;);</p>
<p>		linkedList.addAtlast(&#8220;1&#8243;);</p>
<p>		linkedList.addAtlast(&#8220;1&#8243;);</p>
<p>		linkedList.addAtlast(&#8220;1&#8243;);</p>
<p>	if(linkedList.checkPalindromeUsingStack() )	</p>
<p>		System.out.println(&#8220;ITS PALINDROME&#8221;);</p>
<p>	else</p>
<p>	System.out.println(&#8220;ITS NOT A PALINDROME&#8221;);</p>
<p>	}</p>
<p>}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-34831">
        <div id="dsq-comment-header-34831" class="dsq-comment-header">
            <cite id="dsq-cite-34831">
https://www.facebook.com/?q=#/jambotkar?ref=tn_tnmn                <span id="dsq-author-user-34831">AMIT JAMBOTKAR</span>
            </cite>
        </div>
        <div id="dsq-comment-body-34831" class="dsq-comment-body">
            <div id="dsq-comment-message-34831" class="dsq-comment-message"><p>Method 2: Implementation In java</p>
<p>boolean isPalindromeUsingSublist(){</p>
<p>	 Node fastPointer=head;</p>
<p>	 Node prevSlowPointer=null;</p>
<p>		Node slowPointer=head;</p>
<p>		Node midNode=null;</p>
<p>		Node secondHalf=null;</p>
<p>		while(fastPointer!=null &amp;&amp; fastPointer.getNextReference()!=null  ){//12345</p>
<p>			prevSlowPointer=slowPointer;</p>
<p>			slowPointer=slowPointer.getNextReference();//23</p>
<p>			fastPointer=fastPointer.getNextReference().getNextReference();//35</p>
<p>			}</p>
<p>		if(fastPointer!=null){</p>
<p>			midNode=slowPointer;</p>
<p>			slowPointer=slowPointer.getNextReference();</p>
<p>		}</p>
<p>		secondHalf=slowPointer;</p>
<p>		prevSlowPointer.setNextReference(null);</p>
<p>		secondHalf=	reversingLinkedListForpal(secondHalf);</p>
<p>		boolean flag=compareLists(head,secondHalf);</p>
<p>		secondHalf=reversingLinkedListForpal(secondHalf);</p>
<p>		if(fastPointer!=null){</p>
<p>			prevSlowPointer.setNextReference(midNode)	;</p>
<p>			midNode.setNextReference(secondHalf);</p>
<p>		}else{</p>
<p>			prevSlowPointer.setNextReference(secondHalf);</p>
<p>		}</p>
<p>	return flag; </p>
<p> }</p>
<p> boolean compareLists(Node head1, Node head2)</p>
<p> {</p>
<p>	 Node temp1 = head1;</p>
<p>	 Node temp2 = head2;</p>
<p>     while (temp1!=null &amp;&amp; temp2!=null)</p>
<p>     {</p>
<p>         if (temp1.getValue() .equals(temp2.getValue()) )</p>
<p>         {</p>
<p>             temp1 = temp1.getNextReference();</p>
<p>             temp2 = temp2.getNextReference();</p>
<p>         }</p>
<p>         else return false;</p>
<p>     }</p>
<p>     if (temp1 == null &amp;&amp; temp2 == null)</p>
<p>         return true;</p>
<p>     return false;</p>
<p> }</p>
<p> Node reversingLinkedListForpal(Node head){</p>
<p>		Node prev   = null;</p>
<p>		Node current = head;</p>
<p>		Node next=null;</p>
<p>	    while (current != null)</p>
<p>	    {</p>
<p>	        next  = current.getNextReference(); </p>
<p>	        current.setNextReference(prev) ;//1 null   2 1 null 3 2 1 null</p>
<p>	        prev = current;  //1 null  2 1 null</p>
<p>	        current = next; // 2 3   3 null</p>
<p>	    }</p>
<p>	   return prev;</p>
<p>		}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-32659">
        <div id="dsq-comment-header-32659" class="dsq-comment-header">
            <cite id="dsq-cite-32659">
                <span id="dsq-author-user-32659">cruser11232</span>
            </cite>
        </div>
        <div id="dsq-comment-body-32659" class="dsq-comment-body">
            <div id="dsq-comment-message-32659" class="dsq-comment-message"><p>A crude method below:<br />
list * Compare( list * head, list * head1,int *i)<br />
{<br />
    list * p =head;<br />
    if(head-&gt;next)<br />
    {<br />
        ++(*i);<br />
        head1= Compare(head-&gt;next,head1,i);<br />
    }<br />
    if(head1 &amp;&amp; (p-&gt;a==head1-&gt;a))<br />
    {<br />
        head1= head1-&gt;next;<br />
        (*i)&#8211;;<br />
        return head1;<br />
    }<br />
    else<br />
        return NULL;<br />
}</p>
<p>both head and head1 points to head node. if i is 0 its a palindrome..</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-32277">
        <div id="dsq-comment-header-32277" class="dsq-comment-header">
            <cite id="dsq-cite-32277">
                <span id="dsq-author-user-32277">Himanshu Dagar</span>
            </cite>
        </div>
        <div id="dsq-comment-body-32277" class="dsq-comment-body">
            <div id="dsq-comment-message-32277" class="dsq-comment-message"><p>but there is no need no taking extra variable ispl</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-32274">
        <div id="dsq-comment-header-32274" class="dsq-comment-header">
            <cite id="dsq-cite-32274">
                <span id="dsq-author-user-32274">Himanshu Dagar</span>
            </cite>
        </div>
        <div id="dsq-comment-body-32274" class="dsq-comment-body">
            <div id="dsq-comment-message-32274" class="dsq-comment-message"><p>Very High Concept is required in understanding even the parameters of recursive function<br />
thanks for providing this<br />
i learnt a lot frm this</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-31468">
        <div id="dsq-comment-header-31468" class="dsq-comment-header">
            <cite id="dsq-cite-31468">
                <span id="dsq-author-user-31468">zealfire</span>
            </cite>
        </div>
        <div id="dsq-comment-body-31468" class="dsq-comment-body">
            <div id="dsq-comment-message-31468" class="dsq-comment-message"><p>just need verification whether checking for palindrome in case of strings will work in this way:</p>
<p>//link</p>
<p><a href="http://ideone.com/bfTpf4" rel="nofollow">http://ideone.com/bfTpf4</a></p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-31235">
        <div id="dsq-comment-header-31235" class="dsq-comment-header">
            <cite id="dsq-cite-31235">
                <span id="dsq-author-user-31235">SudhanshuAanand</span>
            </cite>
        </div>
        <div id="dsq-comment-body-31235" class="dsq-comment-body">
            <div id="dsq-comment-message-31235" class="dsq-comment-message"><p>Another way could be(This is a method using only single iteration):<br />
1. Add to the top of stack till the mid of the linked list is reached(using fast and slow).<br />
2. If fast.next is null then:<br />
a) Until the stack is empty do:<br />
    i) pop from stack check against slow<br />
    ii) slow = slow.next<br />
3. else<br />
a) slow = pop()<br />
b) Until the stack is empty do:<br />
    i) pop from the stack check against slow<br />
    ii) slow = slow.next</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-31060">
        <div id="dsq-comment-header-31060" class="dsq-comment-header">
            <cite id="dsq-cite-31060">
                <span id="dsq-author-user-31060">Narendra</span>
            </cite>
        </div>
        <div id="dsq-comment-body-31060" class="dsq-comment-body">
            <div id="dsq-comment-message-31060" class="dsq-comment-message"><p>Solution 3 seems to change the head of the list .. Plz have a look at the below </p>
<p>int checkListIsPallendrome(SList *node)<br />
{<br />
    static int i=1;</p>
<p>    if(!node) return i=i&amp;1;<br />
    checkListIsPallendrome(node-&gt;next);</p>
<p>    static SList *node1 = NULL;<br />
    if(node1 == NULL)<br />
        node1=*getSlistRoot();</p>
<p>    if(node-&gt;data != node1-&gt;data)<br />
        return i=i&amp;0;<br />
    node1=node1-&gt;next;</p>
<p>    return i=i&amp;1;<br />
}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-28561">
        <div id="dsq-comment-header-28561" class="dsq-comment-header">
            <cite id="dsq-cite-28561">
                <span id="dsq-author-user-28561">Pawan Kumar Gupta</span>
            </cite>
        </div>
        <div id="dsq-comment-body-28561" class="dsq-comment-body">
            <div id="dsq-comment-message-28561" class="dsq-comment-message"><p>HI, I need comments or suggestion for this approach. Thanks.</p>
<p>head=first;</p>
<p>boolean isPalindrome(Node node)<br />
{<br />
  if (node == null)<br />
    return;<br />
ispalindrome(node.next);</p>
<p>if (head.data != node.data)<br />
  return false;<br />
else<br />
   head = head.next;<br />
if(head==node )<br />
return true;<br />
}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-27436">
        <div id="dsq-comment-header-27436" class="dsq-comment-header">
            <cite id="dsq-cite-27436">
                <span id="dsq-author-user-27436">Max</span>
            </cite>
        </div>
        <div id="dsq-comment-body-27436" class="dsq-comment-body">
            <div id="dsq-comment-message-27436" class="dsq-comment-message"><p>How about going to the middle of the list and then starting the recursive call till the end, and then trace back? Will need half stack space, and reduce redundant comparisons.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-2" id="dsq-comment-33012">
        <div id="dsq-comment-header-33012" class="dsq-comment-header">
            <cite id="dsq-cite-33012">
                <span id="dsq-author-user-33012">niks</span>
            </cite>
        </div>
        <div id="dsq-comment-body-33012" class="dsq-comment-body">
            <div id="dsq-comment-message-33012" class="dsq-comment-message"><p>Hi Max,</p>
<p>Could you elaborate on the method that you are talking about?</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</li><!-- #comment-## -->
    <li class="comment byuser comment-author-jeevan odd alt thread-even depth-1" id="dsq-comment-25008">
        <div id="dsq-comment-header-25008" class="dsq-comment-header">
            <cite id="dsq-cite-25008">
                <span id="dsq-author-user-25008">jeevan</span>
            </cite>
        </div>
        <div id="dsq-comment-body-25008" class="dsq-comment-body">
            <div id="dsq-comment-message-25008" class="dsq-comment-message"><p>How about this? </p>
<p>private static boolean isPalindrome(Node&lt;String&gt; n) {<br />
		if(n==null) return true;<br />
		Node&lt;String&gt; prev = n;<br />
		Node&lt;String&gt; curr = n;</p>
<p>		while(curr.next != null){<br />
			prev = curr;<br />
			curr = curr.next;<br />
		}</p>
<p>		if(prev == null) return true;</p>
<p>		if(n.key.equals(curr.key)){<br />
			prev.next = null;<br />
			return isPalindrome(n.next);<br />
		}else{<br />
			return false;<br />
		}<br />
	}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-hemanthreddy even thread-odd thread-alt depth-1" id="dsq-comment-24693">
        <div id="dsq-comment-header-24693" class="dsq-comment-header">
            <cite id="dsq-cite-24693">
                <span id="dsq-author-user-24693">hemanthreddy</span>
            </cite>
        </div>
        <div id="dsq-comment-body-24693" class="dsq-comment-body">
            <div id="dsq-comment-message-24693" class="dsq-comment-message"><pre> <code language="C">
struct node * is_palindrome(struct node *front,struct node *back)
{
	if(back-&gt;link)
	{
		if( (front = is_palindrome(front,back-&gt;link)) &amp;&amp; front &amp;&amp; (front-&gt;data == back-&gt;data) )
			return (front-&gt;link) ? (front-&gt;link) : (front);
		else
			return 0;
	}
	return (front-&gt;data == back-&gt;data) ? ( (front-&gt;link) ? (front-&gt;link) : (front) ) : 0;
}
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-geeksforgeeks bypostauthor odd alt thread-even depth-1" id="dsq-comment-21820">
        <div id="dsq-comment-header-21820" class="dsq-comment-header">
            <cite id="dsq-cite-21820">
                <span id="dsq-author-user-21820">GeeksforGeeks</span>
            </cite>
        </div>
        <div id="dsq-comment-body-21820" class="dsq-comment-body">
            <div id="dsq-comment-message-21820" class="dsq-comment-message"><p>@All: We have made following changes to this post<br />
&#8230;Added stack based method as method 1.<br />
&#8230;Fixed bugs in reverse() based method and simplified it.  This method is now Method 2.<br />
&#8230;Added more explanation to recursive method and added a wrapper function so that the original list doesn&#8217;t change. This method is now method 3.</p>
<p>We sincerely appreciate your comments and inputs.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-21801">
        <div id="dsq-comment-header-21801" class="dsq-comment-header">
            <cite id="dsq-cite-21801">
                <span id="dsq-author-user-21801">Sunil</span>
            </cite>
        </div>
        <div id="dsq-comment-body-21801" class="dsq-comment-body">
            <div id="dsq-comment-message-21801" class="dsq-comment-message"><p>We can pass the left pointer by value instead of reference and assign left pointer to a static data member. This way we needn&#8217;t have to modify the head of the linked list all the time. </p>
<p>/*<br />
bool isPalindrome(struct node *left, struct  node *right)<br />
{<br />
   /* stop recursion here */<br />
   static node *l=left;<br />
   if (!right)<br />
      return true;</p>
<p>   /* If sub-list is not palindrome then no need to<br />
       check for current left and right, return false */<br />
   bool isp = isPalindrome(l, right-&gt;next);<br />
   if (isp == false)<br />
      return false;</p>
<p>   /* Check values at current left and right */<br />
   bool isp1 = (right-&gt;data == l-&gt;data);</p>
<p>   /* Move left to next node */<br />
   l = l-&gt;next; /* save next pointer */</p>
<p>   return isp1;<br />
}</p>
<p>*/</p>
</div>
        </div>

    </li><!-- #comment-## -->
</li><!-- #comment-## -->
    <li class="comment byuser comment-author-darkpassenger odd alt thread-even depth-1" id="dsq-comment-20627">
        <div id="dsq-comment-header-20627" class="dsq-comment-header">
            <cite id="dsq-cite-20627">
                <span id="dsq-author-user-20627">darkpassenger</span>
            </cite>
        </div>
        <div id="dsq-comment-body-20627" class="dsq-comment-body">
            <div id="dsq-comment-message-20627" class="dsq-comment-message"><p>@geeksforgeeks your method returns not palindrome when list contains single element. plz correct it&#8230;&#8230;&#8230;</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-geeksforgeeks bypostauthor even depth-2" id="dsq-comment-21818">
        <div id="dsq-comment-header-21818" class="dsq-comment-header">
            <cite id="dsq-cite-21818">
                <span id="dsq-author-user-21818">GeeksforGeeks</span>
            </cite>
        </div>
        <div id="dsq-comment-body-21818" class="dsq-comment-body">
            <div id="dsq-comment-message-21818" class="dsq-comment-message"><p>@darkpassenger: Thanks for pointing this out. We have updated the code. It seems to handle all cases now. Keep it up!</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment byuser comment-author-vibhu-tiwari odd alt thread-odd thread-alt depth-1" id="dsq-comment-19688">
        <div id="dsq-comment-header-19688" class="dsq-comment-header">
            <cite id="dsq-cite-19688">
                <span id="dsq-author-user-19688">Vibhu Tiwari</span>
            </cite>
        </div>
        <div id="dsq-comment-body-19688" class="dsq-comment-body">
            <div id="dsq-comment-message-19688" class="dsq-comment-message"><p>@GeeksforGeeks: Actually i think in the first method if the result is 0 then we do not need to again reverse and add the second half to the first part of the linked list.From there only we shoud return 0 and say that it is a not a palindrome. I know we need to preserve the original linked list but here it will not matter as we are not using recursion or iteration where we might be wanting the original linked list.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-18602">
        <div id="dsq-comment-header-18602" class="dsq-comment-header">
            <cite id="dsq-cite-18602">
                <span id="dsq-author-user-18602">pardeep garg</span>
            </cite>
        </div>
        <div id="dsq-comment-body-18602" class="dsq-comment-body">
            <div id="dsq-comment-message-18602" class="dsq-comment-message"><pre> <code language="C">
/* #include&lt;iostream&gt;
using namespace std;

struct node{
    int data;
    node *next;
}*p=NULL,*m=NULL;
int flag=1;
void insert(node *&amp;t,int data){
    if(t==NULL){
        t=new node;
        t-&gt;data=data;
        t-&gt;next=NULL;
    }
    else{
        node *tmp=t;
        while(tmp-&gt;next!=NULL){
            tmp=tmp-&gt;next;
        }
        tmp-&gt;next=new node;
        tmp=tmp-&gt;next;
        tmp-&gt;data=data;
        tmp-&gt;next=NULL;
    }
}

void print(node *t){
    while(t!=NULL){
        cout&lt;&lt;t-&gt;data&lt;&lt;&quot;  &quot;;
        t=t-&gt;next;
    }
    cout&lt;&lt;endl;
}

void checkpalin(node *t){
    if(t-&gt;next!=NULL)
    checkpalin(t-&gt;next);
    if(m-&gt;data!=t-&gt;data)
    flag=0;
    m=m-&gt;next;
}
int main(){
     insert(p,3);
     insert(p,1);
     insert(p,0);
     insert(p,0);
     insert(p,1);
     insert(p,3);
     print(p);
     m=p;
     checkpalin(p);
     if(flag==0)
     cout&lt;&lt;&quot;not palin\n&quot;;
     else
     cout&lt;&lt;&quot;palin\n&quot;;

     return 0;
}
 */
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-18585">
        <div id="dsq-comment-header-18585" class="dsq-comment-header">
            <cite id="dsq-cite-18585">
                <span id="dsq-author-user-18585">pardeep garg</span>
            </cite>
        </div>
        <div id="dsq-comment-body-18585" class="dsq-comment-body">
            <div id="dsq-comment-message-18585" class="dsq-comment-message"><p>// it takes time=O(n) auxillary space= 0;<br />
// take a global pointer which increment as recursive solution // goes back</p>
<p>#include<br />
using namespace std;</p>
<p>struct node{<br />
    int data;<br />
    node *next;<br />
}*p=NULL,*m=NULL;<br />
int flag=1;<br />
void insert(node *&amp;t,int data){<br />
    if(t==NULL){<br />
        t=new node;<br />
        t-&gt;data=data;<br />
        t-&gt;next=NULL;<br />
    }<br />
    else{<br />
        node *tmp=t;<br />
        while(tmp-&gt;next!=NULL){<br />
            tmp=tmp-&gt;next;<br />
        }<br />
        tmp-&gt;next=new node;<br />
        tmp=tmp-&gt;next;<br />
        tmp-&gt;data=data;<br />
        tmp-&gt;next=NULL;<br />
    }<br />
}</p>
<p>void print(node *t){<br />
    while(t!=NULL){<br />
        cout&lt;data&lt;next;<br />
    }<br />
    cout&lt;next!=NULL)<br />
    checkpalin(t-&gt;next);<br />
    if(m-&gt;data!=t-&gt;data)<br />
    flag=0;<br />
    m=m-&gt;next;<br />
}<br />
int main(){<br />
     insert(p,3);<br />
     insert(p,1);<br />
     insert(p,0);<br />
     insert(p,0);<br />
     insert(p,1);<br />
     insert(p,3);<br />
     print(p);<br />
     m=p;<br />
     checkpalin(p);<br />
     if(flag==0)<br />
     cout&lt;&lt;&quot;not palin\n&quot;;<br />
     else<br />
     cout&lt;&lt;&quot;palin\n&quot;;</p>
<p>     return 0;<br />
}</p>
<p>/* Paste your code here (You may delete these lines if not writing code) */</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-2" id="dsq-comment-18600">
        <div id="dsq-comment-header-18600" class="dsq-comment-header">
            <cite id="dsq-cite-18600">
                <span id="dsq-author-user-18600">pardeep garg</span>
            </cite>
        </div>
        <div id="dsq-comment-body-18600" class="dsq-comment-body">
            <div id="dsq-comment-message-18600" class="dsq-comment-message"><p>// it takes time=O(n) auxillary space= 0;<br />
// take a global pointer which increment as recursive solution goes back<br />
#include<br />
using namespace std;</p>
<p>struct node{<br />
    int data;<br />
    node *next;<br />
}*p=NULL,*m=NULL;<br />
int flag=1;<br />
void insert(node *&amp;t,int data){<br />
    if(t==NULL){<br />
        t=new node;<br />
        t-&gt;data=data;<br />
        t-&gt;next=NULL;<br />
    }<br />
    else{<br />
        node *tmp=t;<br />
        while(tmp-&gt;next!=NULL){<br />
            tmp=tmp-&gt;next;<br />
        }<br />
        tmp-&gt;next=new node;<br />
        tmp=tmp-&gt;next;<br />
        tmp-&gt;data=data;<br />
        tmp-&gt;next=NULL;<br />
    }<br />
}</p>
<p>void print(node *t){<br />
    while(t!=NULL){<br />
        cout&lt;data&lt;next;<br />
    }<br />
    cout&lt;next!=NULL)<br />
    checkpalin(t-&gt;next);<br />
    if(m-&gt;data!=t-&gt;data)<br />
    flag=0;<br />
    m=m-&gt;next;<br />
}<br />
int main(){<br />
     insert(p,3);<br />
     insert(p,1);<br />
     insert(p,0);<br />
     insert(p,0);<br />
     insert(p,1);<br />
     insert(p,3);<br />
     print(p);<br />
     m=p;<br />
     checkpalin(p);<br />
     if(flag==0)<br />
     cout&lt;&lt;&quot;not palin\n&quot;;<br />
     else<br />
     cout&lt;&lt;&quot;palin\n&quot;;</p>
<p>     return 0;<br />
}</p>
<p>/* Paste your code here (You may delete these lines if not writing code) */</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment byuser comment-author-abhishek08aug odd alt thread-even depth-1" id="dsq-comment-17809">
        <div id="dsq-comment-header-17809" class="dsq-comment-header">
            <cite id="dsq-cite-17809">
                <span id="dsq-author-user-17809">abhishek08aug</span>
            </cite>
        </div>
        <div id="dsq-comment-body-17809" class="dsq-comment-body">
            <div id="dsq-comment-message-17809" class="dsq-comment-message"><p>Better make use of stack</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-17253">
        <div id="dsq-comment-header-17253" class="dsq-comment-header">
            <cite id="dsq-cite-17253">
                <span id="dsq-author-user-17253">Vijay Muvva</span>
            </cite>
        </div>
        <div id="dsq-comment-body-17253" class="dsq-comment-body">
            <div id="dsq-comment-message-17253" class="dsq-comment-message"><p>Second method in java.. left is an array list whose first element is the head of the list, right is the head of the list. </p>
<p>public static boolean polindromeCheck(ArrayList&lt;ListNode&lt;String&gt;&gt; left, ListNode&lt;String&gt; right) {</p>
<p>		if (right == null) {<br />
			return true;<br />
		}</p>
<p>		boolean isPolindrome = polindromeCheck(left, right.next);<br />
		if (!isPolindrome) {<br />
			return false;<br />
		}</p>
<p>		boolean temp = (left.get(0).data == right.data);</p>
<p>		left.add(0, left.get(0).next);</p>
<p>		return temp;<br />
	}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-17213">
        <div id="dsq-comment-header-17213" class="dsq-comment-header">
            <cite id="dsq-cite-17213">
                <span id="dsq-author-user-17213">Ankit Malhotra</span>
            </cite>
        </div>
        <div id="dsq-comment-body-17213" class="dsq-comment-body">
            <div id="dsq-comment-message-17213" class="dsq-comment-message"><p>@GeeksForGeeks : Method 1 can be simplified, as there is no need to check odd/even count. Once we find the mid element and split and reverse the lists, we need to check only till end of the first half. In case of odd count of elements the middle element will be at the end of the second half on reversal and will not be considered in comparison when end of first is reached. My code for the solution is included.</p>
<pre> <code language="C">
typedef enum{false, true} bool;
typedef struct node node;
typedef node * nodeptr;
typedef nodeptr * npref;

npref listmid (npref start) {
  npref ptr = start, mid = ptr;
  while (*ptr &amp;&amp; (*ptr)-&gt;next) {
    mid = &amp;((*mid)-&gt;next);
    ptr = &amp;((*ptr)-&gt;next-&gt;next);
  }
  return mid;
}

void reverse (npref ptr) {
  nodeptr reversed = NULL, temp = NULL;
  while (*ptr) {
    temp = (*ptr)-&gt;next;
    (*ptr)-&gt;next = reversed;
    reversed = *ptr;
    *ptr = temp;
  }
  *ptr = reversed;
}

bool palindrome (nodeptr start) {
  counter n;
  npref temp = &amp;start, mid = listmid(&amp;start);
  nodeptr midstart, ptr1, ptr2;
// Break the list from middle
  midstart = *mid;
  *mid = NULL;
// Reverse the second half
  reverse (&amp;midstart);
// Check for equality
  for (ptr1 = start, ptr2 = midstart; 
       ptr1 &amp;&amp; ptr1-&gt;data == ptr2-&gt;data; 
       ptr1 = ptr1-&gt;next, ptr2 = ptr2-&gt;next);

// Restore second half to order
  reverse (&amp;midstart);
// Rejoin the list
  push (temp, midstart);
// Return true if matched till end, false otherwise.
  return (!ptr1);
}
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-2" id="dsq-comment-17215">
        <div id="dsq-comment-header-17215" class="dsq-comment-header">
            <cite id="dsq-cite-17215">
                <span id="dsq-author-user-17215">Ankit Malhotra</span>
            </cite>
        </div>
        <div id="dsq-comment-body-17215" class="dsq-comment-body">
            <div id="dsq-comment-message-17215" class="dsq-comment-message"><p>Including utility functions. For convenience data compared is int instead of char.</p>
<pre> <code language="C">
struct node{
  int data;
  nodeptr next;
};

nodeptr nodeCreator (element data, nodeptr next) {
  nodeptr temp = (node *) malloc(sizeof(node));
  temp-&gt;data = data;
  temp-&gt;next = next;
  return temp;
}

void push (npref start, const nodeptr item) {
  nodeptr ptr = *start;
  if (! *start)
    *start = item;
  else {
    while (ptr-&gt;next) ptr = ptr-&gt;next;
    ptr-&gt;next = item;
    item-&gt;prev = ptr;
  }
}

int main () {
  nodeptr s = NULL;
  push (&amp;s, nodeCreator(1, NULL));
  push (&amp;s, nodeCreator(2, NULL));
  push (&amp;s, nodeCreator(3, NULL));
  push (&amp;s, nodeCreator(2, NULL));
  push (&amp;s, nodeCreator(1, NULL));
  printf (palindrome (s) ? &quot;Yes&quot; : &quot;No&quot;);
  printf (&quot;\n&quot;);
  return 0;
}

</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-15425">
        <div id="dsq-comment-header-15425" class="dsq-comment-header">
            <cite id="dsq-cite-15425">
                <span id="dsq-author-user-15425">Rahul</span>
            </cite>
        </div>
        <div id="dsq-comment-body-15425" class="dsq-comment-body">
            <div id="dsq-comment-message-15425" class="dsq-comment-message"><p>I think the second method is not possible in Java. Since Java is pass by value, the reference will not change inside the method, i.e. the head node will not move next.</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-aygul even thread-even depth-1" id="dsq-comment-15366">
        <div id="dsq-comment-header-15366" class="dsq-comment-header">
            <cite id="dsq-cite-15366">
                <span id="dsq-author-user-15366">aygul</span>
            </cite>
        </div>
        <div id="dsq-comment-body-15366" class="dsq-comment-body">
            <div id="dsq-comment-message-15366" class="dsq-comment-message"><p>@geeksforgeeks<br />
Second method can be improved by the half of the recursion stack.<br />
Similar to the first method find mid point of the list by using slow and fast pointers then call<br />
isPalindrome(&#038;head, second_half);</p>
<p>Also suggested second method changes the head pointer when it is returned in main. A util function<br />
isPalindrome(struct node *head)<br />
that traverses to find the half and calls isPalindrome(&#038;head, second_half); would be a better solution.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-11927">
        <div id="dsq-comment-header-11927" class="dsq-comment-header">
            <cite id="dsq-cite-11927">
                <span id="dsq-author-user-11927">Kartik</span>
            </cite>
        </div>
        <div id="dsq-comment-body-11927" class="dsq-comment-body">
            <div id="dsq-comment-message-11927" class="dsq-comment-message"><p>@sharad Chandra .. thanks for this awesome solution&#8230; nearly unthought of.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-10131">
        <div id="dsq-comment-header-10131" class="dsq-comment-header">
            <cite id="dsq-cite-10131">
                <span id="dsq-author-user-10131">Rajdeep</span>
            </cite>
        </div>
        <div id="dsq-comment-body-10131" class="dsq-comment-body">
            <div id="dsq-comment-message-10131" class="dsq-comment-message"><p>Method making use of two node pointers and one stack:</p>
<p>One method is to move two pointers, slow and fast that will scan the link list such that:<br />
1) slow will move one step at one time and fast will move twice as slow do.<br />
2) While scanning push nodes pointed by slow in the stack.<br />
2) In this case, the time fast reaches the end of list, slow would be pointing the middle of the list and stack will have the nodes of the list, till middle, in the reverse position.<br />
4) Now repeatedly pop stack and move slow pointers, and compare both the nodes. This will if the list is palindrome or not.</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-16302">
        <div id="dsq-comment-header-16302" class="dsq-comment-header">
            <cite id="dsq-cite-16302">
                <span id="dsq-author-user-16302">Soumya Sengupta</span>
            </cite>
        </div>
        <div id="dsq-comment-body-16302" class="dsq-comment-body">
            <div id="dsq-comment-message-16302" class="dsq-comment-message"><p>gud code</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-9616">
        <div id="dsq-comment-header-9616" class="dsq-comment-header">
            <cite id="dsq-cite-9616">
http://www.nikoo28.blogspot.com                <span id="dsq-author-user-9616">nikoo28</span>
            </cite>
        </div>
        <div id="dsq-comment-body-9616" class="dsq-comment-body">
            <div id="dsq-comment-message-9616" class="dsq-comment-message"><p>we can also push all the elements in a stack&#8230;then pop elements one by one and compare it with the start pointer&#8230;with each pop increment the start pointer..if the value does not match at any point, then we can return false&#8230;please point me if i am wrong&#8230;?</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-11960">
        <div id="dsq-comment-header-11960" class="dsq-comment-header">
            <cite id="dsq-cite-11960">
                <span id="dsq-author-user-11960">jasleen</span>
            </cite>
        </div>
        <div id="dsq-comment-body-11960" class="dsq-comment-body">
            <div id="dsq-comment-message-11960" class="dsq-comment-message"><p>Ur method is correct but it requires extra space O(n).</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-9032">
        <div id="dsq-comment-header-9032" class="dsq-comment-header">
            <cite id="dsq-cite-9032">
                <span id="dsq-author-user-9032">nidhi</span>
            </cite>
        </div>
        <div id="dsq-comment-body-9032" class="dsq-comment-body">
            <div id="dsq-comment-message-9032" class="dsq-comment-message"><p>can we do this method? </p>
<p>1. store the output of linklist in some string or stack.</p>
<p>2. reverse the complete linklist.</p>
<p>3. now store the output of new linklist.</p>
<p>4. compare both.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-16322">
        <div id="dsq-comment-header-16322" class="dsq-comment-header">
            <cite id="dsq-cite-16322">
                <span id="dsq-author-user-16322">rakesh mahadasa</span>
            </cite>
        </div>
        <div id="dsq-comment-body-16322" class="dsq-comment-body">
            <div id="dsq-comment-message-16322" class="dsq-comment-message"><p>inefficient</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even depth-2" id="dsq-comment-16323">
        <div id="dsq-comment-header-16323" class="dsq-comment-header">
            <cite id="dsq-cite-16323">
                <span id="dsq-author-user-16323">rakesh mahadasa</span>
            </cite>
        </div>
        <div id="dsq-comment-body-16323" class="dsq-comment-body">
            <div id="dsq-comment-message-16323" class="dsq-comment-message"><p>it uses extra space and time inefficient</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-8209">
        <div id="dsq-comment-header-8209" class="dsq-comment-header">
            <cite id="dsq-cite-8209">
                <span id="dsq-author-user-8209">trial</span>
            </cite>
        </div>
        <div id="dsq-comment-body-8209" class="dsq-comment-body">
            <div id="dsq-comment-message-8209" class="dsq-comment-message"><p>gidraharsh.wordpress.com/2012/04/24/linkedlist-palindrome/</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-8162">
        <div id="dsq-comment-header-8162" class="dsq-comment-header">
            <cite id="dsq-cite-8162">
http://manjunath.j.tripod.com/                <span id="dsq-author-user-8162">Manjunath Janardhan</span>
            </cite>
        </div>
        <div id="dsq-comment-body-8162" class="dsq-comment-body">
            <div id="dsq-comment-message-8162" class="dsq-comment-message"><p>My method:<br />
1) Find the mid<br />
2) Keep pushing the elements into stack until you reach mid<br />
3) Start popping and compare with the reaming elements in the list.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-8210">
        <div id="dsq-comment-header-8210" class="dsq-comment-header">
            <cite id="dsq-cite-8210">
                <span id="dsq-author-user-8210">jagur</span>
            </cite>
        </div>
        <div id="dsq-comment-body-8210" class="dsq-comment-body">
            <div id="dsq-comment-message-8210" class="dsq-comment-message"><p>why do you need stack?</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment byuser comment-author-jaldeep even thread-odd thread-alt depth-1" id="dsq-comment-7387">
        <div id="dsq-comment-header-7387" class="dsq-comment-header">
            <cite id="dsq-cite-7387">
                <span id="dsq-author-user-7387">Jaldeep</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7387" class="dsq-comment-body">
            <div id="dsq-comment-message-7387" class="dsq-comment-message"><p>Can anyone plz suggest a solution with &#8211; an O(n) (only 1 traversal) code with o(1) memory space and without changing link list structure..??</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-16048">
        <div id="dsq-comment-header-16048" class="dsq-comment-header">
            <cite id="dsq-cite-16048">
http://NoWebsite                <span id="dsq-author-user-16048">Barun Kumar Singh</span>
            </cite>
        </div>
        <div id="dsq-comment-body-16048" class="dsq-comment-body">
            <div id="dsq-comment-message-16048" class="dsq-comment-message"><pre> <code language="C">
bool checkListPalindrom(LList * head, LList* temp)
{
	static bool isPalin = true;
	static LList* head2 = head;
	if(temp-&gt;next != NULL)
		checkListPalindrom(head,temp-&gt;next);
	if(head2-&gt;data != temp-&gt;data)
		isPalin = false;
	head2 = head2-&gt;next;
	return isPalin;
}

/* this function should be called from main function like..
if(checkListPalindrom(head,head))
 printf(&quot;\nPalindrom.&quot;);
else
printf (&quot;\nNot Palindrom.&quot;);
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-7294">
        <div id="dsq-comment-header-7294" class="dsq-comment-header">
            <cite id="dsq-cite-7294">
                <span id="dsq-author-user-7294">Avinash</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7294" class="dsq-comment-body">
            <div id="dsq-comment-message-7294" class="dsq-comment-message"><p>2nd method is not so good. Recursion breaks when we have wasted checking for same string as palindrome twice.</p>
<p>In first recursive traversal count N nodes in list and use this extra info [ n/2 ] to break out of recursion early.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-pphanireddy odd alt thread-odd thread-alt depth-1" id="dsq-comment-6640">
        <div id="dsq-comment-header-6640" class="dsq-comment-header">
            <cite id="dsq-cite-6640">
                <span id="dsq-author-user-6640">pphanireddy</span>
            </cite>
        </div>
        <div id="dsq-comment-body-6640" class="dsq-comment-body">
            <div id="dsq-comment-message-6640" class="dsq-comment-message"><pre> <code language="Java">
    public boolean isPalindrome() {
	boolean isPalindrome = true;
	Node middle = getMiddle();
	if(middle == null) return isPalindrome;
	Node firstHead = head;
	Node secondHead = reverseList(middle);
	Node saveSecondHead = secondHead;
	while(firstHead != middle) {
	    if(!firstHead.val.equals(secondHead.val)) {
		isPalindrome = false;
		break;
	    }
	    firstHead = firstHead.next;
	    secondHead = secondHead.next;
	}
	secondHead = reverseList(saveSecondHead);
	return isPalindrome;
    }

</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-4842">
        <div id="dsq-comment-header-4842" class="dsq-comment-header">
            <cite id="dsq-cite-4842">
                <span id="dsq-author-user-4842">Bharath</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4842" class="dsq-comment-body">
            <div id="dsq-comment-message-4842" class="dsq-comment-message"><p>Why are we passing a pointer to a pointer for the left node?</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-venki odd alt thread-odd thread-alt depth-1" id="dsq-comment-4583">
        <div id="dsq-comment-header-4583" class="dsq-comment-header">
            <cite id="dsq-cite-4583">
http://www.linkedin.com/in/ramanawithu                <span id="dsq-author-user-4583">Venki</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4583" class="dsq-comment-body">
            <div id="dsq-comment-message-4583" class="dsq-comment-message"><p>I think quite a few comments on why the second method working fine. I am trying to put few comments.</p>
<p>The idea is to use compiler function call stack as container. Recursively traverse till the end of list. When we return from last NULL, we will be at last node. The last node to be compared with first node of list.</p>
<p>In order to access first node of list we need list head to be available in the last call of recursion. Hence we pass head also the recursive function. If they both match we need to compare (2, n-2) nodes. Again when recursion falls back to (n-2)nd node, we need reference to 2 nd node from head. We advance the head pointer in previous call, to refer to next node in the list. </p>
<p>However, the trick in identifying dual reference. Passing single reference is as good as pass-by-value, and we will pass the same pointer again and again without dual reference. We need to pass the address of head pointer for referring next elements.</p>
<p><strong>Nice work by @Sharad using the power of recursion. Keep it up.</strong></p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-2" id="dsq-comment-11926">
        <div id="dsq-comment-header-11926" class="dsq-comment-header">
            <cite id="dsq-cite-11926">
                <span id="dsq-author-user-11926">Kartik</span>
            </cite>
        </div>
        <div id="dsq-comment-body-11926" class="dsq-comment-body">
            <div id="dsq-comment-message-11926" class="dsq-comment-message"><p>But that does mean that it is making multiple passes to the same list , in right pointer ,, doesnt it?? I am confused in this &#8230;</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment byuser comment-author-rajneesh2k10 odd alt thread-even depth-1" id="dsq-comment-4340">
        <div id="dsq-comment-header-4340" class="dsq-comment-header">
            <cite id="dsq-cite-4340">
                <span id="dsq-author-user-4340">Rajneesh</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4340" class="dsq-comment-body">
            <div id="dsq-comment-message-4340" class="dsq-comment-message"><p>My suggestion has Stack idea with complexity of O(n):</p>
<p>Declare two pointers and initialize both of them to the start of the list. Move one pointer, one node forward in every step and keep pushing the data pointed by it on a stack. Other pointer moves two nodes forward in every step. Repeat until second pointer reaches the end of the loop. Now start popping the data from the stack and move the first pointer one step every time and compare the element pointed by this pointer with the element popped from the stack. If a mismatch is found the its not palindrome. If stack is empty and so we have reached the end of the list, that means its a palindrome.</p>
<p>Pseudo Code:<br />
1. Make two pointers: fastpointer, slowpointer<br />
2. fastpointer = HeadOfTheList, slowpointer = HeadOfTheList<br />
3. Do until fastpointer OR fastpointer-&gt;next is not NULL<br />
   i)   push(slowpointer-&gt;data) on stack<br />
   ii)  slowpointer = slowpointer-&gt;next<br />
   iii) fastpointer = fastepointer-&gt;next-&gt;next<br />
4. Do until stack is empty<br />
   i)   slowpointer = slowpointer-&gt;next<br />
   ii)  temp = popTheStack()<br />
   iii) if ((slowpointer-&gt;data) != temp) return false<br />
5. return true</p>
<p>Above pseudo code might need little check in between depending upon whether the number of elements in the list is even or odd. Do the check yourself.<br />
Correct me if I am wrong.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-2" id="dsq-comment-5351">
        <div id="dsq-comment-header-5351" class="dsq-comment-header">
            <cite id="dsq-cite-5351">
                <span id="dsq-author-user-5351">Anushree</span>
            </cite>
        </div>
        <div id="dsq-comment-body-5351" class="dsq-comment-body">
            <div id="dsq-comment-message-5351" class="dsq-comment-message"><p>really good solution!</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt depth-2" id="dsq-comment-5353">
        <div id="dsq-comment-header-5353" class="dsq-comment-header">
            <cite id="dsq-cite-5353">
                <span id="dsq-author-user-5353">Anushree</span>
            </cite>
        </div>
        <div id="dsq-comment-body-5353" class="dsq-comment-body">
            <div id="dsq-comment-message-5353" class="dsq-comment-message"><p>really nice solution!</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-3" id="dsq-comment-5465">
        <div id="dsq-comment-header-5465" class="dsq-comment-header">
            <cite id="dsq-cite-5465">
                <span id="dsq-author-user-5465">Pradip</span>
            </cite>
        </div>
        <div id="dsq-comment-body-5465" class="dsq-comment-body">
            <div id="dsq-comment-message-5465" class="dsq-comment-message"><p>I think the stack can be avoided by using another pointer to start at beginning&#8230; Otherwise a nice soln.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt depth-2" id="dsq-comment-6419">
        <div id="dsq-comment-header-6419" class="dsq-comment-header">
            <cite id="dsq-cite-6419">
                <span id="dsq-author-user-6419">Anuj Bansal</span>
            </cite>
        </div>
        <div id="dsq-comment-body-6419" class="dsq-comment-body">
            <div id="dsq-comment-message-6419" class="dsq-comment-message"><p>1. I think you can push the whole list to a stack and then start popping the stack and compare it with the list elements by traversing it from the beginning.</p>
<p>2. Another solution could be to read the linked list forward once and backward once and then just compare them. This would avoid maintaining a custom stack although your code would use one while traversing the list backwards recursively.</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment byuser comment-author-yeskay even thread-odd thread-alt depth-1" id="dsq-comment-4092">
        <div id="dsq-comment-header-4092" class="dsq-comment-header">
            <cite id="dsq-cite-4092">
                <span id="dsq-author-user-4092">yeskay</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4092" class="dsq-comment-body">
            <div id="dsq-comment-message-4092" class="dsq-comment-message"><p>This is My version, Check it out!!!</p>
<pre> <code language="C">typedef struct node{
        char ch;
        struct node *link;
}NODE;

void printList(NODE *node){
        while(node){
                printf(&quot;| %c |-&gt;&quot;,node-&gt;ch);
                node = node-&gt;link;
        }
}

int isPalindrome(NODE *head){
        static char str[LEN];
        static int i=0;
        if(head==NULL)
                return;
        str[i++] = head-&gt;ch;
        isPalindrome(head-&gt;link);
        i=i%LEN;
//      printf(&quot;\ni = %d | str[%d] = %c | head-&gt;ch = %c&quot;,i,i,str[i],head-&gt;ch);
        if(str[i] == head-&gt;ch)
                i++;
return i;
}

int main(){
        NODE list[LEN],*head;
        list[0].ch = 'r';
        list[1].ch = 'a';
        list[2].ch = 'a';
        list[3].ch = 'r';
        head = list;

        list[0].link = &amp;list[1];
        list[1].link = &amp;list[2];
        list[2].link = &amp;list[3];
        list[3].link = NULL;
//      list[4].link = NULL;
        printf(&quot;Original List :\n&quot;);
        printList(head);
        printf(&quot;\n&quot;);

        if(isPalindrome(head) == LEN)
                printf(&quot;\nIt is a Palindrome!!!\n&quot;);
        else
                printf(&quot;\nIt is Not Palindrome?!?#@@#\n&quot;);
return 0;
}
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-quadmaniac odd alt thread-even depth-1" id="dsq-comment-4071">
        <div id="dsq-comment-header-4071" class="dsq-comment-header">
            <cite id="dsq-cite-4071">
                <span id="dsq-author-user-4071">quadmaniac</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4071" class="dsq-comment-body">
            <div id="dsq-comment-message-4071" class="dsq-comment-message"><p>The recursive method is brilliant, thanks!</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-4030">
        <div id="dsq-comment-header-4030" class="dsq-comment-header">
            <cite id="dsq-cite-4030">
                <span id="dsq-author-user-4030">abcd</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4030" class="dsq-comment-body">
            <div id="dsq-comment-message-4030" class="dsq-comment-message"><p>but in the second method, we are modifying the given list. i think it is not desirable. please comment.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-vidya odd alt depth-2" id="dsq-comment-5718">
        <div id="dsq-comment-header-5718" class="dsq-comment-header">
            <cite id="dsq-cite-5718">
                <span id="dsq-author-user-5718">Vidya</span>
            </cite>
        </div>
        <div id="dsq-comment-body-5718" class="dsq-comment-body">
            <div id="dsq-comment-message-5718" class="dsq-comment-message"><p>Yes, the link is modified. So keep a copy and allow it to modify.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment byuser comment-author-rimu-nitrkl even thread-even depth-1" id="dsq-comment-3349">
        <div id="dsq-comment-header-3349" class="dsq-comment-header">
            <cite id="dsq-cite-3349">
                <span id="dsq-author-user-3349">Rimu</span>
            </cite>
        </div>
        <div id="dsq-comment-body-3349" class="dsq-comment-body">
            <div id="dsq-comment-message-3349" class="dsq-comment-message"><p>The following code does the exact thing as mentioned above in 2nd case, but using return type as int instead of bool, a small optimisation is done i.e. exit out of the function when we reach the mid of the linked list:</p>
<pre> <code language="C">
&lt;code&gt;int checkPalindrome(Node *N)
{
    static Node *first=NULL;
    
    int rv;

    if(!first)
    {
           if(!N)
                 return 1;
           first=N;
    }
    
    if(N-&gt;next)
    {
               rv=checkPalindrome(N-&gt;next);
               if(rv!=-1)
                   return rv;
    }
    
    //printf(&quot;\nfirst-&gt;data=%d, N-&gt;data=%d&quot;,first-&gt;data,N-&gt;data);
    
    if(first-&gt;data==N-&gt;data)
       if((first==N)||(first-&gt;next==N)) //Exit Criteria: When we reach the mid of the Linked List
          rv=1;
       else
          rv=-1;
    else if(first-&gt;data!=N-&gt;data)
       rv=0;
    
    first=first-&gt;next;
        
    return rv;
    
}
</code> </pre>
<p>Also, the function needs only one pointer as a parameter, the substitute for the other is a static pointer.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-soundbalaji odd alt thread-odd thread-alt depth-1" id="dsq-comment-2904">
        <div id="dsq-comment-header-2904" class="dsq-comment-header">
            <cite id="dsq-cite-2904">
                <span id="dsq-author-user-2904">bala</span>
            </cite>
        </div>
        <div id="dsq-comment-body-2904" class="dsq-comment-body">
            <div id="dsq-comment-message-2904" class="dsq-comment-message"><p>In the recursive method , why do we need to pass pointer-pointer for left ? The program works but I think it will still work with pointer to left because the structure of the list remains the same !</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-wgpshashank even thread-even depth-1" id="dsq-comment-2764">
        <div id="dsq-comment-header-2764" class="dsq-comment-header">
            <cite id="dsq-cite-2764">
http://www.wgpshashank.co.cc                <span id="dsq-author-user-2764">wgpshashank</span>
            </cite>
        </div>
        <div id="dsq-comment-body-2764" class="dsq-comment-body">
            <div id="dsq-comment-message-2764" class="dsq-comment-message"><p>i think we can do this using by push pop &amp; get-reminder operation&#8230;</p>
<p>so say we wants to take 121  so via get reminder method we get single digit starting from left &amp; push it into stack as 1,2,1  no we just popped this 1 by 1 &amp; check that get-reminder is giving same digit at the same index or not if yes its palindrome else it is noe palindrome&#8230;.you check it for 123  </p>
<p>1st we get 3 (using get-reminder method) push it into stack  &amp; then we get 2 push again into stack &amp; the push 1 into stack so stack looks like as  head&#8211;&gt;1-&gt;2-&gt;3  &amp; now pop &amp; as it ouccrs in reverse so first 1 will be popped from stack &amp; compare every single digit with  digit got from get-reminder  method as first 1 will be popped from stack &amp; get-reminder will gives 3 as first digit it become false similarly for remaining digit..please write comments if you finds the logic is wrong&#8230;..</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-wgpshashank odd alt depth-2" id="dsq-comment-2838">
        <div id="dsq-comment-header-2838" class="dsq-comment-header">
            <cite id="dsq-cite-2838">
http://www.wgpshashank.co.cc                <span id="dsq-author-user-2838">wgpshashank</span>
            </cite>
        </div>
        <div id="dsq-comment-body-2838" class="dsq-comment-body">
            <div id="dsq-comment-message-2838" class="dsq-comment-message"><p>Please Write Comment If You Fine Above Concept Is Wrong ..???</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-2647">
        <div id="dsq-comment-header-2647" class="dsq-comment-header">
            <cite id="dsq-cite-2647">
                <span id="dsq-author-user-2647">Shashank Mani Narayan</span>
            </cite>
        </div>
        <div id="dsq-comment-body-2647" class="dsq-comment-body">
            <div id="dsq-comment-message-2647" class="dsq-comment-message"><p>Can sumbody plz xplain me whats happining in the 2nd code  using recusion @ the  top&#8230;thanks in advance..how control is transferred  &amp; why dis stmt is made like </p>
<p>&#8221;  if(!right) &#8221;  reply asap&#8230;</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-2469">
        <div id="dsq-comment-header-2469" class="dsq-comment-header">
            <cite id="dsq-cite-2469">
                <span id="dsq-author-user-2469">Rajeev</span>
            </cite>
        </div>
        <div id="dsq-comment-body-2469" class="dsq-comment-body">
            <div id="dsq-comment-message-2469" class="dsq-comment-message"><p>I think in iterative solution one line is missing.. in the second case<br />
 else<br />
       {<br />
          second_half = slow_ptr-&gt;next;<br />
          prev_of_slow_ptr-&gt;next = NULL;<br />
          reverse(&amp;second_half);<br />
          res = compareLists(head, second_half);</p>
<p>         /*construct the original list back*/<br />
         reverse(&amp;second_half);<br />
         prev_of_slow_ptr-&gt;next = slow_ptr;<br />
         slow_ptr-&gt;next = second_half;<br />
       }<br />
there should be a line of code slow_ptr-&gt;next = NULL;</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-2459">
        <div id="dsq-comment-header-2459" class="dsq-comment-header">
            <cite id="dsq-cite-2459">
                <span id="dsq-author-user-2459">Tushar Roy</span>
            </cite>
        </div>
        <div id="dsq-comment-body-2459" class="dsq-comment-body">
            <div id="dsq-comment-message-2459" class="dsq-comment-message"><p>Just a shorter code for method2. Same logic.</p>
<pre> <code language="C">
bool isPalindrome(Node **left,Node *right)
{
   if(!right)
   {
   	return true;
   }
   bool isPali =  isPalindrome(left,right-&gt;next) &amp;&amp;         ((*left)-&gt;data == right-&gt;data);
   *left = (*left)-&gt;next;
   return isPali;
}
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-5094">
        <div id="dsq-comment-header-5094" class="dsq-comment-header">
            <cite id="dsq-cite-5094">
                <span id="dsq-author-user-5094">root.node</span>
            </cite>
        </div>
        <div id="dsq-comment-body-5094" class="dsq-comment-body">
            <div id="dsq-comment-message-5094" class="dsq-comment-message"><p>@tushar</p>
<p><strong>Dude you method works perfectly. It&#8217;s clear and concise !!</strong></p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-2297">
        <div id="dsq-comment-header-2297" class="dsq-comment-header">
            <cite id="dsq-cite-2297">
                <span id="dsq-author-user-2297">Pranshu Gaur</span>
            </cite>
        </div>
        <div id="dsq-comment-body-2297" class="dsq-comment-body">
            <div id="dsq-comment-message-2297" class="dsq-comment-message"><pre> <code language="C">
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt; 

typedef struct list{
        int data;
        struct list * next;
}* PTR; 
PTR list;
int main() {
    
    int i,j,num, getinp(void);
    void printlist(PTR);
    void addnode(PTR *,PTR *, int );
    int palcheck(PTR);
    PTR lnode, q = lnode = (PTR)0;
    
    while((num = getinp())!= 0) {
          addnode(&amp;lnode,&amp;q,num);
    }
    list = lnode;
    printlist(lnode);
    
    if(palcheck(lnode)) 
      printf(&quot;Hell yaaaa !&quot;);
    else
     printf(&quot;False Alarm !&quot;);
    
    fflush(stdin);
    getchar();
           
    return 0;
}
int palcheck(PTR p) {
    
    if ( p == NULL )
      return 0;
    if( p-&gt;next != NULL ) {
          if(!palcheck(p-&gt;next)) 
            return 0;
    }
    
    if(p-&gt;data == list-&gt;data) {
       list = list-&gt;next;
       return 1;
    }
    return 0;
}

int getinp(void) {
    
    int c;
    while ( ! scanf(&quot;%d&quot;,&amp;c) ) {
          printf(&quot;Invalid Input, try again \n&quot;);
          fflush(stdin);
    }
    return c;
}

void addnode ( PTR* node, PTR* tail, int num) {
     
     
     PTR temp;
     PTR root = *tail;
     temp = (PTR )malloc((int)sizeof(struct list));
     temp -&gt; data = num;
     temp -&gt; next = NULL;
     
     if ( *node == NULL) {
          *node = temp;
          *tail = temp;
     }
     
     else {
          root -&gt; next = temp;
          *tail = temp;
     }
     
}

void printlist(PTR node) {
     
     while (node != NULL ) {
           printf(&quot;%d &quot;,node-&gt;data);
           node = node-&gt;next;
     }
     printf(&quot;\n&quot;); 
}
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-sandeep odd alt depth-2" id="dsq-comment-2298">
        <div id="dsq-comment-header-2298" class="dsq-comment-header">
            <cite id="dsq-cite-2298">
                <span id="dsq-author-user-2298">Sandeep</span>
            </cite>
        </div>
        <div id="dsq-comment-body-2298" class="dsq-comment-body">
            <div id="dsq-comment-message-2298" class="dsq-comment-message"><p>@Pranshu Gaur: Thanks for sharing your code. Your approach looks similar to Method 2 in above post.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment byuser comment-author-shriramparameshgmail-com even thread-odd thread-alt depth-1" id="dsq-comment-2172">
        <div id="dsq-comment-header-2172" class="dsq-comment-header">
            <cite id="dsq-cite-2172">
                <span id="dsq-author-user-2172">shri</span>
            </cite>
        </div>
        <div id="dsq-comment-body-2172" class="dsq-comment-body">
            <div id="dsq-comment-message-2172" class="dsq-comment-message"><p>Sharad Chandra&#8217;s code works fine. Just wanted to suggest an optimization to it&#8230; We can compare the data only if the right pointer has just crossed the left pointer reducing the comparisons to n/2 else simply propagate the previous result. Just the modified function is as follows:</p>
<pre> <code language="C">
   bool isp = isPalindrome(left, right-&gt;next);
   if (isp == false)
      return false;
 
   /* Check values at current left and right */
       if(right &lt; *left)
       {
           bool isp1 = (right-&gt;data == (*left)-&gt;data);

           /* Move left to next node */
           *left = (*left)-&gt;next; /* save next pointer */
         
           return isp1;
       }
       else
       {
           return isp;    
       }
}
</code> </pre>
<p>Thanks.<br />
Shriram</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-shriramparameshgmail-com odd alt depth-2" id="dsq-comment-2173">
        <div id="dsq-comment-header-2173" class="dsq-comment-header">
            <cite id="dsq-cite-2173">
                <span id="dsq-author-user-2173">shri</span>
            </cite>
        </div>
        <div id="dsq-comment-body-2173" class="dsq-comment-body">
            <div id="dsq-comment-message-2173" class="dsq-comment-message"><p>sorry! corrected the error in pasting the entire function isPalindrome.</p>
<pre> <code language="C">
bool isPalindrome(struct node **left, struct  node *right)
{
   /* stop recursion here */
   if (!right)
      return true;
 
   /* If sub-list is not palindrome then no need to
       check for current left and right, return false */
   bool isp = isPalindrome(left, right-&gt;next);
   if (isp == false)
      return false;
 
   /* Check values at current left and right */
       if(right &lt; *left) //optimization
       {
           bool isp1 = (right-&gt;data == (*left)-&gt;data);

           /* Move left to next node */
           *left = (*left)-&gt;next; /* save next pointer */
         
           return isp1;
       }
       else
       {
           return isp; //simply forward the previous  
                      //result
       }
}
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-vipulkv even depth-3" id="dsq-comment-2524">
        <div id="dsq-comment-header-2524" class="dsq-comment-header">
            <cite id="dsq-cite-2524">
                <span id="dsq-author-user-2524">vipulkv</span>
            </cite>
        </div>
        <div id="dsq-comment-body-2524" class="dsq-comment-body">
            <div id="dsq-comment-message-2524" class="dsq-comment-message"><p>Hi Shri,</p>
<p>there is one issue in your code. Two ways you can fix it in:<br />
1. reverse the condition<br />
i.e.</p>
<pre> <code language="C">if(right &gt; *left)</code> </pre>
<p>2. Put the statement
<pre> <code language="C">*left = (*left)-&gt;next; /* save next pointer */
</code> </pre>
<p> outside of if block.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-4" id="dsq-comment-3278">
        <div id="dsq-comment-header-3278" class="dsq-comment-header">
            <cite id="dsq-cite-3278">
                <span id="dsq-author-user-3278">janani</span>
            </cite>
        </div>
        <div id="dsq-comment-body-3278" class="dsq-comment-body">
            <div id="dsq-comment-message-3278" class="dsq-comment-message"><p>@shri &#8211; I think this optimization will not hold.Because,you cannot assume that nodes in a linked list are assigned memory in increasing order.So the statement if(right &gt; *left) will not give desired results.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-2014">
        <div id="dsq-comment-header-2014" class="dsq-comment-header">
            <cite id="dsq-cite-2014">
                <span id="dsq-author-user-2014">priya</span>
            </cite>
        </div>
        <div id="dsq-comment-body-2014" class="dsq-comment-body">
            <div id="dsq-comment-message-2014" class="dsq-comment-message"><p>for checking if its a palindrome i ve tried reversing the linked list and comparing it with the original list..will that an efficient algorithm?</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-vipulkv odd alt depth-2" id="dsq-comment-2523">
        <div id="dsq-comment-header-2523" class="dsq-comment-header">
            <cite id="dsq-cite-2523">
                <span id="dsq-author-user-2523">vipulkv</span>
            </cite>
        </div>
        <div id="dsq-comment-body-2523" class="dsq-comment-body">
            <div id="dsq-comment-message-2523" class="dsq-comment-message"><p>No problem as such. But time complexity will become O(2n) which is eventually O(n). But showing recursive method to ur interviewer would always be impressive.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-844">
        <div id="dsq-comment-header-844" class="dsq-comment-header">
            <cite id="dsq-cite-844">
                <span id="dsq-author-user-844">Sharad Chandra</span>
            </cite>
        </div>
        <div id="dsq-comment-body-844" class="dsq-comment-body">
            <div id="dsq-comment-message-844" class="dsq-comment-message"><p>A recursive version..</p>
<p>reach to the end of List with recursive call and while returning, compare with respective node to check in list.</p>
<pre> <code language="C">
bool checkPalindrom (struct node1d **left, struct node1d *right) {
  if (! right) { /* stop recursion here */
    return true;
  }

  bool isp = checkPalindrom(left, right-&gt;next);
  if (isp == false)
    return false;

  bool isp1 = (right-&gt;data == (*left)-&gt;data);
  *left = (*left)-&gt;next; /* save next pointer */

  return isp1;
}

int main () {
  struct node1d *root;
  struct node1d **rootp;

  root = makePalindromList(5); /* returns a list */
  rootp = &amp;root;
  printMe&lt;struct node1d &gt;(root, NULL); /* print the list */

  bool isp = checkPalindrom (rootp, root);
  cout &lt;&lt; (isp ? &quot;Yes&quot; : &quot;No&quot;) &lt;&lt; endl;
}
</code> </pre>
<p>But recursion is not good for space complexity.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-sandeep odd alt depth-2" id="dsq-comment-859">
        <div id="dsq-comment-header-859" class="dsq-comment-header">
            <cite id="dsq-cite-859">
                <span id="dsq-author-user-859">Sandeep</span>
            </cite>
        </div>
        <div id="dsq-comment-body-859" class="dsq-comment-body">
            <div id="dsq-comment-message-859" class="dsq-comment-message"><p>@Sharad Chandra: Looks like <em>checkPalindrom()</em> returns true for all linked lists. In the code, <em>root </em>is passed as <em>right</em>. In each recursive call right is moved to next. Finally right becomes NULL and checkPalindrom() returns true if right is NULL. Correct me if I am wrong.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-3" id="dsq-comment-863">
        <div id="dsq-comment-header-863" class="dsq-comment-header">
            <cite id="dsq-cite-863">
                <span id="dsq-author-user-863">Sharad Chandra</span>
            </cite>
        </div>
        <div id="dsq-comment-body-863" class="dsq-comment-body">
            <div id="dsq-comment-message-863" class="dsq-comment-message"><p>Hi Sandeep,</p>
<p>Not for all linked list but only for palindrome list. &#8216;True&#8217; is returned when right reached to NULL, is not the final return to main. Variable isp will not play any role if its value is true as isp1 will be returned then. Note comparison to check palindrome is taking place when it starts returning.</p>
<p>Regards,<br />
Sharad Chandra</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-geeksforgeeks bypostauthor odd alt depth-4" id="dsq-comment-864">
        <div id="dsq-comment-header-864" class="dsq-comment-header">
            <cite id="dsq-cite-864">
                <span id="dsq-author-user-864">Sandeep</span>
            </cite>
        </div>
        <div id="dsq-comment-body-864" class="dsq-comment-body">
            <div id="dsq-comment-message-864" class="dsq-comment-message"><p>@Sharad Chandra: I missed to notice the isp part. Yes, it works. Thanks for the explanation!</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment byuser comment-author-geeksforgeeks bypostauthor even depth-2" id="dsq-comment-866">
        <div id="dsq-comment-header-866" class="dsq-comment-header">
            <cite id="dsq-cite-866">
                <span id="dsq-author-user-866">GeeksforGeeks</span>
            </cite>
        </div>
        <div id="dsq-comment-body-866" class="dsq-comment-body">
            <div id="dsq-comment-message-866" class="dsq-comment-message"><p>@Sharad Chandra: Thanks for suggesting a new method. We have included it to the original post. Keep it up!!</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt depth-2" id="dsq-comment-3811">
        <div id="dsq-comment-header-3811" class="dsq-comment-header">
            <cite id="dsq-cite-3811">
                <span id="dsq-author-user-3811">Cracker</span>
            </cite>
        </div>
        <div id="dsq-comment-body-3811" class="dsq-comment-body">
            <div id="dsq-comment-message-3811" class="dsq-comment-message"><p>@geeksfrogeeks,Sandeep,Shrad Chandar..Can You Through some more light on 2nd method using recursion how its working </p>
<p>please help me to understand it..<br />
waiting for your explaination</p>
<p>Thanks</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even depth-2" id="dsq-comment-17916">
        <div id="dsq-comment-header-17916" class="dsq-comment-header">
            <cite id="dsq-cite-17916">
                <span id="dsq-author-user-17916">Ankur Jain</span>
            </cite>
        </div>
        <div id="dsq-comment-body-17916" class="dsq-comment-body">
            <div id="dsq-comment-message-17916" class="dsq-comment-message"><p>I think it will fail in the following case:<br />
1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;1-&gt;5-&gt;6<br />
The code will return false for 6 , 5 ,1 but it will send true for last i.e 4. Hence the ultimate value will be true but the linked list is not a palindrome. </p>
<p>Correct me if i am wrong.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-436">
        <div id="dsq-comment-header-436" class="dsq-comment-header">
            <cite id="dsq-cite-436">
                <span id="dsq-author-user-436">Siva.</span>
            </cite>
        </div>
        <div id="dsq-comment-body-436" class="dsq-comment-body">
            <div id="dsq-comment-message-436" class="dsq-comment-message"><p>Push all the nodes into Stack ,<br />
Pop the node and compare with original list.</p>
<p>This is o(2n).</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-geeksforgeeks bypostauthor even thread-odd thread-alt depth-1" id="dsq-comment-167">
        <div id="dsq-comment-header-167" class="dsq-comment-header">
            <cite id="dsq-cite-167">
                <span id="dsq-author-user-167">geeksforgeeks</span>
            </cite>
        </div>
        <div id="dsq-comment-body-167" class="dsq-comment-body">
            <div id="dsq-comment-message-167" class="dsq-comment-message"><p>@Hari Prasad Perabattula: Thanks for pointing this out.  We have corrected the if condition.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-165">
        <div id="dsq-comment-header-165" class="dsq-comment-header">
            <cite id="dsq-cite-165">
                <span id="dsq-author-user-165">Hari Prasad Perabattula</span>
            </cite>
        </div>
        <div id="dsq-comment-body-165" class="dsq-comment-body">
            <div id="dsq-comment-message-165" class="dsq-comment-message"><p>Hi, I think, it always prints &#8220;Linked list is Palindrome&#8221;. This is because,<br />
1). we return either &#8216;-1&#8242; or &#8216;1&#8217; from &#8216;compareLists&#8217;.<br />
2). The return value is assigned to &#8216;res&#8217; which in turn returned to the &#8216;main&#8217; function.<br />
3). The condition &#8216;if(isPalindrome(head))&#8217; is always true for any input.</p>
<p>Returning &#8216;0&#8217; may solve the problem.</p>
<p>Regards,<br />
Hari.</p>
</div>
        </div>

    </li><!-- #comment-## -->
            </ul>


        </div>

    </div>

<script type="text/javascript">
var disqus_url = 'http://www.geeksforgeeks.org/function-to-check-if-a-singly-linked-list-is-palindrome/';
var disqus_identifier = '1072 http://geeksforgeeks.org/?p=1072';
var disqus_container_id = 'disqus_thread';
var disqus_shortname = 'geeksforgeeks';
var disqus_title = "Function to check if a singly linked list is palindrome";
var disqus_config_custom = window.disqus_config;
var disqus_config = function () {
    /*
    All currently supported events:
    onReady: fires when everything is ready,
    onNewComment: fires when a new comment is posted,
    onIdentify: fires when user is authenticated
    */
    
    
    this.language = '';
    
    if (disqus_config_custom) {
        disqus_config_custom.call(this);
    }
};

(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>

			</div>
	
					
			
			

		</div> <!-- end post -->	

<br></br>
	
</div> <!-- end content -->

<ul id="sidebar">
	<li id="text-19" class="widget widget_text">			<div class="textwidget"><script>
  (function() {
    var cx = '009682134359037907028:tj6eafkv_be';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//www.google.com/cse/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>

<style type="text/css">
  .gsc-control-cse {
    font-family: "Trebuchet MS", sans-serif;
    border-color: #E1F3DA;
    background-color: #E1F3DA;
  }
  input.gsc-input {
    border-color: #94CC7A;
  }
  input.gsc-search-button {
    border-color: #94CC7A;
    background-color: #AADA92;
  }
  .gsc-tabHeader.gsc-tabhInactive {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gsc-tabHeader.gsc-tabhActive {
    border-color: #A9DA92;
    background-color: #A9DA92;
  }
  .gsc-tabsArea {
    border-color: #A9DA92;
  }
  .gsc-webResult.gsc-result {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gsc-webResult.gsc-result:hover {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gs-webResult.gs-result a.gs-title:link,
  .gs-webResult.gs-result a.gs-title:link b {
    color: #009900;
  }
  .gs-webResult.gs-result a.gs-title:visited,
  .gs-webResult.gs-result a.gs-title:visited b {
    color: #009900;
  }
  .gs-webResult.gs-result a.gs-title:hover,
  .gs-webResult.gs-result a.gs-title:hover b {
    color: #003300;
  }
  .gs-webResult.gs-result a.gs-title:active,
  .gs-webResult.gs-result a.gs-title:active b {
    color: #009900;
  }
  .gsc-cursor-page {
    color: #009900;
  }
  a.gsc-trailing-more-results:link {
    color: #009900;
  }
  .gs-webResult.gs-result .gs-snippet {
    color: #454545;
  }
  .gs-webResult.gs-result .gs-visibleUrl {
    color: #33cc00;
  }
  .gs-webResult.gs-result .gs-visibleUrl-short {
    color: #33cc00;
  }
  .gs-webResult.gs-result .gs-visibleUrl-short {
    display: none;
  }
  .gs-webResult.gs-result .gs-visibleUrl-long {
    display: block;
  }
  .gsc-cursor-box {
    border-color: #A9DA92;
  }
  .gsc-results .gsc-cursor-page {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gsc-results .gsc-cursor-page.gsc-cursor-current-page {
    border-color: #A9DA92;
    background-color: #A9DA92;
  }
  .gs-promotion.gs-result {
    border-color: #94CC7A;
    background-color: #CBE8B4;
  }
  .gs-promotion.gs-result a.gs-title:link {
    color: #0066CC;
  }
  .gs-promotion.gs-result a.gs-title:visited {
    color: #0066CC;
  }
  .gs-promotion.gs-result a.gs-title:hover {
    color: #0066CC;
  }
  .gs-promotion.gs-result a.gs-title:active {
    color: #0066CC;
  }
  .gs-promotion.gs-result .gs-snippet {
    color: #454545;
  }
  .gs-promotion.gs-result .gs-visibleUrl,
  .gs-promotion.gs-result .gs-visibleUrl-short {
    color: #815FA7;
  }
</style>    </div>
		</li>
<li id="text-9" class="widget widget_text">			<div class="textwidget"><div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=138031159685820";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>

<div class="fb-like-box" data-href="https://www.facebook.com/pages/GeeksforGeeks/316764689022" data-width="250" data-height="170" data-colorscheme="light" data-show-faces="true" data-header="false" data-stream="false" data-show-border="false"></div></div>
		</li>
<li id="text-18" class="widget widget_text">			<div class="textwidget"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LargeRectangleSide -->
<ins class="adsbygoogle"
     style="display:inline-block;width:336px;height:280px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="1884636833"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
		</li>
<li id="text-13" class="widget widget_text">			<div class="textwidget"><ul><li><a href="http://www.geeksforgeeks.org/category/interview-experiences/">Interview Experiences</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/advance-data-structures">Advanced Data Structures</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/dynamic-programming">Dynamic Programming</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/Greedy-Algorithm/">Greedy Algorithms</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/backtracking">Backtracking</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/pattern-searching">Pattern Searching</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/divide-and-conquer">Divide & Conquer</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/MathematicalAlgo">Mathematical Algorithms</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/recursion">Recursion</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/geometric-algorithms/">Geometric Algorithms</a></li>
</ul></div>
		</li>
<li id="text-17" class="widget widget_text">			<div class="textwidget"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big 300x600 Sidebar -->
<ins class="adsbygoogle"
     style="display:inline-block;width:300px;height:600px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="4402736037"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
		</li>
<li id="text-14" class="widget widget_text"><h2 class="widgettitle">Popular Posts</h2>
			<div class="textwidget"><ul>
<li><a href="http://www.geeksforgeeks.org/write-a-c-program-to-print-all-permutations-of-a-given-string/">  All permutations of a given string </a></li>
<li><a href="http://www.geeksforgeeks.org/memory-layout-of-c-program/"> Memory Layout of C Programs</a> </li>
<li><a href="http://www.geeksforgeeks.org/understanding-extern-keyword-in-c/"> Understanding extern keyword in C</a> </li>
<li><a href="http://www.geeksforgeeks.org/median-of-two-sorted-arrays/">Median of two sorted arrays</a> </li>
<li><a href="http://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/"> Tree traversal without recursion and without stack! </a></li>
<li><a href="http://www.geeksforgeeks.org/structure-member-alignment-padding-and-data-packing/"> Structure Member Alignment, Padding and Data Packing</a> </li>
<li><a href="http://www.geeksforgeeks.org/write-a-function-to-get-the-intersection-point-of-two-linked-lists/"> Intersection point of two Linked Lists</a> </li>
<li><a href="http://www.geeksforgeeks.org/lowest-common-ancestor-in-a-binary-search-tree/"> Lowest Common Ancestor in a BST.</span></a> </li>
<li><a href="http://www.geeksforgeeks.org/a-program-to-check-if-a-binary-tree-is-bst-or-not/"> Check if a binary tree is BST or not</a> </li>
<li><a href="http://www.geeksforgeeks.org/sorted-linked-list-to-balanced-bst/"> Sorted Linked List to Balanced BST</a></li>
</ul></div>
		</li>
<li id="text-3" class="widget widget_text">			<div class="textwidget"><a href="https://twitter.com/GeeksforGeeks" class="twitter-follow-button" data-show-count="false">Follow @GeeksforGeeks</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>         


<!-- GOOGLE FEEDBURNER BUTTON-->
<a href="http://feeds.feedburner.com/Geeksforgeeks" title="Subscribe to my feed" rel="alternate" type="application/rss+xml"><img src="http://www.feedburner.com/fb/images/pub/feed-icon32x32.png" alt="" style="border:0"/></a><a href="http://feeds.feedburner.com/Geeksforgeeks" title="Subscribe to my feed" rel="alternate" type="application/rss+xml">Subscribe</a>

</div>
		</li>
<li id="text-21" class="widget widget_text"><h2 class="widgettitle">Recent Comments</h2>
			<div class="textwidget"><script type="text/javascript" src="http://geeksforgeeks.disqus.com//recent_comments_widget.js?num_items=6&hide_avatars=1&excerpt_length=50&hide_mods=0"></script></div>
		</li>
<li id="text-22" class="widget widget_text">			<div class="textwidget"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LinkAd -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:90px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="2606115235"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LinkAd -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:90px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="2606115235"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LinkAd -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:90px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="2606115235"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
		</li>

</ul>					  
		<div class="clear"></div>

		<div id="footer">
		
		    <div class="xhtml">
                        @geeksforgeeks, <a href="http://creativecommons.org/licenses/by-nc-nd/2.5/in/deed.en_US" title="Valid XHTML Strict 1.0">Some rights reserved</a>  <a href="http://www.geeksforgeeks.org/about/contact-us/"> &nbsp; &nbsp; &nbsp; &nbsp;Contact Us!</a>

		    </div>
		    
		    <div class="credits">
			  Powered by <a href="http://wordpress.org">WordPress </a> &amp; <a href="http://mootools.net/" title="Mootools JavaScript Framework">MooTools</a>, customized by geeksforgeeks team </div>
			  
		   <div class="clear"></div>						                            
		   
		</div> <!--end footer-->  
        
		        <script type="text/javascript">
        // <![CDATA[
        var disqus_shortname = 'geeksforgeeks';
        (function () {
            var nodes = document.getElementsByTagName('span');
            for (var i = 0, url; i < nodes.length; i++) {
                if (nodes[i].className.indexOf('dsq-postid') != -1) {
                    nodes[i].parentNode.setAttribute('data-disqus-identifier', nodes[i].getAttribute('rel'));
                    url = nodes[i].parentNode.href.split('#', 1);
                    if (url.length == 1) { url = url[0]; }
                    else { url = url[1]; }
                    nodes[i].parentNode.href = url + '#disqus_thread';
                }
            }
            var s = document.createElement('script'); 
            s.async = true;
            s.type = 'text/javascript';
            s.src = '//' + disqus_shortname + '.disqus.com/count.js';
            (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
        }());
        // ]]>
        </script>
        <script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/scripts/shCore.js?ver=3.0.9'></script>
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/scripts/shBrushCpp.js?ver=3.0.9'></script>
<script type='text/javascript'>
	(function(){
		var corecss = document.createElement('link');
		var themecss = document.createElement('link');
		var corecssurl = "http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/styles/shCore.css?ver=3.0.9";
		if ( corecss.setAttribute ) {
				corecss.setAttribute( "rel", "stylesheet" );
				corecss.setAttribute( "type", "text/css" );
				corecss.setAttribute( "href", corecssurl );
		} else {
				corecss.rel = "stylesheet";
				corecss.href = corecssurl;
		}
		document.getElementsByTagName("head")[0].insertBefore( corecss, document.getElementById("syntaxhighlighteranchor") );
		var themecssurl = "http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/styles/shThemeDefault.css?ver=3.0.9";
		if ( themecss.setAttribute ) {
				themecss.setAttribute( "rel", "stylesheet" );
				themecss.setAttribute( "type", "text/css" );
				themecss.setAttribute( "href", themecssurl );
		} else {
				themecss.rel = "stylesheet";
				themecss.href = themecssurl;
		}
		//document.getElementById("syntaxhighlighteranchor").appendChild(themecss);
		document.getElementsByTagName("head")[0].insertBefore( themecss, document.getElementById("syntaxhighlighteranchor") );
	})();
	SyntaxHighlighter.config.strings.expandSource = '+ expand source';
	SyntaxHighlighter.config.strings.help = '?';
	SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
	SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
	SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
	SyntaxHighlighter.defaults['gutter'] = false;
	SyntaxHighlighter.defaults['pad-line-numbers'] = true;
	SyntaxHighlighter.defaults['toolbar'] = false;
	SyntaxHighlighter.all();
</script>
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/bbpress/templates/default/js/editor.js?ver=2.5.4-5380'></script>
				  
		</div> <!--end wrapper-->
        <div id="ajaxSpinner"></div> <!--For AJAX spinner holder-->
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-12148232-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
	</body>

</html>
<!-- Dynamic page generated in 0.260 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2014-12-04 12:00:11 -->

<!-- Compression = gzip -->
<!-- super cache -->