<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
       <title>Root to leaf path sum equal to a given number - GeeksforGeeks</title>
       <style type="text/css" media="screen">
          @import url('http://d2o58evtke57tz.cloudfront.net/wp-content/themes/minimoo/style.css');
    </style>
      <link href="http://d2o58evtke57tz.cloudfront.net/wp-content/themes/minimoo/favicon.ico" rel="shortcut icon" />    
    
<!-- This site is optimized with the Yoast WordPress SEO plugin v1.7.1 - https://yoast.com/wordpress/plugins/seo/ -->
<link rel="canonical" href="http://www.geeksforgeeks.org/root-to-leaf-path-sum-equal-to-a-given-number/" />
<meta property="og:locale" content="en_US" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Root to leaf path sum equal to a given number - GeeksforGeeks" />
<meta property="og:description" content="Given a binary tree and a number, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals the given number. Return false if no such path can be found. For example, in the above tree root to leaf paths exist with following sums. 21 &#8211;&gt; &hellip;" />
<meta property="og:url" content="http://www.geeksforgeeks.org/root-to-leaf-path-sum-equal-to-a-given-number/" />
<meta property="og:site_name" content="GeeksforGeeks" />
<meta property="article:section" content="Trees" />
<meta property="article:published_time" content="2010-04-07T19:25:56+00:00" />
<meta property="article:modified_time" content="2012-01-09T08:04:54+00:00" />
<meta property="og:updated_time" content="2012-01-09T08:04:54+00:00" />
<meta property="og:image" content="http://geeksforgeeks.org/wp-content/uploads/sum_property_tree1.gif" />
<!-- / Yoast WordPress SEO plugin. -->

<link rel='stylesheet' id='wp-quicklatex-format-css'  href='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/wp-quicklatex/css/quicklatex-format.css?ver=4.0.1' type='text/css' media='all' />
<link rel='stylesheet' id='bbp-default-css'  href='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/bbpress/templates/default/css/bbpress.css?ver=2.5.4-5380' type='text/css' media='screen' />
<link rel='stylesheet' id='wp-pagenavi-css'  href='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/wp-pagenavi/pagenavi-css.css?ver=2.70' type='text/css' media='all' />
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-includes/js/jquery/jquery.js?ver=1.11.1'></script>
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-includes/js/jquery/jquery-migrate.min.js?ver=1.2.1'></script>
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/wp-quicklatex/js/wp-quicklatex-frontend.js?ver=1.0'></script>

<!-- Bad Behavior 2.2.16 run time: 1.518 ms -->
<script type="text/javascript">
<!--
function bb2_addLoadEvent(func) {
	var oldonload = window.onload;
	if (typeof window.onload != 'function') {
		window.onload = func;
	} else {
		window.onload = function() {
			oldonload();
			func();
		}
	}
}

bb2_addLoadEvent(function() {
	for ( i=0; i < document.forms.length; i++ ) {
		if (document.forms[i].method == 'post') {
			var myElement = document.createElement('input');
			myElement.setAttribute('type', 'hidden');
			myElement.name = 'bb2_screener_';
			myElement.value = '1417111175 210.212.53.139 172.19.11.169';
			document.forms[i].appendChild(myElement);
		}
	}
});
// --></script>
		<style type="text/css" id="syntaxhighlighteranchor"></style>
   <meta name="google-site-verification" content="rHK2v8_zzuAZQY8JHAzbllDN8u-aQxcn2Kqnp67Old0" />
</head>

<body>
<!-- o4dI0sCXUgoSONabbd8mbZ4SA3E -->    
    <div id="wrapper">
        <div class="blog-info">
                <h1 class="blog-title">
                <a href="http://www.geeksforgeeks.org" title="GeeksforGeeks">GeeksforGeeks</a>
            </h1>
       
            <div class="blog-description">
                A computer science portal for geeks            </div>
        </div>
        <b><p>  <h2 align="right"> <a href="http://geeksquiz.com/">GeeksQuiz</a></h2> 
   <a href="http://www.geeksforgeeks.org/wp-login.php">Login</a> 
         </p></b>  
         
         <div class="clear"></div>         
              
                     
            <div id="menu">   
                 <ul>
 <li><a href="http://www.geeksforgeeks.org">Home</a></li>
  <li><a href="http://www.geeksforgeeks.org/fundamentals-of-algorithms/">Algorithms</a></li>
 <li><a href="http://www.geeksforgeeks.org/data-structures/">DS</a></li>
  <li><a href="http://www.geeksforgeeks.org/gate-corner/">GATE</a></li>
  <li><a href="http://www.geeksforgeeks.org/about/interview-corner/">Interview Corner</a></li>
  <li><a href="http://www.geeksforgeeks.org/forums/">Q&A</a></li>
  <li><a href="http://www.geeksforgeeks.org/c/">C</a></li>
  <li><a href="http://www.geeksforgeeks.org/c-plus-plus/">C++</a></li>
  <li><a href="http://www.geeksforgeeks.org/java/">Java</a></li>
  <li><a href="http://www.geeksforgeeks.org/books/">Books</a></li>
  <li><a href="http://www.geeksforgeeks.org/contribute/">Contribute</a></li>
  <li><a href="http://www.geeksforgeeks.org/contribute/ask-a-question/">Ask a Q</a></li>
  <li><a href="http://www.geeksforgeeks.org/about/">About</a></li>
            </ul>

               
            <div class="clear"></div>     
        </div>
             <div id="navmenu">
				<ul id="menu" style="padding:0; margin:0;">
						<li class="cat-item cat-item-3"><a href="http://www.geeksforgeeks.org/category/c-arrays/" title="Questions regarding Arrays">Array</a>
</li>	

	<li class="cat-item cat-item-17"><a href="http://www.geeksforgeeks.org/category/bit-magic/" title="View all posts filed under Bit Magic">Bit Magic</a>
</li>
	<li class="cat-item cat-item-14"><a href="http://www.geeksforgeeks.org/category/c-puzzles/" title="View all posts filed under C/C++ Puzzles">C/C++</a>
</li>

<li class="cat-item cat-item-18"><a href="http://www.geeksforgeeks.org/category/articles/" title="View all posts filed under Articles">Articles</a>
</li>

	<li class="cat-item cat-item-67"><a href="http://www.geeksforgeeks.org/category/gfact/" title="View all posts filed under GFacts">GFacts</a>
</li>
	<li class="cat-item cat-item-8"><a href="http://www.geeksforgeeks.org/category/linked-list/" title="Linked List problems">Linked List</a>
</li>
	<li class="cat-item cat-item-66"><a href="http://www.geeksforgeeks.org/category/multiple-choice-question/" title="View all posts filed under MCQ">MCQ</a>

</li>
	<li class="cat-item cat-item-4"><a href="http://www.geeksforgeeks.org/category/c-programs/" title="Miscellaneous">Misc</a>
</li>
	<li class="cat-item cat-item-5"><a href="http://www.geeksforgeeks.org/category/program-output/" title="View all posts filed under Output">Output</a>
</li>
	<li class="cat-item cat-item-7"><a href="http://www.geeksforgeeks.org/category/c-strings/" title="Questions related to strings">String</a>
</li>
	<li class="cat-item cat-item-19"><a href="http://www.geeksforgeeks.org/category/tree/" title="View all posts filed under Trees">Tree</a>
</li>
	<li class="cat-item cat-item-19"><a href="http://www.geeksforgeeks.org/category/graph/" title="View all posts filed under Graph">Graph</a>
</li>
</ul>
        </div>
             <div id="content">	   	
	<div class="post" id="post">
							<div class="post-info">			
					<div class="post-title-info">
						<h2 class="post-title">Root to leaf path sum equal to a given number</h2>
					</div>			
					<div class="clear"></div>				  
				<div class="post-content" id="post-content">
					<p>Given a binary tree and a number, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals the given number. <span id="more-6201"></span>Return false if no such path can be found. </p>
<p><a href="http://geeksforgeeks.org/wp-content/uploads/sum_property_tree1.gif"><img src="http://geeksforgeeks.org/wp-content/uploads/sum_property_tree1.gif" alt="" title="sum_property_tree" width="267" height="169" class="aligncenter size-full wp-image-4420" /></a></p>
<p>For example, in the above tree root to leaf paths exist with following sums.</p>
<p>21 &#8211;>  10 &#8211; 8 &#8211; 3<br />
23 &#8211;>  10 &#8211; 8 &#8211; 5<br />
14 &#8211;>  10 &#8211; 2 &#8211; 2</p>
<p>So the returned value should be true only for numbers 21, 23 and 14. For any other number, returned value should be false.</p>
<p>Algorithm:<br />
Recursively check if left or right child has path sum equal to ( number – value at current node)</p>
<p>Implementation:</p>
<pre class="brush: cpp; title: ; notranslate" title="">
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#define bool int

/* A binary tree node has data, pointer to left child
   and a pointer to right child */
struct node
{
   int data;
   struct node* left;
   struct node* right;
};

/*
 Given a tree and a sum, return true if there is a path from the root
 down to a leaf, such that adding up all the values along the path
 equals the given sum.

 Strategy: subtract the node value from the sum when recurring down,
 and check to see if the sum is 0 when you run out of tree.
*/
bool hasPathSum(struct node* node, int sum)
{
  /* return true if we run out of tree and sum==0 */
  if (node == NULL)
  {
     return (sum == 0);
  }
 
  else
  {
    bool ans = 0;  
 
    /* otherwise check both subtrees */
    int subSum = sum - node-&gt;data;
 
    /* If we reach a leaf node and sum becomes 0 then return true*/
    if ( subSum == 0 &amp;&amp; node-&gt;left == NULL &amp;&amp; node-&gt;right == NULL )
      return 1;
 
    if(node-&gt;left)
      ans = ans || hasPathSum(node-&gt;left, subSum);
    if(node-&gt;right)
      ans = ans || hasPathSum(node-&gt;right, subSum);
 
    return ans;
  }
}

/* UTILITY FUNCTIONS */
/* Helper function that allocates a new node with the
   given data and NULL left and right pointers. */
struct node* newnode(int data)
{
  struct node* node = (struct node*)
                       malloc(sizeof(struct node));
  node-&gt;data = data;
  node-&gt;left = NULL;
  node-&gt;right = NULL;

  return(node);
}

/* Driver program to test above functions*/
int main()
{

  int sum = 21;

  /* Constructed binary tree is
            10
          /   \
        8      2
      /  \    /
    3     5  2
  */
  struct node *root = newnode(10);
  root-&gt;left        = newnode(8);
  root-&gt;right       = newnode(2);
  root-&gt;left-&gt;left  = newnode(3);
  root-&gt;left-&gt;right = newnode(5);
  root-&gt;right-&gt;left = newnode(2);

  if(hasPathSum(root, sum))
    printf(&quot;There is a root-to-leaf path with sum %d&quot;, sum);
  else
    printf(&quot;There is no root-to-leaf path with sum %d&quot;, sum);

  getchar();
  return 0;
}
</pre>
<p>Time Complexity: O(n)</p>
<p>References:<br />
<a href="http://cslibrary.stanford.edu/110/BinaryTrees.html">http://cslibrary.stanford.edu/110/BinaryTrees.html</a></p>
<p>Author: Tushar Roy</p>
<p></br><br />
Please write comments if you find any bug in above code/algorithm, or find other ways to solve the same problem</p>
		
&nbsp;
&nbsp;
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle"
     style="display:inline-block;width:336px;height:280px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="4061219431"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>



&nbsp;
&nbsp;
&nbsp;
<h3>Related Topics:</h3><ul><li><a href="http://www.geeksforgeeks.org/perfect-binary-tree-specific-level-order-traversal/" title="Perfect Binary Tree Specific Level Order Traversal">Perfect Binary Tree Specific Level Order Traversal</a></li><li><a href="http://www.geeksforgeeks.org/print-nodes-top-view-binary-tree/" title="Print Nodes in Top View of Binary Tree">Print Nodes in Top View of Binary Tree</a></li><li><a href="http://www.geeksforgeeks.org/k-dimensional-tree/" title="K Dimensional Tree">K Dimensional Tree</a></li><li><a href="http://www.geeksforgeeks.org/convert-binary-tree-threaded-binary-tree/" title="Convert a Binary Tree to Threaded binary tree">Convert a Binary Tree to Threaded binary tree</a></li><li><a href="http://www.geeksforgeeks.org/serialize-deserialize-n-ary-tree/" title="Serialize and Deserialize an N-ary Tree">Serialize and Deserialize an N-ary Tree</a></li><li><a href="http://www.geeksforgeeks.org/serialize-deserialize-binary-tree/" title="Serialize and Deserialize a Binary Tree">Serialize and Deserialize a Binary Tree</a></li><li><a href="http://www.geeksforgeeks.org/given-binary-tree-print-nodes-two-given-level-numbers/" title="Print nodes between two given level numbers of a binary tree">Print nodes between two given level numbers of a binary tree</a></li><li><a href="http://www.geeksforgeeks.org/find-height-binary-tree-represented-parent-array/" title="Find Height of Binary Tree represented by Parent array">Find Height of Binary Tree represented by Parent array</a></li></ul>
<p></p> 
<div>
<iframe src="http://www.facebook.com/plugins/like.php?href=http%3A%2F%2Fwww.geeksforgeeks.org%2Froot-to-leaf-path-sum-equal-to-a-given-number%2F&layout=button_count&show_faces=false&width=90&action=like&colorscheme=light" scrolling="no" frameborder="0" allowTransparency="true" style="border:none; overflow:hidden; width:90px; height:20px"></iframe>
<a href="http://twitter.com/share" class="twitter-share-button" data-url="http://www.geeksforgeeks.org/root-to-leaf-path-sum-equal-to-a-given-number/" data-text="Root to leaf path sum equal to a given number" data-count="horizontal" data-via="jakerutter">Tweet</a><script type="text/javascript" src="http://platform.twitter.com/widgets.js"></script>
<g:plusone size="medium" href="http://www.geeksforgeeks.org/root-to-leaf-path-sum-equal-to-a-given-number/"></g:plusone>
<!-- Place this render call where appropriate -->
<script type="text/javascript">
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script></div>





				</div>		  
			</div> <!-- end post main -->					
			<div class="post-meta">
				<div class="left"></div>				
				<div class="clear"></div>
			</div>			
        
			<div class="comments-main">		
 <b>Writing code in comment?</b> Please use <b><a href="http://ideone.com/">ideone.com</a></b> and share the link here.
				
<div id="disqus_thread">
            <div id="dsq-content">


            <ul id="dsq-comments">
                    <li class="comment even thread-even depth-1" id="dsq-comment-34470">
        <div id="dsq-comment-header-34470" class="dsq-comment-header">
            <cite id="dsq-cite-34470">
                <span id="dsq-author-user-34470">yogi</span>
            </cite>
        </div>
        <div id="dsq-comment-body-34470" class="dsq-comment-body">
            <div id="dsq-comment-message-34470" class="dsq-comment-message"><p>This following snippet of code works on all the +ve and -ve numbers. Is there any way this code snippet would break?</p>
<p>bool HasRoot2LeafPathSum(BinNode *pRoot, long remSum)<br />
{<br />
    if(pRoot == NULL)<br />
        return false;<br />
    if(pRoot-&gt;pLeft == NULL &amp;&amp; pRoot-&gt;pRight == NULL)<br />
        return (remSum == pRoot-&gt;data);<br />
    return (HasRoot2LeafPathSum(pRoot-&gt;pLeft, remSum &#8211; pRoot-&gt;data) ||<br />
        HasRoot2LeafPathSum(pRoot-&gt;pRight, remSum &#8211; pRoot-&gt;data));<br />
}<br />
<code></code></p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-33135">
        <div id="dsq-comment-header-33135" class="dsq-comment-header">
            <cite id="dsq-cite-33135">
                <span id="dsq-author-user-33135">Rakesh</span>
            </cite>
        </div>
        <div id="dsq-comment-body-33135" class="dsq-comment-body">
            <div id="dsq-comment-message-33135" class="dsq-comment-message"><p>I got a question in MS to optimize the search in case it&#8217;s a binary search tree (BST) . I tried a lot but can not replied. Right search can be stopped once our current sum exceeds a limit , but can not find way when to stop searching in left path. Can anyone write a algo for it.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-2" id="dsq-comment-33996">
        <div id="dsq-comment-header-33996" class="dsq-comment-header">
            <cite id="dsq-cite-33996">
                <span id="dsq-author-user-33996">danny</span>
            </cite>
        </div>
        <div id="dsq-comment-body-33996" class="dsq-comment-body">
            <div id="dsq-comment-message-33996" class="dsq-comment-message"><p>Left Search can be stopped<br />
If you have reached with no child but the sum is still not what is required it&#8217;s less OR if you have reached the value greater then or equal to sum(given value) but the node is not external&#8230;.</p>
<p>Please correct me If I am wrong.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-32440">
        <div id="dsq-comment-header-32440" class="dsq-comment-header">
            <cite id="dsq-cite-32440">
                <span id="dsq-author-user-32440">Sankeerth</span>
            </cite>
        </div>
        <div id="dsq-comment-body-32440" class="dsq-comment-body">
            <div id="dsq-comment-message-32440" class="dsq-comment-message"><p>The code seems wrong at the line:</p>
<p>if(root==NULL)</p>
<p>return sum==0;</p>
<p>Take the above figure for example. Let the sum to be checked for is 12.</p>
<p>at first root is visited and the sum value becomes 2(12-10). After that  we visits root-&gt;right node which is 2 and now the sum becomes 0(2-2). </p>
<p>But according to the code it returns 0 even though the root-&gt;right node is not a leaf node.</p>
<p>I think the correct code would go like this.</p>
<p>int root_to_leaf_path(struct node* root,int sum)<br />
{</p>
<p>if(root==NULL)<br />
return 0;</p>
<p>if(isleaf(root))<br />
return sum==root-&gt;data;</p>
<p>int subsum=root-&gt;data-sum;</p>
<p>int ans=0;</p>
<p>ans=root_to_leaf_path(root-&gt;left,subsum)|| root_to-leaf_path(root-&gt;right,subsum);</p>
<p>return ans;</p>
<p>}</p>
<p>This code fails for an empty tree. We can write a wrapper function above this to get over this limitation.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-31959">
        <div id="dsq-comment-header-31959" class="dsq-comment-header">
            <cite id="dsq-cite-31959">
                <span id="dsq-author-user-31959">me</span>
            </cite>
        </div>
        <div id="dsq-comment-body-31959" class="dsq-comment-body">
            <div id="dsq-comment-message-31959" class="dsq-comment-message"><p>#include </p>
<p>#include</p>
<p>using namespace std;</p>
<p>struct node</p>
<p>{</p>
<p>	int key;</p>
<p>	struct node *l;</p>
<p>	struct node *r;</p>
<p>};</p>
<p>void inorder(struct node *root)</p>
<p>{</p>
<p>	if(root)</p>
<p>	{</p>
<p>		inorder(root-&gt;l);</p>
<p>		cout&lt;key&lt;r);</p>
<p>	}</p>
<p>}</p>
<p>node *newnode(int key)</p>
<p>{</p>
<p>	node *temp= new struct node;</p>
<p>	temp-&gt;key = key;</p>
<p>    temp-&gt;l = temp-&gt;r = NULL;</p>
<p>    return temp;</p>
<p>}</p>
<p>node *insert(struct node *root,int key)</p>
<p>{</p>
<p>	if(root==NULL)</p>
<p>	return newnode(key);</p>
<p>	if (root-&gt;key &gt; key)</p>
<p>       root-&gt;l = insert(root-&gt;l, key);</p>
<p>    else</p>
<p>       root-&gt;r = insert(root-&gt;r, key);</p>
<p>    return root;</p>
<p>}</p>
<p>int path(node *root,int sum)</p>
<p>{</p>
<p>	if(root==NULL)</p>
<p>	return 0;</p>
<p>	sum=sum-root-&gt;key;</p>
<p>	if(sum==0 &amp;&amp; !root-&gt;l &amp;&amp; !root-&gt;r)</p>
<p>	return 1;</p>
<p>	if(path(root-&gt;l,sum) || path(root-&gt;r,sum))</p>
<p>	return 1;</p>
<p>	return 0;</p>
<p>}</p>
<p>int main(void) </p>
<p>{</p>
<p>	struct node *root=NULL;</p>
<p>	root=insert(root,6);</p>
<p>	root = insert(root, 2);</p>
<p>    root = insert(root, 8);</p>
<p>    root = insert(root, 1);</p>
<p>    root = insert(root, 4);</p>
<p>    root = insert(root, 7);</p>
<p>    root = insert(root, 9);</p>
<p>    cout&lt;&lt;path(root,12)&lt;&lt;endl;</p>
<p>    cout&lt;&lt;path(root,20)&lt;&lt;endl;</p>
<p>    cout&lt;&lt;path(root,21)&lt;&lt;endl;</p>
<p>    cout&lt;&lt;path(root,23)&lt;&lt;endl;</p>
<p>    cout&lt;&lt;path(root,9)&lt;&lt;endl;</p>
<p>	return 0;</p>
<p>}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-31498">
        <div id="dsq-comment-header-31498" class="dsq-comment-header">
            <cite id="dsq-cite-31498">
                <span id="dsq-author-user-31498">Harjit Singh</span>
            </cite>
        </div>
        <div id="dsq-comment-body-31498" class="dsq-comment-body">
            <div id="dsq-comment-message-31498" class="dsq-comment-message"><p>bool hasPathSum(struct node* root, int sum)</p>
<p>{</p>
<p>  if(root==NULL)</p>
<p>     return false;</p>
<p>  if(sumleft==NULL&amp;&amp;root-&gt;right==NULL)&amp;&amp;(sum==root-&gt;data))</p>
<p>       return true;</p>
<p>  return(hasPathSum(root-&gt;left,sum-root-&gt;data)||hasPathSum(root-&gt;right,sum-root-&gt;data));</p>
<p>}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-30938">
        <div id="dsq-comment-header-30938" class="dsq-comment-header">
            <cite id="dsq-cite-30938">
                <span id="dsq-author-user-30938">Uma Trika</span>
            </cite>
        </div>
        <div id="dsq-comment-body-30938" class="dsq-comment-body">
            <div id="dsq-comment-message-30938" class="dsq-comment-message"><p>bool hasPathSum(struct node* node, int sum, int path[], int len)</p>
<p>{</p>
<p>        static int result=0;</p>
<p>        int temp,i,temp_sum=0;</p>
<p>        if(node == NULL)</p>
<p>        return;</p>
<p>        path[len] = node-&gt;data;</p>
<p>        len++;</p>
<p>        if(node-&gt;left == NULL &amp;&amp; node-&gt;right == NULL)</p>
<p>        {</p>
<p>                for(i=0;ileft, sum, path, len);</p>
<p>                hasPathSum(node-&gt;right, sum, path, len);</p>
<p>        }</p>
<p>        return result;</p>
<p>}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-28579">
        <div id="dsq-comment-header-28579" class="dsq-comment-header">
            <cite id="dsq-cite-28579">
                <span id="dsq-author-user-28579">pavansrinivas</span>
            </cite>
        </div>
        <div id="dsq-comment-body-28579" class="dsq-comment-body">
            <div id="dsq-comment-message-28579" class="dsq-comment-message"><p>iterative Soln. in JAVA&#8230;validate me&#8230;</p>
<p><code></p>
<p>    boolean isPathSum(int key){<br />
        Node temp = root;<br />
        Queue q = new LinkedList();<br />
        int leftSum;<br />
        int rightSum;<br />
        int pathsum;<br />
        q.add(temp);<br />
         pathsum = root.iData;<br />
        q.add(pathsum);<br />
        while(!q.isEmpty()){<br />
            temp = (Node)q.remove();<br />
            pathsum = (Integer)q.remove();</p>
<p>       </code><br />
            if(temp.leftChild==null&amp;&amp;temp.rightChild==null){<br />
                if(pathsum==key){</p>
<p>                return true;<br />
                }<br />
            }<br />
            if(temp.leftChild!=null){<br />
                leftSum  = pathsum+temp.leftChild.iData;<br />
                q.add(temp.leftChild);<br />
                q.add(leftSum);<br />
            }<br />
            if(temp.rightChild!=null){<br />
                rightSum  = pathsum+temp.rightChild.iData;<br />
                q.add(temp.rightChild);<br />
                q.add(rightSum);<br />
            }<br />
        }<br />
        return false;<br />
    }</p>
<p>*/</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-28480">
        <div id="dsq-comment-header-28480" class="dsq-comment-header">
            <cite id="dsq-cite-28480">
                <span id="dsq-author-user-28480">Shivam</span>
            </cite>
        </div>
        <div id="dsq-comment-body-28480" class="dsq-comment-body">
            <div id="dsq-comment-message-28480" class="dsq-comment-message"><p>bool rootleavesum(treenode* root,int sum)<br />
{<br />
    if(root==NULL)<br />
       return 0 ;<br />
    sum=sum-root-&gt;data;<br />
    if(root-&gt;left==NULL &amp;&amp; root-&gt;right==NULL )<br />
    {<br />
       if(sum==0) return 1;<br />
       else return 0;<br />
    }<br />
   return  (rootleavesum(root-&gt;left,sum) || rootleavesum(root-&gt;right,sum));<br />
}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-28204">
        <div id="dsq-comment-header-28204" class="dsq-comment-header">
            <cite id="dsq-cite-28204">
                <span id="dsq-author-user-28204">munai</span>
            </cite>
        </div>
        <div id="dsq-comment-body-28204" class="dsq-comment-body">
            <div id="dsq-comment-message-28204" class="dsq-comment-message"><p>#include<br />
#include<br />
struct node<br />
{<br />
int data;<br />
struct node *left,*right;<br />
};<br />
typedef struct node node;<br />
node *NewNode(int val)<br />
{<br />
node *temp=(node *)malloc(sizeof(node));<br />
temp-&gt;data=val;<br />
temp-&gt;left=temp-&gt;right=NULL;<br />
return temp;<br />
}<br />
int IsPathSum(node *root,int sum)<br />
{<br />
int remain_sum;<br />
if(!root)<br />
return (sum==0);<br />
remain_sum=sum-root-&gt;data;<br />
return (IsPathSum(root-&gt;left,remain_sum) || IsPathSum(root-&gt;right,remain_sum));<br />
}<br />
int main()<br />
{<br />
node *root=NewNode(1);<br />
root-&gt;left=NewNode(2);<br />
root-&gt;right=NewNode(3);<br />
root-&gt;left-&gt;left=NewNode(4);<br />
root-&gt;left-&gt;right=NewNode(5);<br />
root-&gt;right-&gt;left=NewNode(6);<br />
//root-&gt;right-&gt;right=NewNode(7);<br />
if(IsPathSum(root,4))<br />
printf(&#8220;Path existsn&#8221;);<br />
else<br />
printf(&#8220;Path doesn&#8217;t existn&#8221;);<br />
return 0;<br />
}</p>
<p>Is there any flaw? please check it out.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-20281">
        <div id="dsq-comment-header-20281" class="dsq-comment-header">
            <cite id="dsq-cite-20281">
                <span id="dsq-author-user-20281">srb</span>
            </cite>
        </div>
        <div id="dsq-comment-body-20281" class="dsq-comment-body">
            <div id="dsq-comment-message-20281" class="dsq-comment-message"><pre> <code language="C">
bool hasPathSum(struct node* node, int sum)
{
  if (node == NULL)
  {
     return (sum == 0);
  }
  else
  {
    bool ans = 0;  
    int subSum = sum - node-&gt;data;
    ans = ans || hasPathSum(node-&gt;left, subSum)||   hasPathSum(node-&gt;right, subSum);;
    return ans;
  }
}

/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-18569">
        <div id="dsq-comment-header-18569" class="dsq-comment-header">
            <cite id="dsq-cite-18569">
                <span id="dsq-author-user-18569">shivi</span>
            </cite>
        </div>
        <div id="dsq-comment-body-18569" class="dsq-comment-body">
            <div id="dsq-comment-message-18569" class="dsq-comment-message"><pre> <code language="C">
bool rootTo(Node *start,int path[],int pathlen,int sum)
{
	if(start==NULL)
	return 0;
	
	else
	{
		path[pathlen]=start-&gt;data+path[pathlen-1];
		++pathlen;
		if(start-&gt;left==NULL &amp;&amp; start-&gt;right==NULL)
		{
			if(path[pathlen-1]==sum)
			return 1;
			
			else 
			return 0;
		}
	}
	return (rootTo(start-&gt;left,path,pathlen,sum) || rootTo(start-&gt;right,path,pathlen,sum));
}

bool rootToLeaf(Node *start,int sum)
{
	int path[100],pathlen=1;
	path[0]=0;
	return rootTo(start,path,pathlen,sum);
}
</code> </pre>
<p>this will take O(n)?</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-abhishek08aug even thread-odd thread-alt depth-1" id="dsq-comment-18109">
        <div id="dsq-comment-header-18109" class="dsq-comment-header">
            <cite id="dsq-cite-18109">
                <span id="dsq-author-user-18109">abhishek08aug</span>
            </cite>
        </div>
        <div id="dsq-comment-body-18109" class="dsq-comment-body">
            <div id="dsq-comment-message-18109" class="dsq-comment-message"><p>C++ code:</p>
<pre> <code language="C">
#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;
using namespace std;
 
class tree_node {
  private:
    int data;
    tree_node * left;
    tree_node * right;
  public:
    tree_node() {
      left=NULL;
      right=NULL;
    }
    void set_data(int data) {
      this-&gt;data=data;
    }
    int get_data() {
      return this-&gt;data;
    }
    void set_left(tree_node * left) {
      this-&gt;left=left;
    }
    tree_node * get_left() {
      return this-&gt;left;
    }
    void set_right(tree_node * right) {
      this-&gt;right=right;
    }
    tree_node * get_right() {
      return this-&gt;right;
    }
    tree_node ** get_left_ref() {
      return &amp;(this-&gt;left);
    }
    tree_node ** get_right_ref() {
      return &amp;(this-&gt;right);
    }
};
 
class tree {
  private:
    tree_node * root;
    int size;
    void _recursive_insert(tree_node ** root_ref, int value);
    void _print_preorder(tree_node * root);
    void _print_inorder(tree_node * root);
    void _print_postorder(tree_node * root);
    int _find_size(tree_node * root);
    int _are_identical(tree_node * tn1, tree_node * tn2);
    int _find_height(tree_node * root);
    void _delete_tree(tree_node ** root);
    void _mirror(tree_node * root);
    void _print_paths(tree_node * root, int * path_nodes, int next_vacant_position);
    void _print_array(int * array, int len);
    tree_node * _lowest_common_ancestor(tree_node * parent, tree_node * root, int a, int b);
    tree_node * _find_node(tree_node * root, int value);
    tree_node * _min_node(tree_node * root);
    void _print_level_order(tree_node * root);
    int _count_leaf_nodes(tree_node * root);
    int _is_bst(tree_node * root);
    int _children_sum(tree_node * root);
    void _ensure_children_sum(tree_node * root);
    int _diameter(tree_node * root);
    int _is_height_balanced(tree_node * root);
    int _leaf_path_sum(tree_node * root, int num);
  public:
    tree() {
      root=NULL;
      size=0;
    }
    void insert(int value);
    void recursive_insert(int value);
    void print_preorder();
    void print_inorder();
    void print_postorder();
    int find_size();
    int get_size() {
      return this-&gt;size;
    }
    int are_identical(tree t);
    int find_height();
    void delete_tree();
    void mirror();
    void print_paths();
    tree_node * lowest_common_ancestor(int a, int b);
    tree_node * find_node(int value);
    tree_node * min_node();
    void print_level_order();
    int count_leaf_nodes();
    int is_bst();
    int children_sum();
    void ensure_children_sum();
    int diameter();
    int is_height_balanced();
    int leaf_path_sum(int num);
};
 
void tree::insert(int value) {
  if(root==NULL) {
    root=new tree_node;
    root-&gt;set_data(value);
  } else {
    tree_node * parent=NULL;
    tree_node * current=root;
    tree_node * new_node=new tree_node;
    new_node-&gt;set_data(value);
    while(current!=NULL) {
      if(value&lt;=current-&gt;get_data()) {
        parent=current;
        current=current-&gt;get_left();
      } else {
        parent=current;
        current=current-&gt;get_right();
      }
    }
    if(value&lt;=parent-&gt;get_data() &amp;&amp; parent-&gt;get_left()==NULL) {
      parent-&gt;set_left(new_node);
    } else if(value&gt;parent-&gt;get_data() &amp;&amp; parent-&gt;get_right()==NULL) {
      parent-&gt;set_right(new_node);
    }
  }
  size++;
}
 
void tree::recursive_insert(int value) {
  _recursive_insert(&amp;root, value);
  size++;
}
 
void tree::_recursive_insert(tree_node ** root_ref, int value) {
  if(*root_ref==NULL) {
    tree_node * new_node=new tree_node;
    new_node-&gt;set_data(value);
    *root_ref=new_node;   
  } else {
    if(value&lt;=(*root_ref)-&gt;get_data()) {
      _recursive_insert((*root_ref)-&gt;get_left_ref(), value);
    } else {
      _recursive_insert((*root_ref)-&gt;get_right_ref(), value);
    }
  }
}
 
void tree::print_preorder() {
  if(root==NULL) {
    return;
  }
  _print_preorder(root);
  cout&lt;&lt;endl;
}
 
void tree::_print_preorder(tree_node * root) {
  if(root==NULL) {
    return;
  }
  cout&lt;&lt;root-&gt;get_data()&lt;&lt;&quot; &quot;;
  if(root-&gt;get_left()!=NULL)
    _print_preorder(root-&gt;get_left());
  if(root-&gt;get_right()!=NULL)
    _print_preorder(root-&gt;get_right());
}
 
void tree::print_inorder() {
  if(root==NULL) {
    return;
  }
  _print_inorder(root);
  cout&lt;&lt;endl;
}
 
void tree::_print_inorder(tree_node * root) {
  if(root==NULL) {
    return;
  }
  if(root-&gt;get_left()!=NULL)
    _print_inorder(root-&gt;get_left());
  cout&lt;&lt;root-&gt;get_data()&lt;&lt;&quot; &quot;;
  if(root-&gt;get_right()!=NULL)
    _print_inorder(root-&gt;get_right());
}
 
void tree::print_postorder() {
  if(root==NULL) {
    return;
  }
  _print_postorder(root);
  cout&lt;&lt;endl;
}
 
void tree::_print_postorder(tree_node * root) {
  if(root==NULL) {
    return;
  }
  if(root-&gt;get_left()!=NULL)
    _print_postorder(root-&gt;get_left());
  if(root-&gt;get_right()!=NULL)
    _print_postorder(root-&gt;get_right());
  cout&lt;&lt;root-&gt;get_data()&lt;&lt;&quot; &quot;;
}

int tree::find_size() {
  return _find_size(root);
}

int tree::_find_size(tree_node * root) {
  if(root==NULL) {
    return 0;
  } else {
    return 1+_find_size(root-&gt;get_left())+_find_size(root-&gt;get_right());
  }
}

int tree::are_identical(tree t) {
  return _are_identical(this-&gt;root, t.root);
}

int tree::_are_identical(tree_node * tn1, tree_node * tn2) {
  if(tn1==NULL &amp;&amp; tn2==NULL) {
    return 1;
  } else if((tn1==NULL &amp;&amp; tn2!=NULL) || (tn1!=NULL &amp;&amp; tn2==NULL) || (tn1-&gt;get_data()!=tn2-&gt;get_data())) {
    return 0;
  } else {
    return _are_identical(tn1-&gt;get_left(), tn2-&gt;get_left()) &amp;&amp; _are_identical(tn1-&gt;get_right(), tn2-&gt;get_right());
  }
}

int tree::find_height() {
  return _find_height(root);
}

int tree::_find_height(tree_node * root) {
  if(root==NULL) {
    return 0;
  }
  else {
    return 1+max(_find_height(root-&gt;get_left()), _find_height(root-&gt;get_right()));
  }
}

void tree::delete_tree() {
  _delete_tree(&amp;root);
  size=0;
}

void tree::_delete_tree(tree_node ** root) {
  if(*root==NULL) {
    return;
  } else {
    if((*root)-&gt;get_left()!=NULL) {
      _delete_tree((*root)-&gt;get_left_ref());
    }
    if((*root)-&gt;get_right()!=NULL) {
      _delete_tree((*root)-&gt;get_right_ref());
    }
    delete(*root);
    *root=NULL;
  }
}

/* alternate _delete_tree */
/*
void tree::_delete_tree(tree_node ** root) {
  if(*root==NULL) {
    return;
  } else {
    if((*root)-&gt;get_left()!=NULL) {
      tree_node * left_ref=(*root)-&gt;get_left();
      _delete_tree(&amp;left_ref);
    }
    if((*root)-&gt;get_right()!=NULL) {
      tree_node * right_ref=(*root)-&gt;get_right();
      _delete_tree(&amp;right_ref);
    }
    delete(*root);
    *root=NULL;
  }
}
*/

void tree::mirror() {
  _mirror(root);
}

void tree::_mirror(tree_node * root) {
  if(root==NULL) {
    return;
  }

  tree_node * temp=root-&gt;get_left();
  root-&gt;set_left(root-&gt;get_right());
  root-&gt;set_right(temp);
  _mirror(root-&gt;get_left());
  _mirror(root-&gt;get_right());
}

void tree::print_paths(){
   int max_path_length=find_height();
   int * path_nodes=(int *)calloc(sizeof(int), max_path_length);
  _print_paths(root, path_nodes, 0);
}

void tree::_print_paths(tree_node * root, int * path_nodes, int next_vacant_position){
  if(root==NULL) {
    return;
  } else if(root-&gt;get_left()==NULL &amp;&amp; root-&gt;get_right()==NULL) {
    *(path_nodes+next_vacant_position)=root-&gt;get_data();
    _print_array(path_nodes, next_vacant_position);
  } else {
    *(path_nodes+next_vacant_position)=root-&gt;get_data();
    _print_paths(root-&gt;get_left(), path_nodes, next_vacant_position+1);
    _print_paths(root-&gt;get_right(), path_nodes, next_vacant_position+1);
  }
}

void tree::_print_array(int * array, int len) {
  int i;
  for(i=0; i&lt;=len; i++) {
    cout&lt;&lt;*(array+i)&lt;&lt;&quot; &quot;;
  }
  cout&lt;&lt;endl;
}

tree_node * tree::find_node(int value) {
  return _find_node(root, value);
}

tree_node * tree::_find_node(tree_node * root, int value) {
  if(root==NULL || root-&gt;get_data()==value) {
    return root;
  } else if(value&lt;=root-&gt;get_data()) {
    return _find_node(root-&gt;get_left(), value);
  } else {
    return _find_node(root-&gt;get_right(), value);
  }
}

tree_node * tree::lowest_common_ancestor(int a, int b) {
  return _lowest_common_ancestor(NULL, root, a, b);
}

tree_node * tree::_lowest_common_ancestor(tree_node * parent, tree_node * root, int a, int b) {
  if(root==NULL) {
    return root;
  } else if((root-&gt;get_data()==a &amp;&amp; (root-&gt;get_left()-&gt;get_data()==b || root-&gt;get_right()-&gt;get_data()==b))
             || (root-&gt;get_data()==b &amp;&amp; (root-&gt;get_left()-&gt;get_data()==a || root-&gt;get_right()-&gt;get_data()==a))) {
    return parent;
  } else if((_find_node(root-&gt;get_left(), a)!=NULL &amp;&amp; _find_node(root-&gt;get_right(), b)!=NULL)
        || (_find_node(root-&gt;get_left(), b)!=NULL &amp;&amp; _find_node(root-&gt;get_right(), a)!=NULL)) {
    return root; 
  } else if(_find_node(root-&gt;get_left(), a)!=NULL &amp;&amp; _find_node(root-&gt;get_left(), b)!=NULL) {
    return _lowest_common_ancestor(root, root-&gt;get_left(), a, b);
  } else if(_find_node(root-&gt;get_right(), a)!=NULL &amp;&amp; _find_node(root-&gt;get_right(), b)!=NULL) {
    return _lowest_common_ancestor(root, root-&gt;get_right(), a, b);
  } else {
    return NULL;
  }
}

tree_node * tree::min_node() {
  return _min_node(root);
}

tree_node * tree::_min_node(tree_node * root) {
  if(root==NULL || root-&gt;get_left()==NULL) {
    return root;
  } else {
    return _min_node(root-&gt;get_left());
  }
}

int tree::count_leaf_nodes() {
  return _count_leaf_nodes(root);
}

int tree::_count_leaf_nodes(tree_node * root) {
  if(root==NULL) {
    return 0;
  } else if(root-&gt;get_left()==NULL &amp;&amp; root-&gt;get_right()==NULL) {
    return 1;
  } else {
    return _count_leaf_nodes(root-&gt;get_left())+_count_leaf_nodes(root-&gt;get_right());
  }
}


int tree::is_bst() {
  return _is_bst(root);
}

int tree::_is_bst(tree_node * root) {
  static tree_node * previous=NULL;
  if(root==NULL) {
    return 1;
  } else {
    if(!_is_bst(root-&gt;get_left())) {
      return 0;
    }
    if(previous!=NULL &amp;&amp; (previous-&gt;get_data())&gt;(root-&gt;get_data())) {
      return 0;
    }
    previous=root;
    if(!_is_bst(root-&gt;get_right())) {
      return 0;
    }    
  }
}

int tree::children_sum() {
  return _children_sum(root);
}

int tree::_children_sum(tree_node * root) {
  if(root==NULL) {
    return 1;
  }
  if(root-&gt;get_left()==NULL &amp;&amp; root-&gt;get_right()==NULL) {
    return 1;
  }
  else if(_children_sum(root-&gt;get_left()) &amp;&amp; _children_sum(root-&gt;get_right())){
    int left_data;
    int right_data;
    if(root-&gt;get_left()!=NULL) {
      left_data=root-&gt;get_left()-&gt;get_data();
    } else {
      left_data=0;
    }
    if(root-&gt;get_right()!=NULL) {
      right_data=root-&gt;get_right()-&gt;get_data();
    } else {
      right_data=0;
    }

    if(left_data+right_data==root-&gt;get_data()) {
      return 1;
    } else {
      return 0;
    }
  } else {
    return 0;
  }
}

void tree::ensure_children_sum() {
  _ensure_children_sum(root);
}

void tree::_ensure_children_sum(tree_node * root) {
  if(root==NULL || (root-&gt;get_left()==NULL &amp;&amp; root-&gt;get_right()==NULL)) {
    return;
  } else {
    _ensure_children_sum(root-&gt;get_left());
    _ensure_children_sum(root-&gt;get_right());
    int left_data;
    int right_data;
    if(root-&gt;get_left()!=NULL) {
      left_data=root-&gt;get_left()-&gt;get_data();
    } else {
      left_data=0;
    }
    if(root-&gt;get_right()!=NULL) {
      right_data=root-&gt;get_right()-&gt;get_data();
    } else {
      right_data=0;
    }
    root-&gt;set_data(left_data+right_data);
  }
}

int tree::diameter() {
  return _diameter(root);
}

int tree::_diameter(tree_node * root) {
  if(root==NULL) {
    return 0;
  } else {
    return max(_find_height(root-&gt;get_left())+_find_height(root-&gt;get_right())+1, max(_diameter(root-&gt;get_left()), _diameter(root-&gt;get_left())));
  }
}

int tree::is_height_balanced() {
  return _is_height_balanced(root);
}

int tree::_is_height_balanced(tree_node * root) {
  if(root==NULL) {
    return 1;
  } else {
    int left_height=_find_height(root-&gt;get_left());
    int right_height=_find_height(root-&gt;get_right());
    if(abs(left_height-right_height)&lt;=1 &amp;&amp; _is_height_balanced(root-&gt;get_left()) &amp;&amp; _is_height_balanced(root-&gt;get_left())) {
      return 1;
    } else {
      return 0;
    }
  }
}

int tree::leaf_path_sum(int sum) {
  return _leaf_path_sum(root, sum);
}

int tree::_leaf_path_sum(tree_node * root, int sum) {
  if(root==NULL) {
    return 0;
  } else if(root-&gt;get_data()==sum &amp;&amp; root-&gt;get_left()==NULL &amp;&amp; root-&gt;get_right()==NULL) {
    return 1;
  } else {
    return _leaf_path_sum(root-&gt;get_left(), sum-root-&gt;get_data()) || _leaf_path_sum(root-&gt;get_right(), sum-root-&gt;get_data());
  }
}

int main() {
  tree t1;

  t1.recursive_insert(5);
  t1.recursive_insert(3);
  t1.insert(10);
  t1.insert(7);
  t1.recursive_insert(50);
  t1.recursive_insert(6);
  t1.recursive_insert(1);
  t1.recursive_insert(45);
  t1.recursive_insert(55);
  t1.recursive_insert(4);

  t1.print_inorder();

  t1.recursive_insert(70);

  if(t1.leaf_path_sum(9)==1) {
    cout&lt;&lt;&quot;Tree has a leaf path with sum 9&quot;&lt;&lt;endl;
  } else {
    cout&lt;&lt;&quot;Tree do not have a leaf path with sum 9&quot;&lt;&lt;endl;
  }

  if(t1.leaf_path_sum(28)==1) {
    cout&lt;&lt;&quot;Tree has a leaf path with sum 28&quot;&lt;&lt;endl;
  } else {
    cout&lt;&lt;&quot;Tree do not have a leaf path with sum 28&quot;&lt;&lt;endl;
  }

  if(t1.leaf_path_sum(0)==1) {
    cout&lt;&lt;&quot;Tree has a leaf path with sum 0&quot;&lt;&lt;endl;
  } else {
    cout&lt;&lt;&quot;Tree do not have a leaf path with sum 0&quot;&lt;&lt;endl;
  }

  if(t1.leaf_path_sum(8)==1) {
    cout&lt;&lt;&quot;Tree has a leaf path with sum 8&quot;&lt;&lt;endl;
  } else {
    cout&lt;&lt;&quot;Tree do not have a leaf path with sum 8&quot;&lt;&lt;endl;
  }

  if(t1.leaf_path_sum(400)==1) {
    cout&lt;&lt;&quot;Tree has a leaf path with sum 400&quot;&lt;&lt;endl;
  } else {
    cout&lt;&lt;&quot;Tree do not have a leaf path with sum 400&quot;&lt;&lt;endl;
  }

  return 0;
}
</code> </pre>
<p>1 3 4 5 6 7 10 45 50 55<br />
Tree has a leaf path with sum 9<br />
Tree has a leaf path with sum 28<br />
Tree do not have a leaf path with sum 0<br />
Tree do not have a leaf path with sum 8<br />
Tree do not have a leaf path with sum 400</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-17885">
        <div id="dsq-comment-header-17885" class="dsq-comment-header">
            <cite id="dsq-cite-17885">
                <span id="dsq-author-user-17885">Sreenivas Doosa</span>
            </cite>
        </div>
        <div id="dsq-comment-body-17885" class="dsq-comment-body">
            <div id="dsq-comment-message-17885" class="dsq-comment-message"><p>What about this..? Please correct me if anything wrong OR inefficient..?</p>
<pre> <code language="C">

bool isRootToLeafPathSum(struct node* root, int sum) {

	if(root == NULL)
		return (sum == 0);

	return isRootToLeafPathSum(root-&gt;left, sum - root-&gt;data) || isRootToLeafPathSum(root-&gt;right, sum - root-&gt;data);
}

</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-2" id="dsq-comment-21279">
        <div id="dsq-comment-header-21279" class="dsq-comment-header">
            <cite id="dsq-cite-21279">
                <span id="dsq-author-user-21279">Prakhar Jain</span>
            </cite>
        </div>
        <div id="dsq-comment-body-21279" class="dsq-comment-body">
            <div id="dsq-comment-message-21279" class="dsq-comment-message"><p>I think this will work because you are using line: if (root == NULL) return (sum == 0);<br />
@author, you don&#8217;t need this if statement if you are checking if the node is not NULL later.</p>
<p>Your revised short code would be:</p>
<pre> <code language="C">
bool hasPathSum(struct node* node, int sum)
{
  /* return true if we run out of tree and sum==0 */
  if (node == NULL)
  {
     return (sum == 0);
  }
  
  else
  {
    bool ans = 0;  
  
    /* otherwise check both subtrees */
    int subSum = sum - node-&gt;data;
  
    /* If we reach a leaf node and sum becomes 0 then return true*/
    if ( subSum == 0 &amp;&amp; node-&gt;left == NULL &amp;&amp; node-&gt;right == NULL )
      return 1;
  
    if(node-&gt;left)
      ans = ans || hasPathSum(node-&gt;left, subSum);
    if(node-&gt;right)
      ans = ans || hasPathSum(node-&gt;right, subSum);
  
    return ans;
  }
}
</code> </pre>
<p>This will not work only in case when root is equal to NULL</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment byuser comment-author-onlynishant odd alt thread-odd thread-alt depth-1" id="dsq-comment-17784">
        <div id="dsq-comment-header-17784" class="dsq-comment-header">
            <cite id="dsq-cite-17784">
https://sites.google.com/site/nishantonl9/                <span id="dsq-author-user-17784">Nishant Kumar</span>
            </cite>
        </div>
        <div id="dsq-comment-body-17784" class="dsq-comment-body">
            <div id="dsq-comment-message-17784" class="dsq-comment-message"><pre> <code language="C">
int hasPathSum(tree* root,int sum){
	if(root==null)
		return 0;
	if(root-&gt;left==null &amp;&amp; root-&gt;right==null &amp;&amp; sum==root-&gt;data)
		return 1;

	int data = root-&gt;data;
	return hasPathSum(root-&gt;left,sum-data) || hasPathSum(root-&gt;right,sum-data);

}
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-cyberwolf even thread-even depth-1" id="dsq-comment-15074">
        <div id="dsq-comment-header-15074" class="dsq-comment-header">
            <cite id="dsq-cite-15074">
                <span id="dsq-author-user-15074">cyberWolf</span>
            </cite>
        </div>
        <div id="dsq-comment-body-15074" class="dsq-comment-body">
            <div id="dsq-comment-message-15074" class="dsq-comment-message"><pre> <code language="C">
int checkSum(treeNode* x, int sum)
{
        if (x-&gt;left==NULL &amp;&amp; x-&gt;right == NULL)
                return (sum==0);

        int l=0, r=0;
        if(x-&gt;left)
                l = checkSum(x-&gt;left, sum-x-&gt;data);

        if(x-&gt;right)
                r = checkSum(x-&gt;right, sum-x-&gt;data);

        return l||r;
}

</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-14241">
        <div id="dsq-comment-header-14241" class="dsq-comment-header">
            <cite id="dsq-cite-14241">
                <span id="dsq-author-user-14241">Gobind Kumar Hembram</span>
            </cite>
        </div>
        <div id="dsq-comment-body-14241" class="dsq-comment-body">
            <div id="dsq-comment-message-14241" class="dsq-comment-message"><p>int hasPathSum(node* root, int sum)<br />
{<br />
if(sum == root-&gt;val &amp;&amp; root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL)<br />
{<br />
return 1;<br />
}</p>
<p>if(sum val) return 0;</p>
<p>if(sum &gt; root-&gt;val)<br />
{<br />
int lAns = hasPathSum(root-&gt;left, (sum &#8211; root-&gt;val));<br />
int rAns = hasPathSum(root-&gt;right, (sum &#8211; root-&gt;val));</p>
<p>if(lAns == 1 || rAns == 1) return 1;<br />
}<br />
return 0;<br />
}</p>
</div>
        </div>

    </li><!-- #comment-## -->
</li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-13968">
        <div id="dsq-comment-header-13968" class="dsq-comment-header">
            <cite id="dsq-cite-13968">
                <span id="dsq-author-user-13968">syang</span>
            </cite>
        </div>
        <div id="dsq-comment-body-13968" class="dsq-comment-body">
            <div id="dsq-comment-message-13968" class="dsq-comment-message"><p>boolean check(Node node, int target, int sum_sofar)<br />
{<br />
    if (node == null)<br />
        return (target == sum_sofar);</p>
<p>    return check(node.left, target, sum_sofar + node.value) ||<br />
           check(node.right, target, sum_sofar + node.value)<br />
}</p>
<p>Call check(root, target, 0)</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-12566">
        <div id="dsq-comment-header-12566" class="dsq-comment-header">
            <cite id="dsq-cite-12566">
                <span id="dsq-author-user-12566">Kapil Agarwal</span>
            </cite>
        </div>
        <div id="dsq-comment-body-12566" class="dsq-comment-body">
            <div id="dsq-comment-message-12566" class="dsq-comment-message"><p>bool givenSum(struct node* root,int sum)<br />
{<br />
    struct node* temp=root;<br />
    int done=0;<br />
     int x=0;<br />
    stack st;<br />
    while(!done)<br />
    {<br />
        if(temp!=NULL)<br />
        {<br />
            st.push(temp);<br />
            sum-=temp-&gt;data;<br />
            temp=temp-&gt;left;</p>
<p>        }<br />
        else if(!st.empty())<br />
        {<br />
            if(sum==0)<br />
            {<br />
                while(!st.empty())<br />
                {<br />
                    temp=st.top();<br />
                    st.pop();</p>
<p>                }<br />
                return 1;<br />
            }</p>
<p>            temp=st.top();<br />
            st.pop();<br />
            sum+=x;<br />
            x=temp-&gt;data;<br />
            temp=temp-&gt;right;<br />
        }</p>
<p>        else<br />
          return 0;<br />
    }</p>
<p>}</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-10192">
        <div id="dsq-comment-header-10192" class="dsq-comment-header">
            <cite id="dsq-cite-10192">
                <span id="dsq-author-user-10192">Saurabh Jain</span>
            </cite>
        </div>
        <div id="dsq-comment-body-10192" class="dsq-comment-body">
            <div id="dsq-comment-message-10192" class="dsq-comment-message"><p>Time Complexity : O(n).</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */

int rootToLeafPathSum(struct node*r, int m)
{
	int ans;
	if(r==NULL)
	{
		if(m==0)
			return 1;
		else
			return 0;
	}
	else 
	{
		if(r-&gt;left==NULL&amp;&amp;r-&gt;right==NULL)
		{
			if(m==r-&gt;info)
				return 1;
			else
				return 0;
		}
		else if(r-&gt;left &amp;&amp; !r-&gt;right)
			return(rootToLeafPathSum(r-&gt;left,m-r-&gt;info));
		else if(!r-&gt;left &amp;&amp; r-&gt;right)
			return(rootToLeafPathSum(r-&gt;right,m-r-&gt;info));
		else
			return(rootToLeafPathSum(r-&gt;left,m-r-&gt;info)||rootToLeafPathSum(r-&gt;right,m-r-&gt;info));
	}
}
// int rootToLeafPathSum(struct node*,int)

</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-9260">
        <div id="dsq-comment-header-9260" class="dsq-comment-header">
            <cite id="dsq-cite-9260">
http://www.geeksforgeeks.org/archives/6201                <span id="dsq-author-user-9260">malvika</span>
            </cite>
        </div>
        <div id="dsq-comment-body-9260" class="dsq-comment-body">
            <div id="dsq-comment-message-9260" class="dsq-comment-message"><p>sorry corrected code:<br />
plz verify if this works</p>
<p>bool hasPathSum(struct node* node, int sum)<br />
{<br />
  if (node == NULL)<br />
     return 0;<br />
  int subSum = sum &#8211; node-&gt;data;<br />
  if ( subSum == 0 &amp;&amp; node-&gt;left == NULL &amp;&amp; node-&gt;right == NULL )<br />
      return 1;<br />
 else<br />
   return  hasPathSum(node-&gt;left, subSum) || hasPathSum(node-&gt;right, subSum);</p>
<p>}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-9259">
        <div id="dsq-comment-header-9259" class="dsq-comment-header">
            <cite id="dsq-cite-9259">
http://www.geeksforgeeks.org/archives/6201                <span id="dsq-author-user-9259">malvika</span>
            </cite>
        </div>
        <div id="dsq-comment-body-9259" class="dsq-comment-body">
            <div id="dsq-comment-message-9259" class="dsq-comment-message"><p>the question says root to leaf path sum so the code should be ths:</p>
<pre> <code language="C">
ool hasPathSum(struct node* node, int sum)
{
  /* return true if we run out of tree and sum==0 */
  if (node == NULL) 
  {
     return 0;  /*it sud return 0 instead whats given in geeksforgeeks code */
  }
 
  else
  {
    bool ans = 0; 
 
    /* otherwise check both subtrees */
    int subSum = sum - node-&gt;data;
 
    /* If we reach a leaf node and sum becomes 0 then return true*/
    if ( subSum == 0 &amp;&amp; node-&gt;left == NULL &amp;&amp; node-&gt;right == NULL )
      return 1;
 
    if(node-&gt;left)
      ans = ans || hasPathSum(node-&gt;left, subSum);
    if(node-&gt;right)
      ans = ans || hasPathSum(node-&gt;right, subSum);
 
    return ans;
  }
}
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-9796">
        <div id="dsq-comment-header-9796" class="dsq-comment-header">
            <cite id="dsq-cite-9796">
                <span id="dsq-author-user-9796">Priso</span>
            </cite>
        </div>
        <div id="dsq-comment-body-9796" class="dsq-comment-body">
            <div id="dsq-comment-message-9796" class="dsq-comment-message"><p>Hi Malvika,</p>
<p>It should be &#8220;return (sum==0);&#8221; only.<br />
consider a case of empty tree called with sum=0, in that case the answer should be &#8220;True&#8221;.</p>
<p>If we modify it to &#8220;return 0;&#8221; the answer will be &#8220;False&#8221;, which is incorrect.</p>
<p>Correct me if I am wrong.</p>
<p>Thanks</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-9180">
        <div id="dsq-comment-header-9180" class="dsq-comment-header">
            <cite id="dsq-cite-9180">
                <span id="dsq-author-user-9180">kaushal</span>
            </cite>
        </div>
        <div id="dsq-comment-body-9180" class="dsq-comment-body">
            <div id="dsq-comment-message-9180" class="dsq-comment-message"><p>This can be also be done using a level order traversal.<br />
when we dequeue from the queue, the children&#8217;s data should be enqueued with their own data + parent&#8217;s data. In the end, we&#8217;ll get the sum of all the branches from root to leaf.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-8557">
        <div id="dsq-comment-header-8557" class="dsq-comment-header">
            <cite id="dsq-cite-8557">
http://www.geeksforgeeks.org/archives/6201                <span id="dsq-author-user-8557">Snowy</span>
            </cite>
        </div>
        <div id="dsq-comment-body-8557" class="dsq-comment-body">
            <div id="dsq-comment-message-8557" class="dsq-comment-message"><p>return (hasPathSum(node-&gt;left, sunSum) ||<br />
            hasPathSum(node-&gt;right, subSum));<br />
What does the &#8216; || &#8216; operator mean here ? Is it addition ?</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-8555">
        <div id="dsq-comment-header-8555" class="dsq-comment-header">
            <cite id="dsq-cite-8555">
http://www.geeksforgeeks.org/archives/6201                <span id="dsq-author-user-8555">Snowy</span>
            </cite>
        </div>
        <div id="dsq-comment-body-8555" class="dsq-comment-body">
            <div id="dsq-comment-message-8555" class="dsq-comment-message"><p>What does the &#8216; || &#8216; operator mean here ? is it a comparison ?</p>
<pre> <code language="C">
return(hasPathSum(node-&gt;left, subSum) ||  hasPathSum(node-&gt;right,
subSum));
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-laddoo odd alt thread-even depth-1" id="dsq-comment-7510">
        <div id="dsq-comment-header-7510" class="dsq-comment-header">
            <cite id="dsq-cite-7510">
                <span id="dsq-author-user-7510">laddoo</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7510" class="dsq-comment-body">
            <div id="dsq-comment-message-7510" class="dsq-comment-message"><p>Guys,</p>
<p>if ( (subSum == 0) &#038;&#038; (node->left != NULL || node->right != NULL) )<br />
      return 0;</p>
<p>should be replaced by :</p>
<p>if ( (subSum < = 0) &#038;&#038; (node->left != NULL || node->right != NULL) )<br />
      return 0;</p>
<p>to involve PRUNING.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-geeksforgeeks even thread-odd thread-alt depth-1" id="dsq-comment-7046">
        <div id="dsq-comment-header-7046" class="dsq-comment-header">
            <cite id="dsq-cite-7046">
                <span id="dsq-author-user-7046">GeeksforGeeks</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7046" class="dsq-comment-body">
            <div id="dsq-comment-message-7046" class="dsq-comment-message"><p>@Dreamer &#038; @Greed:<br />
Thanks for pointing this out. We have updated the post with the correct code.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-4736">
        <div id="dsq-comment-header-4736" class="dsq-comment-header">
            <cite id="dsq-cite-4736">
                <span id="dsq-author-user-4736">Anand</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4736" class="dsq-comment-body">
            <div id="dsq-comment-message-4736" class="dsq-comment-message"><p>Please find the C code for finding all path that sums up to the given value<br />
<a href="http://anandtechblog.blogspot.com/2011/07/print-all-path-of-tree-that-sums-up-to.html" rel="nofollow">http://anandtechblog.blogspot.com/2011/07/print-all-path-of-tree-that-sums-up-to.html</a></p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-4370">
        <div id="dsq-comment-header-4370" class="dsq-comment-header">
            <cite id="dsq-cite-4370">
                <span id="dsq-author-user-4370">neeraj singh</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4370" class="dsq-comment-body">
            <div id="dsq-comment-message-4370" class="dsq-comment-message"><pre> <code language="Java">
/**
     * 
     * @param n      initially it should be root node
     * @param target target sum to check 
     * @param sum    sum of tree nodes so far, initially is should be 0.
     * @return true if target == path sum till any leaf node.
     */
     public static boolean equalsRoot2LeafPathsSum(Node n, int target, int sum) {
        if(null == n){
            return false;
        }

        //is leaf node
        if (null == n.left &amp;&amp; n.right == null) {
            return target == sum + n.value;
        }
         
        return equalsRoot2LeafPathsSum(n.left, target, sum + n.value) ||
        equalsRoot2LeafPathsSum(n.right, target,sum + n.value);

    }
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-5471">
        <div id="dsq-comment-header-5471" class="dsq-comment-header">
            <cite id="dsq-cite-5471">
                <span id="dsq-author-user-5471">Dreamer</span>
            </cite>
        </div>
        <div id="dsq-comment-body-5471" class="dsq-comment-body">
            <div id="dsq-comment-message-5471" class="dsq-comment-message"><p>Yes, this is correct. Any comments/<br />
@geeksforgeeks please update the post. As the currently posted solution is not correct.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-3950">
        <div id="dsq-comment-header-3950" class="dsq-comment-header">
            <cite id="dsq-cite-3950">
                <span id="dsq-author-user-3950">Dreamer</span>
            </cite>
        </div>
        <div id="dsq-comment-body-3950" class="dsq-comment-body">
            <div id="dsq-comment-message-3950" class="dsq-comment-message"><p>Your code will return true even for sum = 12. Which is wrong. You need one more check..</p>
<p>if (node-&gt;left == NULL &amp;&amp; node-&gt;right == NULL &amp;&amp; subSum == 0) {<br />
        return true;</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-sandeep odd alt depth-2" id="dsq-comment-3951">
        <div id="dsq-comment-header-3951" class="dsq-comment-header">
            <cite id="dsq-cite-3951">
                <span id="dsq-author-user-3951">Sandeep</span>
            </cite>
        </div>
        <div id="dsq-comment-body-3951" class="dsq-comment-body">
            <div id="dsq-comment-message-3951" class="dsq-comment-message"><p>@Dreamer: Thanks for pointing out this case.  I think following modified function works for all the cases.</p>
<pre> <code language="C">bool hasPathSum(struct node* node, int sum)
{   
  /* return true if we run out of tree and sum==0 */
  if (node == NULL)
  {
     return (sum == 0);
  }
  
  else
  {
    /* otherwise check both subtrees */
    int subSum = sum - node-&gt;data;
    
    /* If we reach a non leaf node and sum becomes 0 then return false*/
    if ( (subSum == 0) &amp;&amp; (node-&gt;left != NULL || node-&gt;right != NULL) )
      return 0;
    
    return(hasPathSum(node-&gt;left, subSum) ||
           hasPathSum(node-&gt;right, subSum));
  }</code> </pre>
<p>Let me know your thoughts on this modified solution.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-3" id="dsq-comment-6900">
        <div id="dsq-comment-header-6900" class="dsq-comment-header">
            <cite id="dsq-cite-6900">
                <span id="dsq-author-user-6900">P</span>
            </cite>
        </div>
        <div id="dsq-comment-body-6900" class="dsq-comment-body">
            <div id="dsq-comment-message-6900" class="dsq-comment-message"><p>Can someone explain what does this line of code mean? Is it doing a comparison? Please give an example if possible as it aids in clarifying. Thanks.</p>
<p>return(hasPathSum(node-&gt;left, subSum) ||  hasPathSum(node-&gt;right, subSum));</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment byuser comment-author-sandeep odd alt depth-2" id="dsq-comment-3952">
        <div id="dsq-comment-header-3952" class="dsq-comment-header">
            <cite id="dsq-cite-3952">
                <span id="dsq-author-user-3952">Sandeep</span>
            </cite>
        </div>
        <div id="dsq-comment-body-3952" class="dsq-comment-body">
            <div id="dsq-comment-message-3952" class="dsq-comment-message"><p>I think my previous solution doesn&#8217;t work if there are negative numbers in tree.  Following modifications seems to be better and seems to be working for all cases.</p>
<pre> <code language="C">bool hasPathSum(struct node* node, int sum)
{   
  /* return true if we run out of tree and sum==0 */
  if (node == NULL)
  {
     return (sum == 0);
  }
  
  else
  {
    bool ans = 0;  
    
    /* otherwise check both subtrees */
    int subSum = sum - node-&gt;data;
    
    /* If we reach a leaf node and sum becomes 0 then return true*/
    if ( subSum == 0 &amp;&amp; node-&gt;left == NULL &amp;&amp; node-&gt;right == NULL )
      return 1;
    
    if(node-&gt;left)
      ans = ans || hasPathSum(node-&gt;left, subSum);
    if(node-&gt;right)  
      ans = ans || hasPathSum(node-&gt;right, subSum);
      
    return ans;  
  }
} </code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-3" id="dsq-comment-3959">
        <div id="dsq-comment-header-3959" class="dsq-comment-header">
            <cite id="dsq-cite-3959">
http://ashutosh7s.blogspot.com/                <span id="dsq-author-user-3959">WgpShashank</span>
            </cite>
        </div>
        <div id="dsq-comment-body-3959" class="dsq-comment-body">
            <div id="dsq-comment-message-3959" class="dsq-comment-message"><p>@sandeep if -ive our algo wont change even this is the case then we can simply revert sign of namber even its no need &#8230;i dont find any issue with -ive number  i mean if we get desired sum then simply print it else return from program </p>
<p>check this program its printing all the path whose equals to given number including -ive number as well ..let me know if i  missed sumthing </p>
<pre> <code language="C">
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#define bool int
 
/* A binary tree node has data, pointer to left child
   and a pointer to right child */
struct node
{
   int data;
   struct node* left;
   struct node* right;
};
 
/*
 Given a tree and a sum, return true if there is a path from the root
 down to a leaf, such that adding up all the values along the path
 equals the given sum.
 
 Strategy: subtract the node value from the sum when recurring down,
 and check to see if the sum is 0 when you run out of tree.
*/
 
void printArray(int ints[], int len)
{
  int i;
  for (i=0; idatadata*=-1;
 
    ar[index]=node-&gt;data;
    index++; 
     
    int subSum = sum - node-&gt;data;
 
    /* If we reach a leaf node and sum becomes 0 then return true*/
      if (subSum == 0 &amp;&amp; node-&gt;left == NULL &amp;&amp; node-&gt;right == NULL )
               printArray(ar,index);
      if(node-&gt;left)
      hasPathSum(node-&gt;left,subSum,ar,index);
      if(node-&gt;right)
     hasPathSum(node-&gt;right, subSum,ar,index);
 
  }
}
 
 
void hasPath(struct node* root, int sum)
{
      int ar[100];
      hasPathSum(root,sum,ar,0);
    
}
 
/* UTILITY FUNCTIONS */
/* Helper function that allocates a new node with the
   given data and NULL left and right pointers. */
struct node* newnode(int data)
{
  struct node* node = (struct node*)
                       malloc(sizeof(struct node));
  node-&gt;data = data;
  node-&gt;left = NULL;
  node-&gt;right = NULL;
 
  return(node);
}
 
/* Driver program to test above functions*/
int main()
{
 
  int sum = 21;
 
  /* Constructed binary tree is
            10
          /   \
        8      2
      /  \    / \
    3    2   9   4
  */
  struct node *root = newnode(10);
  root-&gt;left        = newnode(-8);//-ive number
  //if we revert sign then we get this path also
  root-&gt;right       = newnode(2);
  root-&gt;left-&gt;left  = newnode(3);
  root-&gt;left-&gt;right = newnode(2);
  root-&gt;left-&gt;right-&gt;left = newnode(1);
  root-&gt;right-&gt;left = newnode(9); 
  root-&gt;right-&gt;right= newnode(4); 
  root-&gt;right-&gt;right-&gt;left= newnode(5); 
   hasPath(root, sum); 
 
  getchar();
  return 0;
}
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt depth-3" id="dsq-comment-3960">
        <div id="dsq-comment-header-3960" class="dsq-comment-header">
            <cite id="dsq-cite-3960">
http://ashutosh7s.blogspot.com/                <span id="dsq-author-user-3960">WgpShashank</span>
            </cite>
        </div>
        <div id="dsq-comment-body-3960" class="dsq-comment-body">
            <div id="dsq-comment-message-3960" class="dsq-comment-message"><p>@sandeep but there is serious issue with all programs i that what if path not starts from the root ?? if we use this algo we will surely miss the path that exist but missed due to wrong implementation ??then our time complexity increase to o(nlogn)..&amp; also we have to modify the main program..??? otherwise we will get wrong </p>
<p>2nd Also u forget to handle the case when sum reaches to 0 we are not at leaf nodes but still path exist..although we can handle dis condition by checking sum==0 in if condition but 1st condition need new Algo..</p>
<p>output..correct me if m wrong.??</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even depth-3" id="dsq-comment-3961">
        <div id="dsq-comment-header-3961" class="dsq-comment-header">
            <cite id="dsq-cite-3961">
http://ashutosh7s.blogspot.com/                <span id="dsq-author-user-3961">WgpShashank</span>
            </cite>
        </div>
        <div id="dsq-comment-body-3961" class="dsq-comment-body">
            <div id="dsq-comment-message-3961" class="dsq-comment-message"><p>@sandeep </p>
<p>Special Case 1 what happen if got sum=0 in the mid before reaching to leaf nodes.?</p>
<p>its handled here <a href="https://ideone.com/q7vbw" rel="nofollow">https://ideone.com/q7vbw</a></p>
<p>Special Case 2 what happens if path not starts from root..??</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-sandeep odd alt depth-4" id="dsq-comment-3972">
        <div id="dsq-comment-header-3972" class="dsq-comment-header">
            <cite id="dsq-cite-3972">
                <span id="dsq-author-user-3972">Sandeep</span>
            </cite>
        </div>
        <div id="dsq-comment-body-3972" class="dsq-comment-body">
            <div id="dsq-comment-message-3972" class="dsq-comment-message"><p>@WgpShashank: </p>
<p><em>Special Case 1 what happen if got sum=0 in the mid before reaching to leaf nodes.?</em><br />
The modified code given in the above comment handles this case.  Could you please provide an example tree for which it doesn&#8217;t work?</p>
<p><em>Special Case 2 what happens if path not starts from root..??</em><br />
Please take a closer look at the question.  According to the question, the path must start from root.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-5" id="dsq-comment-3975">
        <div id="dsq-comment-header-3975" class="dsq-comment-header">
            <cite id="dsq-cite-3975">
http://ashutosh7s.blogspot.com/                <span id="dsq-author-user-3975">WgpShashank</span>
            </cite>
        </div>
        <div id="dsq-comment-body-3975" class="dsq-comment-body">
            <div id="dsq-comment-message-3975" class="dsq-comment-message"><p>@sandeep&#8230;.I m thinking more general problem thats how we csn extend it more in general..lets have look </p>
<p>You are given a binary tree in which each node contains a value. Design an algorithm to print all paths which sum up to that value. Note that it can be any path in the tree &#8211; it does not have to start at the root</p>
<p>so this the case m more thinking about </p>
<p>case i handled in previous comment<br />
but case 2 is need More Modification in Algorithm..That Still In progress..i Will be pleased if you can come with case handled for 2 when node need to start from root  &amp;b still sum exist ..hope you got my point..??</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-3401">
        <div id="dsq-comment-header-3401" class="dsq-comment-header">
            <cite id="dsq-cite-3401">
                <span id="dsq-author-user-3401">ashish</span>
            </cite>
        </div>
        <div id="dsq-comment-body-3401" class="dsq-comment-body">
            <div id="dsq-comment-message-3401" class="dsq-comment-message"><p>can&#8217;t we do it by putting value in stack and with a flag value (which will show that right child has been visited or not)</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-2571">
        <div id="dsq-comment-header-2571" class="dsq-comment-header">
            <cite id="dsq-cite-2571">
                <span id="dsq-author-user-2571">bhardwaj</span>
            </cite>
        </div>
        <div id="dsq-comment-body-2571" class="dsq-comment-body">
            <div id="dsq-comment-message-2571" class="dsq-comment-message"><p>CORRECT CODE IS</p>
<pre> <code language="C">
bool hasPathSum(struct node* node, int sum)
{
  /* return true if we run out of tree and sum==0 */
  if (node == NULL)
  {
    return(sum == 0);
  }
   int subSum = sum - node-&gt;data;
  if(!node-&gt;left &amp;&amp; !node-&gt;right &amp;&amp; !subSum)
  return 1;
  
  else
  {
    /* otherwise check both subtrees */
   
    return(hasPathSum(node-&gt;left, subSum) ||
           hasPathSum(node-&gt;right, subSum));
  }
}
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-2696">
        <div id="dsq-comment-header-2696" class="dsq-comment-header">
            <cite id="dsq-cite-2696">
                <span id="dsq-author-user-2696">Fanatic</span>
            </cite>
        </div>
        <div id="dsq-comment-body-2696" class="dsq-comment-body">
            <div id="dsq-comment-message-2696" class="dsq-comment-message"><p>I think the above code would give wrong answer for the following tree:</p>
<p>          7<br />
         / \<br />
        9   21<br />
         \<br />
          11<br />
Sum:16</p>
<p>Please check..</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-2534">
        <div id="dsq-comment-header-2534" class="dsq-comment-header">
            <cite id="dsq-cite-2534">
                <span id="dsq-author-user-2534">asad khan</span>
            </cite>
        </div>
        <div id="dsq-comment-body-2534" class="dsq-comment-body">
            <div id="dsq-comment-message-2534" class="dsq-comment-message"><pre> <code language="CPP">
bool haspathsum(struct node* root, int sum)
{
	if(root==NULL) return false;
	sum=sum-root-&gt;data;
	if((sumleft!=NULL)&amp;&amp;(root-&gt;right!=NULL)))
	return false;
	if(sum!=0 &amp;&amp; root-&gt;left==NULL &amp;&amp; root-&gt;right==NULL)
	return false;
	if(sum==0 &amp;&amp; root-&gt;left==NULL &amp;&amp; root-&gt;right==NULL)
	return true;
	return (haspathsum(root-&gt;left,sum)||haspathsum(root-&gt;right,sum));
}
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-4192">
        <div id="dsq-comment-header-4192" class="dsq-comment-header">
            <cite id="dsq-cite-4192">
                <span id="dsq-author-user-4192">Greed</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4192" class="dsq-comment-body">
            <div id="dsq-comment-message-4192" class="dsq-comment-message"><p>Your code works fine . The one given above is wrong . They are missing the whole question here <img src="http://d2o58evtke57tz.cloudfront.net/wp-includes/images/smilies/icon_sad.gif" alt=":(" class="wp-smiley" /></p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment byuser comment-author-rka143 even thread-even depth-1" id="dsq-comment-1837">
        <div id="dsq-comment-header-1837" class="dsq-comment-header">
            <cite id="dsq-cite-1837">
                <span id="dsq-author-user-1837">rka143</span>
            </cite>
        </div>
        <div id="dsq-comment-body-1837" class="dsq-comment-body">
            <div id="dsq-comment-message-1837" class="dsq-comment-message"><p>Please ignore my previous post.<br />
i think it should be like this:</p>
<pre> <code language="C">
bool hasPathSum(struct node* node, int sum)  

{  

  /* return true if we run out of tree and sum==0 */ 

  if (node == NULL)  

  {  

    return(sum == 0);  

  }

  int subSum = sum - node-&gt;data;
  
  if (subsum &lt; 0)
       return 0;

  if (subSum == 0)
  {
     if (node-&gt;left==NULL &amp;&amp; node-&gt;right==NULL)
           return 1;
     return 0;
  }

    /* otherwise check both subtrees */ 

    return(hasPathSum(node-&gt;left, subSum) ||  

           hasPathSum(node-&gt;right, subSum));  

  }  

}   
</code> </pre>
<p>Please let me know if anything is wrong.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-2505">
        <div id="dsq-comment-header-2505" class="dsq-comment-header">
            <cite id="dsq-cite-2505">
                <span id="dsq-author-user-2505">rhtdm48</span>
            </cite>
        </div>
        <div id="dsq-comment-body-2505" class="dsq-comment-body">
            <div id="dsq-comment-message-2505" class="dsq-comment-message"><p>Hi rka </p>
<p>I think there is no need of this extra code &#8230;<br />
as last condition it is checking that node should be null and subsum should be 0.</p>
<p>so it doesn&#8217;t matter if subsum is negative or positive<br />
it will return false .. so your cases are covered already .</p>
<p>Thanks.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-3" id="dsq-comment-2506">
        <div id="dsq-comment-header-2506" class="dsq-comment-header">
            <cite id="dsq-cite-2506">
                <span id="dsq-author-user-2506">rhtdm48</span>
            </cite>
        </div>
        <div id="dsq-comment-body-2506" class="dsq-comment-body">
            <div id="dsq-comment-message-2506" class="dsq-comment-message"><p>and also tree can have negative values&#8230;. so your condition will fail&#8230;</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment byuser comment-author-rka143 odd alt thread-odd thread-alt depth-1" id="dsq-comment-1836">
        <div id="dsq-comment-header-1836" class="dsq-comment-header">
            <cite id="dsq-cite-1836">
                <span id="dsq-author-user-1836">rka143</span>
            </cite>
        </div>
        <div id="dsq-comment-body-1836" class="dsq-comment-body">
            <div id="dsq-comment-message-1836" class="dsq-comment-message"><p>I think this code should be link this:</p>
<pre> <code language="C">
bool hasPathSum(struct node* node, int sum)  

{  

  /* return true if we run out of tree and sum==0 */ 

  if (node == NULL)  

  {  

    return(sum == 0);  

  }

  int subSum = sum - node-&gt;data;
  
  if (subsum left==NULL &amp;&amp; node-&gt;right==NULL)
           return 1;
     return 0;
  }

    /* otherwise check both subtrees */ 

    return(hasPathSum(node-&gt;left, subSum) ||  

           hasPathSum(node-&gt;right, subSum));  

  }  

}   
</code> </pre>
<p>Please let me know if anything is wrong in this.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-abhimanu even thread-even depth-1" id="dsq-comment-1551">
        <div id="dsq-comment-header-1551" class="dsq-comment-header">
            <cite id="dsq-cite-1551">
                <span id="dsq-author-user-1551">abhimanu</span>
            </cite>
        </div>
        <div id="dsq-comment-body-1551" class="dsq-comment-body">
            <div id="dsq-comment-message-1551" class="dsq-comment-message"><p>The code provided has bugs as mentioned by flycooler. call funciton with sum = 12. It gives incorrect answer.<br />
Corrected code is</p>
<pre> <code language="C">
bool hasPathSum(TNode *node, int sum)
{
	if (node == NULL) {
		return false;
	}

	int subSum = sum - node-&gt;data;
	if (subSum == 0 &amp;&amp; node-&gt;left == NULL &amp;&amp; node-&gt;right == NULL) {
		return true;
	}
	return (hasPathSum(node-&gt;left, sunSum) || 
			hasPathSum(node-&gt;right, subSum));
}
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-1825">
        <div id="dsq-comment-header-1825" class="dsq-comment-header">
            <cite id="dsq-cite-1825">
                <span id="dsq-author-user-1825">Aravind</span>
            </cite>
        </div>
        <div id="dsq-comment-body-1825" class="dsq-comment-body">
            <div id="dsq-comment-message-1825" class="dsq-comment-message"><p>&#8220;if (subSum == 0 &amp;&amp; <strong>node-&gt;left == NULL &amp;&amp; node-&gt;right == NULL)</strong> {<br />
        return true; }&#8221;<br />
this code doesn&#8217;t return true if there exists a path equating to the given sum from the root node to node(say node_abv) just above the leaf node; as node_abv-&gt;left will not be equal to NULL.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even depth-2" id="dsq-comment-1826">
        <div id="dsq-comment-header-1826" class="dsq-comment-header">
            <cite id="dsq-cite-1826">
                <span id="dsq-author-user-1826">Aravind</span>
            </cite>
        </div>
        <div id="dsq-comment-body-1826" class="dsq-comment-body">
            <div id="dsq-comment-message-1826" class="dsq-comment-message"><p>&#8220;if (subSum == 0 &amp;&amp; <strong>node-&gt;left == NULL &amp;&amp; node-&gt;right == NULL)</strong> {<br />
        return true; }&#8221;<br />
this code doesn&#8217;t return true if there exists a path equating to the given sum from the root node to node(say node_abv) just above the leaf node; as node_abv-&gt;left will not be equal to NULL&#8230;</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt depth-2" id="dsq-comment-33134">
        <div id="dsq-comment-header-33134" class="dsq-comment-header">
            <cite id="dsq-cite-33134">
                <span id="dsq-author-user-33134">Tushar</span>
            </cite>
        </div>
        <div id="dsq-comment-body-33134" class="dsq-comment-body">
            <div id="dsq-comment-message-33134" class="dsq-comment-message"><p>I got a question in MS to optimize the search in case it&#8217;s a binary search tree (BST) . I tried a lot but can not replied. Right search can be stopped once our current sum exceeds a limit , but can not find way when to stop searching in left path.<br />
Can anyone please help ?</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment byuser comment-author-flycooler even thread-odd thread-alt depth-1" id="dsq-comment-1426">
        <div id="dsq-comment-header-1426" class="dsq-comment-header">
            <cite id="dsq-cite-1426">
http://www.mpi-sb.mpg.de/~dong                <span id="dsq-author-user-1426">flycooler</span>
            </cite>
        </div>
        <div id="dsq-comment-body-1426" class="dsq-comment-body">
            <div id="dsq-comment-message-1426" class="dsq-comment-message"><p>The code has bugs for the following BST:</p>
<pre>
                     3
                    /
                   2
                  /
                 1
                /
               1
              /
             1
</pre>
<p>The right code should be following:</p>
<pre> <code language="C">
bool hasPathSum(struct node* node, int sum)
{
       // return true if we run out of tree and sum==0
       if (node == NULL) {
          return(sum == 0);
        }
        else {
        // otherwise check both subtrees
        int subSum = sum - node-&gt;data;
        if ((node-&gt;left&amp;&amp;node-&gt;right)||(!node-&gt;left &amp;&amp; !node-&gt;right))
          return(hasPathSum(node-&gt;left, subSum) ||  hasPathSum(node-&gt;right,
subSum));
        else if (node-&gt;left)
          return hasPathSum(node-&gt;left, subSum);
        else
          return hasPathSum(node-&gt;right, subSum);

      }
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-12635">
        <div id="dsq-comment-header-12635" class="dsq-comment-header">
            <cite id="dsq-cite-12635">
http://dealsindiadeals.com                <span id="dsq-author-user-12635">topcoder</span>
            </cite>
        </div>
        <div id="dsq-comment-body-12635" class="dsq-comment-body">
            <div id="dsq-comment-message-12635" class="dsq-comment-message"><p>Mine is a lot simpler code then yours which works for any binary tree. you wrote a lot of unnecessary code i mean bakwas <img src="http://d2o58evtke57tz.cloudfront.net/wp-includes/images/smilies/icon_smile.gif" alt=":)" class="wp-smiley" /></p>
<pre> <code language="C">
bool hasPathSum(struct node* node, int Sum){
	bool ans = 0;
	i++;
	//printf(&quot;The data in this node is&quot;);
	if(node == NULL)
		return (Sum == 0);
	printf(&quot;The data in this node is %d\n&quot;,node-&gt;data);
	int subSum = Sum - node-&gt;data;
	if((subSum == 0) &amp;&amp; (node-&gt;left == NULL) and (node-&gt;right == NULL))
		return 1;

	return (hasPathSum(node-&gt;left, subSum) || hasPathSum(node-&gt;right, subSum));
}
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-1146">
        <div id="dsq-comment-header-1146" class="dsq-comment-header">
            <cite id="dsq-cite-1146">
                <span id="dsq-author-user-1146">DivyaC</span>
            </cite>
        </div>
        <div id="dsq-comment-body-1146" class="dsq-comment-body">
            <div id="dsq-comment-message-1146" class="dsq-comment-message"><p>This can be can be done in iteration, so like backtracking using external stack and best case would most of the times be log n</p>
</div>
        </div>

    </li><!-- #comment-## -->
            </ul>


        </div>

    </div>

<script type="text/javascript">
var disqus_url = 'http://www.geeksforgeeks.org/root-to-leaf-path-sum-equal-to-a-given-number/';
var disqus_identifier = '6201 http://geeksforgeeks.org/?p=6201';
var disqus_container_id = 'disqus_thread';
var disqus_shortname = 'geeksforgeeks';
var disqus_title = "Root to leaf path sum equal to a given number";
var disqus_config_custom = window.disqus_config;
var disqus_config = function () {
    /*
    All currently supported events:
    onReady: fires when everything is ready,
    onNewComment: fires when a new comment is posted,
    onIdentify: fires when user is authenticated
    */
    
    
    this.language = '';
    
    if (disqus_config_custom) {
        disqus_config_custom.call(this);
    }
};

(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>

			</div>
	
					
			
			

		</div> <!-- end post -->	

<br></br>
	
</div> <!-- end content -->

<ul id="sidebar">
	<li id="text-19" class="widget widget_text">			<div class="textwidget"><script>
  (function() {
    var cx = '009682134359037907028:tj6eafkv_be';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//www.google.com/cse/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>

<style type="text/css">
  .gsc-control-cse {
    font-family: "Trebuchet MS", sans-serif;
    border-color: #E1F3DA;
    background-color: #E1F3DA;
  }
  input.gsc-input {
    border-color: #94CC7A;
  }
  input.gsc-search-button {
    border-color: #94CC7A;
    background-color: #AADA92;
  }
  .gsc-tabHeader.gsc-tabhInactive {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gsc-tabHeader.gsc-tabhActive {
    border-color: #A9DA92;
    background-color: #A9DA92;
  }
  .gsc-tabsArea {
    border-color: #A9DA92;
  }
  .gsc-webResult.gsc-result {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gsc-webResult.gsc-result:hover {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gs-webResult.gs-result a.gs-title:link,
  .gs-webResult.gs-result a.gs-title:link b {
    color: #009900;
  }
  .gs-webResult.gs-result a.gs-title:visited,
  .gs-webResult.gs-result a.gs-title:visited b {
    color: #009900;
  }
  .gs-webResult.gs-result a.gs-title:hover,
  .gs-webResult.gs-result a.gs-title:hover b {
    color: #003300;
  }
  .gs-webResult.gs-result a.gs-title:active,
  .gs-webResult.gs-result a.gs-title:active b {
    color: #009900;
  }
  .gsc-cursor-page {
    color: #009900;
  }
  a.gsc-trailing-more-results:link {
    color: #009900;
  }
  .gs-webResult.gs-result .gs-snippet {
    color: #454545;
  }
  .gs-webResult.gs-result .gs-visibleUrl {
    color: #33cc00;
  }
  .gs-webResult.gs-result .gs-visibleUrl-short {
    color: #33cc00;
  }
  .gs-webResult.gs-result .gs-visibleUrl-short {
    display: none;
  }
  .gs-webResult.gs-result .gs-visibleUrl-long {
    display: block;
  }
  .gsc-cursor-box {
    border-color: #A9DA92;
  }
  .gsc-results .gsc-cursor-page {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gsc-results .gsc-cursor-page.gsc-cursor-current-page {
    border-color: #A9DA92;
    background-color: #A9DA92;
  }
  .gs-promotion.gs-result {
    border-color: #94CC7A;
    background-color: #CBE8B4;
  }
  .gs-promotion.gs-result a.gs-title:link {
    color: #0066CC;
  }
  .gs-promotion.gs-result a.gs-title:visited {
    color: #0066CC;
  }
  .gs-promotion.gs-result a.gs-title:hover {
    color: #0066CC;
  }
  .gs-promotion.gs-result a.gs-title:active {
    color: #0066CC;
  }
  .gs-promotion.gs-result .gs-snippet {
    color: #454545;
  }
  .gs-promotion.gs-result .gs-visibleUrl,
  .gs-promotion.gs-result .gs-visibleUrl-short {
    color: #815FA7;
  }
</style>    </div>
		</li>
<li id="text-9" class="widget widget_text">			<div class="textwidget"><div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=138031159685820";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>

<div class="fb-like-box" data-href="https://www.facebook.com/pages/GeeksforGeeks/316764689022" data-width="250" data-height="170" data-colorscheme="light" data-show-faces="true" data-header="false" data-stream="false" data-show-border="false"></div></div>
		</li>
<li id="text-18" class="widget widget_text">			<div class="textwidget"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LargeRectangleSide -->
<ins class="adsbygoogle"
     style="display:inline-block;width:336px;height:280px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="1884636833"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
		</li>
<li id="text-13" class="widget widget_text">			<div class="textwidget"><ul><li><a href="http://www.geeksforgeeks.org/category/interview-experiences/">Interview Experiences</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/advance-data-structures">Advanced Data Structures</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/dynamic-programming">Dynamic Programming</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/Greedy-Algorithm/">Greedy Algorithms</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/backtracking">Backtracking</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/pattern-searching">Pattern Searching</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/divide-and-conquer">Divide & Conquer</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/MathematicalAlgo">Mathematical Algorithms</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/recursion">Recursion</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/geometric-algorithms/">Geometric Algorithms</a></li>
</ul></div>
		</li>
<li id="text-17" class="widget widget_text">			<div class="textwidget"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big 300x600 Sidebar -->
<ins class="adsbygoogle"
     style="display:inline-block;width:300px;height:600px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="4402736037"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
		</li>
<li id="text-14" class="widget widget_text"><h2 class="widgettitle">Popular Posts</h2>
			<div class="textwidget"><ul>
<li><a href="http://www.geeksforgeeks.org/write-a-c-program-to-print-all-permutations-of-a-given-string/">  All permutations of a given string </a></li>
<li><a href="http://www.geeksforgeeks.org/memory-layout-of-c-program/"> Memory Layout of C Programs</a> </li>
<li><a href="http://www.geeksforgeeks.org/understanding-extern-keyword-in-c/"> Understanding “extern” keyword in C</a> </li>
<li><a href="http://www.geeksforgeeks.org/median-of-two-sorted-arrays/">Median of two sorted arrays</a> </li>
<li><a href="http://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/"> Tree traversal without recursion and without stack! </a></li>
<li><a href="http://www.geeksforgeeks.org/structure-member-alignment-padding-and-data-packing/"> Structure Member Alignment, Padding and Data Packing</a> </li>
<li><a href="http://www.geeksforgeeks.org/write-a-function-to-get-the-intersection-point-of-two-linked-lists/"> Intersection point of two Linked Lists</a> </li>
<li><a href="http://www.geeksforgeeks.org/lowest-common-ancestor-in-a-binary-search-tree/"> Lowest Common Ancestor in a BST.</span></a> </li>
<li><a href="http://www.geeksforgeeks.org/a-program-to-check-if-a-binary-tree-is-bst-or-not/"> Check if a binary tree is BST or not</a> </li>
<li><a href="http://www.geeksforgeeks.org/sorted-linked-list-to-balanced-bst/"> Sorted Linked List to Balanced BST</a></li>
</ul></div>
		</li>
<li id="text-3" class="widget widget_text">			<div class="textwidget"><a href="https://twitter.com/GeeksforGeeks" class="twitter-follow-button" data-show-count="false">Follow @GeeksforGeeks</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>         


<!-- GOOGLE FEEDBURNER BUTTON-->
<a href="http://feeds.feedburner.com/Geeksforgeeks" title="Subscribe to my feed" rel="alternate" type="application/rss+xml"><img src="http://www.feedburner.com/fb/images/pub/feed-icon32x32.png" alt="" style="border:0"/></a><a href="http://feeds.feedburner.com/Geeksforgeeks" title="Subscribe to my feed" rel="alternate" type="application/rss+xml">Subscribe</a>

</div>
		</li>
<li id="text-21" class="widget widget_text"><h2 class="widgettitle">Recent Comments</h2>
			<div class="textwidget"><script type="text/javascript" src="http://geeksforgeeks.disqus.com//recent_comments_widget.js?num_items=6&hide_avatars=1&excerpt_length=50&hide_mods=0"></script></div>
		</li>
<li id="text-22" class="widget widget_text">			<div class="textwidget"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LinkAd -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:90px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="2606115235"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LinkAd -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:90px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="2606115235"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LinkAd -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:90px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="2606115235"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
		</li>

</ul>					  
		<div class="clear"></div>

		<div id="footer">
		
		    <div class="xhtml">
                        @geeksforgeeks, <a href="http://creativecommons.org/licenses/by-nc-nd/2.5/in/deed.en_US" title="Valid XHTML Strict 1.0">Some rights reserved</a>  <a href="http://www.geeksforgeeks.org/about/contact-us/"> &nbsp; &nbsp; &nbsp; &nbsp;Contact Us!</a>

		    </div>
		    
		    <div class="credits">
			  Powered by <a href="http://wordpress.org">WordPress </a> &amp; <a href="http://mootools.net/" title="Mootools JavaScript Framework">MooTools</a>, customized by geeksforgeeks team </div>
			  
		   <div class="clear"></div>						                            
		   
		</div> <!--end footer-->  
        
		        <script type="text/javascript">
        // <![CDATA[
        var disqus_shortname = 'geeksforgeeks';
        (function () {
            var nodes = document.getElementsByTagName('span');
            for (var i = 0, url; i < nodes.length; i++) {
                if (nodes[i].className.indexOf('dsq-postid') != -1) {
                    nodes[i].parentNode.setAttribute('data-disqus-identifier', nodes[i].getAttribute('rel'));
                    url = nodes[i].parentNode.href.split('#', 1);
                    if (url.length == 1) { url = url[0]; }
                    else { url = url[1]; }
                    nodes[i].parentNode.href = url + '#disqus_thread';
                }
            }
            var s = document.createElement('script'); 
            s.async = true;
            s.type = 'text/javascript';
            s.src = '//' + disqus_shortname + '.disqus.com/count.js';
            (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
        }());
        // ]]>
        </script>
        <script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/scripts/shCore.js?ver=3.0.9'></script>
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/scripts/shBrushCpp.js?ver=3.0.9'></script>
<script type='text/javascript'>
	(function(){
		var corecss = document.createElement('link');
		var themecss = document.createElement('link');
		var corecssurl = "http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/styles/shCore.css?ver=3.0.9";
		if ( corecss.setAttribute ) {
				corecss.setAttribute( "rel", "stylesheet" );
				corecss.setAttribute( "type", "text/css" );
				corecss.setAttribute( "href", corecssurl );
		} else {
				corecss.rel = "stylesheet";
				corecss.href = corecssurl;
		}
		document.getElementsByTagName("head")[0].insertBefore( corecss, document.getElementById("syntaxhighlighteranchor") );
		var themecssurl = "http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/styles/shThemeDefault.css?ver=3.0.9";
		if ( themecss.setAttribute ) {
				themecss.setAttribute( "rel", "stylesheet" );
				themecss.setAttribute( "type", "text/css" );
				themecss.setAttribute( "href", themecssurl );
		} else {
				themecss.rel = "stylesheet";
				themecss.href = themecssurl;
		}
		//document.getElementById("syntaxhighlighteranchor").appendChild(themecss);
		document.getElementsByTagName("head")[0].insertBefore( themecss, document.getElementById("syntaxhighlighteranchor") );
	})();
	SyntaxHighlighter.config.strings.expandSource = '+ expand source';
	SyntaxHighlighter.config.strings.help = '?';
	SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
	SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
	SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
	SyntaxHighlighter.defaults['gutter'] = false;
	SyntaxHighlighter.defaults['pad-line-numbers'] = true;
	SyntaxHighlighter.defaults['toolbar'] = false;
	SyntaxHighlighter.all();
</script>
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/bbpress/templates/default/js/editor.js?ver=2.5.4-5380'></script>
				  
		</div> <!--end wrapper-->
        <div id="ajaxSpinner"></div> <!--For AJAX spinner holder-->
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-12148232-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
	</body>

</html>
<!-- Dynamic page generated in 0.225 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2014-11-27 23:29:35 -->

<!-- Compression = gzip -->
<!-- super cache -->