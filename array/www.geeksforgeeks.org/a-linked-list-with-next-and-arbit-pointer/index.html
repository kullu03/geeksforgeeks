<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
       <title>Clone a linked list with next and random pointer | Set 1 - GeeksforGeeks</title>
       <style type="text/css" media="screen">
          @import url('http://d2o58evtke57tz.cloudfront.net/wp-content/themes/minimoo/style.css');
    </style>
      <link href="http://d2o58evtke57tz.cloudfront.net/wp-content/themes/minimoo/favicon.ico" rel="shortcut icon" />    
    
<!-- This site is optimized with the Yoast WordPress SEO plugin v1.7.1 - https://yoast.com/wordpress/plugins/seo/ -->
<link rel="canonical" href="http://www.geeksforgeeks.org/a-linked-list-with-next-and-arbit-pointer/" />
<meta property="og:locale" content="en_US" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Clone a linked list with next and random pointer | Set 1 - GeeksforGeeks" />
<meta property="og:description" content="You are given a Double Link List with one pointer of each node pointing to the next node just like in a single link list. The second pointer however CAN point to any node in the list and not just the previous node. Now write a program in O(n) time to duplicate this list. That &hellip;" />
<meta property="og:url" content="http://www.geeksforgeeks.org/a-linked-list-with-next-and-arbit-pointer/" />
<meta property="og:site_name" content="GeeksforGeeks" />
<meta property="article:section" content="Linked Lists" />
<meta property="article:published_time" content="2009-08-24T02:26:31+00:00" />
<meta property="article:modified_time" content="2015-01-05T12:30:27+00:00" />
<meta property="og:updated_time" content="2015-01-05T12:30:27+00:00" />
<meta property="og:image" content="http://geeksforgeeks.org/wp-content/uploads/2009/08/ArbitLinked-List12.gif" />
<meta property="og:image" content="http://geeksforgeeks.org/wp-content/uploads/2009/08/ArbitLinked-List2.gif" />
<!-- / Yoast WordPress SEO plugin. -->

<link rel='stylesheet' id='wp-quicklatex-format-css'  href='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/wp-quicklatex/css/quicklatex-format.css?ver=4.1' type='text/css' media='all' />
<link rel='stylesheet' id='bbp-default-css'  href='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/bbpress/templates/default/css/bbpress.css?ver=2.5.4-5380' type='text/css' media='screen' />
<link rel='stylesheet' id='wp-pagenavi-css'  href='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/wp-pagenavi/pagenavi-css.css?ver=2.70' type='text/css' media='all' />
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-includes/js/jquery/jquery.js?ver=1.11.1'></script>
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-includes/js/jquery/jquery-migrate.min.js?ver=1.2.1'></script>
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/wp-quicklatex/js/wp-quicklatex-frontend.js?ver=1.0'></script>

<!-- Bad Behavior 2.2.16 run time: 1.621 ms -->
<script type="text/javascript">
<!--
function bb2_addLoadEvent(func) {
	var oldonload = window.onload;
	if (typeof window.onload != 'function') {
		window.onload = func;
	} else {
		window.onload = function() {
			oldonload();
			func();
		}
	}
}

bb2_addLoadEvent(function() {
	for ( i=0; i < document.forms.length; i++ ) {
		if (document.forms[i].method == 'post') {
			var myElement = document.createElement('input');
			myElement.setAttribute('type', 'hidden');
			myElement.name = 'bb2_screener_';
			myElement.value = '1420441513 192.31.114.252';
			document.forms[i].appendChild(myElement);
		}
	}
});
// --></script>
		<style type="text/css" id="syntaxhighlighteranchor"></style>
   <meta name="google-site-verification" content="rHK2v8_zzuAZQY8JHAzbllDN8u-aQxcn2Kqnp67Old0" />
</head>

<body>
<!-- o4dI0sCXUgoSONabbd8mbZ4SA3E -->    
    <div id="wrapper">
        <div class="blog-info">
                <h1 class="blog-title">
                <a href="http://www.geeksforgeeks.org" title="GeeksforGeeks">GeeksforGeeks</a>
            </h1>
       
            <div class="blog-description">
                A computer science portal for geeks            </div>
        </div>
        <b><p>  <h2 align="right"> <a href="http://geeksquiz.com/">GeeksQuiz</a></h2> 
   <a href="http://www.geeksforgeeks.org/wp-login.php">Login</a> 
         </p></b>  
         
         <div class="clear"></div>         
              
                     
            <div id="menu">   
                 <ul>
 <li><a href="http://www.geeksforgeeks.org">Home</a></li>
  <li><a href="http://www.geeksforgeeks.org/fundamentals-of-algorithms/">Algorithms</a></li>
 <li><a href="http://www.geeksforgeeks.org/data-structures/">DS</a></li>
  <li><a href="http://www.geeksforgeeks.org/gate-corner/">GATE</a></li>
  <li><a href="http://www.geeksforgeeks.org/about/interview-corner/">Interview Corner</a></li>
  <li><a href="http://www.geeksforgeeks.org/forums/">Q&A</a></li>
  <li><a href="http://www.geeksforgeeks.org/c/">C</a></li>
  <li><a href="http://www.geeksforgeeks.org/c-plus-plus/">C++</a></li>
  <li><a href="http://www.geeksforgeeks.org/java/">Java</a></li>
  <li><a href="http://www.geeksforgeeks.org/books/">Books</a></li>
  <li><a href="http://www.geeksforgeeks.org/contribute/">Contribute</a></li>
  <li><a href="http://www.geeksforgeeks.org/contribute/ask-a-question/">Ask a Q</a></li>
  <li><a href="http://www.geeksforgeeks.org/about/">About</a></li>
            </ul>

               
            <div class="clear"></div>     
        </div>
             <div id="navmenu">
				<ul id="menu" style="padding:0; margin:0;">
						<li class="cat-item cat-item-3"><a href="http://www.geeksforgeeks.org/category/c-arrays/" title="Questions regarding Arrays">Array</a>
</li>	

	<li class="cat-item cat-item-17"><a href="http://www.geeksforgeeks.org/category/bit-magic/" title="View all posts filed under Bit Magic">Bit Magic</a>
</li>
	<li class="cat-item cat-item-14"><a href="http://www.geeksforgeeks.org/category/c-puzzles/" title="View all posts filed under C/C++ Puzzles">C/C++</a>
</li>

<li class="cat-item cat-item-18"><a href="http://www.geeksforgeeks.org/category/articles/" title="View all posts filed under Articles">Articles</a>
</li>

	<li class="cat-item cat-item-67"><a href="http://www.geeksforgeeks.org/category/gfact/" title="View all posts filed under GFacts">GFacts</a>
</li>
	<li class="cat-item cat-item-8"><a href="http://www.geeksforgeeks.org/category/linked-list/" title="Linked List problems">Linked List</a>
</li>
	<li class="cat-item cat-item-66"><a href="http://www.geeksforgeeks.org/category/multiple-choice-question/" title="View all posts filed under MCQ">MCQ</a>

</li>
	<li class="cat-item cat-item-4"><a href="http://www.geeksforgeeks.org/category/c-programs/" title="Miscellaneous">Misc</a>
</li>
	<li class="cat-item cat-item-5"><a href="http://www.geeksforgeeks.org/category/program-output/" title="View all posts filed under Output">Output</a>
</li>
	<li class="cat-item cat-item-7"><a href="http://www.geeksforgeeks.org/category/c-strings/" title="Questions related to strings">String</a>
</li>
	<li class="cat-item cat-item-19"><a href="http://www.geeksforgeeks.org/category/tree/" title="View all posts filed under Trees">Tree</a>
</li>
	<li class="cat-item cat-item-19"><a href="http://www.geeksforgeeks.org/category/graph/" title="View all posts filed under Graph">Graph</a>
</li>
</ul>
        </div>
             <div id="content">	   	
	<div class="post" id="post">
							<div class="post-info">			
					<div class="post-title-info">
						<h2 class="post-title">Clone a linked list with next and random pointer | Set 1</h2>
					</div>			
					<div class="clear"></div>				  
				<div class="post-content" id="post-content">
					<p>You are given a Double Link List with one pointer of each node pointing to the next node just like in a single link list. The second pointer however CAN point to any node in the list and not just the previous node. Now write a program in<strong> O(n) time </strong>to duplicate this list. That is, write a program which will create a copy of this list.</p>
<p>Let us call the second pointer as arbit pointer as it can point to any arbitrary node in the linked list.</p>
<p style="text-align: center;"><img class="aligncenter size-full wp-image-1254" title="ArbitLinked List1" src="http://geeksforgeeks.org/wp-content/uploads/2009/08/ArbitLinked-List12.gif" alt="ArbitLinked List1" width="450" height="160" /></p>
<p>Arbitrary pointers are shown in red and next pointers in black</p>
<p style="text-align: center;">Figure 1</p>
<p><strong>Method 1 (Uses O(n) extra space)</strong><br />
This method stores the next and arbitrary mappings (of original list) in an array first, then modifies the original Linked List (to create copy), creates a copy. And finally restores the original list.</p>
<p>1) Create all nodes in copy linked list using next pointers.<br />
3) Store the node and its next pointer mappings of original linked list.<br />
3) Change next pointer of all nodes in original linked list to point to the corresponding node in copy linked list.<br />
Following diagram shows status of both Linked Lists after above 3 steps.  The red arrow shows arbit pointers and black arrow shows next pointers.</p>
<p><img class="aligncenter size-full wp-image-1160" title="ArbitLinked List2" src="http://geeksforgeeks.org/wp-content/uploads/2009/08/ArbitLinked-List2.gif" alt="ArbitLinked List2" width="450" height="200" /></p>
<p style="text-align: center;">Figure 2</p>
<p>4) Change the arbit pointer of all nodes in copy linked list to point to corresponding node in original linked list.<br />
5) Now construct the arbit pointer in copy linked list as below and restore the next pointer of nodes in the original linked list.</p>
<pre>       copy_list_node-&gt;arbit =
                      copy_list_node-&gt;arbit-&gt;arbit-&gt;next;
       copy_list_node = copy_list_node->next; 
</pre>
<p>6) Restore the next pointers in original linked list from the stored mappings(in step 2).</p>
<p>Time Complexity:  O(n)<br />
Auxiliary Space:  O(n)</p>
<p></br><br />
<strong>Method 2 (Uses Constant Extra Space)</strong><br />
Thanks to Saravanan Mani for providing this solution. This solution works using constant space.<br />
1) Create the copy of node 1 and insert it between node 1 &#038; node 2 in original Linked List, create the copy of 2 and insert it between 2 &#038; 3.. Continue in this fashion, add the copy of N afte the Nth node<br />
2) Now copy the arbitrary link in this fashion</p>
<pre>
     original->next->arbitrary = original->arbitrary->next;  /*TRAVERSE 
TWO NODES*/
</pre>
<p>This works because original->next is nothing but copy of original and Original->arbitrary->next is nothing but copy of arbitrary.<br />
3) Now restore the original and copy linked lists in this fashion in a single loop.</p>
<pre>
     original->next = original->next->next;
     copy->next = copy->next->next;
</pre>
<p>4) Make sure that last element of original->next is NULL.</p>
<p>Time Complexity: O(n)<br />
Auxiliary Space: O(1)</p>
<p>Refer Following Post for Hashing based Implementation.<br />
<a href="http://www.geeksforgeeks.org/clone-linked-list-next-arbit-pointer-set-2/">Clone a linked list with next and random pointer | Set 2</a></p>
<p>Asked by Varun Bhatia. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
		
&nbsp;
&nbsp;
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle"
     style="display:inline-block;width:336px;height:280px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="4061219431"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>



&nbsp;
&nbsp;
&nbsp;
<h3>Related Topics:</h3><ul><li><a href="http://www.geeksforgeeks.org/clone-linked-list-next-arbit-pointer-set-2/" title="Clone a linked list with next and random pointer | Set 2">Clone a linked list with next and random pointer | Set 2</a></li><li><a href="http://www.geeksforgeeks.org/given-linked-list-line-segments-remove-middle-points/" title="Given a linked list of line segments, remove middle points">Given a linked list of line segments, remove middle points</a></li><li><a href="http://www.geeksforgeeks.org/maximum-sum-linked-list-two-sorted-linked-lists-common-nodes/" title="Construct a Maximum Sum Linked List out of two Sorted Linked Lists having some Common nodes">Construct a Maximum Sum Linked List out of two Sorted Linked Lists having some Common nodes</a></li><li><a href="http://www.geeksforgeeks.org/given-linked-list-reverse-alternate-nodes-append-end/" title="Given a linked list, reverse alternate nodes and append at the end">Given a linked list, reverse alternate nodes and append at the end</a></li><li><a href="http://www.geeksforgeeks.org/pairwise-swap-elements-of-a-given-linked-list-by-changing-links/" title="Pairwise swap elements of a given linked list by changing links">Pairwise swap elements of a given linked list by changing links</a></li><li><a href="http://www.geeksforgeeks.org/self-organizing-list-set-1-introduction/" title="Self Organizing List | Set 1 (Introduction)">Self Organizing List | Set 1 (Introduction)</a></li><li><a href="http://www.geeksforgeeks.org/merge-a-linked-list-into-another-linked-list-at-alternate-positions/" title="Merge a linked list into another linked list at alternate positions">Merge a linked list into another linked list at alternate positions</a></li><li><a href="http://www.geeksforgeeks.org/quicksort-on-singly-linked-list/" title="QuickSort on Singly Linked List">QuickSort on Singly Linked List</a></li></ul>
<p></p> 
<div>
<iframe src="http://www.facebook.com/plugins/like.php?href=http%3A%2F%2Fwww.geeksforgeeks.org%2Fa-linked-list-with-next-and-arbit-pointer%2F&layout=button_count&show_faces=false&width=90&action=like&colorscheme=light" scrolling="no" frameborder="0" allowTransparency="true" style="border:none; overflow:hidden; width:90px; height:20px"></iframe>
<a href="http://twitter.com/share" class="twitter-share-button" data-url="http://www.geeksforgeeks.org/a-linked-list-with-next-and-arbit-pointer/" data-text="Clone a linked list with next and random pointer | Set 1" data-count="horizontal" data-via="jakerutter">Tweet</a><script type="text/javascript" src="http://platform.twitter.com/widgets.js"></script>
<g:plusone size="medium" href="http://www.geeksforgeeks.org/a-linked-list-with-next-and-arbit-pointer/"></g:plusone>
<!-- Place this render call where appropriate -->
<script type="text/javascript">
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script></div>





				</div>		  
			</div> <!-- end post main -->					
			<div class="post-meta">
				<div class="left"></div>				
				<div class="clear"></div>
			</div>			
        
			<div class="comments-main">		
 <b>Writing code in comment?</b> Please use <b><a href="http://ideone.com/">ideone.com</a></b> and share the link here.
				
<div id="disqus_thread">
            <div id="dsq-content">


            <ul id="dsq-comments">
                    <li class="comment even thread-even depth-1" id="dsq-comment-33303">
        <div id="dsq-comment-header-33303" class="dsq-comment-header">
            <cite id="dsq-cite-33303">
                <span id="dsq-author-user-33303">pulkit mehra</span>
            </cite>
        </div>
        <div id="dsq-comment-body-33303" class="dsq-comment-body">
            <div id="dsq-comment-message-33303" class="dsq-comment-message"><p>If the List has Read Only access then the above discussed methods will fail.</p>
<p>The method I came across uses  container of C++ STL. A map is actually an associative array which has a key and a value associated with that key.</p>
<p>Steps: (The code syntax isn&#8217;t coming properly in comments so check online)</p>
<p>1. Copy the original list to new list with next pointers intact, leave arbit pointers for now</p>
<p>2. While copying make a map<br />
           <code><br />
           map  map_hash<br />
            </code></p>
<p>In our case map will have the key as the original list node and value as copy list node</p>
<p>3 Map would be somewhat like this</p>
<p>           Original   &#8211;&gt;      Copy<br />
            Node1    &#8211;&gt;      Node1(copy)<br />
            Node2    &#8211;&gt;      Node2(copy)<br />
            Node3    &#8211;&gt;      Node3(copy)</p>
<p>4 Start from head of copy list, corresponding to this copy list node we have the original list node in map. We can access it using an iterator.<br />
            <code><br />
            map::iterator i<br />
            i = map_hash.begin()<br />
            copy_node-&gt;arbit = map_hash.at((*i).first-&gt;arbit)<br />
            </code></p>
<p>Note:- (*i).first  =  original_List node<br />
           (*i).first-&gt;arbit = arbitrary node pointed by (*i).first<br />
           map_hash.at() gives the value stored at that key</p>
<p>What we are doing is for each copy_List node we take its corresponding original_List node then find its arbit node, next we use our map to find the node in our copy_List corresponding to this arbit node and assign it to the arbit pointer of the copy_List node</p>
<p>Hope this will help!!!</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-31586">
        <div id="dsq-comment-header-31586" class="dsq-comment-header">
            <cite id="dsq-cite-31586">
                <span id="dsq-author-user-31586">darkpassenger</span>
            </cite>
        </div>
        <div id="dsq-comment-body-31586" class="dsq-comment-body">
            <div id="dsq-comment-message-31586" class="dsq-comment-message"><p>if we don&#8217;t want to modify the original list the with the help of 2 hash maps u can clone it&#8230;&#8230;&#8230;.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-30168">
        <div id="dsq-comment-header-30168" class="dsq-comment-header">
            <cite id="dsq-cite-30168">
                <span id="dsq-author-user-30168">neelabhsingh</span>
            </cite>
        </div>
        <div id="dsq-comment-body-30168" class="dsq-comment-body">
            <div id="dsq-comment-message-30168" class="dsq-comment-message"><p>This problem can be done in two scan Linked List</p>
<p>1st Scan: In first scan change change next pointer of original LL to the corresponding same node in the new LL. and change random pointer of new LL to the corresponding same node of the original linked list.</p>
<p>current1 is pointing to the start node of the originalLL.</p>
<p>current2 is pointing to the start node of the newLL</p>
<p>current1=root1;// root node of the original node</p>
<p>current2=roott2// root node of the original node</p>
<p>while(current1!=NULL)</p>
<p>{</p>
<p>        temp=current1-&gt;next;</p>
<p>        current1-&gt;next=current2;</p>
<p>        current2-&gt;random=current1;</p>
<p>        current2=current2-&gt;next;</p>
<p>        current1=temp;</p>
<p>}</p>
<p>// Scan2</p>
<p>current1=root1;// root node of the original node<br />
current2=roott2// root node of the original node</p>
<p>// current1-&gt;next is pointing to the new node so we can node use</p>
<p>while(current2!=NULL)<br />
{<br />
      current2-&gt;random=current2-&gt;random-&gt;random-&gt;next;<br />
current2=current2-&gt;next</p>
<p>}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-29938">
        <div id="dsq-comment-header-29938" class="dsq-comment-header">
            <cite id="dsq-cite-29938">
                <span id="dsq-author-user-29938">pavansrinivas</span>
            </cite>
        </div>
        <div id="dsq-comment-body-29938" class="dsq-comment-body">
            <div id="dsq-comment-message-29938" class="dsq-comment-message"><p>What if the Original list is read only???</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-28343">
        <div id="dsq-comment-header-28343" class="dsq-comment-header">
            <cite id="dsq-cite-28343">
                <span id="dsq-author-user-28343">Prateek Rathore</span>
            </cite>
        </div>
        <div id="dsq-comment-body-28343" class="dsq-comment-body">
            <div id="dsq-comment-message-28343" class="dsq-comment-message"><p>Saravanan Mani , nice trick !!!</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-27951">
        <div id="dsq-comment-header-27951" class="dsq-comment-header">
            <cite id="dsq-cite-27951">
                <span id="dsq-author-user-27951">Neha Garg</span>
            </cite>
        </div>
        <div id="dsq-comment-body-27951" class="dsq-comment-body">
            <div id="dsq-comment-message-27951" class="dsq-comment-message"><p>@d4868dd64c637016efc578852ad7cd68:disqus  where do you need to insert copy element in original list ??<br />
we can do it just first copy the whole list using next pointers &#8230; then copy the arbitrary pointers of original list in copyid list using using a loop till end and picking one element of each LL ??<br />
this will help in reduing two step first insert in between and second to separate them<br />
correct me if i m wrong&#8230;..</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-27950">
        <div id="dsq-comment-header-27950" class="dsq-comment-header">
            <cite id="dsq-cite-27950">
                <span id="dsq-author-user-27950">Neha Garg</span>
            </cite>
        </div>
        <div id="dsq-comment-body-27950" class="dsq-comment-body">
            <div id="dsq-comment-message-27950" class="dsq-comment-message"><p>@3544658edbd8b32cd82d8c035a2ba74f:disqus @d4868dd64c637016efc578852ad7cd68:disqus where do you need to insert copy element in original list ??<br />
we can do it just first copy the whole list using next pointers &#8230; then copy the arbitrary pointers of original list in copyid list using using a loop till end and picking one element of each LL ??<br />
this will help in reduing two step first insert in between and second to separate them<br />
correct me if i m wrong&#8230;..</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-27911">
        <div id="dsq-comment-header-27911" class="dsq-comment-header">
            <cite id="dsq-cite-27911">
                <span id="dsq-author-user-27911">ankit</span>
            </cite>
        </div>
        <div id="dsq-comment-body-27911" class="dsq-comment-body">
            <div id="dsq-comment-message-27911" class="dsq-comment-message"><p>Recursive method(using hashmap):<br />
where hashmap contains  as  pair.</p>
<p>node* copy(node* n1)<br />
{<br />
if(n is null)<br />
return null;</p>
<p>if(if n1 is in hasmap)</p>
<p> return n2;</p>
<p>else</p>
<p>create new node n2;<br />
insert into hashMap(n1,n2);</p>
<p>n2-&gt;data=n1-&gt;data;<br />
n2-&gt;next=copy(n1-&gt;next);<br />
n2-&gt;arbitrary=copy(n1-&gt;arbitrary);</p>
<p>return n2;<br />
}</p>
<p>Can anybody pls verify this method.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-22844">
        <div id="dsq-comment-header-22844" class="dsq-comment-header">
            <cite id="dsq-cite-22844">
                <span id="dsq-author-user-22844">Pavan</span>
            </cite>
        </div>
        <div id="dsq-comment-body-22844" class="dsq-comment-body">
            <div id="dsq-comment-message-22844" class="dsq-comment-message"><pre> <code language="C">
// Method 2 code ,check if there is any bug
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
struct node {
    int data;
    struct node* arbit;
    struct node* next;
};
struct node *newNode(int data)
{
    struct node *new_node = (struct node *) malloc(sizeof(struct node));
    new_node-&gt;data = data;
    new_node-&gt;next = NULL;
    new_node-&gt;arbit = NULL;
    return new_node;
}
void printList(struct node *node)
{
    while(node != NULL)
    {
       if(node-&gt;next==NULL)
        {
             printf(&quot;next and arbitary of %d is NULL and %d \n&quot;,node-&gt;data ,node-&gt;arbit-&gt;data);
        }
        else
        printf(&quot;next and arbitary of %d is %d and %d \n&quot;,node-&gt;data ,node-&gt;next-&gt;data,node-&gt;arbit-&gt;data);
        node = node-&gt;next;
    }
    printf(&quot;\n&quot;);
}
void push(struct node** head_ref, int new_data)
{
    /* allocate node */
    struct node* new_node = newNode(new_data);
 
    /* link the old list off the new node */
    new_node-&gt;next = (*head_ref);
 
    /* move the head to point to the new node */
    (*head_ref)    = new_node;
}
struct node* copyList(struct node*original)
{
    struct node *copy=NULL ,*original_i, *copy_i,*temp ;
    original_i =original ;
    while(original_i !=NULL)
    {
       temp=original_i-&gt;next;
       struct node* newnode =newNode(original_i-&gt;data);
       newnode-&gt;next=temp;
       original_i-&gt;next=newnode;
       original_i=temp;
    }
    copy=original-&gt;next;
    copy_i=copy;
    original_i=original;
    while(original_i!=NULL)
    {
        copy_i-&gt;arbit=original_i-&gt;arbit-&gt;next;
        if(copy_i-&gt;next!=NULL)
        copy_i=copy_i-&gt;next-&gt;next;
        original_i=original_i-&gt;next-&gt;next;
    }
    copy_i=copy;
    original_i=original;
    while(original_i!=NULL)
    {
        original_i-&gt;next=original_i-&gt;next-&gt;next;
        if(copy_i-&gt;next!=NULL)
        copy_i-&gt;next=copy_i-&gt;next-&gt;next;
        original_i= original_i-&gt;next;
        copy_i= copy_i-&gt;next;
    }
    return copy;
}
 
 int main()
{
    struct node* original=NULL, *copy;
    push(&amp;original, 5);
    push(&amp;original, 4);
    push(&amp;original, 3);
    push(&amp;original, 2);
    push(&amp;original, 1);
    original-&gt;arbit = original-&gt;next-&gt;next;
    original-&gt;next-&gt;arbit = original;
    original-&gt;next-&gt;next-&gt;arbit = original-&gt;next-&gt;next-&gt;next-&gt;next;
    original-&gt;next-&gt;next-&gt;next-&gt;arbit = original-&gt;next-&gt;next;
    original-&gt;next-&gt;next-&gt;next-&gt;next-&gt;arbit = original-&gt;next;
    printList(original);
    copy = copyList(original);
    printf(&quot;copy of the linklist with next and arbit pointer\n&quot;);
    printList(copy);
    return 0;
}
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-22848">
        <div id="dsq-comment-header-22848" class="dsq-comment-header">
            <cite id="dsq-cite-22848">
                <span id="dsq-author-user-22848">Gaurav Garg</span>
            </cite>
        </div>
        <div id="dsq-comment-body-22848" class="dsq-comment-body">
            <div id="dsq-comment-message-22848" class="dsq-comment-message"><p>No bug pandu <img src="http://d2o58evtke57tz.cloudfront.net/wp-includes/images/smilies/icon_wink.gif" alt=";)" class="wp-smiley" /><br />
code working fine !<br />
keep posting.</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-22255">
        <div id="dsq-comment-header-22255" class="dsq-comment-header">
            <cite id="dsq-cite-22255">
                <span id="dsq-author-user-22255">Karshit</span>
            </cite>
        </div>
        <div id="dsq-comment-body-22255" class="dsq-comment-body">
            <div id="dsq-comment-message-22255" class="dsq-comment-message"><p>My Code.. with a built in function to test the copied and original Linked List.. Hope it helps.. <img src="http://d2o58evtke57tz.cloudfront.net/wp-includes/images/smilies/icon_smile.gif" alt=":)" class="wp-smiley" /></p>
<pre> <code language="C">
#include &lt;iostream&gt;

using namespace std;

struct node {
    int data;
    node *next;
    node *arbit;
};

node *create(int n)
{
    if (n == 0)
        return NULL;

    node *head = new node();
    node *p = head;

    cin &gt;&gt; (p -&gt; data);

    p -&gt; next = NULL;

    for (int i = 1; i &lt; n; i++) {
        p -&gt; next = new node();
        p = p -&gt; next;

        cin &gt;&gt; (p -&gt; data);

        p -&gt; next = NULL;
    }

    return head;
}

void print(node *head)
{
    while (head != NULL) {
        cout &lt;&lt; head -&gt; data &lt;&lt; &quot; &quot;;
        head = head -&gt; next;
    }

}


node * copy(node *head)
{
    node *p = head;
    node *q;

    while(p) {
        node *dummy = new node();
        dummy -&gt; data = p -&gt; data;
        node *temp = p -&gt; next;
        p -&gt; next = dummy;
        dummy -&gt; next = temp;

        p = p -&gt; next -&gt; next;
    }

    node *head1 = head -&gt; next;
    p = head;
    q = head1;

    while (p) {
        p -&gt; next -&gt; arbit = p -&gt; arbit -&gt; next;
        p = p -&gt; next -&gt; next;
    }

    while(1) {
        head -&gt; next = head -&gt; next -&gt; next;
        head = head -&gt; next;

        if (!head)
            break;

        q -&gt; next = q -&gt; next -&gt; next;
        q = q -&gt; next;

    }


    q -&gt; next = NULL;

    return head1;
}

void test(node *head, node *head1)
{
    while (head) {
        cout &lt;&lt; &quot;In list:\n&quot;&lt;&lt; head -&gt; data &lt;&lt; &quot; and copy = &quot; &lt;&lt; head1 -&gt; data &lt;&lt; endl &lt;&lt; &quot;Arbitrary Node:\n&quot; &lt;&lt; head -&gt; arbit -&gt; data &lt;&lt; &quot; and copy = &quot; &lt;&lt; head1 -&gt; arbit -&gt; data &lt;&lt; endl;
        head = head -&gt; next;
        head1 = head1 -&gt; next;
    }
}
int main()
{
    node *head = NULL;
    node *head1 = NULL;
    head = create(5);

    head -&gt; arbit = head -&gt; next -&gt; next;
    head -&gt; next -&gt; arbit = head -&gt; next -&gt; next -&gt; next;
    head -&gt; next -&gt; next -&gt; arbit = head;
    head -&gt; next -&gt; next -&gt; next -&gt; arbit = head -&gt; next -&gt; next;
    head -&gt; next -&gt; next -&gt; next -&gt; next -&gt; arbit = head -&gt; next -&gt; next;

    head1 = copy(head);

    test(head, head1);

    cout &lt;&lt; &quot;\n&quot;;

    return 0;
}

</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-abhishek08aug odd alt thread-even depth-1" id="dsq-comment-17841">
        <div id="dsq-comment-header-17841" class="dsq-comment-header">
            <cite id="dsq-cite-17841">
                <span id="dsq-author-user-17841">abhishek08aug</span>
            </cite>
        </div>
        <div id="dsq-comment-body-17841" class="dsq-comment-body">
            <div id="dsq-comment-message-17841" class="dsq-comment-message"><p>Intelligent <img src="http://d2o58evtke57tz.cloudfront.net/wp-includes/images/smilies/icon_biggrin.gif" alt=":D" class="wp-smiley" /></p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-17631">
        <div id="dsq-comment-header-17631" class="dsq-comment-header">
            <cite id="dsq-cite-17631">
                <span id="dsq-author-user-17631">Vijay Muvva</span>
            </cite>
        </div>
        <div id="dsq-comment-body-17631" class="dsq-comment-body">
            <div id="dsq-comment-message-17631" class="dsq-comment-message"><p>Hello,</p>
<p>I don&#8217;t see any need for the auxiliary space in the first method. </p>
<p>Why can&#8217;t we restore the original list while adding arbitrary links to the new list? Precisely:<br />
temp = newListNode.next.arbitrary;<br />
newListNode.arbitrary = originalListNode.arbitrary.next;<br />
originalListNode.next = temp;</p>
<p>Do this for every node.</p>
<p>Note: initially new list arbitrary links points to the original list&#8217;s corresponding nodes. </p>
<p>Please correct if I&#8217;m wrong..</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-anshul-chauhan odd alt depth-2" id="dsq-comment-22328">
        <div id="dsq-comment-header-22328" class="dsq-comment-header">
            <cite id="dsq-cite-22328">
                <span id="dsq-author-user-22328">anshul.chauhan</span>
            </cite>
        </div>
        <div id="dsq-comment-body-22328" class="dsq-comment-body">
            <div id="dsq-comment-message-22328" class="dsq-comment-message"><p>yes you are wrong&#8230;try it with an example&#8230;you can&#8217;t point any node to anywhere until whole list traversal is done because node can point to previous nodes as well and u&#8217;ve already lost the pointer to that <img src="http://d2o58evtke57tz.cloudfront.net/wp-includes/images/smilies/icon_smile.gif" alt=":)" class="wp-smiley" /></p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-17024">
        <div id="dsq-comment-header-17024" class="dsq-comment-header">
            <cite id="dsq-cite-17024">
                <span id="dsq-author-user-17024">neham</span>
            </cite>
        </div>
        <div id="dsq-comment-body-17024" class="dsq-comment-body">
            <div id="dsq-comment-message-17024" class="dsq-comment-message"><p>there is more simpler version of method 1.<br />
mahajanneha.blogspot.com/2013/04/to-copy-doubly-linked-list-having-arbit.html</p>
<p>this approach also takes O(n) auxiliary space.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-whizkid08 odd alt thread-odd thread-alt depth-1" id="dsq-comment-16307">
        <div id="dsq-comment-header-16307" class="dsq-comment-header">
            <cite id="dsq-cite-16307">
                <span id="dsq-author-user-16307">whizkid08</span>
            </cite>
        </div>
        <div id="dsq-comment-body-16307" class="dsq-comment-body">
            <div id="dsq-comment-message-16307" class="dsq-comment-message"><p>Code for 1st method:</p>
<pre> <code language="C">
#include &lt;stdio.h&gt;

struct Node
{
	int data;
	struct Node *arbit;
	struct Node *next;
};

typedef struct Node Node;
void push(Node **head, int val)
{
	Node* temp = (Node*) malloc(sizeof(Node));
	temp-&gt;data = val;

	if(*head == 0)
	{
		temp-&gt;next = 0;
		*head = temp;
	}

	else
	{
		temp-&gt;next = *head;
		*head = temp;
	}
}

Node* copyList(Node *head)
{
	Node* temp = head, *cpyhead, *cpytmp;

	if(!head)
	return 0;

	cpyhead = (Node*) malloc(sizeof(Node));
	cpyhead-&gt;data = head-&gt;data;

	temp = head-&gt;next;

	while(temp)
	{
		cpytmp = (Node*) malloc(sizeof(Node));
		cpytmp-&gt;data = temp-&gt;data;
		cpytmp-&gt;next = cpyhead;
		cpyhead = cpytmp;
		temp = temp-&gt;next;
	}

	temp = head;
	cpytmp = cpyhead;

	while(temp)
	{
		Node *sectmp = temp-&gt;next;
		temp-&gt;next = cpytmp;

		cpytmp-&gt;arbit = temp;
		temp = sectmp;
		cpytmp = cpytmp-&gt;next;
	}

	temp = head;
	cpytmp = cpyhead;

	while(cpytmp)
	{
		cpytmp-&gt;arbit = cpytmp-&gt;arbit-&gt;arbit-&gt;next;
		cpytmp = cpytmp-&gt;next;
	}

	return cpyhead;
}


void main()
{
	Node *head = 0, *copy_head, *temp;

	push(&amp;head,10);
	push(&amp;head,20);
	push(&amp;head,50);
	push(&amp;head,30);
	push(&amp;head,25);

	head-&gt;arbit = head-&gt;next-&gt;next;
	head-&gt;next-&gt;arbit = head-&gt;next-&gt;next-&gt;next;
	head-&gt;next-&gt;next-&gt;arbit = head;
	head-&gt;next-&gt;next-&gt;next-&gt;arbit = head-&gt;next-&gt;arbit;
	head-&gt;next-&gt;next-&gt;next-&gt;next-&gt;arbit = head-&gt;next-&gt;next;

	copy_head = copyList(head);
	temp= copy_head;

	while(temp)
	{
	 printf(&quot;\nData=%d&quot;,temp-&gt;data);
	 printf(&quot;\tArbit=%d \n&quot;,temp-&gt;arbit-&gt;data);
	 temp = temp-&gt;next;
	}
}
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-whizkid08 even depth-2" id="dsq-comment-16311">
        <div id="dsq-comment-header-16311" class="dsq-comment-header">
            <cite id="dsq-cite-16311">
                <span id="dsq-author-user-16311">whizkid08</span>
            </cite>
        </div>
        <div id="dsq-comment-body-16311" class="dsq-comment-body">
            <div id="dsq-comment-message-16311" class="dsq-comment-message"><p>Oops. Didn&#8217;t restore original list. Any idea on how to achieve:<br />
(2)Store the node and its next pointer mappings of original linked list.</p>
<p>It can be easily done by having a 3rd list. Any efficient way in C?</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-14589">
        <div id="dsq-comment-header-14589" class="dsq-comment-header">
            <cite id="dsq-cite-14589">
                <span id="dsq-author-user-14589">Aishwarya</span>
            </cite>
        </div>
        <div id="dsq-comment-body-14589" class="dsq-comment-body">
            <div id="dsq-comment-message-14589" class="dsq-comment-message"><pre> <code language="C">
#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;

struct node
{
   int data;
   node *next, *random;
   node(int _data):data(_data),next(NULL),random(NULL){}
};

node *addEnd(node **head, int data)
{
   while(*head)head=&amp;(*head)-&gt;next;
   *head=new node(data);
   return *head;
}

void printNext(node *head)
{
   while(head)
   {
      cout&lt;&lt;head-&gt;data&lt;&lt;&quot; &quot;;
      head=head-&gt;next;
   }
   cout&lt;&lt;endl;
}

void printRandom(node *head)
{
   for(int i=0;i&lt;6;i++)
   {
      cout&lt;&lt;head-&gt;random-&gt;data&lt;&lt;&quot; &quot;;
      head=head-&gt;next;
   }
   cout&lt;&lt;endl;
}

void clone(node *head, node **copy)
{
   if(!head)return;
   node *h=head;
   while(h)
   {
      node *tmp=new node(h-&gt;data);
      tmp-&gt;next=h-&gt;next;
      h-&gt;next=tmp;
      h=tmp-&gt;next;
   }
   *copy=head-&gt;next;
   h=head-&gt;next;
   while(head)
   {
      h-&gt;random=head-&gt;random-&gt;next;
      head-&gt;next=head-&gt;next-&gt;next;
      head=head-&gt;next;
      h-&gt;next=h-&gt;next?h-&gt;next-&gt;next:NULL;
      h=h-&gt;next;
   }      
}

int main(void )
{
   node *head=NULL;
   vector&lt;node*&gt; v;
   v.push_back(addEnd(&amp;head,0));
   v.push_back(addEnd(&amp;head,1));
   v.push_back(addEnd(&amp;head,2));
   v.push_back(addEnd(&amp;head,3));
   v.push_back(addEnd(&amp;head,4));
   v.push_back(addEnd(&amp;head,5));
   v[0]-&gt;random=v[1];
   v[1]-&gt;random=v[3];
   v[2]-&gt;random=v[4];
   v[3]-&gt;random=v[5];
   v[4]-&gt;random=v[2];
   v[5]-&gt;random=v[5];
   cout&lt;&lt;&quot;\noriginal list before copying\n&quot;;
   printNext(head);
   printRandom(head);
   node *copy=NULL;
   clone(head,&amp;copy);
   cout&lt;&lt;&quot;\noriginal list after copying\n&quot;;
   printNext(head);
   printRandom(head);
   cout&lt;&lt;&quot;\ncopied list\n&quot;;
   printNext(copy);
   printRandom(copy);
   getchar();
   return 0;
}  
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-rahulcynosure even depth-2" id="dsq-comment-15818">
        <div id="dsq-comment-header-15818" class="dsq-comment-header">
            <cite id="dsq-cite-15818">
                <span id="dsq-author-user-15818">rahulcynosure</span>
            </cite>
        </div>
        <div id="dsq-comment-body-15818" class="dsq-comment-body">
            <div id="dsq-comment-message-15818" class="dsq-comment-message"><p>Your code has a small bug. Check the output .<br />
original list before copying<br />
0 1 2 3 4 5<br />
1 3 4 5 2 5 </p>
<p>original list after copying<br />
0 1 2 3 4 5<br />
1 3 4 5 2 5 </p>
<p>copied list<br />
0 1 2 3 4 5<br />
1 3 4 5 3 5 </p>
<p>in the copied list random pointer , node with value 4 is pointing to node with value 3 . However in orignal list node with value 4 is pointing to node with value 2. </p>
<p>Here&#8217;s the corrected code.</p>
<p>//this function returns the head of the copied list.<br />
struct node * copy(struct node * head)<br />
{<br />
        struct node * newLH,*h=head;</p>
<p>        while(h)<br />
        {<br />
                node * temp =(struct node *)malloc(sizeof(struct node));<br />
                temp->random = NULL;<br />
                temp->data = h->data;<br />
                temp->next = h->next;<br />
                h->next=temp;<br />
                h = temp->next;</p>
<p>        }<br />
        newLH = head->next;<br />
        node * t = head->next;<br />
        h=head;<br />
        while(h)<br />
        {<br />
                h->next->random = h->random->next;<br />
                h = h->next->next;<br />
        //      t->next = t->next?t->next->next:NULL;<br />
        //      t = t->next;<br />
        //      h = h->next;<br />
        }<br />
        h=head;<br />
        while(h)<br />
        {<br />
                h->next = h->next->next;<br />
                t->next=t->next?t->next->next:NULL;<br />
                t=t->next;<br />
                h=h->next;<br />
        }<br />
        return newLH;<br />
}</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-13489">
        <div id="dsq-comment-header-13489" class="dsq-comment-header">
            <cite id="dsq-cite-13489">
                <span id="dsq-author-user-13489">sushdragon</span>
            </cite>
        </div>
        <div id="dsq-comment-body-13489" class="dsq-comment-body">
            <div id="dsq-comment-message-13489" class="dsq-comment-message"><p>there is no need of extra space. Just change copy_node-&gt;arbitrary-&gt;next=copy_node-&gt;next-&gt;arbitrary.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-9020">
        <div id="dsq-comment-header-9020" class="dsq-comment-header">
            <cite id="dsq-cite-9020">
                <span id="dsq-author-user-9020">user123</span>
            </cite>
        </div>
        <div id="dsq-comment-body-9020" class="dsq-comment-body">
            <div id="dsq-comment-message-9020" class="dsq-comment-message"><p>how is the 1st solution done in O(n) and 2nd one in O(1)?i can&#8217;t understand&#8230;somebody please explain</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-9021">
        <div id="dsq-comment-header-9021" class="dsq-comment-header">
            <cite id="dsq-cite-9021">
                <span id="dsq-author-user-9021">user123</span>
            </cite>
        </div>
        <div id="dsq-comment-body-9021" class="dsq-comment-body">
            <div id="dsq-comment-message-9021" class="dsq-comment-message"><p>with respect to space i&#8217;m asking..</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment byuser comment-author-geeksforgeeks bypostauthor even thread-odd thread-alt depth-1" id="dsq-comment-7311">
        <div id="dsq-comment-header-7311" class="dsq-comment-header">
            <cite id="dsq-cite-7311">
                <span id="dsq-author-user-7311">GeeksforGeeks</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7311" class="dsq-comment-body">
            <div id="dsq-comment-message-7311" class="dsq-comment-message"><p>@WgpShashank:<br />
<em>1. if wen can&#8217;t modify the original linked list e.g. its read only </em><br />
If we can&#8217;t modify the list then we can create a copy in more than O(n) time complexity by storing everything and creating copy from the stored data.<br />
<em>2. if elements are duplicate or all the elements are same.</em><br />
There should not be any problem when there are duplicates as both of the approaches given above do not compare data.</p>
<p>@Ruonan Zhao, @Ishan and @Elijah:<br />
Thanks for pointing this out. We have renmoved method 1 from the original post.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-6610">
        <div id="dsq-comment-header-6610" class="dsq-comment-header">
            <cite id="dsq-cite-6610">
http://shashank7s.blogspot.com                <span id="dsq-author-user-6610">WgpShashank</span>
            </cite>
        </div>
        <div id="dsq-comment-body-6610" class="dsq-comment-body">
            <div id="dsq-comment-message-6610" class="dsq-comment-message"><p>@All Some Issue That I Can See with each approaches  are .</p>
<p>1. if wen can&#8217;t modify the original linked list e.g. its read only </p>
<p>2. if elements are duplicate or all the elements are same.</p>
<p>in these case we have to think some other algorithm ? isn&#8217;t it<br />
?</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-sudha even thread-odd thread-alt depth-1" id="dsq-comment-6334">
        <div id="dsq-comment-header-6334" class="dsq-comment-header">
            <cite id="dsq-cite-6334">
                <span id="dsq-author-user-6334">Sudha Malpeddi</span>
            </cite>
        </div>
        <div id="dsq-comment-body-6334" class="dsq-comment-body">
            <div id="dsq-comment-message-6334" class="dsq-comment-message"><pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
void copy(struct node *p, struct node **q)
{
	if(p!=NULL)
	{ 
		*q=(struct node*)malloc(sizeof(struct node)); 
		(*q)-&gt;num=p-&gt;num; 
		(*q)-&gt;next=NULL; 
		copy(p-&gt;next, &amp;((*q)-&gt;next)); 
		(*q)-&gt;arbit=p-&gt;arbit;
	}
}
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-6361">
        <div id="dsq-comment-header-6361" class="dsq-comment-header">
            <cite id="dsq-cite-6361">
                <span id="dsq-author-user-6361">levis</span>
            </cite>
        </div>
        <div id="dsq-comment-body-6361" class="dsq-comment-body">
            <div id="dsq-comment-message-6361" class="dsq-comment-message"><p>This doesnt work &#8230;In the last step of recursion you are trying to point to the old list arbitrary pointer !!!but it should to point to the new list  &#8230;</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-4285">
        <div id="dsq-comment-header-4285" class="dsq-comment-header">
            <cite id="dsq-cite-4285">
                <span id="dsq-author-user-4285">Ruonan Zhao</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4285" class="dsq-comment-body">
            <div id="dsq-comment-message-4285" class="dsq-comment-message"><p>Hi, I think the restriction assumption is wrong for the first solution. The restriction here is that a node will be pointed by only one arbit pointer in a linked list. Even if we obey this restriction, there still have some cause we can not restore the original list. </p>
<p>For example?<br />
In this case<br />
original_Node1-&gt;arbit=original_Node3<br />
original_Node2-&gt;arbit=original_Node1<br />
original_Node3-&gt;arbit=original_Node2</p>
<p>the original_node2-next cannot be restore by original_node2-&gt;next = original_node2-&gt;next-&gt;next-&gt;arbit, because original_node2-&gt;next-&gt;next is copy_node1 and it&#8217;s arbit has being change to copy_node3 already in the first loop.</p>
<p>So the restriction assumption should be:<br />
The node&#8217;s arbit will point to the node which is after that node.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-6009">
        <div id="dsq-comment-header-6009" class="dsq-comment-header">
            <cite id="dsq-cite-6009">
                <span id="dsq-author-user-6009">Ishan</span>
            </cite>
        </div>
        <div id="dsq-comment-body-6009" class="dsq-comment-body">
            <div id="dsq-comment-message-6009" class="dsq-comment-message"><p>Yes, I also came across the same thing, the 1st approach only works if the arbit pointer points to a node which is after the current node in the list.</p>
<p>If the node is before the current node , the next pointer  of that pointer has already been modified and no longer points to its corresponding node in the duplicated list, thereby producing a wrong result.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-3" id="dsq-comment-6844">
        <div id="dsq-comment-header-6844" class="dsq-comment-header">
            <cite id="dsq-cite-6844">
                <span id="dsq-author-user-6844">Elijah</span>
            </cite>
        </div>
        <div id="dsq-comment-body-6844" class="dsq-comment-body">
            <div id="dsq-comment-message-6844" class="dsq-comment-message"><p>A very valid point. Even I figured out the same case.</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-3931">
        <div id="dsq-comment-header-3931" class="dsq-comment-header">
            <cite id="dsq-cite-3931">
                <span id="dsq-author-user-3931">Raja</span>
            </cite>
        </div>
        <div id="dsq-comment-body-3931" class="dsq-comment-body">
            <div id="dsq-comment-message-3931" class="dsq-comment-message"><p>First figure doesn&#8217;t have the restriction mentioned. A node should be pointed by a single arbit link. But in the figure 1, 3&#8217;s arbit and 4&#8217;s arbit are pointing to node 5.</p>
<p>Please correct me if i&#8217;m wrong.</p>
<p>&#8212;<br />
Raja</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-geeksforgeeks bypostauthor even depth-2" id="dsq-comment-3942">
        <div id="dsq-comment-header-3942" class="dsq-comment-header">
            <cite id="dsq-cite-3942">
                <span id="dsq-author-user-3942">GeeksforGeeks</span>
            </cite>
        </div>
        <div id="dsq-comment-body-3942" class="dsq-comment-body">
            <div id="dsq-comment-message-3942" class="dsq-comment-message"><p>@Raja: Thanks for pointing this out. We shall upadate the post with modified figure.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-3810">
        <div id="dsq-comment-header-3810" class="dsq-comment-header">
            <cite id="dsq-cite-3810">
http://ashutosh7s.blogspot.com/                <span id="dsq-author-user-3810">wgpshashank</span>
            </cite>
        </div>
        <div id="dsq-comment-body-3810" class="dsq-comment-body">
            <div id="dsq-comment-message-3810" class="dsq-comment-message"><pre> <code language="C"> 
struct node
{
  struct node *next;
  struct node *random;
  int val;
 
};
void push(struct node **head_ref, int new_data)
{
     struct node *new_node =
              (struct node *)malloc(sizeof(struct node));
     new_node-&gt;val= new_data;
     new_node-&gt;next = *head_ref;
     *head_ref = new_node;
}
struct node* copy_list(struct node *root)
{
    struct node *res=NULL;
    
    struct node *cur = root;
    struct node *next, *tmp;
    
    //Create the copy of every node in the list and insert 
    //it in original list between current and next node. 
    while(cur)
    {
        tmp =(struct node *)malloc(sizeof(struct node));
        tmp-&gt;val = cur-&gt;val;
        tmp-&gt;random = NULL;
        tmp-&gt;next = cur-&gt;next;
        next = cur-&gt;next;
        cur-&gt;next = tmp;
        cur = next;        
    }
      
    //save result pointer    
    res = root-&gt;next;
    
    //Copy the arbitrary link for result
    cur = root;    
    while(cur)
    {
        cur-&gt;next-&gt;random = cur-&gt;random-&gt;next;
        cur = cur-&gt;next-&gt;next;  //move 2 nodes at a time
    }
    
    //restore the original and copy linked lists
    cur = root;    
    tmp = root-&gt;next;
    while(cur &amp;&amp; tmp)
    {
        cur-&gt;next = cur-&gt;next-&gt;next;
        cur = cur-&gt;next;
        if (tmp-&gt;next){
            tmp-&gt;next = tmp-&gt;next-&gt;next;
            tmp = tmp-&gt;next;
        }        
    }
    
    return res;
}
 
void printList(struct node *head)
{
     while(head!=NULL)
     {
        printf(&quot;%d &quot;,head-&gt;val);
        head=head-&gt;next;
     }
     printf(&quot;\n&quot;);
}
 
int main()
{
struct node *head = NULL;
 
    /* Create following linked list
      12-&gt;15-&gt;10-&gt;11-&gt;5-&gt;6-&gt;2-&gt;3 */
    push(&amp;head,3);
    push(&amp;head,2);
    push(&amp;head,6);
    push(&amp;head,5);
    push(&amp;head,11);
    push(&amp;head,10);
    push(&amp;head,15);
    push(&amp;head,12);
 
    head=copy_list(head);
 
    printf(&quot;Given Linked List: &quot;);
    printList(head);
}
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-disappearedng even thread-odd thread-alt depth-1" id="dsq-comment-3750">
        <div id="dsq-comment-header-3750" class="dsq-comment-header">
            <cite id="dsq-cite-3750">
                <span id="dsq-author-user-3750">disappearedng</span>
            </cite>
        </div>
        <div id="dsq-comment-body-3750" class="dsq-comment-body">
            <div id="dsq-comment-message-3750" class="dsq-comment-message"><p>I am writing this to practice,</p>
<p>How can you write a function, deep_equal, that:<br />
1) Traverse all the nodes at least once and check that the corresponding node in another given list has the same value<br />
2) Terminates?</p>
<p>My approach has been the following:<br />
Given n1, n2:<br />
1) Call on n1.next and n2.next (not n1 and n2) recursively<br />
2) if you are at n1 and n2, return True </p>
<p>This does NOT guarantee to stop because you can simply construct a list where 1=&gt;2=&gt;3 and then 2 and 3&#8217;s arbit pointer points at 2 and 3 respectively and then this recursion will never stop.</p>
<p>How do I go about it?</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-disappearedng odd alt depth-2" id="dsq-comment-3752">
        <div id="dsq-comment-header-3752" class="dsq-comment-header">
            <cite id="dsq-cite-3752">
                <span id="dsq-author-user-3752">disappearedng</span>
            </cite>
        </div>
        <div id="dsq-comment-body-3752" class="dsq-comment-body">
            <div id="dsq-comment-message-3752" class="dsq-comment-message"><p>Note the method of doing the following:</p>
<p>I came up with a two pass algorithm which involves:<br />
1st pass: check both l1 and l2 by traversing next<br />
2nd pass: check both l1 and l2&#8217;s arbit pointers pointing to nodes with the same value and continue traversing the list via next (NOT via the arbit pointers to avoid cycles).</p>
<p>This does **not** work. </p>
<p>Look at the scenario below:</p>
<p>l1: 1-&gt;2-&gt;3-&gt;2<br />
there is only 1 arbit pointer and it&#8217;s from 3 to the first 2</p>
<p>l2: 1-&gt;2-&gt;3-&gt;2<br />
there is only 1 arbit pointer and it&#8217;s from 3 to the SECOND 2.</p>
<p>This algorithm will fail. </p>
<p>Anyone able to help?</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-3408">
        <div id="dsq-comment-header-3408" class="dsq-comment-header">
            <cite id="dsq-cite-3408">
http://wgpshashank.co.cc                <span id="dsq-author-user-3408">wgpshashank</span>
            </cite>
        </div>
        <div id="dsq-comment-body-3408" class="dsq-comment-body">
            <div id="dsq-comment-message-3408" class="dsq-comment-message"><pre> <code language="C">
copy_linked_lists(struct node *q, struct node **s)
{
   if(q!=NULL) {
     *s=malloc(sizeof(struct node));
     (*s)-&gt;data=q-&gt;data;
     (*s)-&gt;link=NULL;
     copy_linked_list(q-&gt;link, &amp;((*s)-&gt;link));
   }
}
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-2876">
        <div id="dsq-comment-header-2876" class="dsq-comment-header">
            <cite id="dsq-cite-2876">
                <span id="dsq-author-user-2876">sri</span>
            </cite>
        </div>
        <div id="dsq-comment-body-2876" class="dsq-comment-body">
            <div id="dsq-comment-message-2876" class="dsq-comment-message"><p>The first algo does not make sense. If you change all arbit pointers first and then try to change the next pointers you cannot.. as the arbit have been modified and vice versa.</p>
<p>Even if you modify arbit pointer of a node and then restore the next pointer of corresponding node in orig list.. then also the last node&#8217;s back pointer shows problem. The next has been modified to point to 3. </p>
<p>Pls explain if i am missing something!!</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-2" id="dsq-comment-4687">
        <div id="dsq-comment-header-4687" class="dsq-comment-header">
            <cite id="dsq-cite-4687">
                <span id="dsq-author-user-4687">guest</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4687" class="dsq-comment-body">
            <div id="dsq-comment-message-4687" class="dsq-comment-message"><p>i don&#8217; tthink u read the algo carefully&#8230; it first modifies the arbit pointer of copy list and then modifies the next pointer of corresponding node in orig list.<br />
and for the last node how can the next point to 3??<br />
for last node :<br />
orig-&gt;next=orig-&gt;next-&gt;next-&gt;arbit;<br />
but for last node : orig-&gt;next-&gt;next==NULL so we can set the next of last node in orig to NULL by checking this condition&#8230;.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment byuser comment-author-kevalvora odd alt thread-even depth-1" id="dsq-comment-2188">
        <div id="dsq-comment-header-2188" class="dsq-comment-header">
            <cite id="dsq-cite-2188">
                <span id="dsq-author-user-2188">kevalvora</span>
            </cite>
        </div>
        <div id="dsq-comment-body-2188" class="dsq-comment-body">
            <div id="dsq-comment-message-2188" class="dsq-comment-message"><p>About the 1st algorithm, either I have not understood it or it is incomplete and does not work properly.</p>
<p>In the example given, after 1st iteration, arbit of 1 in copy-list will point to 3 in copy-list. Also, 1 in original-list will point to 2 in original-list. In 2nd iteration, arbit of 2 in original-list is pointing to 1 in original-list but next of 1 in original-list is pointing back to 2 in original-list (due to the change in 1st iteration). So following statement will fail:</p>
<blockquote><p>copy_list_node-&gt;arbit = copy_list_node-&gt;arbit-&gt;arbit-&gt;next </p></blockquote>
<p>I might not have understood the algorithm, in that case, please explain where I am going wrong.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-kevalvora even depth-2" id="dsq-comment-2192">
        <div id="dsq-comment-header-2192" class="dsq-comment-header">
            <cite id="dsq-cite-2192">
                <span id="dsq-author-user-2192">kevalvora</span>
            </cite>
        </div>
        <div id="dsq-comment-body-2192" class="dsq-comment-body">
            <div id="dsq-comment-message-2192" class="dsq-comment-message"><p>Now I have understood the algorithm and yes, it works properly.</p>
<p>In 1st loop we change the arbit nodes of copy-list and in a separate loop we change the next of nodes in original-list.</p>
<p>A wonderful algorithm <img src="http://d2o58evtke57tz.cloudfront.net/wp-includes/images/smilies/icon_smile.gif" alt=":)" class="wp-smiley" /></p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-3" id="dsq-comment-4222">
        <div id="dsq-comment-header-4222" class="dsq-comment-header">
            <cite id="dsq-cite-4222">
                <span id="dsq-author-user-4222">Stiju</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4222" class="dsq-comment-body">
            <div id="dsq-comment-message-4222" class="dsq-comment-message"><p>1st method doubt :<br />
1st loop we change the arbit nodes of copy-list<br />
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-<br />
it will work fine</p>
<p>separate loop we change the next of nodes in original-list.<br />
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;<br />
&#8220;orig_list_node-&gt;next =<br />
                      orig_list_node-&gt;next-&gt;next-&gt;arbit&#8221;</p>
<p>since orig_list_node-&gt;next links to sibling node in copy list, now arent we dependent on copy_list_node-&gt;arbit which we changed in 1st loop.<br />
wouldn&#8217;t orig_list_node-&gt;next be replaced with arbit&#8217;s of corresponding copy_list_node , which now points to its actual arbit than its sibling on orig_list</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-2181">
        <div id="dsq-comment-header-2181" class="dsq-comment-header">
            <cite id="dsq-cite-2181">
                <span id="dsq-author-user-2181">Parthsarthi</span>
            </cite>
        </div>
        <div id="dsq-comment-body-2181" class="dsq-comment-body">
            <div id="dsq-comment-message-2181" class="dsq-comment-message"><p>the first method is incorrect.I think we will have to store the next pointers in first case too.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-1700">
        <div id="dsq-comment-header-1700" class="dsq-comment-header">
            <cite id="dsq-cite-1700">
http://processmanagerforwindows.blogspot.com/                <span id="dsq-author-user-1700">Arif Ali Saiyed</span>
            </cite>
        </div>
        <div id="dsq-comment-body-1700" class="dsq-comment-body">
            <div id="dsq-comment-message-1700" class="dsq-comment-message"><p>After reading the question i tried solving it myself&#8230;<br />
and came up with the method list below, then i looked into the three solution mentioned here, I liked the solution 3 most.<br />
it&#8217;s really beautiful. </p>
<p>My solution is worst considering the space complexity,<br />
but does not modifies the original list while on other hand all three solutions listed above does that&#8230;</p>
<p>Solution 4:</p>
<p>1) Traverse the list 1 and create list 2 (new copy) , just care about next link ptr,<br />
      forget the previous link ptr  completely. </p>
<p>     While doing this create/update two hash tables</p>
<p>   hash table 1<br />
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;<br />
| list1ptr1 | list2ptr1|<br />
| list1ptr2 | list2ptr |</p>
<p>   hash table 2<br />
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;<br />
| list2ptr1 | list1ptr1|<br />
| list2ptr2 | list1ptr |</p>
<p>All that said above is done in one pass of original list&#8230; that O(n)</p>
<p>2) Now traverse the second list ( copied one) , and store the prevPtr link using 3 hash tables that we created in pass 1. </p>
<p>list2Ptr1-&gt;prePtr =   a) Refer the hash table 2  and get the counter part pointer in list 1.<br />
                                      say list1ptr1<br />
                                  b) find the prevPtr of list1ptr1 in list 1 itself<br />
                                  c) use the hash table 2, to find the counter part node in list 2</p>
<p>Time Complexity : O(2n)<br />
Space Complexity : O(2n)</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-2" id="dsq-comment-3932">
        <div id="dsq-comment-header-3932" class="dsq-comment-header">
            <cite id="dsq-cite-3932">
                <span id="dsq-author-user-3932">Raja</span>
            </cite>
        </div>
        <div id="dsq-comment-body-3932" class="dsq-comment-body">
            <div id="dsq-comment-message-3932" class="dsq-comment-message"><p>do u have code for this?</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt depth-2" id="dsq-comment-16309">
        <div id="dsq-comment-header-16309" class="dsq-comment-header">
            <cite id="dsq-cite-16309">
                <span id="dsq-author-user-16309">Sri1</span>
            </cite>
        </div>
        <div id="dsq-comment-body-16309" class="dsq-comment-body">
            <div id="dsq-comment-message-16309" class="dsq-comment-message"><p>Algo:<br />
This solution can be made much simpler with just one Hash Table.  (Key, value) = (pointer, pointer) or (node_list1, node_list2).  The hash table takes a list1 node as key and returns the corresponding list2 node.</p>
<p>First iteration through original list1:<br />
// Create new link list node<br />
// After creating each node, add old and new nodes to HashMap<br />
// If previous node is present, assign the next node for new list.</p>
<p>Second iteration through both list1 and list 2:<br />
node_list2-&gt;arbit = HashMap(node-&gt;arbit);<br />
//Move current nodes to node_list2-&gt;next; node_list1-&gt;next</p>
<p>Done!  No need for array, index adjustment etc.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-3" id="dsq-comment-16312">
        <div id="dsq-comment-header-16312" class="dsq-comment-header">
            <cite id="dsq-cite-16312">
                <span id="dsq-author-user-16312">Sri1</span>
            </cite>
        </div>
        <div id="dsq-comment-body-16312" class="dsq-comment-body">
            <div id="dsq-comment-message-16312" class="dsq-comment-message"><p>Complexity = O(n)<br />
Storage is 2n storage of memory pointers, so still O(n)</p>
<p>Of course, if this is a very large data structure and it is a memory constrained device, then the Hashmap implementation, collisions, chaining etc. [if retrieval is actually in O(1) time] will come into play.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment byuser comment-author-sambasiva odd alt thread-odd thread-alt depth-1" id="dsq-comment-1383">
        <div id="dsq-comment-header-1383" class="dsq-comment-header">
            <cite id="dsq-cite-1383">
http://effprog.blogspot.com                <span id="dsq-author-user-1383">Sambasiva</span>
            </cite>
        </div>
        <div id="dsq-comment-body-1383" class="dsq-comment-body">
            <div id="dsq-comment-message-1383" class="dsq-comment-message"><pre> <code language="C">

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct Node
{
        int data;
        struct Node *next;
        struct Node *arb;
};

typedef struct Node Node;
typedef Node* list;

Node* dupNode(Node *p)
{
        Node *temp = malloc(sizeof(Node));

        memcpy(temp, p, sizeof(Node));
        p-&gt;next = temp;

        return temp;
}

list copyList(list l)
{
        Node *p;
        Node *temp;

        if(!l) return NULL;

        for(p = l; p ; p = temp-&gt;next)
        {
                temp = dupNode(p);
        }

        for(p = l; p ; p = p-&gt;next-&gt;next)
        {
                if(p-&gt;arb)
                        p-&gt;arb = p-&gt;arb-&gt;next;
        }

        Node *newlist = l-&gt;next;

        for(p = l; p ; p = p-&gt;next)
        {
                temp = p-&gt;next;
                p-&gt;next = temp-&gt;next;
                if(temp-&gt;next)
                        temp-&gt;next = temp-&gt;next-&gt;next;
        }

        return newlist;
}

Node *insertNode(list l, int elm)
{
        Node *temp = malloc(sizeof(Node));
        temp-&gt;next = NULL;
        temp-&gt;arb = NULL;
        temp-&gt;data = elm;

        if(!l)
                return temp;
        temp-&gt;next = l-&gt;next;
        l-&gt;next = temp;
        temp-&gt;arb = l-&gt;next;
        return l;
}


void print(list l)
{
        for(; l ; l = l-&gt;next)
                printf(&quot;%d\n&quot;, l-&gt;data);
}

int main()
{
        list l = NULL;
        int i;

        for(i = 0; i &lt; 10; ++i)
        {
                l = insertNode(l,i);
        }

        print(l);
        list n = copyList(l);
        print(n);
}
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-2" id="dsq-comment-3180">
        <div id="dsq-comment-header-3180" class="dsq-comment-header">
            <cite id="dsq-cite-3180">
                <span id="dsq-author-user-3180">Shashank Mani Narayan</span>
            </cite>
        </div>
        <div id="dsq-comment-body-3180" class="dsq-comment-body">
            <div id="dsq-comment-message-3180" class="dsq-comment-message"><p>@sambasiva &#8230;hi can you explain your code..particularly second for loop inside the copyist Function is not giving clear understanding </p>
<p>..Please Try to Reply ASAP.</p>
<p>Thanks<br />
Shashank</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt depth-2" id="dsq-comment-3808">
        <div id="dsq-comment-header-3808" class="dsq-comment-header">
            <cite id="dsq-cite-3808">
http://ashutosh7s.blogspot.com/                <span id="dsq-author-user-3808">wgpshashank</span>
            </cite>
        </div>
        <div id="dsq-comment-body-3808" class="dsq-comment-body">
            <div id="dsq-comment-message-3808" class="dsq-comment-message"><p>@sambasiva..hi ur program is correct but you forget to initialize the arbitrary pointer of duplicate node inside your dup method&#8230;to avoid null pointer /memory error ..we have to take care of such situation</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even depth-2" id="dsq-comment-6661">
        <div id="dsq-comment-header-6661" class="dsq-comment-header">
            <cite id="dsq-cite-6661">
http://shashank7s.blogspot.com                <span id="dsq-author-user-6661">WgpShashank</span>
            </cite>
        </div>
        <div id="dsq-comment-body-6661" class="dsq-comment-body">
            <div id="dsq-comment-message-6661" class="dsq-comment-message"><p>this method should be ?</p>
<p>Node* dupNode(Node *p)<br />
{<br />
        Node *temp = malloc(sizeof(Node));</p>
<p>        memcpy(temp, p, sizeof(Node));</p>
<p>        temp-&gt;next=p-&gt;next;<br />
        p-&gt;next=temp;<br />
        return temp;</p>
<p>}</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-3" id="dsq-comment-6662">
        <div id="dsq-comment-header-6662" class="dsq-comment-header">
            <cite id="dsq-cite-6662">
http://shashank7s.blogspot.com                <span id="dsq-author-user-6662">WgpShashank</span>
            </cite>
        </div>
        <div id="dsq-comment-body-6662" class="dsq-comment-body">
            <div id="dsq-comment-message-6662" class="dsq-comment-message"><p>@sambasiva </p>
<p>also it should be </p>
<p>  p-&gt;next-&gt;arb = p-&gt;arb-&gt;next;</p>
<p>?</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment byuser comment-author-geeksforgeeks bypostauthor even thread-even depth-1" id="dsq-comment-217">
        <div id="dsq-comment-header-217" class="dsq-comment-header">
            <cite id="dsq-cite-217">
                <span id="dsq-author-user-217">geeksforgeeks</span>
            </cite>
        </div>
        <div id="dsq-comment-body-217" class="dsq-comment-body">
            <div id="dsq-comment-message-217" class="dsq-comment-message"><p>@Saravanan Mani: Good work, we have included your algorithm to the original post.  Keep it up!! </p>
<p>@GT &amp; Goli:  We still believe that we cannot set the next of original list and arbit of copy list with auxiliary space O(1) using first two approaches. Please try your algorithm step by step for figure 3 and check if you can set the next of 4 in original list and arbit of 4 in copy list. If you still believe that it can be done with auxiliary space O(1) with a variation of solution 1 and 2, please do write complete algorithm.  We will modify the post.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-207">
        <div id="dsq-comment-header-207" class="dsq-comment-header">
            <cite id="dsq-cite-207">
                <span id="dsq-author-user-207">Saravanan Mani</span>
            </cite>
        </div>
        <div id="dsq-comment-body-207" class="dsq-comment-body">
            <div id="dsq-comment-message-207" class="dsq-comment-message"><p>create the copy of 1 and insert between 1 &amp; 2, create the copy of 2 and insert between 2 &amp; 3.. continue in this fashion add the copy of N to Nth node</p>
<p>Now copy the arbitrary link in this fashion Original-&gt;next-&gt;arbitrary = Original-&gt;arbitrary-&gt;next; TRAVERSE TWO NODES;</p>
<p>This works because original-&gt;next is nothing but copy of original and Original-&gt;arbitrary-&gt;next is nothing but copy of arbitrary.</p>
<p>now restore the Original and copy linked lists in this fashion in a single loop.<br />
Original-&gt;next = Original-&gt;next-&gt;next;<br />
copy-&gt;next = copy-&gt;next-&gt;next;</p>
<p>Make sure that last element of original-&gt;next is NULL.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-2" id="dsq-comment-7246">
        <div id="dsq-comment-header-7246" class="dsq-comment-header">
            <cite id="dsq-cite-7246">
                <span id="dsq-author-user-7246">Arun</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7246" class="dsq-comment-body">
            <div id="dsq-comment-message-7246" class="dsq-comment-message"><p>@Saravanan Mani : Good creative solution. But I am not sure how the Time Complexity is O(n). It looks like it is O(n^3) : First pass to create the copy, second pass to set the arbitrary pointers and 3rd pass to restore the original next pointers. Am I missing something here ?</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-3" id="dsq-comment-7314">
        <div id="dsq-comment-header-7314" class="dsq-comment-header">
            <cite id="dsq-cite-7314">
                <span id="dsq-author-user-7314">Arun</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7314" class="dsq-comment-body">
            <div id="dsq-comment-message-7314" class="dsq-comment-message"><p>Oops. It is O(3n) and not O(n^3). What was I thinking !</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-202">
        <div id="dsq-comment-header-202" class="dsq-comment-header">
            <cite id="dsq-cite-202">
                <span id="dsq-author-user-202">goli</span>
            </cite>
        </div>
        <div id="dsq-comment-body-202" class="dsq-comment-body">
            <div id="dsq-comment-message-202" class="dsq-comment-message"><p>@GT:<br />
I agree. We dont really need to store the info related to original listnodes. We can restore the next of orig list as </p>
<p>copy_node.arbit.next = copy_node.next.arbit<br />
copy_node.arbit = copy_node.arbit.arbit.next</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-199">
        <div id="dsq-comment-header-199" class="dsq-comment-header">
            <cite id="dsq-cite-199">
                <span id="dsq-author-user-199">GT</span>
            </cite>
        </div>
        <div id="dsq-comment-body-199" class="dsq-comment-body">
            <div id="dsq-comment-message-199" class="dsq-comment-message"><p>do we really need to store the mapping of original listnodes and their next pointers &#8230;</p>
<p>i think we can set the next pointer of original list </p>
<p>via the copied lists next node&#8217;s arbit pointer &#8230;</p>
<p>this works since we are adjusting the arbit pointers of the copied list from left to right &#8230; first node to last node &#8230;</p>
<p>comments are welcome &#8230;</p>
</div>
        </div>

    </li><!-- #comment-## -->
            </ul>


        </div>

    </div>

<script type="text/javascript">
var disqus_url = 'http://www.geeksforgeeks.org/a-linked-list-with-next-and-arbit-pointer/';
var disqus_identifier = '1155 http://geeksforgeeks.org/?p=1155';
var disqus_container_id = 'disqus_thread';
var disqus_shortname = 'geeksforgeeks';
var disqus_title = "Clone a linked list with next and random pointer | Set 1";
var disqus_config_custom = window.disqus_config;
var disqus_config = function () {
    /*
    All currently supported events:
    onReady: fires when everything is ready,
    onNewComment: fires when a new comment is posted,
    onIdentify: fires when user is authenticated
    */
    
    
    this.language = '';
    
    if (disqus_config_custom) {
        disqus_config_custom.call(this);
    }
};

(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>

			</div>
	
					
			
			

		</div> <!-- end post -->	

<br></br>
	
</div> <!-- end content -->

<ul id="sidebar">
	<li id="text-19" class="widget widget_text">			<div class="textwidget"><script>
  (function() {
    var cx = '009682134359037907028:tj6eafkv_be';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//www.google.com/cse/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>

<style type="text/css">
  .gsc-control-cse {
    font-family: "Trebuchet MS", sans-serif;
    border-color: #E1F3DA;
    background-color: #E1F3DA;
  }
  input.gsc-input {
    border-color: #94CC7A;
  }
  input.gsc-search-button {
    border-color: #94CC7A;
    background-color: #AADA92;
  }
  .gsc-tabHeader.gsc-tabhInactive {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gsc-tabHeader.gsc-tabhActive {
    border-color: #A9DA92;
    background-color: #A9DA92;
  }
  .gsc-tabsArea {
    border-color: #A9DA92;
  }
  .gsc-webResult.gsc-result {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gsc-webResult.gsc-result:hover {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gs-webResult.gs-result a.gs-title:link,
  .gs-webResult.gs-result a.gs-title:link b {
    color: #009900;
  }
  .gs-webResult.gs-result a.gs-title:visited,
  .gs-webResult.gs-result a.gs-title:visited b {
    color: #009900;
  }
  .gs-webResult.gs-result a.gs-title:hover,
  .gs-webResult.gs-result a.gs-title:hover b {
    color: #003300;
  }
  .gs-webResult.gs-result a.gs-title:active,
  .gs-webResult.gs-result a.gs-title:active b {
    color: #009900;
  }
  .gsc-cursor-page {
    color: #009900;
  }
  a.gsc-trailing-more-results:link {
    color: #009900;
  }
  .gs-webResult.gs-result .gs-snippet {
    color: #454545;
  }
  .gs-webResult.gs-result .gs-visibleUrl {
    color: #33cc00;
  }
  .gs-webResult.gs-result .gs-visibleUrl-short {
    color: #33cc00;
  }
  .gs-webResult.gs-result .gs-visibleUrl-short {
    display: none;
  }
  .gs-webResult.gs-result .gs-visibleUrl-long {
    display: block;
  }
  .gsc-cursor-box {
    border-color: #A9DA92;
  }
  .gsc-results .gsc-cursor-page {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gsc-results .gsc-cursor-page.gsc-cursor-current-page {
    border-color: #A9DA92;
    background-color: #A9DA92;
  }
  .gs-promotion.gs-result {
    border-color: #94CC7A;
    background-color: #CBE8B4;
  }
  .gs-promotion.gs-result a.gs-title:link {
    color: #0066CC;
  }
  .gs-promotion.gs-result a.gs-title:visited {
    color: #0066CC;
  }
  .gs-promotion.gs-result a.gs-title:hover {
    color: #0066CC;
  }
  .gs-promotion.gs-result a.gs-title:active {
    color: #0066CC;
  }
  .gs-promotion.gs-result .gs-snippet {
    color: #454545;
  }
  .gs-promotion.gs-result .gs-visibleUrl,
  .gs-promotion.gs-result .gs-visibleUrl-short {
    color: #815FA7;
  }
</style>    </div>
		</li>
<li id="text-9" class="widget widget_text">			<div class="textwidget"><div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=138031159685820";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>

<div class="fb-like-box" data-href="https://www.facebook.com/pages/GeeksforGeeks/316764689022" data-width="250" data-height="170" data-colorscheme="light" data-show-faces="true" data-header="false" data-stream="false" data-show-border="false"></div></div>
		</li>
<li id="text-18" class="widget widget_text">			<div class="textwidget"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LargeRectangleSide -->
<ins class="adsbygoogle"
     style="display:inline-block;width:336px;height:280px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="1884636833"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
		</li>
<li id="text-13" class="widget widget_text">			<div class="textwidget"><ul><li><a href="http://www.geeksforgeeks.org/category/interview-experiences/">Interview Experiences</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/advance-data-structures">Advanced Data Structures</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/dynamic-programming">Dynamic Programming</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/Greedy-Algorithm/">Greedy Algorithms</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/backtracking">Backtracking</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/pattern-searching">Pattern Searching</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/divide-and-conquer">Divide & Conquer</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/MathematicalAlgo">Mathematical Algorithms</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/recursion">Recursion</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/geometric-algorithms/">Geometric Algorithms</a></li>
</ul></div>
		</li>
<li id="text-17" class="widget widget_text">			<div class="textwidget"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big 300x600 Sidebar -->
<ins class="adsbygoogle"
     style="display:inline-block;width:300px;height:600px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="4402736037"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
		</li>
<li id="text-14" class="widget widget_text"><h2 class="widgettitle">Popular Posts</h2>
			<div class="textwidget"><ul>
<li><a href="http://www.geeksforgeeks.org/write-a-c-program-to-print-all-permutations-of-a-given-string/">  All permutations of a given string </a></li>
<li><a href="http://www.geeksforgeeks.org/memory-layout-of-c-program/"> Memory Layout of C Programs</a> </li>
<li><a href="http://www.geeksforgeeks.org/understanding-extern-keyword-in-c/"> Understanding “extern” keyword in C</a> </li>
<li><a href="http://www.geeksforgeeks.org/median-of-two-sorted-arrays/">Median of two sorted arrays</a> </li>
<li><a href="http://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/"> Tree traversal without recursion and without stack! </a></li>
<li><a href="http://www.geeksforgeeks.org/structure-member-alignment-padding-and-data-packing/"> Structure Member Alignment, Padding and Data Packing</a> </li>
<li><a href="http://www.geeksforgeeks.org/write-a-function-to-get-the-intersection-point-of-two-linked-lists/"> Intersection point of two Linked Lists</a> </li>
<li><a href="http://www.geeksforgeeks.org/lowest-common-ancestor-in-a-binary-search-tree/"> Lowest Common Ancestor in a BST.</span></a> </li>
<li><a href="http://www.geeksforgeeks.org/a-program-to-check-if-a-binary-tree-is-bst-or-not/"> Check if a binary tree is BST or not</a> </li>
<li><a href="http://www.geeksforgeeks.org/sorted-linked-list-to-balanced-bst/"> Sorted Linked List to Balanced BST</a></li>
</ul></div>
		</li>
<li id="text-3" class="widget widget_text">			<div class="textwidget"><a href="https://twitter.com/GeeksforGeeks" class="twitter-follow-button" data-show-count="false">Follow @GeeksforGeeks</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>         


<!-- GOOGLE FEEDBURNER BUTTON-->
<a href="http://feeds.feedburner.com/Geeksforgeeks" title="Subscribe to my feed" rel="alternate" type="application/rss+xml"><img src="http://www.feedburner.com/fb/images/pub/feed-icon32x32.png" alt="" style="border:0"/></a><a href="http://feeds.feedburner.com/Geeksforgeeks" title="Subscribe to my feed" rel="alternate" type="application/rss+xml">Subscribe</a>

</div>
		</li>
<li id="text-21" class="widget widget_text"><h2 class="widgettitle">Recent Comments</h2>
			<div class="textwidget"><script type="text/javascript" src="http://geeksforgeeks.disqus.com//recent_comments_widget.js?num_items=6&hide_avatars=1&excerpt_length=50&hide_mods=0"></script></div>
		</li>
<li id="text-22" class="widget widget_text">			<div class="textwidget"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LinkAd -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:90px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="2606115235"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LinkAd -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:90px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="2606115235"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LinkAd -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:90px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="2606115235"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
		</li>

</ul>					  
		<div class="clear"></div>

		<div id="footer">
		
		    <div class="xhtml">
                        @geeksforgeeks, <a href="http://creativecommons.org/licenses/by-nc-nd/2.5/in/deed.en_US" title="Valid XHTML Strict 1.0">Some rights reserved</a>  <a href="http://www.geeksforgeeks.org/about/contact-us/"> &nbsp; &nbsp; &nbsp; &nbsp;Contact Us!</a>

		    </div>
		    
		    <div class="credits">
			  Powered by <a href="http://wordpress.org">WordPress </a> &amp; <a href="http://mootools.net/" title="Mootools JavaScript Framework">MooTools</a>, customized by geeksforgeeks team </div>
			  
		   <div class="clear"></div>						                            
		   
		</div> <!--end footer-->  
        
		        <script type="text/javascript">
        // <![CDATA[
        var disqus_shortname = 'geeksforgeeks';
        (function () {
            var nodes = document.getElementsByTagName('span');
            for (var i = 0, url; i < nodes.length; i++) {
                if (nodes[i].className.indexOf('dsq-postid') != -1) {
                    nodes[i].parentNode.setAttribute('data-disqus-identifier', nodes[i].getAttribute('data-dsqidentifier'));
                    url = nodes[i].parentNode.href.split('#', 1);
                    if (url.length == 1) { url = url[0]; }
                    else { url = url[1]; }
                    nodes[i].parentNode.href = url + '#disqus_thread';
                }
            }
            var s = document.createElement('script'); 
            s.async = true;
            s.type = 'text/javascript';
            s.src = '//' + disqus_shortname + '.disqus.com/count.js';
            (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
        }());
        // ]]>
        </script>
        <script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/bbpress/templates/default/js/editor.js?ver=2.5.4-5380'></script>
				  
		</div> <!--end wrapper-->
        <div id="ajaxSpinner"></div> <!--For AJAX spinner holder-->
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-12148232-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
	</body>

</html>
<!-- Dynamic page generated in 0.236 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2015-01-05 12:35:13 -->

<!-- Compression = gzip -->
<!-- super cache -->