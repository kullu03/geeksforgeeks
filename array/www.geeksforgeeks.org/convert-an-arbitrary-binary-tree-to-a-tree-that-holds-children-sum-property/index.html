<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
       <title>Convert an arbitrary Binary Tree to a tree that holds Children Sum Property - GeeksforGeeks</title>
       <style type="text/css" media="screen">
          @import url('http://d2o58evtke57tz.cloudfront.net/wp-content/themes/minimoo/style.css');
    </style>
      <link href="http://d2o58evtke57tz.cloudfront.net/wp-content/themes/minimoo/favicon.ico" rel="shortcut icon" />    
    
<!-- This site is optimized with the Yoast WordPress SEO plugin v1.7.1 - https://yoast.com/wordpress/plugins/seo/ -->
<link rel="canonical" href="http://www.geeksforgeeks.org/convert-an-arbitrary-binary-tree-to-a-tree-that-holds-children-sum-property/" />
<meta property="og:locale" content="en_US" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Convert an arbitrary Binary Tree to a tree that holds Children Sum Property - GeeksforGeeks" />
<meta property="og:description" content="Question: Given an arbitrary binary tree, convert it to a binary tree that holds Children Sum Property. You can only increment data values in any node (You cannot change structure of tree and cannot decrement value of any node). For example, the below tree doesn&#8217;t hold the children sum property, convert it to a tree &hellip;" />
<meta property="og:url" content="http://www.geeksforgeeks.org/convert-an-arbitrary-binary-tree-to-a-tree-that-holds-children-sum-property/" />
<meta property="og:site_name" content="GeeksforGeeks" />
<meta property="article:section" content="Trees" />
<meta property="article:published_time" content="2010-02-03T16:29:03+00:00" />
<meta property="article:modified_time" content="2013-07-19T20:05:36+00:00" />
<meta property="og:updated_time" content="2013-07-19T20:05:36+00:00" />
<!-- / Yoast WordPress SEO plugin. -->

<link rel='stylesheet' id='wp-quicklatex-format-css'  href='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/wp-quicklatex/css/quicklatex-format.css?ver=4.0.1' type='text/css' media='all' />
<link rel='stylesheet' id='bbp-default-css'  href='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/bbpress/templates/default/css/bbpress.css?ver=2.5.4-5380' type='text/css' media='screen' />
<link rel='stylesheet' id='wp-pagenavi-css'  href='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/wp-pagenavi/pagenavi-css.css?ver=2.70' type='text/css' media='all' />
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-includes/js/jquery/jquery.js?ver=1.11.1'></script>
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-includes/js/jquery/jquery-migrate.min.js?ver=1.2.1'></script>
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/wp-quicklatex/js/wp-quicklatex-frontend.js?ver=1.0'></script>

<!-- Bad Behavior 2.2.16 run time: 1.519 ms -->
<script type="text/javascript">
<!--
function bb2_addLoadEvent(func) {
	var oldonload = window.onload;
	if (typeof window.onload != 'function') {
		window.onload = func;
	} else {
		window.onload = function() {
			oldonload();
			func();
		}
	}
}

bb2_addLoadEvent(function() {
	for ( i=0; i < document.forms.length; i++ ) {
		if (document.forms[i].method == 'post') {
			var myElement = document.createElement('input');
			myElement.setAttribute('type', 'hidden');
			myElement.name = 'bb2_screener_';
			myElement.value = '1417111171 210.212.53.139 172.19.11.169';
			document.forms[i].appendChild(myElement);
		}
	}
});
// --></script>
		<style type="text/css" id="syntaxhighlighteranchor"></style>
   <meta name="google-site-verification" content="rHK2v8_zzuAZQY8JHAzbllDN8u-aQxcn2Kqnp67Old0" />
</head>

<body>
<!-- o4dI0sCXUgoSONabbd8mbZ4SA3E -->    
    <div id="wrapper">
        <div class="blog-info">
                <h1 class="blog-title">
                <a href="http://www.geeksforgeeks.org" title="GeeksforGeeks">GeeksforGeeks</a>
            </h1>
       
            <div class="blog-description">
                A computer science portal for geeks            </div>
        </div>
        <b><p>  <h2 align="right"> <a href="http://geeksquiz.com/">GeeksQuiz</a></h2> 
   <a href="http://www.geeksforgeeks.org/wp-login.php">Login</a> 
         </p></b>  
         
         <div class="clear"></div>         
              
                     
            <div id="menu">   
                 <ul>
 <li><a href="http://www.geeksforgeeks.org">Home</a></li>
  <li><a href="http://www.geeksforgeeks.org/fundamentals-of-algorithms/">Algorithms</a></li>
 <li><a href="http://www.geeksforgeeks.org/data-structures/">DS</a></li>
  <li><a href="http://www.geeksforgeeks.org/gate-corner/">GATE</a></li>
  <li><a href="http://www.geeksforgeeks.org/about/interview-corner/">Interview Corner</a></li>
  <li><a href="http://www.geeksforgeeks.org/forums/">Q&A</a></li>
  <li><a href="http://www.geeksforgeeks.org/c/">C</a></li>
  <li><a href="http://www.geeksforgeeks.org/c-plus-plus/">C++</a></li>
  <li><a href="http://www.geeksforgeeks.org/java/">Java</a></li>
  <li><a href="http://www.geeksforgeeks.org/books/">Books</a></li>
  <li><a href="http://www.geeksforgeeks.org/contribute/">Contribute</a></li>
  <li><a href="http://www.geeksforgeeks.org/contribute/ask-a-question/">Ask a Q</a></li>
  <li><a href="http://www.geeksforgeeks.org/about/">About</a></li>
            </ul>

               
            <div class="clear"></div>     
        </div>
             <div id="navmenu">
				<ul id="menu" style="padding:0; margin:0;">
						<li class="cat-item cat-item-3"><a href="http://www.geeksforgeeks.org/category/c-arrays/" title="Questions regarding Arrays">Array</a>
</li>	

	<li class="cat-item cat-item-17"><a href="http://www.geeksforgeeks.org/category/bit-magic/" title="View all posts filed under Bit Magic">Bit Magic</a>
</li>
	<li class="cat-item cat-item-14"><a href="http://www.geeksforgeeks.org/category/c-puzzles/" title="View all posts filed under C/C++ Puzzles">C/C++</a>
</li>

<li class="cat-item cat-item-18"><a href="http://www.geeksforgeeks.org/category/articles/" title="View all posts filed under Articles">Articles</a>
</li>

	<li class="cat-item cat-item-67"><a href="http://www.geeksforgeeks.org/category/gfact/" title="View all posts filed under GFacts">GFacts</a>
</li>
	<li class="cat-item cat-item-8"><a href="http://www.geeksforgeeks.org/category/linked-list/" title="Linked List problems">Linked List</a>
</li>
	<li class="cat-item cat-item-66"><a href="http://www.geeksforgeeks.org/category/multiple-choice-question/" title="View all posts filed under MCQ">MCQ</a>

</li>
	<li class="cat-item cat-item-4"><a href="http://www.geeksforgeeks.org/category/c-programs/" title="Miscellaneous">Misc</a>
</li>
	<li class="cat-item cat-item-5"><a href="http://www.geeksforgeeks.org/category/program-output/" title="View all posts filed under Output">Output</a>
</li>
	<li class="cat-item cat-item-7"><a href="http://www.geeksforgeeks.org/category/c-strings/" title="Questions related to strings">String</a>
</li>
	<li class="cat-item cat-item-19"><a href="http://www.geeksforgeeks.org/category/tree/" title="View all posts filed under Trees">Tree</a>
</li>
	<li class="cat-item cat-item-19"><a href="http://www.geeksforgeeks.org/category/graph/" title="View all posts filed under Graph">Graph</a>
</li>
</ul>
        </div>
             <div id="content">	   	
	<div class="post" id="post">
							<div class="post-info">			
					<div class="post-title-info">
						<h2 class="post-title">Convert an arbitrary Binary Tree to a tree that holds Children Sum Property</h2>
					</div>			
					<div class="clear"></div>				  
				<div class="post-content" id="post-content">
					<p><strong>Question:</strong> Given an arbitrary binary tree, convert it to a binary tree that holds <a href="http://geeksforgeeks.org/?p=4358">Children Sum Property</a>. You can only increment data values in any node <span id="more-4386"></span>(You cannot change structure of tree and cannot decrement value of any node). </p>
<p>For example, the below tree doesn&#8217;t hold the children sum property, convert it to a tree that holds the property.</p>
<pre>
             50
           /     \     
         /         \
       7             2
     / \             /\
   /     \          /   \
  3        5      1      30
</pre>
<p><strong>Algorithm:</strong><br />
Traverse given tree in post order to convert it, i.e., first change left and right children to hold the children sum property then change the parent node.   </p>
<p>Let difference between node’s data and children sum be diff. </p>
<pre>
     diff = node’s children sum - node’s data  
</pre>
<p>If diff is 0 then nothing needs to be done.  </p>
<p>If diff >  0 ( node’s data is smaller than node&#8217;s children sum) increment the node’s data by diff.</p>
<p>If diff <  0  (node’s data is greater than the node's children sum) then increment one child’s data. We can choose to increment either left or right child if they both are not NULL. Let us always first increment the left child.  Incrementing a child changes the subtree’s children sum property so we need to change left subtree also. So we recursively increment the left child. If left child is empty then we recursively call increment() for right child.</p>
<p>Let us run the algorithm for the given example.  </p>
<p>First convert the left subtree (increment 7 to 8).</p>
<pre>
             50
           /     \     
         /         \
      <strong> 8  </strong>           2
     / \             /\
   /     \          /   \
  3        5      1      30
</pre>
<p>Then convert the right subtree (increment 2 to 31)</p>
<pre>
          50
        /    \     
      /        \
    8           <strong> 31</strong>
   / \           / \
 /     \       /     \
3       5    1       30
</pre>
<p>Now convert the root, we have to increment left subtree for converting the root.  </p>
<pre>
          50
        /    \     
      /        \
   <strong> 19 </strong>          31
   / \           /  \
 /     \       /      \
<strong>14</strong>      5     1       30
</pre>
<p>Please note the last step – we have incremented 8 to 19, and to fix the subtree we have incremented 3 to 14.</p>
<p><strong>Implementation:</strong></p>
<pre class="brush: cpp; highlight: [22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81]; title: ; notranslate" title="">
/* Program to convert an aribitary binary tree to
   a tree that holds children sum property */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct node
{
  int data;
  struct node* left;
  struct node* right;
};

/* This function is used to increment left subtree */
void increment(struct node* node, int diff);

/* Helper function that allocates a new node
 with the given data and NULL left and right
 pointers. */
struct node* newNode(int data);

/* This function changes a tree to to hold children sum
   property */
void convertTree(struct node* node)
{
  int left_data = 0,  right_data = 0, diff;

  /* If tree is empty or it's a leaf node then
     return true */
  if (node == NULL ||
     (node-&gt;left == NULL &amp;&amp; node-&gt;right == NULL))
    return;
  else
  {
    /* convert left and right subtrees  */
    convertTree(node-&gt;left);
    convertTree(node-&gt;right);

    /* If left child is not present then 0 is used
       as data of left child */
    if (node-&gt;left != NULL)
      left_data = node-&gt;left-&gt;data;

    /* If right child is not present then 0 is used
      as data of right child */
    if (node-&gt;right != NULL)
      right_data = node-&gt;right-&gt;data;

    /* get the diff of node's data and children sum */
    diff = left_data + right_data - node-&gt;data;

    /* If node's children sum is greater than the node's data */
    if (diff &gt; 0)
       node-&gt;data = node-&gt;data + diff;

    /* THIS IS TRICKY --&gt; If node's data is greater than children sum,
      then increment subtree by diff */
    if (diff &lt; 0)
      increment(node, -diff);  // -diff is used to make diff positive
  }
}

/* This function is used to increment subtree by diff */
void increment(struct node* node, int diff)
{
  /* IF left child is not NULL then increment it */
  if(node-&gt;left != NULL)
  {
    node-&gt;left-&gt;data = node-&gt;left-&gt;data + diff;

    // Recursively call to fix the descendants of node-&gt;left
    increment(node-&gt;left, diff);  
  }
  else if (node-&gt;right != NULL) // Else increment right child
  {
    node-&gt;right-&gt;data = node-&gt;right-&gt;data + diff;

    // Recursively call to fix the descendants of node-&gt;right
    increment(node-&gt;right, diff);
  }
}

/* Given a binary tree, printInorder() prints out its
   inorder traversal*/
void printInorder(struct node* node)
{
  if (node == NULL)
    return;

  /* first recur on left child */
  printInorder(node-&gt;left);

  /* then print the data of node */
  printf(&quot;%d &quot;, node-&gt;data);

  /* now recur on right child */
  printInorder(node-&gt;right);
}

/* Helper function that allocates a new node
 with the given data and NULL left and right
 pointers. */
struct node* newNode(int data)
{
  struct node* node =
      (struct node*)malloc(sizeof(struct node));
  node-&gt;data = data;
  node-&gt;left = NULL;
  node-&gt;right = NULL;
  return(node);
}

/* Driver program to test above functions */
int main()
{
  struct node *root = newNode(50);
  root-&gt;left        = newNode(7);
  root-&gt;right       = newNode(2);
  root-&gt;left-&gt;left  = newNode(3);
  root-&gt;left-&gt;right = newNode(5);
  root-&gt;right-&gt;left  = newNode(1);
  root-&gt;right-&gt;right = newNode(30);

  printf(&quot;\n Inorder traversal before conversion &quot;);
  printInorder(root);

  convertTree(root);

  printf(&quot;\n Inorder traversal after conversion &quot;);
  printInorder(root);

  getchar();
  return 0;
}
</pre>
<p><strong>Time Complexity:</strong>  O(n^2), Worst case complexity is for a skewed tree such that nodes are in decreasing order from root to leaf.</p>
<p>Please write comments if you find any bug in the above algorithm or a better way to solve the same problem.</p>
		
&nbsp;
&nbsp;
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle"
     style="display:inline-block;width:336px;height:280px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="4061219431"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>



&nbsp;
&nbsp;
&nbsp;
<h3>Related Topics:</h3><ul><li><a href="http://www.geeksforgeeks.org/perfect-binary-tree-specific-level-order-traversal/" title="Perfect Binary Tree Specific Level Order Traversal">Perfect Binary Tree Specific Level Order Traversal</a></li><li><a href="http://www.geeksforgeeks.org/print-nodes-top-view-binary-tree/" title="Print Nodes in Top View of Binary Tree">Print Nodes in Top View of Binary Tree</a></li><li><a href="http://www.geeksforgeeks.org/k-dimensional-tree/" title="K Dimensional Tree">K Dimensional Tree</a></li><li><a href="http://www.geeksforgeeks.org/convert-binary-tree-threaded-binary-tree/" title="Convert a Binary Tree to Threaded binary tree">Convert a Binary Tree to Threaded binary tree</a></li><li><a href="http://www.geeksforgeeks.org/serialize-deserialize-n-ary-tree/" title="Serialize and Deserialize an N-ary Tree">Serialize and Deserialize an N-ary Tree</a></li><li><a href="http://www.geeksforgeeks.org/serialize-deserialize-binary-tree/" title="Serialize and Deserialize a Binary Tree">Serialize and Deserialize a Binary Tree</a></li><li><a href="http://www.geeksforgeeks.org/given-binary-tree-print-nodes-two-given-level-numbers/" title="Print nodes between two given level numbers of a binary tree">Print nodes between two given level numbers of a binary tree</a></li><li><a href="http://www.geeksforgeeks.org/find-height-binary-tree-represented-parent-array/" title="Find Height of Binary Tree represented by Parent array">Find Height of Binary Tree represented by Parent array</a></li></ul>
<p></p> 
<div>
<iframe src="http://www.facebook.com/plugins/like.php?href=http%3A%2F%2Fwww.geeksforgeeks.org%2Fconvert-an-arbitrary-binary-tree-to-a-tree-that-holds-children-sum-property%2F&layout=button_count&show_faces=false&width=90&action=like&colorscheme=light" scrolling="no" frameborder="0" allowTransparency="true" style="border:none; overflow:hidden; width:90px; height:20px"></iframe>
<a href="http://twitter.com/share" class="twitter-share-button" data-url="http://www.geeksforgeeks.org/convert-an-arbitrary-binary-tree-to-a-tree-that-holds-children-sum-property/" data-text="Convert an arbitrary Binary Tree to a tree that holds Children Sum Property" data-count="horizontal" data-via="jakerutter">Tweet</a><script type="text/javascript" src="http://platform.twitter.com/widgets.js"></script>
<g:plusone size="medium" href="http://www.geeksforgeeks.org/convert-an-arbitrary-binary-tree-to-a-tree-that-holds-children-sum-property/"></g:plusone>
<!-- Place this render call where appropriate -->
<script type="text/javascript">
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script></div>





				</div>		  
			</div> <!-- end post main -->					
			<div class="post-meta">
				<div class="left"></div>				
				<div class="clear"></div>
			</div>			
        
			<div class="comments-main">		
 <b>Writing code in comment?</b> Please use <b><a href="http://ideone.com/">ideone.com</a></b> and share the link here.
				
<div id="disqus_thread">
            <div id="dsq-content">


            <ul id="dsq-comments">
                    <li class="comment even thread-even depth-1" id="dsq-comment-33989">
        <div id="dsq-comment-header-33989" class="dsq-comment-header">
            <cite id="dsq-cite-33989">
                <span id="dsq-author-user-33989">danny</span>
            </cite>
        </div>
        <div id="dsq-comment-body-33989" class="dsq-comment-body">
            <div id="dsq-comment-message-33989" class="dsq-comment-message"><p>A O(n) solution is possible :-<br />
Algorithm..<br />
We take the Top-Bottom approach<br />
 Step-1:-    Check the parents value and Sum of child&#8217;s value<br />
               take, diff=(parent value-sum of child&#8217;s value).<br />
               If diff&gt;0,<br />
                    then, arbitrary choose either left and right child and add the diff                                         to the                     child value.<br />
               Else,<br />
                    arbitrary choose either left and right child and subtract the diff                                         to the                       child value.<br />
Step-2:-     Recursively Call for left and right child.</p>
<p>Please comment and correct me if I am making some mistake or if my concept is wrong&#8230;..</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-33329">
        <div id="dsq-comment-header-33329" class="dsq-comment-header">
            <cite id="dsq-cite-33329">
                <span id="dsq-author-user-33329">Ameet Chhatwal</span>
            </cite>
        </div>
        <div id="dsq-comment-body-33329" class="dsq-comment-body">
            <div id="dsq-comment-message-33329" class="dsq-comment-message"><p>A clean O(n) Solution:<br />
1. Keep adding the root value to its child value and keep traversing down the tree.  Note(IMP) if the value is negative make it positive * (-1)<br />
2. once a node&#8217;s right and left child are visited update the  node&#8217;s value to left child + right child (Trick is nodes value will always increase since you have already added value of root to child)</p>
<p>Any feedback is appreciated</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-29905">
        <div id="dsq-comment-header-29905" class="dsq-comment-header">
            <cite id="dsq-cite-29905">
                <span id="dsq-author-user-29905">Sumit Poddar</span>
            </cite>
        </div>
        <div id="dsq-comment-body-29905" class="dsq-comment-body">
            <div id="dsq-comment-message-29905" class="dsq-comment-message"><p>Kindly check my JAVA implementation for the same. I believe the solution will have O(n) time complexity. Requesting groups to review it and let me know in case of any issues..</p>
<p>&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;</p>
<p>public class TreeToCSPTree {</p>
<p>    /**<br />
     * @param args<br />
     */<br />
    public static void main(String[] args) {<br />
        Node n1 = new Node(5, new Node(2, null, null), new Node(5, null, null));<br />
        Node n2 = new Node(3, null, null);<br />
        Node n3 = new Node(7, n2, n1);<br />
        Node n4 = new Node(1, null, null);<br />
        Node n5 = new Node(50, n4, new Node(30, null, null));<br />
        Node n = new Node(50, n3, n5);<br />
        Node partn = convert(n, null, new ChangeAttr());<br />
        System.out.println(partn);</p>
<p>    }</p>
<p>    public static Node convert(Node root, Node parent, ChangeAttr chngeAttr) {<br />
        if ((root.left == null) &amp;&amp; (root.right == null)) {<br />
            return root;<br />
        }<br />
        Node left = new Node(0), right = new Node(0);<br />
        if (root.left != null) {<br />
            left = convert(root.left, root, chngeAttr);<br />
        }<br />
        if (root.right != null) {<br />
            right = convert(root.right, root, chngeAttr);<br />
        }<br />
        if ((chngeAttr.data &gt; -1) &amp;&amp; (chngeAttr.toChange)) {<br />
            if (root.left != null<br />
                    &amp;&amp; root.left.data &lt; root.left.data + chngeAttr.data) {<br />
                root.left.data = root.left.data + chngeAttr.data;<br />
                left = root.left;<br />
            } else if (root.right != null<br />
                    &amp;&amp; root.right.data  root.data) {<br />
            if (parent == null) {<br />
                root.data = left.data + right.data;<br />
            } else {<br />
                if (parent.left.data == root.data) {<br />
                    parent.left.data = left.data + right.data;<br />
                } else {<br />
                    parent.right.data = left.data + right.data;<br />
                }<br />
            }<br />
        } else if ((left.data + right.data) &lt; root.data) {<br />
            chngeAttr.data = root.data &#8211; (left.data + right.data);<br />
            chngeAttr.toChange = true;<br />
            convert(root, root, chngeAttr);<br />
        }<br />
        return root;<br />
    }<br />
}</p>
<p>class ChangeAttr {<br />
    int data = -1;<br />
    boolean toChange = false;</p>
<p>}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-27642">
        <div id="dsq-comment-header-27642" class="dsq-comment-header">
            <cite id="dsq-cite-27642">
                <span id="dsq-author-user-27642">vaibhav</span>
            </cite>
        </div>
        <div id="dsq-comment-body-27642" class="dsq-comment-body">
            <div id="dsq-comment-message-27642" class="dsq-comment-message"><p>my code if problem arises ill be thankful to critic <img src="http://d2o58evtke57tz.cloudfront.net/wp-includes/images/smilies/icon_smile.gif" alt=":)" class="wp-smiley" /><br />
#include</p>
<p>#include</p>
<p>#include</p>
<p>using namespace std;</p>
<p>void add(int);</p>
<p>typedef struct node { int value; </p>
<p>struct node *left; </p>
<p>struct node *right; }mynode;</p>
<p>int child(mynode*root)</p>
<p>{if(!root)</p>
<p> return 0;</p>
<p> int h1,h2;</p>
<p> h1=child(root-&gt;left);</p>
<p> h2=child(root-&gt;right);</p>
<p> if(root-&gt;value&gt;h1+h2&amp;&amp;h1&amp;&amp;h2)</p>
<p>   {root-&gt;right-&gt;value=root-&gt;value-root-&gt;left-&gt;value;</p>
<p>   child(root-&gt;right);</p>
<p>   return(root-&gt;value);</p>
<p>   }</p>
<p>    if(root-&gt;value&gt;h1+h2&amp;&amp;!h1&amp;&amp;h2)</p>
<p>   {root-&gt;right-&gt;value+=root-&gt;value-root-&gt;right-&gt;value;</p>
<p>   child(root-&gt;right);</p>
<p>   return(root-&gt;value);</p>
<p>   }</p>
<p>  if(root-&gt;value&gt;h1+h2&amp;&amp;h1&amp;&amp;!h2)</p>
<p>   {root-&gt;left-&gt;value=root-&gt;value;</p>
<p>   child(root-&gt;left);</p>
<p>   return(root-&gt;value);</p>
<p>   }  </p>
<p> if(root-&gt;valuevalue=h1+h2;</p>
<p>return(root-&gt;value);</p>
<p>}</p>
<p>return(root-&gt;value);</p>
<p>}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-27344">
        <div id="dsq-comment-header-27344" class="dsq-comment-header">
            <cite id="dsq-cite-27344">
                <span id="dsq-author-user-27344">Rohan</span>
            </cite>
        </div>
        <div id="dsq-comment-body-27344" class="dsq-comment-body">
            <div id="dsq-comment-message-27344" class="dsq-comment-message"><p>How about this aprroach : </p>
<p>int  makeChildSumTree(struct node* node)</p>
<p>{</p>
<p>	if(!node) return 0;</p>
<p>	int left = makeChildSumTree(node-&gt;left);</p>
<p>	int right = makeChildSumTree(node-&gt;right);</p>
<p>	if(node-&gt;data data =  left + right;</p>
<p>	else{</p>
<p>		if(node-&gt;left &amp;&amp; node-&gt;right){</p>
<p>			node-&gt;left-&gt;data = node-&gt;data &#8211; node-&gt;right-&gt;data;</p>
<p>			makeChildSumTree(node-&gt;left);</p>
<p>		}</p>
<p>		else if(node-&gt;left){</p>
<p>			node-&gt;left-&gt;data = node-&gt;data;</p>
<p>			makeChildSumTree(node-&gt;left);</p>
<p>		}</p>
<p>		else if(node-&gt;right){</p>
<p>			node-&gt;right-&gt;data = node-&gt;data;</p>
<p>			makeChildSumTree(node-&gt;left);</p>
<p>		}</p>
<p>	}</p>
<p>	return node-&gt;data;</p>
<p>}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-26076">
        <div id="dsq-comment-header-26076" class="dsq-comment-header">
            <cite id="dsq-cite-26076">
                <span id="dsq-author-user-26076">vinit</span>
            </cite>
        </div>
        <div id="dsq-comment-body-26076" class="dsq-comment-body">
            <div id="dsq-comment-message-26076" class="dsq-comment-message"><p>@GeekforGeeks i think there can be O(n) solution possible for this problem. please correct me if u find any mistake. </p>
<p>Algorithm:-<br />
step 1. bottom up part( if sum of childs weight &gt;parent weight then give this to parent)more or like post order traversal</p>
<p>Note:- step 1 will ensure that parents will have value more than or equal to sum of its child.</p>
<p>step2.top down part (if sum of childs weight &gt;parents weight distribute it to one of the child )</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
<p>void make_Sum_Tree_Bottomup(struct Bt_Node *root){<br />
    if(root!=NULL){<br />
        make_Sum_Tree_Bottomup(root-&gt;left);<br />
        make_Sum_Tree_Bottomup(root-&gt;right);<br />
        int l=0;<br />
        int r=0;<br />
        if(root-&gt;left!=NULL){<br />
            l=root-&gt;left-&gt;data;<br />
        }<br />
        if(root-&gt;right!=NULL){<br />
            r=root-&gt;right-&gt;data;<br />
        }<br />
        if(root-&gt;left==NULL &amp;&amp; root-&gt;right==NULL){<br />
            l=root-&gt;data;//base case<br />
        }<br />
        if(l+r&gt;root-&gt;data){<br />
            root-&gt;data=l+r;<br />
        }<br />
    }<br />
}<br />
void make_Sum_Tree_TopDown(struct Bt_Node *root){<br />
    if(root!=NULL){<br />
        int l=0;<br />
        int r=0;<br />
        if(root-&gt;left!=NULL){<br />
            l=root-&gt;left-&gt;data;<br />
        }<br />
        if(root-&gt;right!=NULL){<br />
            r=root-&gt;right-&gt;data;<br />
        }<br />
        if(root-&gt;left!=NULL){<br />
            if(l+rdata)<br />
                root-&gt;left-&gt;data=root-&gt;data-r;<br />
        }<br />
        else{<br />
            if(l+rdata)<br />
                root-&gt;right-&gt;data=root-&gt;data-l;</p>
<p>        }<br />
    }<br />
}</p>
<p>void make_Sum_Tree(struct Bt_Node *root){<br />
    make_Sum_Tree_Bottomup(root);<br />
    make_Sum_Tree_TopDown(root);<br />
}</p>
</div>
        </div>

    </li><!-- #comment-## -->
</li><!-- #comment-## -->
    <li class="comment byuser comment-author-denial even thread-even depth-1" id="dsq-comment-22373">
        <div id="dsq-comment-header-22373" class="dsq-comment-header">
            <cite id="dsq-cite-22373">
                <span id="dsq-author-user-22373">denial</span>
            </cite>
        </div>
        <div id="dsq-comment-body-22373" class="dsq-comment-body">
            <div id="dsq-comment-message-22373" class="dsq-comment-message"><p>@geeksforgeeks : </p>
<p>Please correct the algorithm above. In condition where &#8216;diff < 0&#8242; it is written &#8220;node’s data is smaller than the node&#8217;s children sum&#8221; , it should be &#8220;node&#8217;s children sum is smaller than the node&#8217;s data&#8221; . </p>
<p>Correct if I&#8217;m wrong.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-geeksforgeeks bypostauthor odd alt depth-2" id="dsq-comment-22375">
        <div id="dsq-comment-header-22375" class="dsq-comment-header">
            <cite id="dsq-cite-22375">
                <span id="dsq-author-user-22375">GeeksforGeeks</span>
            </cite>
        </div>
        <div id="dsq-comment-body-22375" class="dsq-comment-body">
            <div id="dsq-comment-message-22375" class="dsq-comment-message"><p>Please take a closer look, it is greater, not smaller.</p>
<p>&#8220;If node&#8217;s data is *greater* than children sum,then increment subtree by diff&#8221;</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-denial even depth-3" id="dsq-comment-22382">
        <div id="dsq-comment-header-22382" class="dsq-comment-header">
            <cite id="dsq-cite-22382">
                <span id="dsq-author-user-22382">denial</span>
            </cite>
        </div>
        <div id="dsq-comment-body-22382" class="dsq-comment-body">
            <div id="dsq-comment-message-22382" class="dsq-comment-message"><p>@geeksforgeeks :<br />
I&#8217;m talking about algorithm not code.</p>
<p>&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-<br />
diff = node’s children sum &#8211; node’s data</p>
<p>If diff is 0 then nothing needs to be done.</p>
<p>If diff > 0 ( node’s data is smaller than node’s children sum) increment the node’s data by diff.</p>
<p>If diff < 0 (node’s data is smaller than the node&#8217;s children sum) then increment one child’s data<br />
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-geeksforgeeks bypostauthor odd alt depth-4" id="dsq-comment-22384">
        <div id="dsq-comment-header-22384" class="dsq-comment-header">
            <cite id="dsq-cite-22384">
                <span id="dsq-author-user-22384">GeeksforGeeks</span>
            </cite>
        </div>
        <div id="dsq-comment-body-22384" class="dsq-comment-body">
            <div id="dsq-comment-message-22384" class="dsq-comment-message"><p>@denial: Thanks for pointing this out.  We have corrected the line. Appreciate your contribution.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment byuser comment-author-4m7u1 even thread-odd thread-alt depth-1" id="dsq-comment-18287">
        <div id="dsq-comment-header-18287" class="dsq-comment-header">
            <cite id="dsq-cite-18287">
                <span id="dsq-author-user-18287">4m7u1</span>
            </cite>
        </div>
        <div id="dsq-comment-body-18287" class="dsq-comment-body">
            <div id="dsq-comment-message-18287" class="dsq-comment-message"><p>smart <img src="http://d2o58evtke57tz.cloudfront.net/wp-includes/images/smilies/icon_biggrin.gif" alt=":D" class="wp-smiley" /> !</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-abhishek08aug odd alt thread-even depth-1" id="dsq-comment-18070">
        <div id="dsq-comment-header-18070" class="dsq-comment-header">
            <cite id="dsq-cite-18070">
                <span id="dsq-author-user-18070">abhishek08aug</span>
            </cite>
        </div>
        <div id="dsq-comment-body-18070" class="dsq-comment-body">
            <div id="dsq-comment-message-18070" class="dsq-comment-message"><p>C++ code:</p>
<pre> <code language="C">
#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;
using namespace std;
 
class tree_node {
  private:
    int data;
    tree_node * left;
    tree_node * right;
  public:
    tree_node() {
      left=NULL;
      right=NULL;
    }
    void set_data(int data) {
      this-&gt;data=data;
    }
    int get_data() {
      return this-&gt;data;
    }
    void set_left(tree_node * left) {
      this-&gt;left=left;
    }
    tree_node * get_left() {
      return this-&gt;left;
    }
    void set_right(tree_node * right) {
      this-&gt;right=right;
    }
    tree_node * get_right() {
      return this-&gt;right;
    }
    tree_node ** get_left_ref() {
      return &amp;(this-&gt;left);
    }
    tree_node ** get_right_ref() {
      return &amp;(this-&gt;right);
    }
};
 
class tree {
  private:
    tree_node * root;
    int size;
    void _recursive_insert(tree_node ** root_ref, int value);
    void _print_preorder(tree_node * root);
    void _print_inorder(tree_node * root);
    void _print_postorder(tree_node * root);
    int _find_size(tree_node * root);
    int _are_identical(tree_node * tn1, tree_node * tn2);
    int _find_height(tree_node * root);
    void _delete_tree(tree_node ** root);
    void _mirror(tree_node * root);
    void _print_paths(tree_node * root, int * path_nodes, int next_vacant_position);
    void _print_array(int * array, int len);
    tree_node * _lowest_common_ancestor(tree_node * parent, tree_node * root, int a, int b);
    tree_node * _find_node(tree_node * root, int value);
    tree_node * _min_node(tree_node * root);
    void _print_level_order(tree_node * root);
    int _count_leaf_nodes(tree_node * root);
    int _is_bst(tree_node * root);
    int _children_sum(tree_node * root);
    void _ensure_children_sum(tree_node * root);
  public:
    tree() {
      root=NULL;
      size=0;
    }
    void insert(int value);
    void recursive_insert(int value);
    void print_preorder();
    void print_inorder();
    void print_postorder();
    int find_size();
    int get_size() {
      return this-&gt;size;
    }
    int are_identical(tree t);
    int find_height();
    void delete_tree();
    void mirror();
    void print_paths();
    tree_node * lowest_common_ancestor(int a, int b);
    tree_node * find_node(int value);
    tree_node * min_node();
    void print_level_order();
    int count_leaf_nodes();
    int is_bst();
    int children_sum();
    void ensure_children_sum();
};
 
void tree::insert(int value) {
  if(root==NULL) {
    root=new tree_node;
    root-&gt;set_data(value);
  } else {
    tree_node * parent=NULL;
    tree_node * current=root;
    tree_node * new_node=new tree_node;
    new_node-&gt;set_data(value);
    while(current!=NULL) {
      if(value&lt;=current-&gt;get_data()) {
        parent=current;
        current=current-&gt;get_left();
      } else {
        parent=current;
        current=current-&gt;get_right();
      }
    }
    if(value&lt;=parent-&gt;get_data() &amp;&amp; parent-&gt;get_left()==NULL) {
      parent-&gt;set_left(new_node);
    } else if(value&gt;parent-&gt;get_data() &amp;&amp; parent-&gt;get_right()==NULL) {
      parent-&gt;set_right(new_node);
    }
  }
  size++;
}
 
void tree::recursive_insert(int value) {
  _recursive_insert(&amp;root, value);
  size++;
}
 
void tree::_recursive_insert(tree_node ** root_ref, int value) {
  if(*root_ref==NULL) {
    tree_node * new_node=new tree_node;
    new_node-&gt;set_data(value);
    *root_ref=new_node;   
  } else {
    if(value&lt;=(*root_ref)-&gt;get_data()) {
      _recursive_insert((*root_ref)-&gt;get_left_ref(), value);
    } else {
      _recursive_insert((*root_ref)-&gt;get_right_ref(), value);
    }
  }
}
 
void tree::print_preorder() {
  if(root==NULL) {
    return;
  }
  _print_preorder(root);
  cout&lt;&lt;endl;
}
 
void tree::_print_preorder(tree_node * root) {
  if(root==NULL) {
    return;
  }
  cout&lt;&lt;root-&gt;get_data()&lt;&lt;&quot; &quot;;
  if(root-&gt;get_left()!=NULL)
    _print_preorder(root-&gt;get_left());
  if(root-&gt;get_right()!=NULL)
    _print_preorder(root-&gt;get_right());
}
 
void tree::print_inorder() {
  if(root==NULL) {
    return;
  }
  _print_inorder(root);
  cout&lt;&lt;endl;
}
 
void tree::_print_inorder(tree_node * root) {
  if(root==NULL) {
    return;
  }
  if(root-&gt;get_left()!=NULL)
    _print_inorder(root-&gt;get_left());
  cout&lt;&lt;root-&gt;get_data()&lt;&lt;&quot; &quot;;
  if(root-&gt;get_right()!=NULL)
    _print_inorder(root-&gt;get_right());
}
 
void tree::print_postorder() {
  if(root==NULL) {
    return;
  }
  _print_postorder(root);
  cout&lt;&lt;endl;
}
 
void tree::_print_postorder(tree_node * root) {
  if(root==NULL) {
    return;
  }
  if(root-&gt;get_left()!=NULL)
    _print_postorder(root-&gt;get_left());
  if(root-&gt;get_right()!=NULL)
    _print_postorder(root-&gt;get_right());
  cout&lt;&lt;root-&gt;get_data()&lt;&lt;&quot; &quot;;
}

int tree::find_size() {
  return _find_size(root);
}

int tree::_find_size(tree_node * root) {
  if(root==NULL) {
    return 0;
  } else {
    return 1+_find_size(root-&gt;get_left())+_find_size(root-&gt;get_right());
  }
}

int tree::are_identical(tree t) {
  return _are_identical(this-&gt;root, t.root);
}

int tree::_are_identical(tree_node * tn1, tree_node * tn2) {
  if(tn1==NULL &amp;&amp; tn2==NULL) {
    return 1;
  } else if((tn1==NULL &amp;&amp; tn2!=NULL) || (tn1!=NULL &amp;&amp; tn2==NULL) || (tn1-&gt;get_data()!=tn2-&gt;get_data())) {
    return 0;
  } else {
    return _are_identical(tn1-&gt;get_left(), tn2-&gt;get_left()) &amp;&amp; _are_identical(tn1-&gt;get_right(), tn2-&gt;get_right());
  }
}

int tree::find_height() {
  return _find_height(root);
}

int tree::_find_height(tree_node * root) {
  if(root==NULL) {
    return 0;
  }
  else {
    return 1+max(_find_height(root-&gt;get_left()), _find_height(root-&gt;get_right()));
  }
}

void tree::delete_tree() {
  _delete_tree(&amp;root);
  size=0;
}

void tree::_delete_tree(tree_node ** root) {
  if(*root==NULL) {
    return;
  } else {
    if((*root)-&gt;get_left()!=NULL) {
      _delete_tree((*root)-&gt;get_left_ref());
    }
    if((*root)-&gt;get_right()!=NULL) {
      _delete_tree((*root)-&gt;get_right_ref());
    }
    delete(*root);
    *root=NULL;
  }
}

/* alternate _delete_tree */
/*
void tree::_delete_tree(tree_node ** root) {
  if(*root==NULL) {
    return;
  } else {
    if((*root)-&gt;get_left()!=NULL) {
      tree_node * left_ref=(*root)-&gt;get_left();
      _delete_tree(&amp;left_ref);
    }
    if((*root)-&gt;get_right()!=NULL) {
      tree_node * right_ref=(*root)-&gt;get_right();
      _delete_tree(&amp;right_ref);
    }
    delete(*root);
    *root=NULL;
  }
}
*/

void tree::mirror() {
  _mirror(root);
}

void tree::_mirror(tree_node * root) {
  if(root==NULL) {
    return;
  }

  tree_node * temp=root-&gt;get_left();
  root-&gt;set_left(root-&gt;get_right());
  root-&gt;set_right(temp);
  _mirror(root-&gt;get_left());
  _mirror(root-&gt;get_right());
}

void tree::print_paths(){
   int max_path_length=find_height();
   int * path_nodes=(int *)calloc(sizeof(int), max_path_length);
  _print_paths(root, path_nodes, 0);
}

void tree::_print_paths(tree_node * root, int * path_nodes, int next_vacant_position){
  if(root==NULL) {
    return;
  } else if(root-&gt;get_left()==NULL &amp;&amp; root-&gt;get_right()==NULL) {
    *(path_nodes+next_vacant_position)=root-&gt;get_data();
    _print_array(path_nodes, next_vacant_position);
  } else {
    *(path_nodes+next_vacant_position)=root-&gt;get_data();
    _print_paths(root-&gt;get_left(), path_nodes, next_vacant_position+1);
    _print_paths(root-&gt;get_right(), path_nodes, next_vacant_position+1);
  }
}

void tree::_print_array(int * array, int len) {
  int i;
  for(i=0; i&lt;=len; i++) {
    cout&lt;&lt;*(array+i)&lt;&lt;&quot; &quot;;
  }
  cout&lt;&lt;endl;
}

tree_node * tree::find_node(int value) {
  return _find_node(root, value);
}

tree_node * tree::_find_node(tree_node * root, int value) {
  if(root==NULL || root-&gt;get_data()==value) {
    return root;
  } else if(value&lt;=root-&gt;get_data()) {
    return _find_node(root-&gt;get_left(), value);
  } else {
    return _find_node(root-&gt;get_right(), value);
  }
}

tree_node * tree::lowest_common_ancestor(int a, int b) {
  return _lowest_common_ancestor(NULL, root, a, b);
}

tree_node * tree::_lowest_common_ancestor(tree_node * parent, tree_node * root, int a, int b) {
  if(root==NULL) {
    return root;
  } else if((root-&gt;get_data()==a &amp;&amp; (root-&gt;get_left()-&gt;get_data()==b || root-&gt;get_right()-&gt;get_data()==b))
             || (root-&gt;get_data()==b &amp;&amp; (root-&gt;get_left()-&gt;get_data()==a || root-&gt;get_right()-&gt;get_data()==a))) {
    return parent;
  } else if((_find_node(root-&gt;get_left(), a)!=NULL &amp;&amp; _find_node(root-&gt;get_right(), b)!=NULL)
        || (_find_node(root-&gt;get_left(), b)!=NULL &amp;&amp; _find_node(root-&gt;get_right(), a)!=NULL)) {
    return root; 
  } else if(_find_node(root-&gt;get_left(), a)!=NULL &amp;&amp; _find_node(root-&gt;get_left(), b)!=NULL) {
    return _lowest_common_ancestor(root, root-&gt;get_left(), a, b);
  } else if(_find_node(root-&gt;get_right(), a)!=NULL &amp;&amp; _find_node(root-&gt;get_right(), b)!=NULL) {
    return _lowest_common_ancestor(root, root-&gt;get_right(), a, b);
  } else {
    return NULL;
  }
}

tree_node * tree::min_node() {
  return _min_node(root);
}

tree_node * tree::_min_node(tree_node * root) {
  if(root==NULL || root-&gt;get_left()==NULL) {
    return root;
  } else {
    return _min_node(root-&gt;get_left());
  }
}

int tree::count_leaf_nodes() {
  return _count_leaf_nodes(root);
}

int tree::_count_leaf_nodes(tree_node * root) {
  if(root==NULL) {
    return 0;
  } else if(root-&gt;get_left()==NULL &amp;&amp; root-&gt;get_right()==NULL) {
    return 1;
  } else {
    return _count_leaf_nodes(root-&gt;get_left())+_count_leaf_nodes(root-&gt;get_right());
  }
}


int tree::is_bst() {
  return _is_bst(root);
}

int tree::_is_bst(tree_node * root) {
  static tree_node * previous=NULL;
  if(root==NULL) {
    return 1;
  } else {
    if(!_is_bst(root-&gt;get_left())) {
      return 0;
    }
    if(previous!=NULL &amp;&amp; (previous-&gt;get_data())&gt;(root-&gt;get_data())) {
      return 0;
    }
    previous=root;
    if(!_is_bst(root-&gt;get_right())) {
      return 0;
    }    
  }
}

int tree::children_sum() {
  return _children_sum(root);
}

int tree::_children_sum(tree_node * root) {
  if(root==NULL) {
    return 1;
  }
  if(root-&gt;get_left()==NULL &amp;&amp; root-&gt;get_right()==NULL) {
    return 1;
  }
  else if(_children_sum(root-&gt;get_left()) &amp;&amp; _children_sum(root-&gt;get_right())){
    int left_data;
    int right_data;
    if(root-&gt;get_left()!=NULL) {
      left_data=root-&gt;get_left()-&gt;get_data();
    } else {
      left_data=0;
    }
    if(root-&gt;get_right()!=NULL) {
      right_data=root-&gt;get_right()-&gt;get_data();
    } else {
      right_data=0;
    }

    if(left_data+right_data==root-&gt;get_data()) {
      return 1;
    } else {
      return 0;
    }
  } else {
    return 0;
  }
}

void tree::ensure_children_sum() {
  _ensure_children_sum(root);
}

void tree::_ensure_children_sum(tree_node * root) {
  if(root==NULL || (root-&gt;get_left()==NULL &amp;&amp; root-&gt;get_right()==NULL)) {
    return;
  } else {
    _ensure_children_sum(root-&gt;get_left());
    _ensure_children_sum(root-&gt;get_right());
    int left_data;
    int right_data;
    if(root-&gt;get_left()!=NULL) {
      left_data=root-&gt;get_left()-&gt;get_data();
    } else {
      left_data=0;
    }
    if(root-&gt;get_right()!=NULL) {
      right_data=root-&gt;get_right()-&gt;get_data();
    } else {
      right_data=0;
    }
    root-&gt;set_data(left_data+right_data);
  }
}
int main() {
  tree t1;

  t1.recursive_insert(5);
  t1.recursive_insert(3);
  t1.insert(10);
  t1.insert(7);
  t1.recursive_insert(50);
  t1.recursive_insert(6);
  t1.recursive_insert(1);
  t1.recursive_insert(45);
  t1.recursive_insert(55);
  t1.recursive_insert(4);

  t1.print_inorder();

  if(t1.children_sum()) {
    cout&lt;&lt;&quot;Tree satisfies children sum property&quot;&lt;&lt;endl;
  } else {
    cout&lt;&lt;&quot;Tree does not satisfy children sum property&quot;&lt;&lt;endl;
  }

  t1.ensure_children_sum();
  t1.print_inorder();

  if(t1.children_sum()) {
    cout&lt;&lt;&quot;Tree satisfies children sum property&quot;&lt;&lt;endl;
  } else {
    cout&lt;&lt;&quot;Tree does not satisfy children sum property&quot;&lt;&lt;endl;
  }

  return 0;
}
</code> </pre>
<p>1 3 4 5 6 7 10 45 50 55<br />
Tree does not satisfy children sum property<br />
1 5 4 111 6 6 106 45 100 55<br />
Tree satisfies children sum property</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-17682">
        <div id="dsq-comment-header-17682" class="dsq-comment-header">
            <cite id="dsq-cite-17682">
                <span id="dsq-author-user-17682">Durga Guntoju</span>
            </cite>
        </div>
        <div id="dsq-comment-body-17682" class="dsq-comment-body">
            <div id="dsq-comment-message-17682" class="dsq-comment-message"><p>int makeItChildSumTree(struct node *root)<br />
{<br />
    if(root)<br />
    {<br />
        int l_value=makeItChildSumTree(root-&gt;left);<br />
        int r_value=makeItChildSumTree(root-&gt;right);<br />
        if((root-&gt;left)||(root-&gt;right))<br />
        if(root-&gt;data!=l_value+r_value)<br />
            root-&gt;data=l_value+r_value;<br />
        return root-&gt;data;<br />
    }<br />
    else return 0;<br />
}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-16875">
        <div id="dsq-comment-header-16875" class="dsq-comment-header">
            <cite id="dsq-cite-16875">
                <span id="dsq-author-user-16875">Hanish</span>
            </cite>
        </div>
        <div id="dsq-comment-body-16875" class="dsq-comment-body">
            <div id="dsq-comment-message-16875" class="dsq-comment-message"><p>We can optimise the code to work in O(n) time as:<br />
Logic:<br />
If a node&#8217;s data is smaller than the sum of its children, it wont ever become greater than them.<br />
If a node&#8217;s data is greater than sum of its children, we will increment the left(or right) child&#8217;s data Before calling convert_tree(node-&gt;left). Now when we will return to this node in postfix order, its children would have remained constant or increased i.e. either the node&#8217;s data is equal to or less than the sum of its childrern. So we need not call the increment function.</p>
<p>Thus, the code works in O(n) time.</p>
<p>Here is the optimised function :</p>
<p>void convertTree(struct node* node)<br />
{<br />
  int left_data = 0,  right_data = 0, diff;<br />
  if(node == NULL ||<br />
     (node-&gt;left == NULL &amp;&amp; node-&gt;right == NULL))<br />
    return;<br />
  else<br />
  {<br />
    if(node-&gt;left != NULL)<br />
      left_data = node-&gt;left-&gt;data;</p>
<p>    if(node-&gt;right != NULL)<br />
      right_data = node-&gt;right-&gt;data;</p>
<p>    diff = left_data + right_data &#8211; node-&gt;data;</p>
<p>    if(diff left);<br />
    convertTree(node-&gt;right);</p>
<p>    if(node-&gt;left != NULL)<br />
      left_data = node-&gt;left-&gt;data;</p>
<p>    if(node-&gt;right != NULL)<br />
      right_data = node-&gt;right-&gt;data;</p>
<p>    diff = left_data + right_data &#8211; node-&gt;data;</p>
<p>    if(diff &gt; 0)<br />
       node-&gt;data = node-&gt;data + diff;<br />
  }<br />
}</p>
<p>void increment(struct node* node, int diff)<br />
{<br />
  if(node-&gt;left != NULL)<br />
    node-&gt;left-&gt;data = node-&gt;left-&gt;data + diff;<br />
  else if (node-&gt;right != NULL)<br />
    node-&gt;right-&gt;data = node-&gt;right-&gt;data + diff;<br />
}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-16686">
        <div id="dsq-comment-header-16686" class="dsq-comment-header">
            <cite id="dsq-cite-16686">
                <span id="dsq-author-user-16686">Aditya</span>
            </cite>
        </div>
        <div id="dsq-comment-body-16686" class="dsq-comment-body">
            <div id="dsq-comment-message-16686" class="dsq-comment-message"><p>Can it be done something like this in one function itself ?</p>
<p>The adjustment in the case of diff &lt; 0 will be done in the deepest node first<br />
and will be adjusted accordingly in the parent.</p>
<p>int convertTree(Node *n, int delta = 0) {<br />
    if (n == NULL) {<br />
        return 0;<br />
    }<br />
    if (n-&gt;left == NULL &amp;&amp; n-&gt;right == NULL) {<br />
        n-&gt;data += delta; // Fix in the deepest node.<br />
        return n-&gt;data;<br />
    }<br />
    int sum = convertTree(n-&gt;left, delta);<br />
    sum += convertTree(n-&gt;right, delta);<br />
    int diff = sum &#8211; n-&gt;data;<br />
    if (diff == 0) { return n-&gt;data; }<br />
    else if (diff &gt; 0) {<br />
        n-&gt;data += diff;<br />
        return n-&gt;data;<br />
    } else { //diff&lt;0<br />
        diff = -1 * diff;<br />
        if (n-&gt;left) { convertTree(n-&gt;left, diff); }<br />
        else if (n-&gt;right) { convertTree(n-&gt;right,diff); }<br />
    }<br />
    return n-&gt;data;<br />
}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-15467">
        <div id="dsq-comment-header-15467" class="dsq-comment-header">
            <cite id="dsq-cite-15467">
                <span id="dsq-author-user-15467">Nikin</span>
            </cite>
        </div>
        <div id="dsq-comment-body-15467" class="dsq-comment-body">
            <div id="dsq-comment-message-15467" class="dsq-comment-message"><pre> <code language="C">

void convertTree(node *sr)
{
if(sr == NULL)
return;
int lData = rData = 0;
else
{
convertTree(sr-&gt;left);
convertTree(sr-&gt;right);

if(sr-&gt;left)
lData = sr-&gt;left-&gt;data;
if(sr-&gt;right)
rData = sr-&gt;right-&gt;data;

int diff = lData + rData - sr-&gt;data;

if(diff&gt;0)
sr-&gt;data += diff;
if(diff&lt;0)
increment(sr, -diff);

}

}

</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-14091">
        <div id="dsq-comment-header-14091" class="dsq-comment-header">
            <cite id="dsq-cite-14091">
                <span id="dsq-author-user-14091">TC</span>
            </cite>
        </div>
        <div id="dsq-comment-body-14091" class="dsq-comment-body">
            <div id="dsq-comment-message-14091" class="dsq-comment-message"><p>@GeekforGeeks,</p>
<p>I think proposed solution may fail, if root value is less than sum of its children.</p>
<p>Why can&#8217;t we visit left and right child of a root, after we did some processing rather than visiting children nodes before.</p>
<p>That is I am suggesting for Top-down approach rather than bottom &#8211; up as proposed in given solution.</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-11999">
        <div id="dsq-comment-header-11999" class="dsq-comment-header">
            <cite id="dsq-cite-11999">
                <span id="dsq-author-user-11999">vaibhavbright</span>
            </cite>
        </div>
        <div id="dsq-comment-body-11999" class="dsq-comment-body">
            <div id="dsq-comment-message-11999" class="dsq-comment-message"><p>better answer &#8211; takes O(n) time for all cases <img src="http://d2o58evtke57tz.cloudfront.net/wp-includes/images/smilies/icon_smile.gif" alt=":)" class="wp-smiley" /></p>
<p>Algorithm &#8212; do a DFS traversal (mixture of pre and post) and is children_sum &gt; node_value, update it. If the situation is reverse add this to current_index of array to_adjust.<br />
Now we are maintaining an array to_adjust to store the amount by which node_value is greater than children_sum. I am also using a static variable called index. So, the nodes(only the internal nodes) are given an index in a preorder fashion, i.e., when we reach that node we increment the index value to be given to the next node. And the to_adjust[index] is set after we have traversed left and right subtree ofcourse when we have their values.</p>
<p>The second function/stage is another DFS when I am updating the children values accordingly. This is purely a pre-order type traversal.</p>
<p>Both traversals take O(n) time. So, time complexity = O(n)</p>
<p>Code is given below.</p>
<pre> <code language="C">
int increment_node_data(node *current_node, int *to_adjust) {
    static int index = 0;
    if((current_node-&gt;left == NULL) &amp;&amp; (current_node-&gt;right == NULL)) {
        return current_node-&gt;data;
    }
    int sum = 0;
    int current_index = index;
    index++;
    if(current_node-&gt;left != NULL)
        sum += increment_node_data(current_node-&gt;left, to_adjust);
    if(current_node-&gt;right != NULL)
        sum += increment_node_data(current_node-&gt;right, to_adjust);
    if(current_node-&gt;data &lt; sum)
        current_node-&gt;data = sum;
    else
        to_adjust[current_index] = current_node-&gt;data - sum;
    return current_node-&gt;data;
}

void increment_child_data(node *current_node, int *to_adjust, int to_increment) {
    static int index = 0;
    current_node-&gt;data += to_increment;
    if((current_node-&gt;left != NULL) || (current_node-&gt;right != NULL)) {
        to_increment += to_adjust[index];
        index++;
        if(current_node-&gt;left != NULL) {
            increment_child_data(current_node-&gt;left, to_adjust, to_increment);
            to_increment = 0;
        }
        if(current_node-&gt;right != NULL)
            increment_child_data(current_node-&gt;right, to_adjust, to_increment);
    }
}

void tree::convert_to_children_sum_tree() {
    int *to_adjust = new int[100];
    increment_node_data(root, to_adjust);
    increment_child_data(root, to_adjust, 0);
}
</code> </pre>
<p>call it simply by &#8220;t1.convert_to_children_sum_tree()&#8221; in main.</p>
<p>Regards.</p>
<p>Regards.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-11917">
        <div id="dsq-comment-header-11917" class="dsq-comment-header">
            <cite id="dsq-cite-11917">
                <span id="dsq-author-user-11917">a2</span>
            </cite>
        </div>
        <div id="dsq-comment-body-11917" class="dsq-comment-body">
            <div id="dsq-comment-message-11917" class="dsq-comment-message"><p>Is there any problem with the following recursive code ?</p>
<pre> <code language="C">
#include&lt;stdlib.h&gt;

typedef struct node{
	int data;
	struct node* left;
	struct node* right;
} node;

node* newNode(int data)
{
	node* temp = (node*)malloc(sizeof(node));
	temp-&gt;data=data;
	temp-&gt;left=temp-&gt;right=NULL;
	return temp;
}

node* createTree()
{
	node* root=newNode(50);
	root-&gt;left=newNode(7);
	root-&gt;left-&gt;left=newNode(3);
	root-&gt;left-&gt;right=newNode(5);
	root-&gt;right=newNode(2);
	root-&gt;right-&gt;left=newNode(1);
	root-&gt;right-&gt;right=newNode(30);
	return root;
}

void print(node* node)
{
   if(!node) return;
   print(node-&gt;left);
   printf(&quot; %d &quot;,node-&gt;data);
   print(node-&gt;right,1);
}

int Convert(node *root)
{
	if(!root) return 0;
	if(!root-&gt;left &amp;&amp; !root-&gt;right) return root-&gt;data;
	Convert(root-&gt;left);
	Convert(root-&gt;right);
	if(root-&gt;left &amp;&amp; root-&gt;right)
	{
		int l = root-&gt;left-&gt;data;
		int r = root-&gt;right-&gt;data;
		if(root-&gt;data &lt; ( l + r ))
		{
			root-&gt;data += ( (l + r ) - root-&gt;data );
		}
		else
		{
			root-&gt;left-&gt;data += root-&gt;data - ( l + r ) ;
			Convert(root-&gt;left);
		}
	}
	if(!root-&gt;left &amp;&amp; root-&gt;right)
	{
		int r = root-&gt;right-&gt;data;
		if(root-&gt;data &lt; r ) root-&gt;data += r - root-&gt;data;
		else{
			root-&gt;right-&gt;data += root-&gt;data - r;
			Convert(root-&gt;right);
		}
	}
	if(root-&gt;left &amp;&amp; !root-&gt;right)
	{
		int l = root-&gt;left-&gt;data;
		if(root-&gt;data &lt; l) root-&gt;data += l - root-&gt;data;
		else{
			root-&gt;left-&gt;data += root-&gt;data - l;
			Convert(root-&gt;left);
		}
	}
    return root-&gt;data;
}

int main()
{
	node* root=createTree();
	print(root,1);
	Convert(root);
	printf(&quot;\nafter convert ....\n\n&quot;);
	print(root,1);
	return 0;
}


</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-11918">
        <div id="dsq-comment-header-11918" class="dsq-comment-header">
            <cite id="dsq-cite-11918">
                <span id="dsq-author-user-11918">a2</span>
            </cite>
        </div>
        <div id="dsq-comment-body-11918" class="dsq-comment-body">
            <div id="dsq-comment-message-11918" class="dsq-comment-message"><p>Sorry , there has been some type errors in the the print function and to its call !</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-8865">
        <div id="dsq-comment-header-8865" class="dsq-comment-header">
            <cite id="dsq-cite-8865">
                <span id="dsq-author-user-8865">Nitin</span>
            </cite>
        </div>
        <div id="dsq-comment-body-8865" class="dsq-comment-body">
            <div id="dsq-comment-message-8865" class="dsq-comment-message"><p>Please tell me if I am wrong but the question doesn&#8217;t say that we need to make the sum minimum also.If that is the case then we can simply calculate the maximum value once ( O(n) ), then we can make the value of all leaves equal to maximum value and propagate the sum of left, right child upwards (recursively).</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-geeksforgeeks bypostauthor odd alt thread-odd thread-alt depth-1" id="dsq-comment-7910">
        <div id="dsq-comment-header-7910" class="dsq-comment-header">
            <cite id="dsq-cite-7910">
                <span id="dsq-author-user-7910">GeeksforGeeks</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7910" class="dsq-comment-body">
            <div id="dsq-comment-message-7910" class="dsq-comment-message"><p>@All: We have fixed the increment function. If left subtree is not NULL, then it increments the left subtree. If left subtree is NULL, then it increments the right subtree. It recursively calls itself to fix the complete tree down. So the code now works for following type of trees.</p>
<pre>
   13
   /\
  4  6
   \
    4
</pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-7893">
        <div id="dsq-comment-header-7893" class="dsq-comment-header">
            <cite id="dsq-cite-7893">
                <span id="dsq-author-user-7893">Abhishek</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7893" class="dsq-comment-body">
            <div id="dsq-comment-message-7893" class="dsq-comment-message"><p>We can do the following recursively (Please tell me if i am wrong) </p>
<p>void convert(tree_node *node)<br />
&gt; convert(node-&gt;left)<br />
&gt; convert(node-&gt;right)<br />
&gt; node-&gt;data = sum(left, right)<br />
&gt;return;</p>
<p>Code given below (We can write the code for sum() where we can check if one node is NULL, we just return the other&#8217;s data, else we return the sum of the data of both)</p>
<pre> <code language="C">
void convert(tree_node *node) {
  if(node == NULL) {
    return;
  }
/* Take care if its a leaf node...just return */
  if((node-&gt;left == NULL) &amp;&amp; (node-&gt;right == NULL)) {
    return;
  }

  /* Traverse postorder */

  convert(node-&gt;left);
  convert(node-&gt;right);

  node-&gt;data = sum(node-&gt;left, node-&gt;right);
  return;
}
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-7894">
        <div id="dsq-comment-header-7894" class="dsq-comment-header">
            <cite id="dsq-cite-7894">
                <span id="dsq-author-user-7894">Abhishek</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7894" class="dsq-comment-body">
            <div id="dsq-comment-message-7894" class="dsq-comment-message"><p>Aaaaah!! got it! sorry for the wrong post.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-7529">
        <div id="dsq-comment-header-7529" class="dsq-comment-header">
            <cite id="dsq-cite-7529">
                <span id="dsq-author-user-7529">Vijay</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7529" class="dsq-comment-body">
            <div id="dsq-comment-message-7529" class="dsq-comment-message"><p>I think the following need be added to increment function at the end of while loop to take care of cases like<br />
diff=3  </p>
<pre>
   13
   /\
  4  6
   \ 
    4
Without this line, result after applying increment function would be:
   13
   /\
  7  6
   \
    4
</pre>
<pre> <code language="C">
if(node-&gt;right != NULL)
{
    node-&gt;left = newNode(diff);
    return;
}
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-amitp49 odd alt thread-even depth-1" id="dsq-comment-7440">
        <div id="dsq-comment-header-7440" class="dsq-comment-header">
            <cite id="dsq-cite-7440">
                <span id="dsq-author-user-7440">amitp49</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7440" class="dsq-comment-body">
            <div id="dsq-comment-message-7440" class="dsq-comment-message"><p>Does it necessary to have unique tree after this conversion?<br />
i mean if somebody increment right child and resultant tree satisfy the Children sum property then will it be consider as right answer?</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-6983">
        <div id="dsq-comment-header-6983" class="dsq-comment-header">
            <cite id="dsq-cite-6983">
                <span id="dsq-author-user-6983">ada</span>
            </cite>
        </div>
        <div id="dsq-comment-body-6983" class="dsq-comment-body">
            <div id="dsq-comment-message-6983" class="dsq-comment-message"><pre> <code language="C">
Cant you just do a Preorder, check if parent satisfy child sum pro if not increment left child and keep on repeating activity for subchilds...this way you will always increase values and also retain the prop and it will take a single pass only... please let me know if there is any flow i this...
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-6428">
        <div id="dsq-comment-header-6428" class="dsq-comment-header">
            <cite id="dsq-cite-6428">
                <span id="dsq-author-user-6428">Vikram</span>
            </cite>
        </div>
        <div id="dsq-comment-body-6428" class="dsq-comment-body">
            <div id="dsq-comment-message-6428" class="dsq-comment-message"><pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
I think it has a very simple and elegant solution:


Convert(node *head){
  if(head is not leaf){
    head-&gt;data = Convert(head-&gt;left) + Convert(head-&gt;right);
  }
  return head-&gt;data;
}


</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-2" id="dsq-comment-15119">
        <div id="dsq-comment-header-15119" class="dsq-comment-header">
            <cite id="dsq-cite-15119">
                <span id="dsq-author-user-15119">Rahim</span>
            </cite>
        </div>
        <div id="dsq-comment-body-15119" class="dsq-comment-body">
            <div id="dsq-comment-message-15119" class="dsq-comment-message"><p>You cannot decrement value of any node, remember? This does not guarantee that.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment byuser comment-author-hari6988 odd alt thread-odd thread-alt depth-1" id="dsq-comment-4870">
        <div id="dsq-comment-header-4870" class="dsq-comment-header">
            <cite id="dsq-cite-4870">
                <span id="dsq-author-user-4870">hari6988</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4870" class="dsq-comment-body">
            <div id="dsq-comment-message-4870" class="dsq-comment-message"><p>consider a tree like this<br />
     7<br />
    /<br />
   3<br />
  /<br />
 2<br />
/<br />
1</p>
<p>In this case, the diff is 1. So, u should just increment the value of root&#8217;s left node (node 3) to get a sum tree.  But, in ur code, u will increment both 3 and 2 ,which will not give u a sum tree</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-hari6988 even depth-2" id="dsq-comment-4871">
        <div id="dsq-comment-header-4871" class="dsq-comment-header">
            <cite id="dsq-cite-4871">
                <span id="dsq-author-user-4871">hari6988</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4871" class="dsq-comment-body">
            <div id="dsq-comment-message-4871" class="dsq-comment-message"><p>sorry ,it was a stupid comment&#8230; i didn&#8217;t understand correctly</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-3" id="dsq-comment-5797">
        <div id="dsq-comment-header-5797" class="dsq-comment-header">
            <cite id="dsq-cite-5797">
                <span id="dsq-author-user-5797">Adam</span>
            </cite>
        </div>
        <div id="dsq-comment-body-5797" class="dsq-comment-body">
            <div id="dsq-comment-message-5797" class="dsq-comment-message"><p>when node data is greater than the sum of two of its children why aint we decreasing the node value rather increasing its left children&#8230;is there is some algorithm for doing so&#8230;.or we doing just as it is!</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment byuser comment-author-jagannath even thread-even depth-1" id="dsq-comment-4812">
        <div id="dsq-comment-header-4812" class="dsq-comment-header">
            <cite id="dsq-cite-4812">
                <span id="dsq-author-user-4812">jagannath</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4812" class="dsq-comment-body">
            <div id="dsq-comment-message-4812" class="dsq-comment-message"><pre> <code language="CPP">
#include&lt;iostream&gt;
using namespace std;

struct Node
{
       int data;
       Node * lchild;
       Node * rchild;
};

typedef Node * Nodeptr;
Node * create_node(int value)
{
     Node * temp = new Node();
     temp-&gt;data = value;
     temp-&gt;lchild = NULL;
     temp-&gt;rchild = NULL;
     return temp;
}

int height_of_tree(Node * root)
{
    if(root == NULL)
            return 0;
    int l = height_of_tree(root-&gt;lchild);
    int r = height_of_tree(root-&gt;rchild);
    
    if(l&gt;r)
       return l+1;
    else
       return r+1;
}

void print_nodes_at_level_l_from_root(Node * root,int l)
{
     if(root == NULL)
     {
         return;
     }
     if(l == 0)
         cout&lt;data&lt;lchild,l-1);
     print_nodes_at_level_l_from_root(root-&gt;rchild,l-1);
}

void update_node_values_with_child_sum_from_leaf_nodes(Node ** root)
{
    if(*root == NULL)
            return ;
    
    update_node_values_with_child_sum_from_leaf_nodes(&amp;(*root)-&gt;lchild);
    update_node_values_with_child_sum_from_leaf_nodes(&amp;(*root)-&gt;rchild); 
    
    int root_value = (*root)-&gt;data;
    int lchild_value = ((*root)-&gt;lchild?(*root)-&gt;lchild-&gt;data:0);
    int rchild_value = ((*root)-&gt;rchild?(*root)-&gt;rchild-&gt;data:0);
    
    if(root_value data = (lchild_value + rchild_value);
    }   
}

void update_node_values_with_child_sum_from_root_nodes(Nodeptr *root)
{
     if(*root == NULL )
            return ;
           
     int root_value = (*root)-&gt;data;
     int lchild_value;
     int rchild_value;
 
     lchild_value = ((*root)-&gt;lchild? (*root)-&gt;lchild-&gt;data:0);
     rchild_value = ((*root)-&gt;rchild? (*root)-&gt;rchild-&gt;data:0);
     
     int result = root_value - (lchild_value + rchild_value);
     if(result &gt; 0 )
     {
               if((*root)-&gt;lchild == NULL &amp;&amp; (*root)-&gt;rchild != NULL )
               {
                   (*root)-&gt;lchild-&gt;data += result;
               }
               else if((*root)-&gt;rchild == NULL &amp;&amp; (*root)-&gt;lchild != NULL)
               {
                   (*root)-&gt;lchild-&gt;data += result;
               }
               else if((*root)-&gt;lchild != NULL &amp;&amp; (*root)-&gt;rchild != NULL)
               {
                    if(lchild_value lchild-&gt;data += result;
                    }    
                    else
                    {
                     (*root)-&gt;rchild-&gt;data += result;
                    }
               }
     }

     update_node_values_with_child_sum_from_root_nodes(&amp;(*root)-&gt;lchild);
     update_node_values_with_child_sum_from_root_nodes(&amp;(*root)-&gt;rchild);    
}

int main()
{
     Nodeptr root = create_node(1);
     root-&gt;lchild       = create_node(2);
     root-&gt;rchild       = create_node(3);
     root-&gt;rchild-&gt;rchild = create_node(44);
     root-&gt;lchild-&gt;lchild  = create_node(4);
     root-&gt;lchild-&gt;rchild = create_node(5);
     root-&gt;lchild-&gt;lchild-&gt;lchild  = create_node(7);
     
     /*root = create_node(50);
     root-&gt;lchild       = create_node(7);
     root-&gt;rchild       = create_node(2);
     root-&gt;rchild-&gt;rchild = create_node(30);
     root-&gt;lchild-&gt;lchild  = create_node(3);
     root-&gt;lchild-&gt;rchild = create_node(5);
     root-&gt;rchild-&gt;lchild = create_node(1);*/

     update_node_values_with_child_sum_from_leaf_nodes(&amp;root);
     update_node_values_with_child_sum_from_root_nodes(&amp;root);
  
     int height = height_of_tree(root);
     for(int i=0;i&lt;height;i++)
     {
        print_nodes_at_level_l_from_root(root,i);
        cout&lt;&lt;endl;
     }
     getchar();
     return 0;
}
</code> </pre>
<p>Algorithms:</p>
<p>Step1 : First i traverse the tree in postorder and check for the root nodes whose sum is less than the sum of its child nodes and if its less we update the value of root node and do the same thing for all the nodes.<br />
Step2: Now i traverse the tree in preorder and check , if root nodes value is greater than child nodes sum then update one of the child node value (child node = min(left child,right child)).</p>
<p>Complexity:</p>
<p>So i think complexity for my algorithm is O(n) as i am traversing the tree twice postorder and preorder.</p>
<p>Correct me if i am wrong.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-jagannath odd alt depth-2" id="dsq-comment-4816">
        <div id="dsq-comment-header-4816" class="dsq-comment-header">
            <cite id="dsq-cite-4816">
                <span id="dsq-author-user-4816">jagannath</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4816" class="dsq-comment-body">
            <div id="dsq-comment-message-4816" class="dsq-comment-message"><pre> <code language="C">
void update_node_values_with_child_sum_from_leaf_nodes(Node ** root)
{
    if(*root == NULL)
            return ;
    
    update_node_values_with_child_sum_from_leaf_nodes(&amp;(*root)-&gt;lchild);
    update_node_values_with_child_sum_from_leaf_nodes(&amp;(*root)-&gt;rchild); 
    
    int root_value = (*root)-&gt;data;
    int lchild_value = ((*root)-&gt;lchild?(*root)-&gt;lchild-&gt;data:0);
    int rchild_value = ((*root)-&gt;rchild?(*root)-&gt;rchild-&gt;data:0);
    
    if(root_value data = (lchild_value + rchild_value);
    }   
}

void  update_node_values_with_child_sum_from_root_nodes(Node **root)
{
     if(*root == NULL )
            return ;
           
     int root_value = (*root)-&gt;data;
     int lchild_value;
     int rchild_value;
 
     lchild_value = ((*root)-&gt;lchild? (*root)-&gt;lchild-&gt;data:0);
     rchild_value = ((*root)-&gt;rchild? (*root)-&gt;rchild-&gt;data:0);
     
     int result = root_value - (lchild_value + rchild_value);
     if(result &gt; 0 )
     {
               if((*root)-&gt;lchild == NULL &amp;&amp; (*root)-&gt;rchild != NULL )
               {
                   (*root)-&gt;lchild-&gt;data += result;
               }
               else if((*root)-&gt;rchild == NULL &amp;&amp; (*root)-&gt;lchild != NULL)
               {
                   (*root)-&gt;lchild-&gt;data += result;
               }
               else if((*root)-&gt;lchild != NULL &amp;&amp; (*root)-&gt;rchild != NULL)
               {
                    if(lchild_value lchild-&gt;data += result;
                    }    
                    else
                    {
                     (*root)-&gt;rchild-&gt;data += result;
                    }
               }
     }

     update_node_values_with_child_sum_from_root_nodes(&amp;(*root)-&gt;lchild);
     update_node_values_with_child_sum_from_root_nodes(&amp;(*root)-&gt;rchild);    
}
</code> </pre>
<p>These are basics two functions which helps to form the child sum tree, need to call the functions in this order only.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-jagannath even depth-3" id="dsq-comment-4817">
        <div id="dsq-comment-header-4817" class="dsq-comment-header">
            <cite id="dsq-cite-4817">
                <span id="dsq-author-user-4817">jagannath</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4817" class="dsq-comment-body">
            <div id="dsq-comment-message-4817" class="dsq-comment-message"><pre> <code language="C">
void update_node_values_with_child_sum_from_leaf_nodes(Node ** root)
{
       if(*root == NULL)
             return ;
       
        update_node_values_with_child_sum_from_leaf_nodes
(&amp;(*root)-&gt;lchild);
     
        update_node_values_with_child_sum_from_leaf_nodes
(&amp;(*root)-&gt;rchild);                                                                                         
    int root_value = (*root)-&gt;data;
    int lchild_value =  ((*root)-&gt;lchild?(*root)-&gt;lchild-&gt;data:0);
    int rchild_value = ((*root)-&gt;rchild?(*root)-&gt;rchild-&gt;data:0);
    
     if(root_value &lt; (lchild_value + rchild_value))
     {
         (*root)-&amp;gtdata = (lchild_value + rchild_value);
     }   
}

void  update_node_values_with_child_sum_from_root_nodes(Node **root)
{
      if(*root == NULL )
             return ;
           
      int root_value = (*root)-&gt;data;
      int lchild_value;
      int rchild_value;
 
      lchild_value = ((*root)-&gt;lchild? (*root)-&gt;lchild-&gt;data:0);
      rchild_value = ((*root)-&gt;rchild? (*root)-&gt;rchild-&gt;data:0);
     
      int result = root_value - (lchild_value + rchild_value);
      if(result &gt; 0 )
      {
               if((*root)-&gt;lchild == NULL &amp;&amp; (*root)-&gt;rchild != NULL )
               {
                   (*root)-&gt;lchild-&gt;data += result;
               }
               else if((*root)-&gt;rchild == NULL &amp;&amp; (*root)-&gt;lchild != NULL)
               {
                   (*root)-&gt;lchild-&gt;data += result;
               }
               else if((*root)-&gt;lchild != NULL &amp;&amp; (*root)-&gt;rchild != NULL)
               {
                    if(lchild_value &lt; rchild_value)
                    {
                         (*root)-&gt;lchild-&gt;data += result;
                    }    
                    else
                    {
                     (*root)-&gt;rchild-&gt;data += result;
                    }
               }
     }

     update_node_values_with_child_sum_from_root_nodes(&amp;(*root)-&gt;lchild);
     update_node_values_with_child_sum_from_root_nodes(&amp;(*root)-&gt;rchild);    
}
</code> </pre>
<p>These are basics two functions which helps to form the child sum tree, need to call the functions in this order only.</p>
<p>Sorry for spaming.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment byuser comment-author-devendra088 odd alt thread-odd thread-alt depth-1" id="dsq-comment-4060">
        <div id="dsq-comment-header-4060" class="dsq-comment-header">
            <cite id="dsq-cite-4060">
                <span id="dsq-author-user-4060">devendra088</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4060" class="dsq-comment-body">
            <div id="dsq-comment-message-4060" class="dsq-comment-message"><p>there is a typo at line :  if diff &lt; 0 (node’s data is smaller than the node&#039;s children sum) &#8230; it should be if diff &lt; 0 (node’s data is larger than the node&#039;s children sum)</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-2665">
        <div id="dsq-comment-header-2665" class="dsq-comment-header">
            <cite id="dsq-cite-2665">
                <span id="dsq-author-user-2665">Shri</span>
            </cite>
        </div>
        <div id="dsq-comment-body-2665" class="dsq-comment-body">
            <div id="dsq-comment-message-2665" class="dsq-comment-message"><p>In the increment function I think you should create the node with the diff after fixing the left subtree.. So increment function should be like&#8230; </p>
<pre> <code language="C">
void increment(struct node* node, int diff)
{
 
  /* Go in depth, and fix all left children */
  while(node-&gt;left != NULL)
  {
    node-&gt;left-&gt;data = node-&gt;left-&gt;data + diff;
    node = node-&gt;left;
  }

  /* This if is for the case where left child is NULL */
  if(node-&gt;left == NULL)
  {
    node-&gt;left = newNode(diff);
    return;
  }
}
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-2666">
        <div id="dsq-comment-header-2666" class="dsq-comment-header">
            <cite id="dsq-cite-2666">
                <span id="dsq-author-user-2666">Shri</span>
            </cite>
        </div>
        <div id="dsq-comment-body-2666" class="dsq-comment-body">
            <div id="dsq-comment-message-2666" class="dsq-comment-message"><p>Or before creating check if we haven&#8217;t reached at leaf node(i.e. right child exist).</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment byuser comment-author-vibhav3008 even thread-odd thread-alt depth-1" id="dsq-comment-2341">
        <div id="dsq-comment-header-2341" class="dsq-comment-header">
            <cite id="dsq-cite-2341">
                <span id="dsq-author-user-2341">vibhav3008</span>
            </cite>
        </div>
        <div id="dsq-comment-body-2341" class="dsq-comment-body">
            <div id="dsq-comment-message-2341" class="dsq-comment-message"><pre> <code language="C">
void increment(node * root,int data)
{
    node *current=root;
    while(current!=NULL)
    {
        current-&gt;data+=data;
        if(current-&gt;left!=NULL)
        {
            current=current-&gt;left;
        }
        else
            current=current-&gt;right;
    }
    delete current;
}

void binarytochildsum(node *root)
{
    int rdata=0,ldata=0;
    if((root-&gt;left==NULL &amp;&amp; root-&gt;right==NULL) || root==NULL) //Leaf node
        return;
    binarytochildsum(root-&gt;left);
    binarytochildsum(root-&gt;right);
    if(root-&gt;right!=NULL)
    {
        rdata=root-&gt;right-&gt;data;
    }
    if(root-&gt;left!=NULL)
    {
        ldata=root-&gt;left-&gt;data;
    }
    int diff=root-&gt;data - (rdata+ldata);
    if(diffdata-=diff;
    }
    else
    {
        if(root-&gt;left!=NULL)
            increment(root-&gt;left,diff);
        else
            increment(root-&gt;right,diff);
    }
    return;
}
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-vibhav3008 odd alt depth-2" id="dsq-comment-2342">
        <div id="dsq-comment-header-2342" class="dsq-comment-header">
            <cite id="dsq-cite-2342">
                <span id="dsq-author-user-2342">vibhav3008</span>
            </cite>
        </div>
        <div id="dsq-comment-body-2342" class="dsq-comment-body">
            <div id="dsq-comment-message-2342" class="dsq-comment-message"><p>Please comment on this solution. It retains the structure of the tree.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-sandeep even depth-3" id="dsq-comment-2347">
        <div id="dsq-comment-header-2347" class="dsq-comment-header">
            <cite id="dsq-cite-2347">
                <span id="dsq-author-user-2347">Sandeep</span>
            </cite>
        </div>
        <div id="dsq-comment-body-2347" class="dsq-comment-body">
            <div id="dsq-comment-message-2347" class="dsq-comment-message"><p>@vibhav3008:</p>
<p>Could you please provide code of main() that you used to test your code. Also, please add few words about your approach.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-4" id="dsq-comment-3998">
        <div id="dsq-comment-header-3998" class="dsq-comment-header">
            <cite id="dsq-cite-3998">
                <span id="dsq-author-user-3998">Cracker</span>
            </cite>
        </div>
        <div id="dsq-comment-body-3998" class="dsq-comment-body">
            <div id="dsq-comment-message-3998" class="dsq-comment-message"><p>@sandeep&#8230;i think its complexity is O(nj)..why r saying its O(n^2)..?? can u please explain..??</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment byuser comment-author-gauravs even thread-even depth-1" id="dsq-comment-1938">
        <div id="dsq-comment-header-1938" class="dsq-comment-header">
            <cite id="dsq-cite-1938">
                <span id="dsq-author-user-1938">gauravs</span>
            </cite>
        </div>
        <div id="dsq-comment-body-1938" class="dsq-comment-body">
            <div id="dsq-comment-message-1938" class="dsq-comment-message"><p>Why not Increment the value of the right node if left node is not present instead of creating the left node&#8230;</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-994">
        <div id="dsq-comment-header-994" class="dsq-comment-header">
            <cite id="dsq-cite-994">
                <span id="dsq-author-user-994">coderyogi</span>
            </cite>
        </div>
        <div id="dsq-comment-body-994" class="dsq-comment-body">
            <div id="dsq-comment-message-994" class="dsq-comment-message"><p>This algorithm does not take into account if different nodes have same values. Moreover, i don&#8217;t think adding a new node to a given tree in order to satisfy the children sum property is practical, instead, in the function convertTree(), increment the right subtree if the left one is NULL.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-2" id="dsq-comment-2065">
        <div id="dsq-comment-header-2065" class="dsq-comment-header">
            <cite id="dsq-cite-2065">
                <span id="dsq-author-user-2065">Harsh</span>
            </cite>
        </div>
        <div id="dsq-comment-body-2065" class="dsq-comment-body">
            <div id="dsq-comment-message-2065" class="dsq-comment-message"><p>Yes, i agree.</p>
<p>Could anyone provide an algorithm where the structure of the tree is not changed.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-480">
        <div id="dsq-comment-header-480" class="dsq-comment-header">
            <cite id="dsq-cite-480">
                <span id="dsq-author-user-480">Jyothiq</span>
            </cite>
        </div>
        <div id="dsq-comment-body-480" class="dsq-comment-body">
            <div id="dsq-comment-message-480" class="dsq-comment-message"><p>Sorry, Missed the statement &#8220;you can only increment data values in any node&#8221;. Now its working fine</p>
<p>Thanks</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-geeksforgeeks bypostauthor even thread-odd thread-alt depth-1" id="dsq-comment-472">
        <div id="dsq-comment-header-472" class="dsq-comment-header">
            <cite id="dsq-cite-472">
                <span id="dsq-author-user-472">GeeksforGeeks</span>
            </cite>
        </div>
        <div id="dsq-comment-body-472" class="dsq-comment-body">
            <div id="dsq-comment-message-472" class="dsq-comment-message"><p>@Jyothi: Please read the question statement carefully. The question says you can only increment data values in any node.  So in the 3rd step, we cannot decrement root&#8217;s value from 50 to 8 + 31.  We are following the convention of incrementing the left subtree in such cases, so we have incremented the left subtree. </p>
<p>Now, the question is &#8211; why are we incrementing left subtree not just left child?  We are doing this because just incrementing the left child makes left subtree violate children sum property.</p>
<p>The program works for trees with more than two levels.  Let us know the tree for which you faced problems.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-471">
        <div id="dsq-comment-header-471" class="dsq-comment-header">
            <cite id="dsq-cite-471">
                <span id="dsq-author-user-471">Jyothi</span>
            </cite>
        </div>
        <div id="dsq-comment-body-471" class="dsq-comment-body">
            <div id="dsq-comment-message-471" class="dsq-comment-message"><p>In the 3rd step why are we changing the left subtree values instead of changing the root node value directly. Instead of summing 8+31 directly why are we changing the values 8-&gt;19,3-&gt;14. </p>
<p>And why didnt you follow the same steps for 1 and 2. If the tree level is more than 2 how would you proceed?</p>
</div>
        </div>

    </li><!-- #comment-## -->
            </ul>


        </div>

    </div>

<script type="text/javascript">
var disqus_url = 'http://www.geeksforgeeks.org/convert-an-arbitrary-binary-tree-to-a-tree-that-holds-children-sum-property/';
var disqus_identifier = '4386 http://geeksforgeeks.org/?p=4386';
var disqus_container_id = 'disqus_thread';
var disqus_shortname = 'geeksforgeeks';
var disqus_title = "Convert an arbitrary Binary Tree to a tree that holds Children Sum Property";
var disqus_config_custom = window.disqus_config;
var disqus_config = function () {
    /*
    All currently supported events:
    onReady: fires when everything is ready,
    onNewComment: fires when a new comment is posted,
    onIdentify: fires when user is authenticated
    */
    
    
    this.language = '';
    
    if (disqus_config_custom) {
        disqus_config_custom.call(this);
    }
};

(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>

			</div>
	
					
			
			

		</div> <!-- end post -->	

<br></br>
	
</div> <!-- end content -->

<ul id="sidebar">
	<li id="text-19" class="widget widget_text">			<div class="textwidget"><script>
  (function() {
    var cx = '009682134359037907028:tj6eafkv_be';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//www.google.com/cse/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>

<style type="text/css">
  .gsc-control-cse {
    font-family: "Trebuchet MS", sans-serif;
    border-color: #E1F3DA;
    background-color: #E1F3DA;
  }
  input.gsc-input {
    border-color: #94CC7A;
  }
  input.gsc-search-button {
    border-color: #94CC7A;
    background-color: #AADA92;
  }
  .gsc-tabHeader.gsc-tabhInactive {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gsc-tabHeader.gsc-tabhActive {
    border-color: #A9DA92;
    background-color: #A9DA92;
  }
  .gsc-tabsArea {
    border-color: #A9DA92;
  }
  .gsc-webResult.gsc-result {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gsc-webResult.gsc-result:hover {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gs-webResult.gs-result a.gs-title:link,
  .gs-webResult.gs-result a.gs-title:link b {
    color: #009900;
  }
  .gs-webResult.gs-result a.gs-title:visited,
  .gs-webResult.gs-result a.gs-title:visited b {
    color: #009900;
  }
  .gs-webResult.gs-result a.gs-title:hover,
  .gs-webResult.gs-result a.gs-title:hover b {
    color: #003300;
  }
  .gs-webResult.gs-result a.gs-title:active,
  .gs-webResult.gs-result a.gs-title:active b {
    color: #009900;
  }
  .gsc-cursor-page {
    color: #009900;
  }
  a.gsc-trailing-more-results:link {
    color: #009900;
  }
  .gs-webResult.gs-result .gs-snippet {
    color: #454545;
  }
  .gs-webResult.gs-result .gs-visibleUrl {
    color: #33cc00;
  }
  .gs-webResult.gs-result .gs-visibleUrl-short {
    color: #33cc00;
  }
  .gs-webResult.gs-result .gs-visibleUrl-short {
    display: none;
  }
  .gs-webResult.gs-result .gs-visibleUrl-long {
    display: block;
  }
  .gsc-cursor-box {
    border-color: #A9DA92;
  }
  .gsc-results .gsc-cursor-page {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gsc-results .gsc-cursor-page.gsc-cursor-current-page {
    border-color: #A9DA92;
    background-color: #A9DA92;
  }
  .gs-promotion.gs-result {
    border-color: #94CC7A;
    background-color: #CBE8B4;
  }
  .gs-promotion.gs-result a.gs-title:link {
    color: #0066CC;
  }
  .gs-promotion.gs-result a.gs-title:visited {
    color: #0066CC;
  }
  .gs-promotion.gs-result a.gs-title:hover {
    color: #0066CC;
  }
  .gs-promotion.gs-result a.gs-title:active {
    color: #0066CC;
  }
  .gs-promotion.gs-result .gs-snippet {
    color: #454545;
  }
  .gs-promotion.gs-result .gs-visibleUrl,
  .gs-promotion.gs-result .gs-visibleUrl-short {
    color: #815FA7;
  }
</style>    </div>
		</li>
<li id="text-9" class="widget widget_text">			<div class="textwidget"><div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=138031159685820";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>

<div class="fb-like-box" data-href="https://www.facebook.com/pages/GeeksforGeeks/316764689022" data-width="250" data-height="170" data-colorscheme="light" data-show-faces="true" data-header="false" data-stream="false" data-show-border="false"></div></div>
		</li>
<li id="text-18" class="widget widget_text">			<div class="textwidget"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LargeRectangleSide -->
<ins class="adsbygoogle"
     style="display:inline-block;width:336px;height:280px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="1884636833"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
		</li>
<li id="text-13" class="widget widget_text">			<div class="textwidget"><ul><li><a href="http://www.geeksforgeeks.org/category/interview-experiences/">Interview Experiences</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/advance-data-structures">Advanced Data Structures</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/dynamic-programming">Dynamic Programming</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/Greedy-Algorithm/">Greedy Algorithms</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/backtracking">Backtracking</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/pattern-searching">Pattern Searching</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/divide-and-conquer">Divide & Conquer</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/MathematicalAlgo">Mathematical Algorithms</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/recursion">Recursion</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/geometric-algorithms/">Geometric Algorithms</a></li>
</ul></div>
		</li>
<li id="text-17" class="widget widget_text">			<div class="textwidget"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big 300x600 Sidebar -->
<ins class="adsbygoogle"
     style="display:inline-block;width:300px;height:600px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="4402736037"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
		</li>
<li id="text-14" class="widget widget_text"><h2 class="widgettitle">Popular Posts</h2>
			<div class="textwidget"><ul>
<li><a href="http://www.geeksforgeeks.org/write-a-c-program-to-print-all-permutations-of-a-given-string/">  All permutations of a given string </a></li>
<li><a href="http://www.geeksforgeeks.org/memory-layout-of-c-program/"> Memory Layout of C Programs</a> </li>
<li><a href="http://www.geeksforgeeks.org/understanding-extern-keyword-in-c/"> Understanding “extern” keyword in C</a> </li>
<li><a href="http://www.geeksforgeeks.org/median-of-two-sorted-arrays/">Median of two sorted arrays</a> </li>
<li><a href="http://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/"> Tree traversal without recursion and without stack! </a></li>
<li><a href="http://www.geeksforgeeks.org/structure-member-alignment-padding-and-data-packing/"> Structure Member Alignment, Padding and Data Packing</a> </li>
<li><a href="http://www.geeksforgeeks.org/write-a-function-to-get-the-intersection-point-of-two-linked-lists/"> Intersection point of two Linked Lists</a> </li>
<li><a href="http://www.geeksforgeeks.org/lowest-common-ancestor-in-a-binary-search-tree/"> Lowest Common Ancestor in a BST.</span></a> </li>
<li><a href="http://www.geeksforgeeks.org/a-program-to-check-if-a-binary-tree-is-bst-or-not/"> Check if a binary tree is BST or not</a> </li>
<li><a href="http://www.geeksforgeeks.org/sorted-linked-list-to-balanced-bst/"> Sorted Linked List to Balanced BST</a></li>
</ul></div>
		</li>
<li id="text-3" class="widget widget_text">			<div class="textwidget"><a href="https://twitter.com/GeeksforGeeks" class="twitter-follow-button" data-show-count="false">Follow @GeeksforGeeks</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>         


<!-- GOOGLE FEEDBURNER BUTTON-->
<a href="http://feeds.feedburner.com/Geeksforgeeks" title="Subscribe to my feed" rel="alternate" type="application/rss+xml"><img src="http://www.feedburner.com/fb/images/pub/feed-icon32x32.png" alt="" style="border:0"/></a><a href="http://feeds.feedburner.com/Geeksforgeeks" title="Subscribe to my feed" rel="alternate" type="application/rss+xml">Subscribe</a>

</div>
		</li>
<li id="text-21" class="widget widget_text"><h2 class="widgettitle">Recent Comments</h2>
			<div class="textwidget"><script type="text/javascript" src="http://geeksforgeeks.disqus.com//recent_comments_widget.js?num_items=6&hide_avatars=1&excerpt_length=50&hide_mods=0"></script></div>
		</li>
<li id="text-22" class="widget widget_text">			<div class="textwidget"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LinkAd -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:90px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="2606115235"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LinkAd -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:90px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="2606115235"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LinkAd -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:90px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="2606115235"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
		</li>

</ul>					  
		<div class="clear"></div>

		<div id="footer">
		
		    <div class="xhtml">
                        @geeksforgeeks, <a href="http://creativecommons.org/licenses/by-nc-nd/2.5/in/deed.en_US" title="Valid XHTML Strict 1.0">Some rights reserved</a>  <a href="http://www.geeksforgeeks.org/about/contact-us/"> &nbsp; &nbsp; &nbsp; &nbsp;Contact Us!</a>

		    </div>
		    
		    <div class="credits">
			  Powered by <a href="http://wordpress.org">WordPress </a> &amp; <a href="http://mootools.net/" title="Mootools JavaScript Framework">MooTools</a>, customized by geeksforgeeks team </div>
			  
		   <div class="clear"></div>						                            
		   
		</div> <!--end footer-->  
        
		        <script type="text/javascript">
        // <![CDATA[
        var disqus_shortname = 'geeksforgeeks';
        (function () {
            var nodes = document.getElementsByTagName('span');
            for (var i = 0, url; i < nodes.length; i++) {
                if (nodes[i].className.indexOf('dsq-postid') != -1) {
                    nodes[i].parentNode.setAttribute('data-disqus-identifier', nodes[i].getAttribute('rel'));
                    url = nodes[i].parentNode.href.split('#', 1);
                    if (url.length == 1) { url = url[0]; }
                    else { url = url[1]; }
                    nodes[i].parentNode.href = url + '#disqus_thread';
                }
            }
            var s = document.createElement('script'); 
            s.async = true;
            s.type = 'text/javascript';
            s.src = '//' + disqus_shortname + '.disqus.com/count.js';
            (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
        }());
        // ]]>
        </script>
        <script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/scripts/shCore.js?ver=3.0.9'></script>
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/scripts/shBrushCpp.js?ver=3.0.9'></script>
<script type='text/javascript'>
	(function(){
		var corecss = document.createElement('link');
		var themecss = document.createElement('link');
		var corecssurl = "http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/styles/shCore.css?ver=3.0.9";
		if ( corecss.setAttribute ) {
				corecss.setAttribute( "rel", "stylesheet" );
				corecss.setAttribute( "type", "text/css" );
				corecss.setAttribute( "href", corecssurl );
		} else {
				corecss.rel = "stylesheet";
				corecss.href = corecssurl;
		}
		document.getElementsByTagName("head")[0].insertBefore( corecss, document.getElementById("syntaxhighlighteranchor") );
		var themecssurl = "http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/styles/shThemeDefault.css?ver=3.0.9";
		if ( themecss.setAttribute ) {
				themecss.setAttribute( "rel", "stylesheet" );
				themecss.setAttribute( "type", "text/css" );
				themecss.setAttribute( "href", themecssurl );
		} else {
				themecss.rel = "stylesheet";
				themecss.href = themecssurl;
		}
		//document.getElementById("syntaxhighlighteranchor").appendChild(themecss);
		document.getElementsByTagName("head")[0].insertBefore( themecss, document.getElementById("syntaxhighlighteranchor") );
	})();
	SyntaxHighlighter.config.strings.expandSource = '+ expand source';
	SyntaxHighlighter.config.strings.help = '?';
	SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
	SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
	SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
	SyntaxHighlighter.defaults['gutter'] = false;
	SyntaxHighlighter.defaults['pad-line-numbers'] = true;
	SyntaxHighlighter.defaults['toolbar'] = false;
	SyntaxHighlighter.all();
</script>
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/bbpress/templates/default/js/editor.js?ver=2.5.4-5380'></script>
				  
		</div> <!--end wrapper-->
        <div id="ajaxSpinner"></div> <!--For AJAX spinner holder-->
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-12148232-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
	</body>

</html>
<!-- Dynamic page generated in 0.226 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2014-11-27 23:29:31 -->

<!-- Compression = gzip -->
<!-- super cache -->