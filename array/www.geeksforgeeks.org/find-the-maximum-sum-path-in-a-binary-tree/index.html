<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
       <title>Find the maximum sum leaf to root path in a Binary Tree - GeeksforGeeks</title>
       <style type="text/css" media="screen">
          @import url('http://d2o58evtke57tz.cloudfront.net/wp-content/themes/minimoo/style.css');
    </style>
      <link href="http://d2o58evtke57tz.cloudfront.net/wp-content/themes/minimoo/favicon.ico" rel="shortcut icon" />    
    
<!-- This site is optimized with the Yoast WordPress SEO plugin v1.7.1 - https://yoast.com/wordpress/plugins/seo/ -->
<link rel="canonical" href="http://www.geeksforgeeks.org/find-the-maximum-sum-path-in-a-binary-tree/" />
<meta property="og:locale" content="en_US" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Find the maximum sum leaf to root path in a Binary Tree - GeeksforGeeks" />
<meta property="og:description" content="Given a Binary Tree, find the maximum sum path from a leaf to root. For example, in the following tree, there are three leaf to root paths 8-&gt;-2-&gt;10, -4-&gt;-2-&gt;10 and 7-&gt;10. The sums of these three paths are 16, 4 and 17 respectively. The maximum of them is 17 and the path for maximum is &hellip;" />
<meta property="og:url" content="http://www.geeksforgeeks.org/find-the-maximum-sum-path-in-a-binary-tree/" />
<meta property="og:site_name" content="GeeksforGeeks" />
<meta property="article:section" content="Trees" />
<meta property="article:published_time" content="2012-04-06T23:39:27+00:00" />
<meta property="article:modified_time" content="2013-05-31T08:41:43+00:00" />
<meta property="og:updated_time" content="2013-05-31T08:41:43+00:00" />
<!-- / Yoast WordPress SEO plugin. -->

<link rel='stylesheet' id='wp-quicklatex-format-css'  href='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/wp-quicklatex/css/quicklatex-format.css?ver=4.0.1' type='text/css' media='all' />
<link rel='stylesheet' id='bbp-default-css'  href='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/bbpress/templates/default/css/bbpress.css?ver=2.5.4-5380' type='text/css' media='screen' />
<link rel='stylesheet' id='wp-pagenavi-css'  href='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/wp-pagenavi/pagenavi-css.css?ver=2.70' type='text/css' media='all' />
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-includes/js/jquery/jquery.js?ver=1.11.1'></script>
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-includes/js/jquery/jquery-migrate.min.js?ver=1.2.1'></script>
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/wp-quicklatex/js/wp-quicklatex-frontend.js?ver=1.0'></script>

<!-- Bad Behavior 2.2.16 run time: 1.528 ms -->
<script type="text/javascript">
<!--
function bb2_addLoadEvent(func) {
	var oldonload = window.onload;
	if (typeof window.onload != 'function') {
		window.onload = func;
	} else {
		window.onload = function() {
			oldonload();
			func();
		}
	}
}

bb2_addLoadEvent(function() {
	for ( i=0; i < document.forms.length; i++ ) {
		if (document.forms[i].method == 'post') {
			var myElement = document.createElement('input');
			myElement.setAttribute('type', 'hidden');
			myElement.name = 'bb2_screener_';
			myElement.value = '1417111199 210.212.53.139 172.19.11.169';
			document.forms[i].appendChild(myElement);
		}
	}
});
// --></script>
		<style type="text/css" id="syntaxhighlighteranchor"></style>
   <meta name="google-site-verification" content="rHK2v8_zzuAZQY8JHAzbllDN8u-aQxcn2Kqnp67Old0" />
</head>

<body>
<!-- o4dI0sCXUgoSONabbd8mbZ4SA3E -->    
    <div id="wrapper">
        <div class="blog-info">
                <h1 class="blog-title">
                <a href="http://www.geeksforgeeks.org" title="GeeksforGeeks">GeeksforGeeks</a>
            </h1>
       
            <div class="blog-description">
                A computer science portal for geeks            </div>
        </div>
        <b><p>  <h2 align="right"> <a href="http://geeksquiz.com/">GeeksQuiz</a></h2> 
   <a href="http://www.geeksforgeeks.org/wp-login.php">Login</a> 
         </p></b>  
         
         <div class="clear"></div>         
              
                     
            <div id="menu">   
                 <ul>
 <li><a href="http://www.geeksforgeeks.org">Home</a></li>
  <li><a href="http://www.geeksforgeeks.org/fundamentals-of-algorithms/">Algorithms</a></li>
 <li><a href="http://www.geeksforgeeks.org/data-structures/">DS</a></li>
  <li><a href="http://www.geeksforgeeks.org/gate-corner/">GATE</a></li>
  <li><a href="http://www.geeksforgeeks.org/about/interview-corner/">Interview Corner</a></li>
  <li><a href="http://www.geeksforgeeks.org/forums/">Q&A</a></li>
  <li><a href="http://www.geeksforgeeks.org/c/">C</a></li>
  <li><a href="http://www.geeksforgeeks.org/c-plus-plus/">C++</a></li>
  <li><a href="http://www.geeksforgeeks.org/java/">Java</a></li>
  <li><a href="http://www.geeksforgeeks.org/books/">Books</a></li>
  <li><a href="http://www.geeksforgeeks.org/contribute/">Contribute</a></li>
  <li><a href="http://www.geeksforgeeks.org/contribute/ask-a-question/">Ask a Q</a></li>
  <li><a href="http://www.geeksforgeeks.org/about/">About</a></li>
            </ul>

               
            <div class="clear"></div>     
        </div>
             <div id="navmenu">
				<ul id="menu" style="padding:0; margin:0;">
						<li class="cat-item cat-item-3"><a href="http://www.geeksforgeeks.org/category/c-arrays/" title="Questions regarding Arrays">Array</a>
</li>	

	<li class="cat-item cat-item-17"><a href="http://www.geeksforgeeks.org/category/bit-magic/" title="View all posts filed under Bit Magic">Bit Magic</a>
</li>
	<li class="cat-item cat-item-14"><a href="http://www.geeksforgeeks.org/category/c-puzzles/" title="View all posts filed under C/C++ Puzzles">C/C++</a>
</li>

<li class="cat-item cat-item-18"><a href="http://www.geeksforgeeks.org/category/articles/" title="View all posts filed under Articles">Articles</a>
</li>

	<li class="cat-item cat-item-67"><a href="http://www.geeksforgeeks.org/category/gfact/" title="View all posts filed under GFacts">GFacts</a>
</li>
	<li class="cat-item cat-item-8"><a href="http://www.geeksforgeeks.org/category/linked-list/" title="Linked List problems">Linked List</a>
</li>
	<li class="cat-item cat-item-66"><a href="http://www.geeksforgeeks.org/category/multiple-choice-question/" title="View all posts filed under MCQ">MCQ</a>

</li>
	<li class="cat-item cat-item-4"><a href="http://www.geeksforgeeks.org/category/c-programs/" title="Miscellaneous">Misc</a>
</li>
	<li class="cat-item cat-item-5"><a href="http://www.geeksforgeeks.org/category/program-output/" title="View all posts filed under Output">Output</a>
</li>
	<li class="cat-item cat-item-7"><a href="http://www.geeksforgeeks.org/category/c-strings/" title="Questions related to strings">String</a>
</li>
	<li class="cat-item cat-item-19"><a href="http://www.geeksforgeeks.org/category/tree/" title="View all posts filed under Trees">Tree</a>
</li>
	<li class="cat-item cat-item-19"><a href="http://www.geeksforgeeks.org/category/graph/" title="View all posts filed under Graph">Graph</a>
</li>
</ul>
        </div>
             <div id="content">	   	
	<div class="post" id="post">
							<div class="post-info">			
					<div class="post-title-info">
						<h2 class="post-title">Find the maximum sum leaf to root path in a Binary Tree</h2>
					</div>			
					<div class="clear"></div>				  
				<div class="post-content" id="post-content">
					<p>Given a Binary Tree, find the maximum sum path from a leaf to root.<span id="more-18722"></span> For example, in the following tree, there are three leaf to root paths 8->-2->10,  -4->-2->10 and 7->10. The sums of these three paths are 16, 4 and 17 respectively.  The maximum of them is 17 and the path for maximum is 7->10. </p>
<pre>
                  10
               /      \
	     -2        7
           /   \     
	 8     -4    
</pre>
<p><strong>Solution</strong><br />
1) First find the leaf node that is on the maximum sum path. In the following code getTargetLeaf() does this by assigning the result to *target_leaf_ref.<br />
2) Once we have the target leaf node, we can print the maximum sum path by traversing the tree.  In the following code, printPath() does this.</p>
<p>The main function is maxSumPath() that uses above two functions to get the complete solution. </p>
<pre class="brush: cpp; highlight: [12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75]; title: ; notranslate" title="">
#include&lt;stdio.h&gt;
#include&lt;limits.h&gt;

/* A tree node structure */
struct node
{
    int data;
    struct node *left;
    struct node *right;
};

// A utility function that prints all nodes on the path from root to target_leaf
bool printPath (struct node *root, struct node *target_leaf)
{
    // base case
    if (root == NULL)
        return false;

    // return true if this node is the target_leaf or target leaf is present in
    // one of its descendants
    if (root == target_leaf || printPath(root-&gt;left, target_leaf) ||
            printPath(root-&gt;right, target_leaf) )
    {
        printf(&quot;%d &quot;, root-&gt;data);
        return true;
    }

    return false;
}

// This function Sets the target_leaf_ref to refer the leaf node of the maximum 
// path sum.  Also, returns the max_sum using max_sum_ref
void getTargetLeaf (struct node *node, int *max_sum_ref, int curr_sum,
                   struct node **target_leaf_ref)
{
    if (node == NULL)
        return;

    // Update current sum to hold sum of nodes on path from root to this node
    curr_sum = curr_sum + node-&gt;data;

    // If this is a leaf node and path to this node has maximum sum so far,
    // then make this node target_leaf
    if (node-&gt;left == NULL &amp;&amp; node-&gt;right == NULL)
    {
        if (curr_sum &gt; *max_sum_ref)
        {
            *max_sum_ref = curr_sum;
            *target_leaf_ref = node;
        }
    }

    // If this is not a leaf node, then recur down to find the target_leaf
    getTargetLeaf (node-&gt;left, max_sum_ref, curr_sum, target_leaf_ref);
    getTargetLeaf (node-&gt;right, max_sum_ref, curr_sum, target_leaf_ref);
}

// Returns the maximum sum and prints the nodes on max sum path
int maxSumPath (struct node *node)
{
    // base case
    if (node == NULL)
        return 0;

    struct node *target_leaf;
    int max_sum = INT_MIN;

    // find the target leaf and maximum sum
    getTargetLeaf (node, &amp;max_sum, 0, &amp;target_leaf);

    // print the path from root to the target leaf
    printPath (node, target_leaf);

    return max_sum;  // return maximum sum
}

/* Utility function to create a new Binary Tree node */
struct node* newNode (int data)
{
    struct node *temp = new struct node;
    temp-&gt;data = data;
    temp-&gt;left = NULL;
    temp-&gt;right = NULL;
    return temp;
}

/* Driver function to test above functions */
int main()
{
    struct node *root = NULL;

    /* Constructing tree given in the above figure */
    root = newNode(10);
    root-&gt;left = newNode(-2);
    root-&gt;right = newNode(7);
    root-&gt;left-&gt;left = newNode(8);
    root-&gt;left-&gt;right = newNode(-4);

    printf (&quot;Following are the nodes on the maximum sum path \n&quot;);
    int sum = maxSumPath(root);
    printf (&quot;\nSum of the nodes is %d &quot;, sum);

    getchar();
    return 0;
}
</pre>
<p>Output:</p>
<pre>
Following are the nodes on the maximum sum path
7 10
Sum of the nodes is 17
</pre>
<p>Time Complexity: Time complexity of the above solution is O(n) as it involves tree traversal two times.</p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
		
&nbsp;
&nbsp;
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle"
     style="display:inline-block;width:336px;height:280px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="4061219431"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>



&nbsp;
&nbsp;
&nbsp;
<h3>Related Topics:</h3><ul><li><a href="http://www.geeksforgeeks.org/perfect-binary-tree-specific-level-order-traversal/" title="Perfect Binary Tree Specific Level Order Traversal">Perfect Binary Tree Specific Level Order Traversal</a></li><li><a href="http://www.geeksforgeeks.org/print-nodes-top-view-binary-tree/" title="Print Nodes in Top View of Binary Tree">Print Nodes in Top View of Binary Tree</a></li><li><a href="http://www.geeksforgeeks.org/k-dimensional-tree/" title="K Dimensional Tree">K Dimensional Tree</a></li><li><a href="http://www.geeksforgeeks.org/convert-binary-tree-threaded-binary-tree/" title="Convert a Binary Tree to Threaded binary tree">Convert a Binary Tree to Threaded binary tree</a></li><li><a href="http://www.geeksforgeeks.org/serialize-deserialize-n-ary-tree/" title="Serialize and Deserialize an N-ary Tree">Serialize and Deserialize an N-ary Tree</a></li><li><a href="http://www.geeksforgeeks.org/serialize-deserialize-binary-tree/" title="Serialize and Deserialize a Binary Tree">Serialize and Deserialize a Binary Tree</a></li><li><a href="http://www.geeksforgeeks.org/given-binary-tree-print-nodes-two-given-level-numbers/" title="Print nodes between two given level numbers of a binary tree">Print nodes between two given level numbers of a binary tree</a></li><li><a href="http://www.geeksforgeeks.org/find-height-binary-tree-represented-parent-array/" title="Find Height of Binary Tree represented by Parent array">Find Height of Binary Tree represented by Parent array</a></li></ul>
<p></p> 
<div>
<iframe src="http://www.facebook.com/plugins/like.php?href=http%3A%2F%2Fwww.geeksforgeeks.org%2Ffind-the-maximum-sum-path-in-a-binary-tree%2F&layout=button_count&show_faces=false&width=90&action=like&colorscheme=light" scrolling="no" frameborder="0" allowTransparency="true" style="border:none; overflow:hidden; width:90px; height:20px"></iframe>
<a href="http://twitter.com/share" class="twitter-share-button" data-url="http://www.geeksforgeeks.org/find-the-maximum-sum-path-in-a-binary-tree/" data-text="Find the maximum sum leaf to root path in a Binary Tree" data-count="horizontal" data-via="jakerutter">Tweet</a><script type="text/javascript" src="http://platform.twitter.com/widgets.js"></script>
<g:plusone size="medium" href="http://www.geeksforgeeks.org/find-the-maximum-sum-path-in-a-binary-tree/"></g:plusone>
<!-- Place this render call where appropriate -->
<script type="text/javascript">
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script></div>





				</div>		  
			</div> <!-- end post main -->					
			<div class="post-meta">
				<div class="left"></div>				
				<div class="clear"></div>
			</div>			
        
			<div class="comments-main">		
 <b>Writing code in comment?</b> Please use <b><a href="http://ideone.com/">ideone.com</a></b> and share the link here.
				
<div id="disqus_thread">
            <div id="dsq-content">


            <ul id="dsq-comments">
                    <li class="comment even thread-even depth-1" id="dsq-comment-31590">
        <div id="dsq-comment-header-31590" class="dsq-comment-header">
            <cite id="dsq-cite-31590">
                <span id="dsq-author-user-31590">isidorouk</span>
            </cite>
        </div>
        <div id="dsq-comment-body-31590" class="dsq-comment-body">
            <div id="dsq-comment-message-31590" class="dsq-comment-message"><p>Can some one help me to understand what is wrong with this method, which should get the max path of a pyramid?</p>
<p>private long GetMax(int row, int column, Pyramid pyramid)</p>
<p>{</p>
<p>    if (row == 0) return pyramid[row, column];</p>
<p>    long value = pyramid[row, column];</p>
<p>    if (row != 0)</p>
<p>    {</p>
<p>        long left = pyramid[row &#8211; 1, column];</p>
<p>        long right = pyramid[row &#8211; 1, column + 1];</p>
<p>        long highest = Math.Max(left, right);</p>
<p>        int nextColumn = highest == left ? column : column + 1;</p>
<p>        value += GetTotalAbove(row – 1, nextColumn, pyramid);</p>
<p>    }</p>
<p>    return value;</p>
<p>}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-19697">
        <div id="dsq-comment-header-19697" class="dsq-comment-header">
            <cite id="dsq-cite-19697">
                <span id="dsq-author-user-19697">Akhil</span>
            </cite>
        </div>
        <div id="dsq-comment-body-19697" class="dsq-comment-body">
            <div id="dsq-comment-message-19697" class="dsq-comment-message"><p>To print the maximum sum :<br />
An O(n) postorder simple code</p>
<pre> <code language="C">
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
struct tree
{
    int info;
    struct tree *l;
    struct tree *r;
};
typedef struct tree *Tree;

Tree newNode(int num)
{
    Tree temp = (Tree)malloc(sizeof(struct tree));
    temp-&gt;info = num;
    temp-&gt;l = NULL;
    temp-&gt;r = NULL;
    return temp;
}
/* the idea is to calculate the max sum from leaf to root */
int maxRootLeaf(Tree root)
{
    if(!root)
        return 0;
    if(!root-&gt;l &amp;&amp; !root-&gt;r)
        return root-&gt;info;
    /* find max sum for the subtrees*/
    int ls = maxRootLeaf(root-&gt;l);
    int rs = maxRootLeaf(root-&gt;r);
    /* return maximum of subtrees+ data of the root */
    return(root-&gt;info + (ls&gt;rs?ls:rs));
}
int main()
{
    struct tree *root = NULL;

    /* Constructing tree given in the above figure */
    root = newNode(10);
    root-&gt;l = newNode(-2);
    root-&gt;r = newNode(7);
    root-&gt;l-&gt;l = newNode(8);
    root-&gt;l-&gt;r = newNode(-4);
    int sum = maxRootLeaf(root);
    printf (&quot;\nSum of the nodes is %d &quot;, sum);
    return 0;
}


</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-2" id="dsq-comment-27325">
        <div id="dsq-comment-header-27325" class="dsq-comment-header">
            <cite id="dsq-cite-27325">
                <span id="dsq-author-user-27325">Guest</span>
            </cite>
        </div>
        <div id="dsq-comment-body-27325" class="dsq-comment-body">
            <div id="dsq-comment-message-27325" class="dsq-comment-message"><p>And in Haskell:<br />
<code><br />
data Tree a =<br />
       Empty<br />
     | Node (Tree a) a (Tree a)<br />
     deriving (Eq,Show)</p>
<p>maxRootLeaf :: Tree Int -&gt; Int<br />
       maxRootLeaf Empty         = 0<br />
       maxRootLeaf (Node l x r)  = x + (if maxRootLeaf (r) &gt; maxRootLeaf (l)<br />
                                                      then maxRootLeaf (r)<br />
                                                      else maxRootLeaf (l))</p>
<p></code></p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-18938">
        <div id="dsq-comment-header-18938" class="dsq-comment-header">
            <cite id="dsq-cite-18938">
                <span id="dsq-author-user-18938">NNavneet</span>
            </cite>
        </div>
        <div id="dsq-comment-body-18938" class="dsq-comment-body">
            <div id="dsq-comment-message-18938" class="dsq-comment-message"><p>&#8220;The sums of these three paths are 16, 8 and 17 respectively.&#8221;<br />
It should be<br />
&#8221; The sums of these three paths are 16, 4 and 17 respectively.&#8221; In the first paragraph.</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-geeksforgeeks bypostauthor even depth-2" id="dsq-comment-18939">
        <div id="dsq-comment-header-18939" class="dsq-comment-header">
            <cite id="dsq-cite-18939">
                <span id="dsq-author-user-18939">GeeksforGeeks</span>
            </cite>
        </div>
        <div id="dsq-comment-body-18939" class="dsq-comment-body">
            <div id="dsq-comment-message-18939" class="dsq-comment-message"><p>Thanks for pointing this out.  We have corrected it.  Keep it up!</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment byuser comment-author-ysunil040 odd alt thread-odd thread-alt depth-1" id="dsq-comment-18768">
        <div id="dsq-comment-header-18768" class="dsq-comment-header">
            <cite id="dsq-cite-18768">
                <span id="dsq-author-user-18768">ysunil040</span>
            </cite>
        </div>
        <div id="dsq-comment-body-18768" class="dsq-comment-body">
            <div id="dsq-comment-message-18768" class="dsq-comment-message"><pre> <code language="C">
int maxSum(Tree root,int toPrint)
{
	if (root == NULL)
		return INT_MIN;
	if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL)
	{
		if (toPrint)
			printf(&quot;%d\n&quot;,root-&gt;data);
		return root-&gt;data;
	}
	int lsum = maxSum(root-&gt;left,0);
	int rsum = maxSum(root-&gt;right,0);

	if (toPrint)
	{
		printf(&quot;%d &quot;,root-&gt;data);
		int sum = root-&gt;data;
		if (lsum &gt;= rsum)
			sum += maxSum(root-&gt;left,toPrint);
		else
			sum += maxSum(root-&gt;right,toPrint);
		return sum;
	}
	else
	{
		return root-&gt;data + max(lsum,rsum);
	}
}

Call the function as maxSum(root,1)
It's a two pass solution.
Time Complexity O(H*N) - H - Height of the Tree and N - Number of Nodes
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-ysunil040 even thread-even depth-1" id="dsq-comment-18767">
        <div id="dsq-comment-header-18767" class="dsq-comment-header">
            <cite id="dsq-cite-18767">
                <span id="dsq-author-user-18767">ysunil040</span>
            </cite>
        </div>
        <div id="dsq-comment-body-18767" class="dsq-comment-body">
            <div id="dsq-comment-message-18767" class="dsq-comment-message"><pre> <code language="C">
int maxSum(Tree root,int toPrint)
{
        if (root == NULL)
		return INT_MIN;
	if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL)
	{
		if (toPrint)
			printf(&quot;%d\n&quot;,root-&gt;data);
		return root-&gt;data;
	}
	int lsum = maxSum(root-&gt;left,0);
	int rsum = maxSum(root-&gt;right,0);

	if (toPrint)
	{
		printf(&quot;%d &quot;,root-&gt;data);
		int sum = root-&gt;data;
		if (lsum &gt;= rsum)
			sum += maxSum(root-&gt;left,toPrint);
		else
			sum += maxSum(root-&gt;right,toPrint);
		return sum;
	}
	else
	{
		return root-&gt;data + max(lsum,rsum);
	}
}

Call the above function as 
  maxSum(root,1)

This will print path from root to leaf and time complexity is O(H*N) H - Height of Tree and N - Number of Nodes in tree
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-abhishek08aug odd alt thread-odd thread-alt depth-1" id="dsq-comment-18388">
        <div id="dsq-comment-header-18388" class="dsq-comment-header">
            <cite id="dsq-cite-18388">
                <span id="dsq-author-user-18388">abhishek08aug</span>
            </cite>
        </div>
        <div id="dsq-comment-body-18388" class="dsq-comment-body">
            <div id="dsq-comment-message-18388" class="dsq-comment-message"><p>Intelligent <img src="http://d2o58evtke57tz.cloudfront.net/wp-includes/images/smilies/icon_biggrin.gif" alt=":D" class="wp-smiley" /></p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-17315">
        <div id="dsq-comment-header-17315" class="dsq-comment-header">
            <cite id="dsq-cite-17315">
                <span id="dsq-author-user-17315">ishanu</span>
            </cite>
        </div>
        <div id="dsq-comment-body-17315" class="dsq-comment-body">
            <div id="dsq-comment-message-17315" class="dsq-comment-message"><p>//i dont understand why people are writing so complicated codes.this can be done just by using on function only</p>
<pre> <code language="C">

#include &lt;iostream&gt;
//to find the maximum distance between root and a leaf
using namespace std;

struct bst
{
	int data;
	bst *lchild;
	bst *rchild;
};
bst* root=NULL;
bst* total=NULL;
bst* newNode(int num)
{
	bst*node= new bst;
	node-&gt;data=num;
	node-&gt;lchild=NULL;
	node-&gt;rchild=NULL;
	return node;
}

void preorder(bst *node,bst *total,int a[2],int sum)
{
    if(node==NULL)
		return;
    
    sum=sum+node-&gt;data;
    if(sum&gt;total-&gt;data)
    {
		total-&gt;data=sum;
		a[1]=node-&gt;data;
	}
    preorder(node-&gt;lchild,total,a,sum);
 
   preorder(node-&gt;rchild,total,a,sum);
 
   
}



int main()
{
	bst* total=new bst;
	total-&gt;data=0;
	
	  root = newNode(10);
    root-&gt;lchild = newNode(-2);
    root-&gt;rchild = newNode(7);
    root-&gt;lchild-&gt;lchild = newNode(8);
    root-&gt;lchild-&gt;rchild = newNode(-4);
   int a[2];
    a[0]=root-&gt;data;
	
	preorder(root,total,a,0);
cout&lt;&lt;&quot;\nmaximum path is:&quot;&lt;&lt;total-&gt;data;
cout&lt;&lt;&quot;\nthe maximum path is between &quot;&lt;&lt;a[0]&lt;&lt;&quot; &amp; &quot;&lt;&lt;a[1];



}
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-17316">
        <div id="dsq-comment-header-17316" class="dsq-comment-header">
            <cite id="dsq-cite-17316">
                <span id="dsq-author-user-17316">ishanu</span>
            </cite>
        </div>
        <div id="dsq-comment-body-17316" class="dsq-comment-body">
            <div id="dsq-comment-message-17316" class="dsq-comment-message"><p>a minor change to the above code</p>
<pre> <code language="C">
#include &lt;iostream&gt;
//to find the maximum distance between root and a leaf
using namespace std;

struct bst
{
	int data;
	bst *lchild;
	bst *rchild;
};
bst* root=NULL;
bst* total=NULL;
bst* newNode(int num)
{
	bst*node= new bst;
	node-&gt;data=num;
	node-&gt;lchild=NULL;
	node-&gt;rchild=NULL;
	return node;
}

void preorder(bst *node,bst *total,int a[2],int sum)
{
    if(node==NULL)
		return;
    
    sum=sum+node-&gt;data;
    if(sum&gt;total-&gt;data&amp;&amp;node-&gt;lchild==NULL&amp;&amp;node-&gt;rchild==NULL)
    {
		total-&gt;data=sum;
		a[1]=node-&gt;data;
	}
    preorder(node-&gt;lchild,total,a,sum);
 
   preorder(node-&gt;rchild,total,a,sum);
 
   
}



int main()
{
	bst* total=new bst;
	total-&gt;data=0;
	
	  root = newNode(10);
    root-&gt;lchild = newNode(6);
    root-&gt;rchild = newNode(7);
    root-&gt;lchild-&gt;lchild = newNode(8);
    root-&gt;lchild-&gt;rchild = newNode(-4);
   int a[2];
    a[0]=root-&gt;data;
	
	preorder(root,total,a,0);
cout&lt;&lt;&quot;\nmaximum path is:&quot;&lt;&lt;total-&gt;data;
cout&lt;&lt;&quot;\nthe maximum path is between &quot;&lt;&lt;a[0]&lt;&lt;&quot; &amp; &quot;&lt;&lt;a[1];



}

</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even depth-2" id="dsq-comment-17317">
        <div id="dsq-comment-header-17317" class="dsq-comment-header">
            <cite id="dsq-cite-17317">
                <span id="dsq-author-user-17317">ishanu</span>
            </cite>
        </div>
        <div id="dsq-comment-body-17317" class="dsq-comment-body">
            <div id="dsq-comment-message-17317" class="dsq-comment-message"><p>a minor change to the above code</p>
<pre> <code language="C">
#include &lt;iostream&gt;
//to find the maximum distance between root and a leaf
using namespace std;

struct bst
{
	int data;
	bst *lchild;
	bst *rchild;
};
bst* root=NULL;

bst* newNode(int num)
{
	bst*node= new bst;
	node-&gt;data=num;
	node-&gt;lchild=NULL;
	node-&gt;rchild=NULL;
	return node;
}

void preorder(bst *node,bst *total,int a[2],int sum)
{
    if(node==NULL)
		return;
    
    sum=sum+node-&gt;data;
    if(sum&gt;total-&gt;data&amp;&amp;node-&gt;lchild==NULL&amp;&amp;node-&gt;rchild==NULL)
    {
		total-&gt;data=sum;
		a[1]=node-&gt;data;
	}
    preorder(node-&gt;lchild,total,a,sum);
 
   preorder(node-&gt;rchild,total,a,sum);
 
   
}



int main()
{
	bst* total=new bst;
	total-&gt;data=0;
	
	  root = newNode(10);
    root-&gt;lchild = newNode(6);
    root-&gt;rchild = newNode(7);
    root-&gt;lchild-&gt;lchild = newNode(8);
    root-&gt;lchild-&gt;rchild = newNode(-4);
   int a[2];
    a[0]=root-&gt;data;
	
	preorder(root,total,a,0);
cout&lt;&lt;&quot;\nmaximum path is:&quot;&lt;&lt;total-&gt;data;
cout&lt;&lt;&quot;\nthe maximum path is between &quot;&lt;&lt;a[0]&lt;&lt;&quot; &amp; &quot;&lt;&lt;a[1];



}

</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-16262">
        <div id="dsq-comment-header-16262" class="dsq-comment-header">
            <cite id="dsq-cite-16262">
                <span id="dsq-author-user-16262">sirisha</span>
            </cite>
        </div>
        <div id="dsq-comment-body-16262" class="dsq-comment-body">
            <div id="dsq-comment-message-16262" class="dsq-comment-message"><pre> <code language="C">
main()
{
struct node *root=NULL;
root=newnode(10);
root-&gt;left=newnode(-2);
root-&gt;right=newnode(7);
root-&gt;left-&gt;left=newnode(8);
root-&gt;left-&gt;right=newnode(-4);
print_max_sum_path(root);
}
struct node* newnode(int n)
{
struct node *nu;
nu=(struct node*)malloc(sizeof(struct node));
nu-&gt;data=n;
nu-&gt;left=NULL;
nu-&gt;right=NULL;
return nu;
}
int max_sum_path(struct node *root)
{
if(root==NULL)
  return;

if(root-&gt;left==NULL &amp;&amp; root-&gt;right==NULL)
   return root-&gt;data;

int ls,rs;

ls=max_sum_path(root-&gt;left);
rs=max_sum_path(root-&gt;right);

if(ls&gt;rs)
return ls+root-&gt;data ;
else
return rs+root-&gt;data;
}

void print_max_sum_path(struct node *root)
{
if(root==NULL)
  return;

if(root-&gt;left==NULL &amp;&amp; root-&gt;right==NULL)
  {
   printf(&quot;%d &quot;,root-&gt;data);
   return;
  }

int ls,rs;

ls=max_sum_path(root-&gt;left);
rs=max_sum_path(root-&gt;right);

if(ls&gt;rs)
print_max_sum_path(root-&gt;left);
else
print_max_sum_path(root-&gt;right);

printf(&quot;%d &quot;,root-&gt;data);
}

                                                                                                                                   
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-14321">
        <div id="dsq-comment-header-14321" class="dsq-comment-header">
            <cite id="dsq-cite-14321">
                <span id="dsq-author-user-14321">Karthik</span>
            </cite>
        </div>
        <div id="dsq-comment-body-14321" class="dsq-comment-body">
            <div id="dsq-comment-message-14321" class="dsq-comment-message"><p>How about simple postorder traversal?</p>
<p>class Node<br />
{<br />
public:<br />
	Node* left;<br />
	Node* right;<br />
	int data;<br />
	Node(int data, Node*right = NULL, Node* left = NULL):data(data),right(right),left(left){};<br />
};<br />
int postorderSum(Node* root, vector&lt;int&gt; &amp;list)<br />
{<br />
	if(!root)<br />
		return 0;</p>
<p>	vector&lt;int&gt; rightList, leftList;<br />
	int	rightSum =  postorderSum(root-&gt;right, rightList);<br />
	int	leftSum = postorderSum(root-&gt;left, leftList);</p>
<p>	int result = 0;</p>
<p>	if(rightSum &gt; leftSum)<br />
	{<br />
		list = rightList;<br />
		list.push_back(root-&gt;data);<br />
		result = rightSum + root-&gt;data;<br />
	}<br />
	else<br />
	{<br />
		list = leftList;<br />
		list.push_back(root-&gt;data);<br />
		result = leftSum + root-&gt;data;<br />
	}</p>
<p>	return result;<br />
}</p>
<p>void maxSumLeaf(Node* root)<br />
{<br />
	if(!root)<br />
		return;</p>
<p>	vector&lt;int&gt; list;<br />
	int sum = postorderSum(root,list);</p>
<p>	cout &lt;&lt; &quot;Sum is &quot; &lt;&lt; sum &lt;&lt; endl;<br />
	for(vector&lt;int&gt;::iterator it = list.begin(); it != list.end(); ++it)<br />
		cout&lt;&lt;*it&lt;&lt;&quot; &quot;;<br />
}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-11059">
        <div id="dsq-comment-header-11059" class="dsq-comment-header">
            <cite id="dsq-cite-11059">
                <span id="dsq-author-user-11059">Nikhil</span>
            </cite>
        </div>
        <div id="dsq-comment-body-11059" class="dsq-comment-body">
            <div id="dsq-comment-message-11059" class="dsq-comment-message"><p>#include&lt;iostream&gt;<br />
using namespace std;<br />
#include&lt;stdio.h&gt;<br />
#include&lt;stdlib.h&gt;<br />
struct node<br />
{<br />
    int info;<br />
    struct node *left;<br />
    struct node *right;<br />
};<br />
typedef struct node *nodeptr;</p>
<p>nodeptr head=NULL;<br />
nodeptr maketree(int x)<br />
{<br />
    nodeptr p;<br />
    p=(nodeptr)malloc(sizeof(struct node));<br />
    p-&gt;info=x;<br />
    p-&gt;left=NULL;<br />
    p-&gt;right=NULL;<br />
    return p;<br />
}<br />
int maxSum(nodeptr root)<br />
{</p>
<p>    int max;</p>
<p>    if(root==NULL)<br />
    return 0;</p>
<p>    int a=maxSum(root-&gt;left)+root-&gt;info;<br />
    int b=maxSum(root-&gt;right)+root-&gt;info;</p>
<p>    if(a&gt;b)<br />
    max=a;<br />
    else<br />
    max=b;</p>
<p>    return max;<br />
}<br />
int main()<br />
{<br />
    nodeptr root=maketree(10);<br />
    root-&gt;left=maketree(-2);<br />
    root-&gt;right=maketree(7);<br />
    root-&gt;left-&gt;left=maketree(8);<br />
    root-&gt;left-&gt;right=maketree(-4);<br />
    root-&gt;right-&gt;left=maketree(6);<br />
    root-&gt;right-&gt;right=maketree(8);</p>
<p>    cout&lt;&lt;maxSum(root);</p>
<p>    return 0;<br />
}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-9602">
        <div id="dsq-comment-header-9602" class="dsq-comment-header">
            <cite id="dsq-cite-9602">
                <span id="dsq-author-user-9602">RJ</span>
            </cite>
        </div>
        <div id="dsq-comment-body-9602" class="dsq-comment-body">
            <div id="dsq-comment-message-9602" class="dsq-comment-message"><pre> <code language="C">
#include &lt;iostream&gt;
#include&lt;string&gt;
#include&lt;cstdlib&gt;
using namespace std;

struct node
{
    int data;
    struct node *left;
    struct node *right;
};
void PrintMaxSum(struct node* , int , int&amp;  , string , string&amp;);
void Print(struct node* root)
{
	int sum = 0;
	int maxsum = 0;
	string path =&quot;&quot;;
	string maxpath=&quot;&quot;;
	PrintMaxSum(root, sum,maxsum, path, maxpath);
	cout&lt;&lt;&quot;maxpath is &quot;&lt;&lt;maxpath&lt;&lt;endl;
	cout&lt;&lt;&quot;maxsum is&quot;&lt;&lt;maxsum&lt;&lt;endl;
}

void PrintMaxSum(struct node* root, int sum, int&amp; maxsum , string path, string&amp; maxpath)
{
	
	if(root==NULL)
		return;
	else if(root-&gt;left==NULL &amp;&amp; root-&gt;right==NULL)
	{
		sum+=root-&gt;data;
		path+=itoa(root-&gt;data);
		if(sum &gt; maxsum)
		{
			maxsum = sum;
			maxpath = path;
		}
	}
	else
	{
	   sum+=root-&gt;data;
	   path+=itoa(root-&gt;data);
	   PrintMaxSum(root-&gt;left, sum, maxsum,path,maxpath);
	   PrintMaxSum(root-&gt;right, sum, maxsum, path,maxpath);
	}
	
}

struct node* newNode (int data)
{
    struct node *temp = new struct node;
    temp-&gt;data = data;
    temp-&gt;left = NULL;
    temp-&gt;right = NULL;
    return temp;
}

int main (int argc, char * const argv[]) {
    // insert code here...
	
    struct node *root = NULL;
    root = newNode(10);
    root-&gt;left = newNode(-2);
    root-&gt;right = newNode(7);
    root-&gt;left-&gt;left = newNode(8);
    root-&gt;left-&gt;right = newNode(-4);
	Print(root);
    
	
	return 0;
}
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-9551">
        <div id="dsq-comment-header-9551" class="dsq-comment-header">
            <cite id="dsq-cite-9551">
                <span id="dsq-author-user-9551">Kundan</span>
            </cite>
        </div>
        <div id="dsq-comment-body-9551" class="dsq-comment-body">
            <div id="dsq-comment-message-9551" class="dsq-comment-message"><p>Sir, The explanation is good. But if the solution for the problem is little bit in an elaborated way, it would be good for a learner to understand in a crystal clear way. apologies if my idea doesnt fit here.</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-9540">
        <div id="dsq-comment-header-9540" class="dsq-comment-header">
            <cite id="dsq-cite-9540">
                <span id="dsq-author-user-9540">RameshSuthan</span>
            </cite>
        </div>
        <div id="dsq-comment-body-9540" class="dsq-comment-body">
            <div id="dsq-comment-message-9540" class="dsq-comment-message"><p>int maxSumtoLeaf(tnodeptr node,int sum,char *decisionTree,int nodePos)<br />
{<br />
	if(node==NULL)<br />
	{<br />
		return sum;<br />
	}</p>
<p>        int nodesum = sum + node-&gt;val;<br />
	int leftSum  = maxSumtoLeaf(node-&gt;left,nodesum,decisionTree,left(nodePos));<br />
	int rightSum =  maxSumtoLeaf(node-&gt;right,nodesum,decisionTree,right(nodePos));</p>
<p>	decisionTree[nodePos]= (leftSum &gt; rightSum)? &#8216;L&#8217; : &#8216;R';<br />
	int max =  ( leftSum &gt; rightSum ) ? leftSum : rightSum ;</p>
<p>	return max;<br />
}</p>
<p>void printMaxSumPath(tnodeptr node,char* decisionTree,int index)<br />
{<br />
	char decision= decisionTree[index];</p>
<p>	if(node==NULL)<br />
		return;</p>
<p>	printf(&#8220;-&gt; %d&#8221;,node-&gt;val);</p>
<p>	if(decision==&#8217;L&#8217;)<br />
	{<br />
		printMaxSumPath(node-&gt;left,decisionTree,left(index));<br />
	}<br />
	else<br />
	{<br />
		printMaxSumPath(node-&gt;right,decisionTree,right(index));<br />
	}</p>
<p>}</p>
<p>int left(int i)<br />
{<br />
	return (2*i+1);<br />
}</p>
<p>int right(int i)<br />
{<br />
	return (2*i+2);<br />
}</p>
<p>int main()<br />
{<br />
	//treesize -&gt; 2^ height of the tree<br />
	char* decisionTree = (char *) malloc(treesize * sizeof(char));<br />
	maxsum = maxSumtoLeaf(root,0,decisionTree,0);<br />
	printf(&#8220;\n\n maximum sum leaf to root path : %d \n\n&#8221;,maxsum);<br />
	printf(&#8220;DecisionTree : %s \n&#8221;,decisionTree);<br />
	printMaxSumPath(root,decisionTree,0);</p>
<p>	return 0;</p>
<p>}</p>
<p>//this program uses extra space to store the decision -&gt; 2^ height of the tree<br />
//can be optimized by not storing the leaf node decision.<br />
//Further can be optimized as Single bit is enough to store the decision<br />
    	1<br />
      /    \<br />
     2      3<br />
   /   \   /   \<br />
  4     5  9    7<br />
maximum sum leaf to root path: 13<br />
DecisionTree : RRLRRRR<br />
-&gt; 1-&gt; 3-&gt; 9</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-9539">
        <div id="dsq-comment-header-9539" class="dsq-comment-header">
            <cite id="dsq-cite-9539">
                <span id="dsq-author-user-9539">RameshSuthan</span>
            </cite>
        </div>
        <div id="dsq-comment-body-9539" class="dsq-comment-body">
            <div id="dsq-comment-message-9539" class="dsq-comment-message"><pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
int maxSumtoLeaf(tnodeptr node,int sum,char *decisionTree,int nodePos)
{
	if(node==NULL)
	{
		return sum;
	}
	
        int nodesum = sum + node-&gt;val;
	int leftSum  = maxSumtoLeaf(node-&gt;left,nodesum,decisionTree,left(nodePos));
	int rightSum =  maxSumtoLeaf(node-&gt;right,nodesum,decisionTree,right(nodePos));
	
	decisionTree[nodePos]= (leftSum &gt; rightSum)? 'L' : 'R';
	int max =  ( leftSum &gt; rightSum ) ? leftSum : rightSum ;

	return max;
}


void printMaxSumPath(tnodeptr node,char* decisionTree,int index)
{
	char decision= decisionTree[index];

	if(node==NULL)
		return;
	
	printf(&quot;-&gt; %d&quot;,node-&gt;val);

	if(decision=='L') 
	{
		printMaxSumPath(node-&gt;left,decisionTree,left(index));
	}
	else
	{
		printMaxSumPath(node-&gt;right,decisionTree,right(index));
	}

}

int left(int i)
{
	return (2*i+1);
}

int right(int i)
{
	return (2*i+2);
}

int main()
{
	//treesize -&gt; 2^ height of the tree
	char* decisionTree = (char *) malloc(treesize * sizeof(char));
	maxsum = maxSumtoLeaf(root,0,decisionTree,0);
	printf(&quot;\n\n maximum sum leaf to root path : %d \n\n&quot;,maxsum);
	printf(&quot;DecisionTree : %s \n&quot;,decisionTree);
	printMaxSumPath(root,decisionTree,0);

	return 0;

}

//this program uses extra space to store the decision -&gt; 2^ height of the tree
//can be optimized by not storing the leaf node decision.
//Further can be optimized as Single bit is enough to store the decision 
    	1
      /    \
     2      3
   /   \   /   \
  4     5  9    7
maximum sum leaf to root path: 13   
DecisionTree : RRLRRRR 
-&gt; 1-&gt; 3-&gt; 9
 
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-9537">
        <div id="dsq-comment-header-9537" class="dsq-comment-header">
            <cite id="dsq-cite-9537">
                <span id="dsq-author-user-9537">Robin</span>
            </cite>
        </div>
        <div id="dsq-comment-body-9537" class="dsq-comment-body">
            <div id="dsq-comment-message-9537" class="dsq-comment-message"><p>Thanks</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-9535">
        <div id="dsq-comment-header-9535" class="dsq-comment-header">
            <cite id="dsq-cite-9535">
                <span id="dsq-author-user-9535">Ramesh Suthan</span>
            </cite>
        </div>
        <div id="dsq-comment-body-9535" class="dsq-comment-body">
            <div id="dsq-comment-message-9535" class="dsq-comment-message"><pre> <code language="C">
int maxSumtoLeaf(tnodeptr node,int sum,char *decisionTree,int nodePos)
{
	if(node==NULL)
	{
		return sum;
	}
	
        int nodesum = sum + node-&gt;val;
	int leftSum  = maxSumtoLeaf(node-&gt;left,nodesum,decisionTree,left(nodePos));
	int rightSum =  maxSumtoLeaf(node-&gt;right,nodesum,decisionTree,right(nodePos));
	
	decisionTree[nodePos]= (leftSum &gt; rightSum)? 'L' : 'R';
	int max =  ( leftSum &gt; rightSum ) ? leftSum : rightSum ;

	return max;
}


void printMaxSumPath(tnodeptr node,char* decisionTree,int index)
{
	char decision= decisionTree[index];

	if(node==NULL)
		return;
	
	printf(&quot;-&gt; %d&quot;,node-&gt;val);

	if(decision=='L') 
	{
		printMaxSumPath(node-&gt;left,decisionTree,left(index));
	}
	else
	{
		printMaxSumPath(node-&gt;right,decisionTree,right(index));
	}

}

int left(int i)
{
	return (2*i+1);
}

int right(int i)
{
	return (2*i+2);
}

int main()
{
	//treesize -&gt; 2^ height of the tree
	char* decisionTree = (char *) malloc(treesize * sizeof(char));
	maxsum = maxSumtoLeaf(root,0,decisionTree,0);
	printf(&quot;\n\n maximum sum leaf to root path : %d \n\n&quot;,maxsum);
	printf(&quot;DecisionTree : %s \n&quot;,decisionTree);
	printMaxSumPath(root,decisionTree,0);
	printf(&quot;\n&quot;);

	return 0;

}

//this program uses extra space to store the decision -&gt; 2^ height of the tree
//can be optimized by not storing the leaf node decision.
//Further can be optimized as Single bit is enough to store the decision 
    	1
      /    \
     2      3
   /   \   /   \
  4     5  9    7
maximum sum leaf to root path: 13   
DecisionTree : RRLRRRR 
-&gt; 1-&gt; 3-&gt; 9
 
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-9281">
        <div id="dsq-comment-header-9281" class="dsq-comment-header">
            <cite id="dsq-cite-9281">
                <span id="dsq-author-user-9281">Shipra Agrawal</span>
            </cite>
        </div>
        <div id="dsq-comment-body-9281" class="dsq-comment-body">
            <div id="dsq-comment-message-9281" class="dsq-comment-message"><p>I too have a recursive method which also prints the path from leaf to root.</p>
<pre> <code language="C">

#include&lt;stdio.h&gt;
#include&lt;conio.h&gt;
#include&lt;iostream.h&gt;
#include&lt;stdlib.h&gt;
void createbst(int,struct tree**);
int maxsump(struct tree*);
int max(int,int);
struct tree{
		int val;
		struct tree* left;
		struct tree* right;
		};
void main()
{
	clrscr();
	int ch=0,val;
	struct tree* root1=NULL,*root2=NULL;
	cout&lt;&lt;&quot;enter elements of 1st bst&quot;;
	do{
		cout&lt;&lt;&quot;enter&quot;;
		cin&gt;&gt;val;
		createbst(val,&amp;root1);
		cout&lt;&lt;&quot;want more?&quot;;
		cin&gt;&gt;ch;
		}while(ch==1);

	int x = maxsump(root1);
	cout&lt;&lt;&quot;path from leaf to root is &quot;;
	cout&lt;&lt;&quot;\n&quot;&lt;&lt;root1-&gt;val;
	cout&lt;&lt;&quot;\nsum is &quot;&lt;&lt;x;


	getch();
}

void createbst(int val,struct tree** root)
{
	struct tree* t=(struct tree*)malloc(sizeof(struct tree));
	t-&gt;val=val;
	t-&gt;left=NULL;
	t-&gt;right=NULL;
	struct tree* ptr=*root,*par;
	char child='c';
	if(*root==NULL)
		*root=t;

	while(ptr!=NULL)
	{
		if(val&lt;ptr-&gt;val)
		{
			par=ptr;
			ptr=ptr-&gt;left;
			child='l';
		}
		else if(val&gt;ptr-&gt;val)
		{
			par=ptr;
			ptr=ptr-&gt;right;
			child='r';
		}
	}
	if(child=='l')
		par-&gt;left=t;
	else if(child=='r')
		par-&gt;right=t;
}


int maxsump(struct tree* ptr)
{
	if(ptr==NULL)
		return 0;

		int temp1=maxsump(ptr-&gt;left);
		int temp2=maxsump(ptr-&gt;right);
		int temp=max(temp1,temp2);
		if(temp!=0)
		{
			if(temp==temp1)
				cout&lt;&lt;&quot;\n &quot;&lt;&lt;ptr-&gt;left-&gt;val;
			else
				cout&lt;&lt;&quot; \n&quot;&lt;&lt;ptr-&gt;right-&gt;val;
		}
		return(ptr-&gt;val+temp);
}

int max(int a,int b)
{
	if(a&gt;b)
	{

	return a;
	}
	else
	{

	return b;
	}

}



</code> </pre>
<p>Thanks,<br />
Shipra</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-31418">
        <div id="dsq-comment-header-31418" class="dsq-comment-header">
            <cite id="dsq-cite-31418">
                <span id="dsq-author-user-31418">Sreenivas</span>
            </cite>
        </div>
        <div id="dsq-comment-body-31418" class="dsq-comment-body">
            <div id="dsq-comment-message-31418" class="dsq-comment-message"><p>This is simple and good <img src="http://d2o58evtke57tz.cloudfront.net/wp-includes/images/smilies/icon_smile.gif" alt=":)" class="wp-smiley" /></p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-9128">
        <div id="dsq-comment-header-9128" class="dsq-comment-header">
            <cite id="dsq-cite-9128">
                <span id="dsq-author-user-9128">Anil arya</span>
            </cite>
        </div>
        <div id="dsq-comment-body-9128" class="dsq-comment-body">
            <div id="dsq-comment-message-9128" class="dsq-comment-message"><p>/* Paste your code here (You may delete these lines if not writing code) */<br />
[/ void  max_sum(struct node *root,int *max)<br />
{<br />
            if(root==NULL)<br />
                return  ;</p>
<p>            if(root-&gt;left==NULL&amp;&amp;root-&gt;right==NULL)<br />
            {<br />
                    if(root-&gt;data&gt;*max)<br />
                        *max=root-&gt;data;</p>
<p>            }</p>
<p>            if(root-&gt;left)<br />
                root-&gt;left-&gt;data+=root-&gt;data;</p>
<p>            if(root-&gt;right)<br />
                root-&gt;right-&gt;data+=root-&gt;data;</p>
<p>               max_sum(root-&gt;left,max);<br />
               max_sum(root-&gt;right,max);</p>
<p>    }<br />
       ]</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-9165">
        <div id="dsq-comment-header-9165" class="dsq-comment-header">
            <cite id="dsq-cite-9165">
                <span id="dsq-author-user-9165">xerox</span>
            </cite>
        </div>
        <div id="dsq-comment-body-9165" class="dsq-comment-body">
            <div id="dsq-comment-message-9165" class="dsq-comment-message"><p>this code changes the tree structure and doesn&#8217;t prints path</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-9120">
        <div id="dsq-comment-header-9120" class="dsq-comment-header">
            <cite id="dsq-cite-9120">
                <span id="dsq-author-user-9120">Algogeek</span>
            </cite>
        </div>
        <div id="dsq-comment-body-9120" class="dsq-comment-body">
            <div id="dsq-comment-message-9120" class="dsq-comment-message"><p>we can print from root to leaf by little modification in the print_path() function.</p>
<pre> <code language="C">

int array[20]={0};
int path_print(struct node* root,struct node* targetleaf)
{
    static int i=0;
    if(root==NULL)
        return 0;
    if((root==targetleaf)||path_print(root-&gt;left,targetleaf)||path_print(root-&gt;right,targetleaf))
    {
        array[i++]= root-&gt;data;
        return i;
    }
return 0;
}

</code> </pre>
<p>In the main function, we can print the array elements from i-1 to 0. This will be path from root to node.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-9143">
        <div id="dsq-comment-header-9143" class="dsq-comment-header">
            <cite id="dsq-cite-9143">
                <span id="dsq-author-user-9143">red</span>
            </cite>
        </div>
        <div id="dsq-comment-body-9143" class="dsq-comment-body">
            <div id="dsq-comment-message-9143" class="dsq-comment-message"><p>Yeah nice . <img src="http://d2o58evtke57tz.cloudfront.net/wp-includes/images/smilies/icon_smile.gif" alt=":)" class="wp-smiley" /></p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-9097">
        <div id="dsq-comment-header-9097" class="dsq-comment-header">
            <cite id="dsq-cite-9097">
                <span id="dsq-author-user-9097">Arpit</span>
            </cite>
        </div>
        <div id="dsq-comment-body-9097" class="dsq-comment-body">
            <div id="dsq-comment-message-9097" class="dsq-comment-message"><pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code)
#include&lt;stdio.h&gt;
#include&lt;limits.h&gt;

struct node
{
       int data;
       struct node *left;
       struct node *right;
}*root;

struct node *newNode(int key)
{
       struct node*tmp=(struct node*)malloc(sizeof(struct node));
       tmp-&gt;left=NULL;
       tmp-&gt;right=NULL;
       tmp-&gt;data=key;
       return tmp;
}

    int prevsum=INT_MIN;
    int a[100],arr[100],sum=0,x;
       
maxsum_leafroot(struct node *root,int a[],int n,int sum)
{
                       int i;
                       if(root==NULL) return;
                       a[n++]=root-&gt;data;
                       sum+=root-&gt;data;
                       if(root-&gt;left==NULL &amp;&amp; root-&gt;right==NULL)
                       {
                                          // printf(&quot;\nsum=%d prevsum=%d&quot;,sum,prevsum);
                                           if(sum&gt;prevsum)
                                           {
                                             prevsum=sum;
                                           for(i=0;i&lt;n;i++)
                                              arr[i]=a[i];
                                              x=n;
                                           }  
                                              
                       }
 maxsum_leafroot(root-&gt;left,a,n,sum);                         
 maxsum_leafroot(root-&gt;right,a,n,sum);      
}     
                
                
displaytree(struct node *root)
{
               if(root==NULL) return;
               displaytree(root-&gt;left);
               printf(&quot;%d &quot;,root-&gt;data);
               displaytree(root-&gt;right);
}


    
int main()
{
    /* Let us construct the following Tree
          50
       /      \
     10        60
    /  \       /  \
   5   20    75    70
            /     /  \
          85     65    80
  */
 
  struct node *root = newNode(50);
  root-&gt;left        = newNode(10);
  root-&gt;right       = newNode(60);
  root-&gt;left-&gt;left  = newNode(5);
  root-&gt;left-&gt;right = newNode(20);
  root-&gt;right-&gt;left  = newNode(75);
  root-&gt;right-&gt;left-&gt;left  = newNode(85);
  root-&gt;right-&gt;right = newNode(70);
  root-&gt;right-&gt;right-&gt;left = newNode(65);
  root-&gt;right-&gt;right-&gt;right = newNode(80);
      
     maxsum_leafroot(root,a,0,0);
      int i;
      printf(&quot;\n Maximum sum is : %d&quot;,prevsum);
      printf(&quot;\n Nodes are leaf to root are:&quot;);
     for(i=x-1;i&gt;=0;i--)
       printf(&quot;%d &quot;,arr[i]);
      
      getchar();
}
 */
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-8318">
        <div id="dsq-comment-header-8318" class="dsq-comment-header">
            <cite id="dsq-cite-8318">
                <span id="dsq-author-user-8318">bobby</span>
            </cite>
        </div>
        <div id="dsq-comment-body-8318" class="dsq-comment-body">
            <div id="dsq-comment-message-8318" class="dsq-comment-message"><p>I found a recursive solution that uses extra memory to track and print the path.<br />
<a href="http://www.codingissue.com/QuestionSearch.aspx?id=PrintMaxSumPath" rel="nofollow">http://www.codingissue.com/QuestionSearch.aspx?id=PrintMaxSumPath</a></p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-8293">
        <div id="dsq-comment-header-8293" class="dsq-comment-header">
            <cite id="dsq-cite-8293">
                <span id="dsq-author-user-8293">ani</span>
            </cite>
        </div>
        <div id="dsq-comment-body-8293" class="dsq-comment-body">
            <div id="dsq-comment-message-8293" class="dsq-comment-message"><p>i need code to draw parse tree</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-8215">
        <div id="dsq-comment-header-8215" class="dsq-comment-header">
            <cite id="dsq-cite-8215">
                <span id="dsq-author-user-8215">Gautam</span>
            </cite>
        </div>
        <div id="dsq-comment-body-8215" class="dsq-comment-body">
            <div id="dsq-comment-message-8215" class="dsq-comment-message"><pre> <code language="C">
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;limits.h&gt;
 
/* A binary tree node has data, pointer to left child
   and a pointer to right child */
struct node
{
   int data;
   struct node* left;
   struct node* right;
};
 
 //static int maxsum=INT_MIN;
 int maxpath[1000];
 int maxsumlen=0;
/* Prototypes for funtions needed in printPaths() */
void printPathsRecur(struct node* node, int path[], int pathLen);
void printArray(int ints[], int len);
 
/*Given a binary tree, print out all of its root-to-leaf
 paths, one per line. Uses a recursive helper to do the work.*/
void printPaths(struct node* node)
{
  int path[1000];
   printPathsRecur(node, path, 0);
}
 
/* Recursive helper function -- given a node, and an array containing
 the path from the root node up to but not including this node,
 print out all the root-leaf paths.*/
void printPathsRecur(struct node* node, int path[], int pathLen)
{
  if (node==NULL)
    return;
 
  /* append this node to the path array */
  path[pathLen] = node-&gt;data;
  pathLen++;
  /* it's a leaf, so print the path that led to here  */
  if (node-&gt;left==NULL &amp;&amp; node-&gt;right==NULL)
  {
    printArray(path, pathLen);
  }
  else
  {
    /* otherwise try both subtrees */
    printPathsRecur(node-&gt;left, path, pathLen);
    printPathsRecur(node-&gt;right, path, pathLen);
  }
}
 
/* UTILITY FUNCTIONS */
/* Utility that prints out an array on a line. */
void printArray(int ints[], int len)
{
  static int maxsum=INT_MIN;
  int i;
  int sum=0;
  for (i=0; i&lt;len; i++)
  {
    sum+=ints[i];
  }
  
  if(maxsum &lt; sum)
  {
    maxsum=sum;
    for (i=0; i&lt;len; i++)
     {
      maxpath[i]=ints[i];
     }
    maxsumlen=len; 
  }
}   
 
int PrintMaxPath()
{
 int i;
 int sum=0;
 for (i=0; i&lt;maxsumlen; i++)
  {
    sum+=maxpath[i];
    printf(&quot;%d &quot;, maxpath[i]);
  }
  printf(&quot;\n&quot;);
  return sum;
} 
/* utility that allocates a new node with the
   given data and NULL left and right pointers. */
struct node* newNode(int data)
{
  struct node* node = (struct node*)
                       malloc(sizeof(struct node));
  node-&gt;data = data;
  node-&gt;left = NULL;
  node-&gt;right = NULL;
 
  return(node);
}
 
/* Driver program to test above functions*/
int main()
{
   struct node *root = NULL;
   
    /* Constructing tree given in the above figure */
    root = newNode(10);
    root-&gt;left = newNode(-2);
    root-&gt;right = newNode(7);
    root-&gt;left-&gt;left = newNode(8);
    root-&gt;left-&gt;right = newNode(-4);
 
    printf (&quot;Following are the nodes on the maximum sum path \n&quot;);
    printPaths(root);
    int sum= PrintMaxPath();
    printf (&quot;Sum of the nodes is %d &quot;, sum);
    getchar();
    return 0;
}
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-sambasiva even thread-odd thread-alt depth-1" id="dsq-comment-8012">
        <div id="dsq-comment-header-8012" class="dsq-comment-header">
            <cite id="dsq-cite-8012">
http://effprog.blogspot.com                <span id="dsq-author-user-8012">Sambasiva</span>
            </cite>
        </div>
        <div id="dsq-comment-body-8012" class="dsq-comment-body">
            <div id="dsq-comment-message-8012" class="dsq-comment-message"><p><a href="<br />
http://effprog.blogspot.com/2011/06/print-path-of-minimum-sum-in-binary.html">http://effprog.blogspot.com/2011/06/print-path-of-minimum-sum-in-binary.html</a></p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-nishantssj odd alt thread-even depth-1" id="dsq-comment-7999">
        <div id="dsq-comment-header-7999" class="dsq-comment-header">
            <cite id="dsq-cite-7999">
                <span id="dsq-author-user-7999">Daddy</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7999" class="dsq-comment-body">
            <div id="dsq-comment-message-7999" class="dsq-comment-message"><pre> <code language="C">
#include&lt;stdio.h&gt;
#include&lt;conio.h&gt;
#include&lt;malloc.h&gt;

struct node{
       int data;
       struct node* left;
       struct node* right;
       };
int maxsum,k;       
int d[10];
struct node* insert(struct node* ,int );
struct node* newnode(int );
void preorder(struct node*);
void printmaxpath(struct node* );
void checkallpaths(struct node*,int [],int);
void maxpath(struct node*,int [],int);
void printpath(int [],int);

int main()
{
    struct node *root = newnode(9);
  root-&gt;left        = newnode(5);
 root-&gt;right       = newnode(10);
  root-&gt;left-&gt;left  = newnode(4);
  root-&gt;left-&gt;left-&gt;left  = newnode(3);
  root-&gt;right-&gt;right = newnode(11);
  root=insert(root,7);
  root=insert(root,6);
    preorder(root);
    printmaxpath(root);
    getch();
    return 0;
}

struct node* newnode(int data)
{
       struct node* node=(struct node*)malloc(sizeof(struct node));
       node-&gt;data=data;
       node-&gt;left=NULL;
       node-&gt;right=NULL;
       return node;
}

struct node* insert(struct node* node,int n)
{
       if(node==NULL)
       return(newnode(n));
       else
       {
           if(n&lt;=node-&gt;data)
           node-&gt;left=insert(node-&gt;left,n);
           else
           node-&gt;right=insert(node-&gt;right,n);
           return node;
       }
}          

void preorder(struct node* node)
{
     if(node==NULL)
     return;
         
         printf(&quot;%d &quot;,node-&gt;data);
         preorder(node-&gt;left);
         preorder(node-&gt;right);
         
}

void printmaxpath(struct node *root)
{
     int arr[10],i;
     checkallpaths(root,arr,0);
     printf(&quot;\nThe sum is %d\n&quot;,maxsum);
     for(i=0;i&lt;k;i++)
     printf(&quot;%d &quot;,d[i]);
}

void checkallpaths(struct node* node,int arr[],int i)
{
     if(node==NULL)
     return;
     arr[i++]=node-&gt;data;
     if((node-&gt;left==NULL)&amp;&amp;(node-&gt;right==NULL))
     maxpath(node,arr,i);
     else
     {
     checkallpaths(node-&gt;left,arr,i);
     checkallpaths(node-&gt;right,arr,i);
     }
}

void maxpath(struct node* node,int arr[],int i)
{
     int j,sum=0;
     for(j=0;j&lt;i;j++)
     sum+=arr[j];
     if(sum&gt;maxsum)
     {
     maxsum=sum;
     k=i;
     for(j=0;j&lt;i;j++)
     d[j]=arr[j];
     }
}

void printpath(int arr[],int i)
{
     int j;
          printf(&quot;\nThere is but one path...\n&quot;);
     for(j=0;j&lt;i;j++)
     {                
     printf(&quot;%d &quot;,arr[j]);
     }
     printf(&quot;\n&quot;);
}

</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-akshayjohri even thread-odd thread-alt depth-1" id="dsq-comment-7998">
        <div id="dsq-comment-header-7998" class="dsq-comment-header">
            <cite id="dsq-cite-7998">
                <span id="dsq-author-user-7998">akshayjohri</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7998" class="dsq-comment-body">
            <div id="dsq-comment-message-7998" class="dsq-comment-message"><pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
int max=0;
char *maxdir=&quot;&quot;;
char *curdir=&quot;&quot;;
void push(char ch){
curdir[++top]=ch;
}
char pop(){
return curdir[top--];
}

void maxpath(Node root,int val,char dir){
    if(root==NULL) return 0;
    root-&gt;val= root-&gt;val + val;
    push(dir);
    if(root-&gt;val&gt;max){
       max=root-&gt;val;
       strcpy(maxdir,curdir);
    }
    maxpath(root-&gt;left,root-&gt;val,l);
    maxpath(root-&gt;right,root-&gt;val,r);
}
//Here we have converted the tree from
    3
   / \
  4  7
 / \
2   5

to 
    3
   / \
  7  10
 / \
9   12

Since when we get the max val we save the path to it i.e. a string of 'l' and 'r'

//Now we just need to traverse the tree once to print this value and path
//And one traversal required to return the tree to normal state






</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-agniswar odd alt thread-even depth-1" id="dsq-comment-7986">
        <div id="dsq-comment-header-7986" class="dsq-comment-header">
            <cite id="dsq-cite-7986">
                <span id="dsq-author-user-7986">Agniswar</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7986" class="dsq-comment-body">
            <div id="dsq-comment-message-7986" class="dsq-comment-message"><p>Here is the recursive function i have written..</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code)*/

int maxSumPath(node *root)
{
    if(root==NULL)
                  return 0;
    else
    {
        int ls=maxSumPath(root-&gt;left);
        int rs=maxSumPath(root-&gt;right);
        
        int max=(ls&gt;rs)? ls: rs;
        return root-&gt;data + max;
    }
}


 











</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-kartik even depth-2" id="dsq-comment-7991">
        <div id="dsq-comment-header-7991" class="dsq-comment-header">
            <cite id="dsq-cite-7991">
                <span id="dsq-author-user-7991">kartik</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7991" class="dsq-comment-body">
            <div id="dsq-comment-message-7991" class="dsq-comment-message"><p>@Agniswar: thanks for suggesting a new method. This seems good.  Could you add code to print path as well.  We will add it to the original post.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt depth-2" id="dsq-comment-8090">
        <div id="dsq-comment-header-8090" class="dsq-comment-header">
            <cite id="dsq-cite-8090">
                <span id="dsq-author-user-8090">gaurav</span>
            </cite>
        </div>
        <div id="dsq-comment-body-8090" class="dsq-comment-body">
            <div id="dsq-comment-message-8090" class="dsq-comment-message"><p>good one</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-3" id="dsq-comment-8108">
        <div id="dsq-comment-header-8108" class="dsq-comment-header">
            <cite id="dsq-cite-8108">
                <span id="dsq-author-user-8108">dumbcoder</span>
            </cite>
        </div>
        <div id="dsq-comment-body-8108" class="dsq-comment-body">
            <div id="dsq-comment-message-8108" class="dsq-comment-message"><p>#include<br />
#include<br />
#include </p>
<p>/* A tree node structure */<br />
struct Node<br />
{<br />
    Node(int dat) {<br />
      data = dat;<br />
      left = NULL;<br />
      right = NULL;<br />
      maxSum = INT_MIN;<br />
    }</p>
<p>    ~Node() {<br />
      if (left != NULL) delete left;<br />
      if (right != NULL) delete right;<br />
    }</p>
<p>    int data;<br />
    Node *left;<br />
    Node *right;<br />
    std::vector path;<br />
    int maxSum;<br />
};</p>
<p>int maxSum(Node* node) {<br />
    // base case<br />
    if (node == NULL) {<br />
        return INT_MIN;<br />
    }</p>
<p>    (node-&gt;path).push_back(node); // add self</p>
<p>    // Leaf node<br />
    if (node-&gt;left == NULL &amp;&amp; node-&gt;right == NULL) {<br />
        node-&gt;maxSum = node-&gt;data;<br />
        return node-&gt;maxSum;<br />
    } </p>
<p>    // Any other node<br />
    int maxSumLeft = maxSum(node-&gt;left);<br />
    int maxSumRight = maxSum(node-&gt;right);</p>
<p>    std::vector::const_iterator it;<br />
    std::vector* survivingPath;</p>
<p>    if (maxSumLeft &gt; maxSumRight) {<br />
      node-&gt;maxSum = maxSumLeft + node-&gt;data;<br />
      survivingPath = &amp;(node-&gt;left-&gt;path);<br />
    } else if (maxSumRight &gt; maxSumLeft) {<br />
      node-&gt;maxSum = maxSumRight + node-&gt;data;<br />
      survivingPath = &amp;(node-&gt;right-&gt;path);<br />
    } else {<br />
      node-&gt;maxSum = maxSumLeft + node-&gt;data; // doesn&#8217;t matter which one you pick<br />
      survivingPath = &amp;(node-&gt;left-&gt;path);<br />
    }</p>
<p>    for (it = (*survivingPath).begin(); it != (*survivingPath).end(); it++) {<br />
      (node-&gt;path).push_back(*it);  // add the members of the surviving path of the child node to current node&#8217;s path<br />
    }</p>
<p>    return node-&gt;maxSum;<br />
}</p>
<p>Node* generateTestTree(int testcase) {<br />
  Node* root = NULL;</p>
<p>  switch (testcase) {<br />
      case 0:<br />
          root = NULL;<br />
          break;<br />
      case 1:<br />
          // happy case<br />
          root = new Node(10);<br />
          root-&gt;left = new Node(-2);<br />
          root-&gt;right = new Node(7);<br />
          root-&gt;left-&gt;left = new Node(8);<br />
          root-&gt;left-&gt;right = new Node(-4);<br />
          break;<br />
      case 2:<br />
          // test equal case<br />
          root = new Node(10);<br />
          root-&gt;left = new Node(-1);<br />
          root-&gt;right = new Node(7);<br />
          root-&gt;left-&gt;left = new Node(8);<br />
          root-&gt;left-&gt;right = new Node(-4);<br />
          break;<br />
      case 3:<br />
          // unbalanced case<br />
          root = new Node(10);<br />
          root-&gt;left = new Node(-2);<br />
          root-&gt;left-&gt;left = new Node(-8);<br />
          root-&gt;left-&gt;left-&gt;left = new Node(-4);<br />
          break;<br />
      default:<br />
          return NULL;<br />
   }     </p>
<p>   return root;<br />
}</p>
<p>/* Driver function to test above functions */<br />
int main()<br />
{<br />
    for (int testcase = 0; testcase &lt; 4; testcase++) {<br />
        Node* root = generateTestTree(testcase);</p>
<p>        int max_sum = INT_MIN;<br />
        if (root != NULL) {<br />
            // Recursively build max_sum and surviving path within node struct O(n)<br />
            max_sum = maxSum(root);</p>
<p>            std::cout &lt;&lt; &quot;Max sum &quot; &lt;&lt; max_sum;</p>
<p>            std::cout &lt;&lt; &quot;; Surviving path = &quot;;<br />
            std::vector::const_iterator it;<br />
            for (it = (root-&gt;path).begin(); it != (root-&gt;path).end(); it++) {<br />
              std::cout &lt;data &lt;&lt; &quot; &quot;;<br />
            }</p>
<p>            delete root;<br />
        }<br />
        std::cout &lt;&lt; &quot;\n&quot;;<br />
    }</p>
<p>    return 0;<br />
}</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt depth-2" id="dsq-comment-8112">
        <div id="dsq-comment-header-8112" class="dsq-comment-header">
            <cite id="dsq-cite-8112">
                <span id="dsq-author-user-8112">rohit</span>
            </cite>
        </div>
        <div id="dsq-comment-body-8112" class="dsq-comment-body">
            <div id="dsq-comment-message-8112" class="dsq-comment-message"><pre> <code language="C">
would you like to share the printing code
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-7980">
        <div id="dsq-comment-header-7980" class="dsq-comment-header">
            <cite id="dsq-cite-7980">
http://ostechnoinfo.blogspot.com/                <span id="dsq-author-user-7980">Nitin Gupta</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7980" class="dsq-comment-body">
            <div id="dsq-comment-message-7980" class="dsq-comment-message"><p>I have another method which work recursively&#8230;.</p>
<p>take<br />
a static variable called Current_value it will contain the value so far which have highest sum.</p>
<p>a current_sum variable which will hold current sum.</p>
<p>a max_sum variable which will hold maximum sum connected with current_value variable </p>
<p>we are going to find maximum sum from left side of the root then proceed right side of the root of tree.</p>
<p>example:<br />
initially Current_sum = max_sum= current_value=0<br />
 Say you have tree like</p>
<pre>
                  10
               /      \
	     -2        7
           /   \
	 8     -4
</pre>
<p>root=10<br />
current sum = 10 current value = 10 max_sum = 10<br />
move left of Root(10)<br />
we got -2 so current_sum = 8 compare current_sum with max_sum we got current value = 10<br />
then left of -2 is 8 so current sum = 16 which greater than max_sum so max_sum = 16 current_value = 8<br />
since there is no left child of 8 so we back to the root of 8 which is -2 and current_sum = current_sum &#8211; current_value = 8<br />
then move right of -2 which is -4 so current_sum = 4 and max_sum = 16 and current_value = 8</p>
<p>Up to we got max_sum = 16 and leaf node value = 8 </p>
<p>now there is no more child left of left side of the tree corresponding to root ( 10 ) so we move right side of the root(10) proceed in same way as above explained.</p>
<p>at last we got current_sum = 17 max_sum = 17 and current_value = 7<br />
for printing<br />
traverse the tree from root (10) to 7 and print all of them   </p>
<p>total complexity is O(log n * log n)</p>
<p>Pls tell me if i m wrong ..</p>
<p>/* Paste your code here (You may delete these lines if not writing code) */</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-7970">
        <div id="dsq-comment-header-7970" class="dsq-comment-header">
            <cite id="dsq-cite-7970">
                <span id="dsq-author-user-7970">avinash</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7970" class="dsq-comment-body">
            <div id="dsq-comment-message-7970" class="dsq-comment-message"><pre> <code language="C">
I think it is printing the path from leaf to root.
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-geeksforgeeks bypostauthor even depth-2" id="dsq-comment-7972">
        <div id="dsq-comment-header-7972" class="dsq-comment-header">
            <cite id="dsq-cite-7972">
                <span id="dsq-author-user-7972">GeeksforGeeks</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7972" class="dsq-comment-body">
            <div id="dsq-comment-message-7972" class="dsq-comment-message"><p>@avinash: Thanks for pointing this out. We have changed the title of the post.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment byuser comment-author-g33k odd alt thread-odd thread-alt depth-1" id="dsq-comment-7965">
        <div id="dsq-comment-header-7965" class="dsq-comment-header">
            <cite id="dsq-cite-7965">
                <span id="dsq-author-user-7965">g33k</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7965" class="dsq-comment-body">
            <div id="dsq-comment-message-7965" class="dsq-comment-message"><p>I have a recursive algorithm, which I believe is correct.</p>
<p>int maxPath(Node root){</p>
<p>       if(root == null) return 0;<br />
       //find sum path of left tree and right tree<br />
       int maxLeft = maxPath(root->left);<br />
       int maxRight = maxPath(root->right);</p>
<p>       //max can be either of the two<br />
       if(maxLeft > maxRight){<br />
          retunrn max(maxLeft, root, root + maxLeft);<br />
       else<br />
          return max(maxRIght, root, root+maxRight);</p>
<p>}</p>
<p>I will modify the code to get the path or someone can do. It should be easy.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-2" id="dsq-comment-7977">
        <div id="dsq-comment-header-7977" class="dsq-comment-header">
            <cite id="dsq-cite-7977">
                <span id="dsq-author-user-7977">Ila</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7977" class="dsq-comment-body">
            <div id="dsq-comment-message-7977" class="dsq-comment-message"><p>When you are taking max(maxLeft,root,root+maxleft) u may or may not include the root node in the maxsum but the question requires to display a complete path from root to leaf if i am not wrong. You should make it return max(maxRight,maxLeft) and store whichever node returns max for the printing of path.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-g33k odd alt depth-3" id="dsq-comment-7987">
        <div id="dsq-comment-header-7987" class="dsq-comment-header">
            <cite id="dsq-cite-7987">
                <span id="dsq-author-user-7987">g33k</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7987" class="dsq-comment-body">
            <div id="dsq-comment-message-7987" class="dsq-comment-message"><p>I think you are right. Just remove the root from max funtcion.</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
            </ul>


        </div>

    </div>

<script type="text/javascript">
var disqus_url = 'http://www.geeksforgeeks.org/find-the-maximum-sum-path-in-a-binary-tree/';
var disqus_identifier = '18722 http://www.geeksforgeeks.org/?p=18722';
var disqus_container_id = 'disqus_thread';
var disqus_shortname = 'geeksforgeeks';
var disqus_title = "Find the maximum sum leaf to root path in a Binary Tree";
var disqus_config_custom = window.disqus_config;
var disqus_config = function () {
    /*
    All currently supported events:
    onReady: fires when everything is ready,
    onNewComment: fires when a new comment is posted,
    onIdentify: fires when user is authenticated
    */
    
    
    this.language = '';
    
    if (disqus_config_custom) {
        disqus_config_custom.call(this);
    }
};

(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>

			</div>
	
					
			
			

		</div> <!-- end post -->	

<br></br>
	
</div> <!-- end content -->

<ul id="sidebar">
	<li id="text-19" class="widget widget_text">			<div class="textwidget"><script>
  (function() {
    var cx = '009682134359037907028:tj6eafkv_be';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//www.google.com/cse/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>

<style type="text/css">
  .gsc-control-cse {
    font-family: "Trebuchet MS", sans-serif;
    border-color: #E1F3DA;
    background-color: #E1F3DA;
  }
  input.gsc-input {
    border-color: #94CC7A;
  }
  input.gsc-search-button {
    border-color: #94CC7A;
    background-color: #AADA92;
  }
  .gsc-tabHeader.gsc-tabhInactive {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gsc-tabHeader.gsc-tabhActive {
    border-color: #A9DA92;
    background-color: #A9DA92;
  }
  .gsc-tabsArea {
    border-color: #A9DA92;
  }
  .gsc-webResult.gsc-result {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gsc-webResult.gsc-result:hover {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gs-webResult.gs-result a.gs-title:link,
  .gs-webResult.gs-result a.gs-title:link b {
    color: #009900;
  }
  .gs-webResult.gs-result a.gs-title:visited,
  .gs-webResult.gs-result a.gs-title:visited b {
    color: #009900;
  }
  .gs-webResult.gs-result a.gs-title:hover,
  .gs-webResult.gs-result a.gs-title:hover b {
    color: #003300;
  }
  .gs-webResult.gs-result a.gs-title:active,
  .gs-webResult.gs-result a.gs-title:active b {
    color: #009900;
  }
  .gsc-cursor-page {
    color: #009900;
  }
  a.gsc-trailing-more-results:link {
    color: #009900;
  }
  .gs-webResult.gs-result .gs-snippet {
    color: #454545;
  }
  .gs-webResult.gs-result .gs-visibleUrl {
    color: #33cc00;
  }
  .gs-webResult.gs-result .gs-visibleUrl-short {
    color: #33cc00;
  }
  .gs-webResult.gs-result .gs-visibleUrl-short {
    display: none;
  }
  .gs-webResult.gs-result .gs-visibleUrl-long {
    display: block;
  }
  .gsc-cursor-box {
    border-color: #A9DA92;
  }
  .gsc-results .gsc-cursor-page {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gsc-results .gsc-cursor-page.gsc-cursor-current-page {
    border-color: #A9DA92;
    background-color: #A9DA92;
  }
  .gs-promotion.gs-result {
    border-color: #94CC7A;
    background-color: #CBE8B4;
  }
  .gs-promotion.gs-result a.gs-title:link {
    color: #0066CC;
  }
  .gs-promotion.gs-result a.gs-title:visited {
    color: #0066CC;
  }
  .gs-promotion.gs-result a.gs-title:hover {
    color: #0066CC;
  }
  .gs-promotion.gs-result a.gs-title:active {
    color: #0066CC;
  }
  .gs-promotion.gs-result .gs-snippet {
    color: #454545;
  }
  .gs-promotion.gs-result .gs-visibleUrl,
  .gs-promotion.gs-result .gs-visibleUrl-short {
    color: #815FA7;
  }
</style>    </div>
		</li>
<li id="text-9" class="widget widget_text">			<div class="textwidget"><div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=138031159685820";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>

<div class="fb-like-box" data-href="https://www.facebook.com/pages/GeeksforGeeks/316764689022" data-width="250" data-height="170" data-colorscheme="light" data-show-faces="true" data-header="false" data-stream="false" data-show-border="false"></div></div>
		</li>
<li id="text-18" class="widget widget_text">			<div class="textwidget"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LargeRectangleSide -->
<ins class="adsbygoogle"
     style="display:inline-block;width:336px;height:280px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="1884636833"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
		</li>
<li id="text-13" class="widget widget_text">			<div class="textwidget"><ul><li><a href="http://www.geeksforgeeks.org/category/interview-experiences/">Interview Experiences</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/advance-data-structures">Advanced Data Structures</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/dynamic-programming">Dynamic Programming</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/Greedy-Algorithm/">Greedy Algorithms</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/backtracking">Backtracking</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/pattern-searching">Pattern Searching</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/divide-and-conquer">Divide & Conquer</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/MathematicalAlgo">Mathematical Algorithms</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/recursion">Recursion</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/geometric-algorithms/">Geometric Algorithms</a></li>
</ul></div>
		</li>
<li id="text-17" class="widget widget_text">			<div class="textwidget"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big 300x600 Sidebar -->
<ins class="adsbygoogle"
     style="display:inline-block;width:300px;height:600px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="4402736037"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
		</li>
<li id="text-14" class="widget widget_text"><h2 class="widgettitle">Popular Posts</h2>
			<div class="textwidget"><ul>
<li><a href="http://www.geeksforgeeks.org/write-a-c-program-to-print-all-permutations-of-a-given-string/">  All permutations of a given string </a></li>
<li><a href="http://www.geeksforgeeks.org/memory-layout-of-c-program/"> Memory Layout of C Programs</a> </li>
<li><a href="http://www.geeksforgeeks.org/understanding-extern-keyword-in-c/"> Understanding “extern” keyword in C</a> </li>
<li><a href="http://www.geeksforgeeks.org/median-of-two-sorted-arrays/">Median of two sorted arrays</a> </li>
<li><a href="http://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/"> Tree traversal without recursion and without stack! </a></li>
<li><a href="http://www.geeksforgeeks.org/structure-member-alignment-padding-and-data-packing/"> Structure Member Alignment, Padding and Data Packing</a> </li>
<li><a href="http://www.geeksforgeeks.org/write-a-function-to-get-the-intersection-point-of-two-linked-lists/"> Intersection point of two Linked Lists</a> </li>
<li><a href="http://www.geeksforgeeks.org/lowest-common-ancestor-in-a-binary-search-tree/"> Lowest Common Ancestor in a BST.</span></a> </li>
<li><a href="http://www.geeksforgeeks.org/a-program-to-check-if-a-binary-tree-is-bst-or-not/"> Check if a binary tree is BST or not</a> </li>
<li><a href="http://www.geeksforgeeks.org/sorted-linked-list-to-balanced-bst/"> Sorted Linked List to Balanced BST</a></li>
</ul></div>
		</li>
<li id="text-3" class="widget widget_text">			<div class="textwidget"><a href="https://twitter.com/GeeksforGeeks" class="twitter-follow-button" data-show-count="false">Follow @GeeksforGeeks</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>         


<!-- GOOGLE FEEDBURNER BUTTON-->
<a href="http://feeds.feedburner.com/Geeksforgeeks" title="Subscribe to my feed" rel="alternate" type="application/rss+xml"><img src="http://www.feedburner.com/fb/images/pub/feed-icon32x32.png" alt="" style="border:0"/></a><a href="http://feeds.feedburner.com/Geeksforgeeks" title="Subscribe to my feed" rel="alternate" type="application/rss+xml">Subscribe</a>

</div>
		</li>
<li id="text-21" class="widget widget_text"><h2 class="widgettitle">Recent Comments</h2>
			<div class="textwidget"><script type="text/javascript" src="http://geeksforgeeks.disqus.com//recent_comments_widget.js?num_items=6&hide_avatars=1&excerpt_length=50&hide_mods=0"></script></div>
		</li>
<li id="text-22" class="widget widget_text">			<div class="textwidget"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LinkAd -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:90px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="2606115235"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LinkAd -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:90px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="2606115235"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LinkAd -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:90px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="2606115235"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
		</li>

</ul>					  
		<div class="clear"></div>

		<div id="footer">
		
		    <div class="xhtml">
                        @geeksforgeeks, <a href="http://creativecommons.org/licenses/by-nc-nd/2.5/in/deed.en_US" title="Valid XHTML Strict 1.0">Some rights reserved</a>  <a href="http://www.geeksforgeeks.org/about/contact-us/"> &nbsp; &nbsp; &nbsp; &nbsp;Contact Us!</a>

		    </div>
		    
		    <div class="credits">
			  Powered by <a href="http://wordpress.org">WordPress </a> &amp; <a href="http://mootools.net/" title="Mootools JavaScript Framework">MooTools</a>, customized by geeksforgeeks team </div>
			  
		   <div class="clear"></div>						                            
		   
		</div> <!--end footer-->  
        
		        <script type="text/javascript">
        // <![CDATA[
        var disqus_shortname = 'geeksforgeeks';
        (function () {
            var nodes = document.getElementsByTagName('span');
            for (var i = 0, url; i < nodes.length; i++) {
                if (nodes[i].className.indexOf('dsq-postid') != -1) {
                    nodes[i].parentNode.setAttribute('data-disqus-identifier', nodes[i].getAttribute('rel'));
                    url = nodes[i].parentNode.href.split('#', 1);
                    if (url.length == 1) { url = url[0]; }
                    else { url = url[1]; }
                    nodes[i].parentNode.href = url + '#disqus_thread';
                }
            }
            var s = document.createElement('script'); 
            s.async = true;
            s.type = 'text/javascript';
            s.src = '//' + disqus_shortname + '.disqus.com/count.js';
            (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
        }());
        // ]]>
        </script>
        <script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/scripts/shCore.js?ver=3.0.9'></script>
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/scripts/shBrushCpp.js?ver=3.0.9'></script>
<script type='text/javascript'>
	(function(){
		var corecss = document.createElement('link');
		var themecss = document.createElement('link');
		var corecssurl = "http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/styles/shCore.css?ver=3.0.9";
		if ( corecss.setAttribute ) {
				corecss.setAttribute( "rel", "stylesheet" );
				corecss.setAttribute( "type", "text/css" );
				corecss.setAttribute( "href", corecssurl );
		} else {
				corecss.rel = "stylesheet";
				corecss.href = corecssurl;
		}
		document.getElementsByTagName("head")[0].insertBefore( corecss, document.getElementById("syntaxhighlighteranchor") );
		var themecssurl = "http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/styles/shThemeDefault.css?ver=3.0.9";
		if ( themecss.setAttribute ) {
				themecss.setAttribute( "rel", "stylesheet" );
				themecss.setAttribute( "type", "text/css" );
				themecss.setAttribute( "href", themecssurl );
		} else {
				themecss.rel = "stylesheet";
				themecss.href = themecssurl;
		}
		//document.getElementById("syntaxhighlighteranchor").appendChild(themecss);
		document.getElementsByTagName("head")[0].insertBefore( themecss, document.getElementById("syntaxhighlighteranchor") );
	})();
	SyntaxHighlighter.config.strings.expandSource = '+ expand source';
	SyntaxHighlighter.config.strings.help = '?';
	SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
	SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
	SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
	SyntaxHighlighter.defaults['gutter'] = false;
	SyntaxHighlighter.defaults['pad-line-numbers'] = true;
	SyntaxHighlighter.defaults['toolbar'] = false;
	SyntaxHighlighter.all();
</script>
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/bbpress/templates/default/js/editor.js?ver=2.5.4-5380'></script>
				  
		</div> <!--end wrapper-->
        <div id="ajaxSpinner"></div> <!--For AJAX spinner holder-->
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-12148232-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
	</body>

</html>
<!-- Dynamic page generated in 0.226 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2014-11-27 23:29:59 -->

<!-- Compression = gzip -->
<!-- super cache -->