<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
       <title>Swap Kth node from beginning with Kth node from end in a Linked List - GeeksforGeeks</title>
       <style type="text/css" media="screen">
          @import url('http://d2o58evtke57tz.cloudfront.net/wp-content/themes/minimoo/style.css');
    </style>
      <link href="http://d2o58evtke57tz.cloudfront.net/wp-content/themes/minimoo/favicon.ico" rel="shortcut icon" />    
    
<!-- This site is optimized with the Yoast WordPress SEO plugin v1.7.1 - https://yoast.com/wordpress/plugins/seo/ -->
<link rel="canonical" href="http://www.geeksforgeeks.org/swap-kth-node-from-beginning-with-kth-node-from-end-in-a-linked-list/" />
<meta property="og:locale" content="en_US" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Swap Kth node from beginning with Kth node from end in a Linked List - GeeksforGeeks" />
<meta property="og:description" content="Given a singly linked list, swap kth node from beginning with kth node from end. Swapping of data is not allowed, only pointers should be changed. This requirement may be logical in many situations where the linked list data part is huge (For example student details line Name, RollNo, Address, ..etc). The pointers are always &hellip;" />
<meta property="og:url" content="http://www.geeksforgeeks.org/swap-kth-node-from-beginning-with-kth-node-from-end-in-a-linked-list/" />
<meta property="og:site_name" content="GeeksforGeeks" />
<meta property="article:section" content="Linked Lists" />
<meta property="article:published_time" content="2013-05-10T13:20:03+00:00" />
<meta property="article:modified_time" content="2013-05-10T14:42:20+00:00" />
<meta property="og:updated_time" content="2013-05-10T14:42:20+00:00" />
<meta property="og:image" content="http://d2o58evtke57tz.cloudfront.net/wp-content/uploads/Linked-List1.png" />
<!-- / Yoast WordPress SEO plugin. -->

<link rel='stylesheet' id='wp-quicklatex-format-css'  href='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/wp-quicklatex/css/quicklatex-format.css?ver=4.0.1' type='text/css' media='all' />
<link rel='stylesheet' id='bbp-default-css'  href='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/bbpress/templates/default/css/bbpress.css?ver=2.5.4-5380' type='text/css' media='screen' />
<link rel='stylesheet' id='wp-pagenavi-css'  href='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/wp-pagenavi/pagenavi-css.css?ver=2.70' type='text/css' media='all' />
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-includes/js/jquery/jquery.js?ver=1.11.1'></script>
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-includes/js/jquery/jquery-migrate.min.js?ver=1.2.1'></script>
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/wp-quicklatex/js/wp-quicklatex-frontend.js?ver=1.0'></script>

<!-- Bad Behavior 2.2.16 run time: 1.631 ms -->
<script type="text/javascript">
<!--
function bb2_addLoadEvent(func) {
	var oldonload = window.onload;
	if (typeof window.onload != 'function') {
		window.onload = func;
	} else {
		window.onload = function() {
			oldonload();
			func();
		}
	}
}

bb2_addLoadEvent(function() {
	for ( i=0; i < document.forms.length; i++ ) {
		if (document.forms[i].method == 'post') {
			var myElement = document.createElement('input');
			myElement.setAttribute('type', 'hidden');
			myElement.name = 'bb2_screener_';
			myElement.value = '1417110786 121.242.198.2';
			document.forms[i].appendChild(myElement);
		}
	}
});
// --></script>
		<style type="text/css" id="syntaxhighlighteranchor"></style>
   <meta name="google-site-verification" content="rHK2v8_zzuAZQY8JHAzbllDN8u-aQxcn2Kqnp67Old0" />
</head>

<body>
<!-- o4dI0sCXUgoSONabbd8mbZ4SA3E -->    
    <div id="wrapper">
        <div class="blog-info">
                <h1 class="blog-title">
                <a href="http://www.geeksforgeeks.org" title="GeeksforGeeks">GeeksforGeeks</a>
            </h1>
       
            <div class="blog-description">
                A computer science portal for geeks            </div>
        </div>
        <b><p>  <h2 align="right"> <a href="http://geeksquiz.com/">GeeksQuiz</a></h2> 
   <a href="http://www.geeksforgeeks.org/wp-login.php">Login</a> 
         </p></b>  
         
         <div class="clear"></div>         
              
                     
            <div id="menu">   
                 <ul>
 <li><a href="http://www.geeksforgeeks.org">Home</a></li>
  <li><a href="http://www.geeksforgeeks.org/fundamentals-of-algorithms/">Algorithms</a></li>
 <li><a href="http://www.geeksforgeeks.org/data-structures/">DS</a></li>
  <li><a href="http://www.geeksforgeeks.org/gate-corner/">GATE</a></li>
  <li><a href="http://www.geeksforgeeks.org/about/interview-corner/">Interview Corner</a></li>
  <li><a href="http://www.geeksforgeeks.org/forums/">Q&A</a></li>
  <li><a href="http://www.geeksforgeeks.org/c/">C</a></li>
  <li><a href="http://www.geeksforgeeks.org/c-plus-plus/">C++</a></li>
  <li><a href="http://www.geeksforgeeks.org/java/">Java</a></li>
  <li><a href="http://www.geeksforgeeks.org/books/">Books</a></li>
  <li><a href="http://www.geeksforgeeks.org/contribute/">Contribute</a></li>
  <li><a href="http://www.geeksforgeeks.org/contribute/ask-a-question/">Ask a Q</a></li>
  <li><a href="http://www.geeksforgeeks.org/about/">About</a></li>
            </ul>

               
            <div class="clear"></div>     
        </div>
             <div id="navmenu">
				<ul id="menu" style="padding:0; margin:0;">
						<li class="cat-item cat-item-3"><a href="http://www.geeksforgeeks.org/category/c-arrays/" title="Questions regarding Arrays">Array</a>
</li>	

	<li class="cat-item cat-item-17"><a href="http://www.geeksforgeeks.org/category/bit-magic/" title="View all posts filed under Bit Magic">Bit Magic</a>
</li>
	<li class="cat-item cat-item-14"><a href="http://www.geeksforgeeks.org/category/c-puzzles/" title="View all posts filed under C/C++ Puzzles">C/C++</a>
</li>

<li class="cat-item cat-item-18"><a href="http://www.geeksforgeeks.org/category/articles/" title="View all posts filed under Articles">Articles</a>
</li>

	<li class="cat-item cat-item-67"><a href="http://www.geeksforgeeks.org/category/gfact/" title="View all posts filed under GFacts">GFacts</a>
</li>
	<li class="cat-item cat-item-8"><a href="http://www.geeksforgeeks.org/category/linked-list/" title="Linked List problems">Linked List</a>
</li>
	<li class="cat-item cat-item-66"><a href="http://www.geeksforgeeks.org/category/multiple-choice-question/" title="View all posts filed under MCQ">MCQ</a>

</li>
	<li class="cat-item cat-item-4"><a href="http://www.geeksforgeeks.org/category/c-programs/" title="Miscellaneous">Misc</a>
</li>
	<li class="cat-item cat-item-5"><a href="http://www.geeksforgeeks.org/category/program-output/" title="View all posts filed under Output">Output</a>
</li>
	<li class="cat-item cat-item-7"><a href="http://www.geeksforgeeks.org/category/c-strings/" title="Questions related to strings">String</a>
</li>
	<li class="cat-item cat-item-19"><a href="http://www.geeksforgeeks.org/category/tree/" title="View all posts filed under Trees">Tree</a>
</li>
	<li class="cat-item cat-item-19"><a href="http://www.geeksforgeeks.org/category/graph/" title="View all posts filed under Graph">Graph</a>
</li>
</ul>
        </div>
             <div id="content">	   	
	<div class="post" id="post">
							<div class="post-info">			
					<div class="post-title-info">
						<h2 class="post-title">Swap Kth node from beginning with Kth node from end in a Linked List</h2>
					</div>			
					<div class="clear"></div>				  
				<div class="post-content" id="post-content">
					<p>Given a singly linked list, swap kth node from beginning with kth node from end.  <strong>Swapping of data is not allowed, only pointers should be changed.</strong><span id="more-117603"></span> This requirement may be logical in many situations where the linked list data part is huge (For example student details line Name, RollNo, Address, ..etc). The pointers are always fixed (4 bytes for most of the compilers).</p>
<p><a href="http://d2o58evtke57tz.cloudfront.net/wp-content/uploads/Linked-List1.png"><img src="http://d2o58evtke57tz.cloudfront.net/wp-content/uploads/Linked-List1.png" alt="Linked List" width="512" height="117" class="alignCentre size-full wp-image-117638" /></a></p>
<p>The problem seems simple at first look, but it has many interesting cases.   </p>
<p>Let X be the kth node from beginning and Y be the kth node from end. Following are the interesting cases that must be handled.<br />
<strong>1) </strong>Y is next to X<br />
<strong>2) </strong>X is next to Y<br />
<strong>3) </strong>X and Y are same<br />
<strong>4) </strong>X and Y don&#8217;t exist (k is more than number of nodes in linked list)</p>
<p>We strongly recommend you to try it yourself first, then see the below solution. It will be a good exercise of pointers.</p>
<pre class="brush: cpp; highlight: [45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100]; title: ; notranslate" title="">
// A C++ program to swap Kth node from beginning with kth node from end
#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;
using namespace std;

// A Linked List node
struct node
{
    int data;
    struct node *next;
};

/* Utility function to insert a node at the beginning */
void push(struct node **head_ref, int new_data)
{
    struct node *new_node = (struct node *) malloc(sizeof(struct node));
    new_node-&gt;data = new_data;
    new_node-&gt;next = (*head_ref);
    (*head_ref) = new_node;
}

/* Utility function for displaying linked list */
void printList(struct node *node)
{
    while (node != NULL)
    {
        cout &lt;&lt; node-&gt;data &lt;&lt; &quot; &quot;;
        node = node-&gt;next;
    }
    cout &lt;&lt; endl;
}

/* Utility function for calculating length of linked list */
int countNodes(struct node *s)
{
    int count = 0;
    while (s != NULL)
    {
        count++;
        s = s-&gt;next;
    }
    return count;
}

/* Function for swapping kth nodes from both ends of linked list */
void swapKth(struct node **head_ref, int k)
{
    // Count nodes in linked list
    int n = countNodes(*head_ref);

    // Check if k is valid
    if (n &lt; k)  return;

    // If x (kth node from start) and y(kth node from end) are same
    if (2*k - 1 == n) return;

    // Find the kth node from beginning of linked list. We also find
    // previous of kth node because we need to update next pointer of
    // the previous.
    node *x = *head_ref;
    node *x_prev = NULL;
    for (int i = 1; i &lt; k; i++)
    {
        x_prev = x;
        x = x-&gt;next;
    }

    // Similarly, find the kth node from end and its previous. kth node
    // from end is (n-k+1)th node from beginning
    node *y = *head_ref;
    node *y_prev = NULL;
    for (int i = 1; i &lt; n-k+1; i++)
    {
        y_prev = y;
        y = y-&gt;next;
    }

    // If x_prev exists, then new next of it will be y. Consider the case
    // when y-&gt;next is x, in this case, x_prev and y are same. So the statement
    // &quot;x_prev-&gt;next = y&quot; creates a self loop. This self loop will be broken
    // when we change y-&gt;next.
    if (x_prev)
        x_prev-&gt;next = y;

    // Same thing applies to y_prev
    if (y_prev)
        y_prev-&gt;next = x;

    // Swap next pointers of x and y. These statements also break self
    // loop if x-&gt;next is y or y-&gt;next is x
    node *temp = x-&gt;next;
    x-&gt;next = y-&gt;next;
    y-&gt;next = temp;

    // Change head pointers when k is 1 or n
    if (k == 1)
        *head_ref = y;
    if (k == n)
        *head_ref = x;
}

// Driver program to test above functions
int main()
{
    // Let us create the following linked list for testing
    // 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8
    struct node *head = NULL;
    for (int i = 8; i &gt;= 1; i--)
       push(&amp;head, i);

    cout &lt;&lt; &quot;Original Linked List: &quot;;
    printList(head);

    for (int k = 1; k &lt; 10; k++)
    {
        swapKth(&amp;head, k);
        cout &lt;&lt; &quot;\nModified List for k = &quot; &lt;&lt; k &lt;&lt; endl;
        printList(head);
    }

    return 0;
}
</pre>
<p>Output:
<pre>Original Linked List: 1 2 3 4 5 6 7 8

Modified List for k = 1
8 2 3 4 5 6 7 1

Modified List for k = 2
8 7 3 4 5 6 2 1

Modified List for k = 3
8 7 6 4 5 3 2 1

Modified List for k = 4
8 7 6 5 4 3 2 1

Modified List for k = 5
8 7 6 4 5 3 2 1

Modified List for k = 6
8 7 3 4 5 6 2 1

Modified List for k = 7
8 2 3 4 5 6 7 1

Modified List for k = 8
1 2 3 4 5 6 7 8

Modified List for k = 9
1 2 3 4 5 6 7 8</pre>
<p>Please note that the above code runs three separate loops to count nodes, find x and x prev, and to find y and y_prev. These three things can be done in a single loop.  The code uses three loops to keep things simple and readable.</p>
<p>Thanks to <a href="https://www.facebook.com/chandra.prakash.52643?fref=ts">Chandra Prakash</a> for initial solution. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
		
&nbsp;
&nbsp;
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle"
     style="display:inline-block;width:336px;height:280px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="4061219431"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>



&nbsp;
&nbsp;
&nbsp;
<h3>Related Topics:</h3><ul><li><a href="http://www.geeksforgeeks.org/given-linked-list-reverse-alternate-nodes-append-end/" title="Given a linked list, reverse alternate nodes and append at the end">Given a linked list, reverse alternate nodes and append at the end</a></li><li><a href="http://www.geeksforgeeks.org/pairwise-swap-elements-of-a-given-linked-list-by-changing-links/" title="Pairwise swap elements of a given linked list by changing links">Pairwise swap elements of a given linked list by changing links</a></li><li><a href="http://www.geeksforgeeks.org/self-organizing-list-set-1-introduction/" title="Self Organizing List | Set 1 (Introduction)">Self Organizing List | Set 1 (Introduction)</a></li><li><a href="http://www.geeksforgeeks.org/merge-a-linked-list-into-another-linked-list-at-alternate-positions/" title="Merge a linked list into another linked list at alternate positions">Merge a linked list into another linked list at alternate positions</a></li><li><a href="http://www.geeksforgeeks.org/quicksort-on-singly-linked-list/" title="QuickSort on Singly Linked List">QuickSort on Singly Linked List</a></li><li><a href="http://www.geeksforgeeks.org/delete-n-nodes-after-m-nodes-of-a-linked-list/" title="Delete N nodes after M nodes of a linked list">Delete N nodes after M nodes of a linked list</a></li><li><a href="http://www.geeksforgeeks.org/design-a-stack-with-find-middle-operation/" title="Design a stack with operations on middle element">Design a stack with operations on middle element</a></li><li><a href="http://www.geeksforgeeks.org/quicksort-for-linked-list/" title="QuickSort on Doubly Linked List">QuickSort on Doubly Linked List</a></li></ul>
<p></p> 
<div>
<iframe src="http://www.facebook.com/plugins/like.php?href=http%3A%2F%2Fwww.geeksforgeeks.org%2Fswap-kth-node-from-beginning-with-kth-node-from-end-in-a-linked-list%2F&layout=button_count&show_faces=false&width=90&action=like&colorscheme=light" scrolling="no" frameborder="0" allowTransparency="true" style="border:none; overflow:hidden; width:90px; height:20px"></iframe>
<a href="http://twitter.com/share" class="twitter-share-button" data-url="http://www.geeksforgeeks.org/swap-kth-node-from-beginning-with-kth-node-from-end-in-a-linked-list/" data-text="Swap Kth node from beginning with Kth node from end in a Linked List" data-count="horizontal" data-via="jakerutter">Tweet</a><script type="text/javascript" src="http://platform.twitter.com/widgets.js"></script>
<g:plusone size="medium" href="http://www.geeksforgeeks.org/swap-kth-node-from-beginning-with-kth-node-from-end-in-a-linked-list/"></g:plusone>
<!-- Place this render call where appropriate -->
<script type="text/javascript">
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script></div>





				</div>		  
			</div> <!-- end post main -->					
			<div class="post-meta">
				<div class="left"></div>				
				<div class="clear"></div>
			</div>			
        
			<div class="comments-main">		
 <b>Writing code in comment?</b> Please use <b><a href="http://ideone.com/">ideone.com</a></b> and share the link here.
				
<div id="disqus_thread">
            <div id="dsq-content">


            <ul id="dsq-comments">
                    <li class="comment even thread-even depth-1" id="dsq-comment-34434">
        <div id="dsq-comment-header-34434" class="dsq-comment-header">
            <cite id="dsq-cite-34434">
                <span id="dsq-author-user-34434">Ravi Kiran</span>
            </cite>
        </div>
        <div id="dsq-comment-body-34434" class="dsq-comment-body">
            <div id="dsq-comment-message-34434" class="dsq-comment-message"><p>using recursion.. but doesn&#8217;t work when k=length of the list need to change code.</p>
<p>Please comment on the code.<br />
// @author Ravi Kiran<br />
int main()<br />
{<br />
swapKthNodeFrontAndBack(root1,1,11);</p>
<p>}</p>
<p>//global variable<br />
node * temp = NULL;</p>
<p>int swapKthNodeFrontAndBack(node* root,int a,int k)<br />
{<br />
	  if(root-&gt;next == NULL)<br />
	  {<br />
		 return a;<br />
	  }<br />
	   if(a == k)<br />
	   {<br />
		  temp = root;<br />
		  std::cout&lt;&lt;&quot;Kth element is:&quot;&lt;a&lt;next,a+1,k);</p>
<p>	   if(length-(a-1) == k)<br />
	   {<br />
		 std::cout&lt;&lt;&quot;Kth element from last is:&quot;&lt;a&lt;a;<br />
		 root-&gt;a= temp-&gt;a;<br />
		 temp-&gt;a=temp1;</p>
<p>	   }<br />
	return length;<br />
}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-33267">
        <div id="dsq-comment-header-33267" class="dsq-comment-header">
            <cite id="dsq-cite-33267">
                <span id="dsq-author-user-33267">shruti</span>
            </cite>
        </div>
        <div id="dsq-comment-body-33267" class="dsq-comment-body">
            <div id="dsq-comment-message-33267" class="dsq-comment-message"><p>this code is not working for k=1 and k=n..can anybody correct and explain?</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-32584">
        <div id="dsq-comment-header-32584" class="dsq-comment-header">
            <cite id="dsq-cite-32584">
                <span id="dsq-author-user-32584">Vignesh Murugesan</span>
            </cite>
        </div>
        <div id="dsq-comment-body-32584" class="dsq-comment-body">
            <div id="dsq-comment-message-32584" class="dsq-comment-message"><p>void Swap(int x, int y)	//0 -&gt; len-1<br />
{<br />
if (x &lt; 0 || y y) swapVals(&amp;x, &amp;y);<br />
if (Head == NULL || Head-&gt;Next == NULL) return;<br />
Node *First= Head, *Second = Head;<br />
while (&#8211;x &gt; -1 &amp;&amp; First != NULL) First = First-&gt;Next;<br />
while (&#8211;y &gt; -1 &amp;&amp; Second != NULL)	 Second= Second-&gt;Next;<br />
if (!(First&amp;&amp;Second)) return;<br />
Node* Ptr = Head;<br />
bool SwappedHead = false;<br />
if (Ptr == First)<br />
  SwappedHead = true;<br />
if (First-&gt;Next == Second)<br />
{<br />
  First-&gt;Next = Second-&gt;Next;<br />
  Second-&gt;Next = First;<br />
  if (SwappedHead) Head = Second;<br />
  else<br />
  {<br />
    while (Ptr-&gt;Next != First)<br />
      Ptr = Ptr-&gt;Next;<br />
    Ptr-&gt;Next = Second;<br />
  }<br />
  return;<br />
}<br />
while (!SwappedHead &amp;&amp; Ptr-&gt;Next != First)<br />
  Ptr = Ptr-&gt;Next;<br />
Node* Ptr1 = Head;</p>
<p>while (Ptr1-&gt;Next != Second)<br />
   Ptr1 = Ptr1-&gt;Next;<br />
Node *Rest = Second-&gt;Next;</p>
<p>if (SwappedHead) Head = Second;<br />
Ptr-&gt;Next = Second;<br />
Second-&gt;Next = First-&gt;Next;<br />
if (Ptr1) Ptr1-&gt;Next = First;<br />
First-&gt;Next = Rest;<br />
}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-31485">
        <div id="dsq-comment-header-31485" class="dsq-comment-header">
            <cite id="dsq-cite-31485">
                <span id="dsq-author-user-31485">Thanh Nguyen</span>
            </cite>
        </div>
        <div id="dsq-comment-body-31485" class="dsq-comment-body">
            <div id="dsq-comment-message-31485" class="dsq-comment-message"><p>/*  *** HOW DO YOU PRESERVE WHITE SPACE WHEN EDITING THIS, anyway?</p>
<p>I would do everything in the swapKth() function above in 1 single pass.  And, you don&#8217;t have to know the count (or len) of the linked list.  Here is what I would do.<br />
*/</p>
<p>void swapKth(struct node **head_ref, int k)<br />
{    struct node* N1, N2, prev1, prev2, temp;<br />
    int i = 0;<br />
    if (!*head_ref || *head_ref-&gt;next) return;<br />
    N1 = *head_ref;<br />
    prev1 = null;</p>
<p>    while((inext)){<br />
         N1 = N1-&gt;next;<br />
         if (prev1) prev1 = prev1-&gt;next;<br />
         else prev1 = *head_ref;<br />
         i++;<br />
      }<br />
      if (i != k-1) return;   // list is too short<br />
    N2 = *head_ref;<br />
    temp = N1;<br />
    prev2 = null;</p>
<p>     while(temp-&gt;next ){<br />
        N2 = N2-&gt;next;<br />
        if (prev2) prev2 = prev2-&gt;next;<br />
        else prev2 = *head_ref;<br />
        temp = temp-&gt;next;<br />
     }<br />
     if (prev1) prev1-&gt;next = N2;<br />
     else *head_ref = N2;</p>
<p>      if (prev2) prev2-&gt;next = N1;<br />
      else *head_ref = N1;</p>
<p>      temp = N1-&gt;next;<br />
      N1-&gt;next = N2-&gt;next;<br />
      N2-&gt;next = temp-&gt;next;</p>
<p>     return;<br />
}</p>
<p>}}}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-30345">
        <div id="dsq-comment-header-30345" class="dsq-comment-header">
            <cite id="dsq-cite-30345">
                <span id="dsq-author-user-30345">groomnestle</span>
            </cite>
        </div>
        <div id="dsq-comment-body-30345" class="dsq-comment-body">
            <div id="dsq-comment-message-30345" class="dsq-comment-message"><p>Have an array indexing from 1 to store address of each node when counting length N. </p>
<p>Then you can access related nodes by index. Need to check special case when K=1   and 2*K =N.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-29218">
        <div id="dsq-comment-header-29218" class="dsq-comment-header">
            <cite id="dsq-cite-29218">
                <span id="dsq-author-user-29218">shanky</span>
            </cite>
        </div>
        <div id="dsq-comment-body-29218" class="dsq-comment-body">
            <div id="dsq-comment-message-29218" class="dsq-comment-message"><p>i didn&#8217;t get this </p>
<p>/ If x_prev exists, then new next of it will be y. Consider the case<br />
    // when y-&gt;next is x, in this case, x_prev and y are same. So the statement<br />
    // &#8220;x_prev-&gt;next = y&#8221; creates a self loop. This self loop will be broken<br />
    // when we change y-&gt;next.<br />
    if (x_prev)<br />
        x_prev-&gt;next = y;</p>
<p>    // Same thing applies to y_prev<br />
    if (y_prev)<br />
        y_prev-&gt;next = x;</p>
<p>Can you please throw some light on this ?</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-25073">
        <div id="dsq-comment-header-25073" class="dsq-comment-header">
            <cite id="dsq-cite-25073">
                <span id="dsq-author-user-25073">Chandu</span>
            </cite>
        </div>
        <div id="dsq-comment-body-25073" class="dsq-comment-body">
            <div id="dsq-comment-message-25073" class="dsq-comment-message"><p>// Working for all the test cases&#8230;:)<br />
void swapKth(struct node **head, int k)<br />
{<br />
	struct node *temp = *head, *fslow_ptr = NULL;<br />
	int tot_nodes = count(temp);  // call function count to count total no. of nodes</p>
<p>	if(tot_nodes &lt; k) // When nodes don&#039;t exist<br />
		return;</p>
<p>	if( (tot_nodes%2) &amp;&amp; ((tot_nodes/2)+1 == k) )  // Kth node from beg and end are same.<br />
		return;</p>
<p>	if(tot_nodes/2 &lt; k)   // Tricky step, go thru it<br />
		k = tot_nodes-k+1;</p>
<p>	int p=0;<br />
	while( (temp!=NULL) &amp;&amp; pnext;<br />
		p++;<br />
	}</p>
<p>	struct node *ptr = temp, *temp1 = *head, *lslow_ptr = NULL;<br />
	while(ptr-&gt;next!=NULL)  // Setting the second node to be swapped<br />
	{<br />
		lslow_ptr = temp1;<br />
		temp1 = temp1-&gt;next;<br />
		ptr = ptr-&gt;next;<br />
	}</p>
<p>	if(lslow_ptr == temp) {   // Case1: when the nodes are adjacent to each other.<br />
		temp-&gt;next = temp1-&gt;next;<br />
		temp1-&gt;next = temp;<br />
		fslow_ptr-&gt;next = temp1;<br />
	}<br />
	else if(fslow_ptr == NULL)  // Case2: When first and last nodes are to be swapped.<br />
	{<br />
		struct node *save = temp1-&gt;next;<br />
		lslow_ptr-&gt;next = temp;<br />
		temp1-&gt;next = temp-&gt;next;<br />
		temp-&gt;next = save;<br />
		*head = temp1;<br />
	}<br />
	else {<br />
		struct node *save1 = temp, *save2 = temp1;<br />
		lslow_ptr-&gt;next = temp1-&gt;next;<br />
		fslow_ptr-&gt;next = temp-&gt;next;</p>
<p>		save2-&gt;next = fslow_ptr-&gt;next;<br />
		fslow_ptr-&gt;next = save2;</p>
<p>		save1-&gt;next = lslow_ptr-&gt;next;<br />
		lslow_ptr-&gt;next = save1;<br />
	}</p>
<p>}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-24955">
        <div id="dsq-comment-header-24955" class="dsq-comment-header">
            <cite id="dsq-cite-24955">
                <span id="dsq-author-user-24955">mukesh</span>
            </cite>
        </div>
        <div id="dsq-comment-body-24955" class="dsq-comment-body">
            <div id="dsq-comment-message-24955" class="dsq-comment-message"><p>#include<br />
#include<br />
#include<br />
  struct  node<br />
 {<br />
     int data;<br />
     struct  node *link;</p>
<p> };<br />
typedef struct node linklist;</p>
<p>linklist *start;</p>
<p> void create(int x)<br />
{</p>
<p>    linklist *p,*temp;<br />
    temp=(linklist*)malloc(sizeof(linklist));<br />
    temp-&gt;data=x;<br />
    temp-&gt;link=NULL;<br />
    if(start==NULL)<br />
    start=temp;<br />
    else<br />
    {<br />
        p=start;<br />
        while((p-&gt;link)!=NULL)<br />
              p=p-&gt;link;<br />
        p-&gt;link=temp;<br />
}<br />
}</p>
<p>int display(linklist *x)<br />
{<br />
    x=start;<br />
if(start==NULL)<br />
printf(&#8220;linklist is empty\n&#8221;);<br />
else<br />
{<br />
    while(x!=NULL)<br />
    {<br />
         printf(&#8220;data is=%d\n&#8221;,x-&gt;data);<br />
        x=x-&gt;link;</p>
<p>    }</p>
<p>}<br />
}</p>
<p>void swap(linklist *ptr,int k)<br />
{<br />
    int count=1,i=0,m;<br />
    linklist *temp1,*x,*y,*x_next,*y_next;<br />
    temp1=ptr;<br />
    x=ptr;<br />
    y=ptr;<br />
    while(temp1-&gt;link!=NULL)<br />
    {</p>
<p>        temp1=temp1-&gt;link;<br />
        count++;<br />
    }<br />
    if(k&gt;count||k==0)<br />
       {<br />
           printf(&#8220;!!!sorry,,,enter a valid number\n&#8221;);<br />
           return;<br />
       }<br />
    if(k&gt;(count/2))<br />
    {<br />
       m=(count%k)+1;</p>
<p>       if(m==k)<br />
       {<br />
           printf(&#8220;linklist is successfully swaped\n&#8221;);<br />
           display(start);<br />
           return;<br />
       }<br />
       k=m;</p>
<p>    }<br />
    for(i=k;i&gt;2;i&#8211;)<br />
    {<br />
        x=x-&gt;link;<br />
        ptr=ptr-&gt;link;<br />
    }</p>
<p>    for(i=(count-k);i&gt;0;i&#8211;)<br />
    {<br />
        y=y-&gt;link;<br />
    }</p>
<p>    if(k==1)<br />
    {<br />
        x_next=x-&gt;link;<br />
        y_next=NULL;<br />
        ptr=y;<br />
        ptr-&gt;link=x_next;<br />
        start=ptr;<br />
    }<br />
    else<br />
    {<br />
        x=x-&gt;link;<br />
    x_next=x-&gt;link;<br />
        y_next=y-&gt;link;<br />
 ptr-&gt;link=y;<br />
 y-&gt;link=x_next;<br />
    }</p>
<p> while(x_next-&gt;link!=y)<br />
 {<br />
 x_next=x_next-&gt;link;<br />
 }<br />
 x_next-&gt;link=x;<br />
 x-&gt;link=y_next;<br />
printf(&#8220;linklist is successfully swaped\n&#8221;);<br />
display(start);<br />
}</p>
<p>main()<br />
 {<br />
     int i,n,d,choice,c,k=0;<br />
      start=NULL;<br />
     do<br />
     {<br />
           printf(&#8220;enter your choice what you want to do\n1.create link list\n2.display link list\n3.swap kth node from begining with kth node from end.\n&#8221;);<br />
     scanf(&#8220;%d&#8221;,&amp;choice);<br />
     switch(choice)<br />
     {<br />
         case 1:<br />
         printf(&#8220;enter the no of nodes in list\n&#8221;);<br />
     scanf(&#8220;%d&#8221;,&amp;n);<br />
     for(i=1;i&lt;=n;i++)<br />
     {<br />
         printf(&quot;enter the data part of %dst node\n&quot;,i);<br />
         scanf(&quot;%d&quot;,&amp;d);<br />
         create(d);<br />
         printf(&quot;creation completed\n&quot;);<br />
     }<br />
     break;<br />
     case 2:<br />
     display(start);<br />
     break;<br />
     case 3: printf(&quot;enter the value of k\n&quot;);<br />
            scanf(&quot;%d&quot;,&amp;k);<br />
            swap(start,k);<br />
             break;<br />
     default:<br />
     printf(&quot;sorry!you entered wrong choice try again&quot;);<br />
     }</p>
<p>     printf(&quot;\nyou want more operation then press 1\n&quot;);<br />
     scanf(&quot;%d&quot;,&amp;c);<br />
   }<br />
     while(c==1);<br />
 }</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-22249">
        <div id="dsq-comment-header-22249" class="dsq-comment-header">
            <cite id="dsq-cite-22249">
                <span id="dsq-author-user-22249">bharath kumar</span>
            </cite>
        </div>
        <div id="dsq-comment-body-22249" class="dsq-comment-body">
            <div id="dsq-comment-message-22249" class="dsq-comment-message"><p>#include<br />
#include<br />
#include<br />
using namespace std;<br />
typedef struct link<br />
{<br />
	int data;<br />
	struct link *next;<br />
}*s;<br />
s root;<br />
s getnode()<br />
{<br />
	s temp;<br />
	int d;<br />
	temp=(s)malloc(sizeof(s));<br />
	cin&gt;&gt;d;<br />
	temp-&gt;data=d;<br />
	temp-&gt;next=NULL;<br />
	return temp;<br />
}<br />
int create()<br />
{<br />
	s temp;<br />
	int n,i;<br />
	cout&lt;&gt;n;<br />
	root=(s)malloc(sizeof(s));<br />
	temp=root;<br />
	temp-&gt;next=NULL;<br />
	for(i=0;inext=getnode();<br />
		temp=temp-&gt;next;<br />
		temp-&gt;next=NULL;<br />
	}<br />
	root=root-&gt;next;<br />
	return n;<br />
}<br />
void display(s root)<br />
{<br />
	s temp=root;<br />
	while(temp!=NULL)<br />
	{<br />
		cout&lt;data&lt;next;<br />
	}<br />
}<br />
void swap(int k,int n)<br />
{<br />
	int i=0,j=0;<br />
	s temp=root,temp1,ret,temp2=root,temp3,temp4;<br />
	while((i&lt;k||j&lt;n-k)&amp;&amp;(temp!=NULL&amp;&amp;temp2!=NULL))<br />
	{<br />
		if(inext;</p>
<p>		}<br />
		if(jnext;<br />
		}<br />
		i=i++;<br />
		j=j++;<br />
	}<br />
	if(temp!=root)<br />
	{<br />
		if((temp!=temp2)&amp;&amp;(temp!=NULL&amp;&amp;temp2!=NULL)&amp;&amp;(temp-&gt;next!=temp2))<br />
		{<br />
			temp1-&gt;next=temp2;<br />
			temp4=temp2-&gt;next;<br />
			temp2-&gt;next=temp-&gt;next;<br />
			temp3-&gt;next=temp;<br />
			temp-&gt;next=temp4;<br />
		}<br />
	}<br />
	if(temp==root)<br />
	{<br />
		temp4=root;<br />
		root=temp2;<br />
		temp2-&gt;next=temp4-&gt;next;<br />
		temp3-&gt;next=temp4;<br />
		temp4-&gt;next=NULL;<br />
	}<br />
	if(temp==temp3)<br />
	{<br />
		temp4=temp2-&gt;next;<br />
		temp1-&gt;next=temp2;<br />
		temp2-&gt;next=temp;<br />
		temp-&gt;next=temp4;<br />
	}<br />
}<br />
void main()<br />
{<br />
	int d,ret;<br />
	system(&#8220;cls&#8221;);<br />
	ret=create();<br />
	cout&lt;&gt;d;<br />
	swap(d,ret);<br />
	display(root);<br />
	getch();<br />
}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-22075">
        <div id="dsq-comment-header-22075" class="dsq-comment-header">
            <cite id="dsq-cite-22075">
                <span id="dsq-author-user-22075">Himanshu</span>
            </cite>
        </div>
        <div id="dsq-comment-body-22075" class="dsq-comment-body">
            <div id="dsq-comment-message-22075" class="dsq-comment-message"><p>in o(N) complexity</p>
<pre> <code language="C">
/*
Given a singly linked list, swap kth node from beginning with kth node from end. Swapping of data is not allowed, only pointers should be changed. This requirement may be logical in many situations where the linked list data part is huge (For example student details line Name, RollNo, Address, ..etc). The pointers are always fixed (4 bytes for most of the compilers).
*/


#include&lt;stdio.h&gt;
#include&lt;conio.h&gt;
#include&lt;stdlib.h&gt;


struct node
{
	int x;
	struct node * next;

}*head;
typedef struct node* link;

link nw(int x)
{
	link temp;
	temp=(link)malloc (sizeof(node));
	temp-&gt;x=x;
	temp-&gt;next=NULL;
	return temp;
}
void insert(int x)
{
	if(head==NULL)
		head=nw(x);
	else
		{
			link t;
			t=head;
			
			while(1)
			{
				
				if(t-&gt;next==NULL)
			    {
                 t-&gt;next=nw(x);
                 break;                
                 }
                else
                t=t-&gt;next; 	                 
			}
			
		}
}

void print()
{
     printf(&quot;\n link list is \n&quot;);
	link t;
	t=head;
	
	while(t!=NULL)
	{
		printf(&quot;  %d  &quot;,t-&gt;x);
		t=t-&gt;next;
	
	}
  
}





void replace(int k)
{
	int i,j=0;
	int flag=0;
	int tot=0;
	link t;
	t=head;

  //  printf(&quot; hi &quot;);	
	while(t!=NULL)
	{
		tot++;
		t=t-&gt;next;
	}
	
	printf(&quot; \n total node is %d &quot;,tot);
 
	if(k&gt;tot||k==0)
		{
			printf(&quot;\n sorry range is not available&quot;);
			return; 
		}
	int st=k;
	int en=tot-k+1;
	int curr=0;

	if(st==en)
		{
			flag=1;
			return ;
		}
	
	if(st&gt;en)
		{
			j=st;
			st=en;
			en=j;
		
		}
	link tt;
	link pre1=NULL,t1,pre2,t2;
	t1=head;
	
	i=1;
			while(i!=st)
				{
					i++;
					pre1=t1;
					t1=t1-&gt;next;
				}
				t2=t1;
				pre2=pre1;
			while(i!=en)
				{
					i++;
					pre2=t2;
					t2=t2-&gt;next;
				}
				tt=t2-&gt;next;
				pre2-&gt;next=t1;
		    	t2-&gt;next=t1-&gt;next;
				t1-&gt;next=tt;	
		        if(pre1!=NULL)
		             pre1-&gt;next=t2;
		        else
                    {
                       head=t2;                           
                                   
                    }
                    
                    
                         
		  	         
				return;
		
	
/*	

	for(i=j;ct[i]!='&#092;&#048;';i++)
	{
		ct[i]='&#092;&#048;';
	}
	printf(&quot; The string is %s &quot;,ct);
*/
}



int main()
{
insert(1);
insert(2);
insert(3);
insert(4);
insert(5);
insert(6);
insert(7);

/*
insert(2);
insert(2);
insert(2);
insert(2);
insert(2);
*/
print();
int rep;
int tot=7;
for(rep=0;rep&lt;tot;rep++)
{
                        replace(rep);
                        print();
}
getch();
return 0;
}

</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-neo_t even thread-even depth-1" id="dsq-comment-21065">
        <div id="dsq-comment-header-21065" class="dsq-comment-header">
            <cite id="dsq-cite-21065">
                <span id="dsq-author-user-21065">Neo_T</span>
            </cite>
        </div>
        <div id="dsq-comment-body-21065" class="dsq-comment-body">
            <div id="dsq-comment-message-21065" class="dsq-comment-message"><pre> <code language="C">
/* // If x_prev exists, then new next of it will be y. Consider the case
    // when y-&gt;next is x, in this case, x_prev and y are same. So the statement
    // &quot;x_prev-&gt;next = y&quot; creates a self loop. This self loop will be broken
    // when we change y-&gt;next.
    if (x_prev)
        x_prev-&gt;next = y;
 
    // Same thing applies to y_prev
    if (y_prev)
        y_prev-&gt;next = x; */
</code> </pre>
<p>I am not able to understand how the code works for special cases mentioned above, ie Y is next of X or X is next of Y.<br />
How is the self loop created by the statement y_prev->next=x (in case of Y next to X) terminated ?<br />
Kindly help me.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-19999">
        <div id="dsq-comment-header-19999" class="dsq-comment-header">
            <cite id="dsq-cite-19999">
                <span id="dsq-author-user-19999">crazy</span>
            </cite>
        </div>
        <div id="dsq-comment-body-19999" class="dsq-comment-body">
            <div id="dsq-comment-message-19999" class="dsq-comment-message"><pre> <code language="C">
#include &lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
using namespace std;
typedef struct node
{
    int data;
    struct node *next;
}node;
void printlist(node *head)
{
    for(;head!=NULL;head=head-&gt;next)
     printf(&quot;%d &quot;,head-&gt;data);
    printf(&quot;\n&quot;);
}
void push(node **headref,int data)
{
    node *newnode=(node *)malloc(sizeof(node));
    newnode-&gt;data=data;
    newnode-&gt;next=(*headref);
    (*headref)=newnode;
}
void swapnode(node **headref,int k,int n)
{
    int i;
    if(n&lt;k)
     return;
    if(2*k-1==n)
     return;
    node *x,*xprev,*y,*yprev;
    xprev=yprev=NULL;
    x=y=(*headref);
    for(i=0;i&lt;k-1;i++)
    {
        xprev=x;
        x=x-&gt;next;
    }
    for(i=0;i&lt;n-k;i++)
    {
        yprev=y;
        y=y-&gt;next;
    }
    if(xprev)
     xprev-&gt;next=y;
    if(yprev)
     yprev-&gt;next=x;
    node *temp=y-&gt;next;
    y-&gt;next=x-&gt;next;
    x-&gt;next=temp;
    if(k==1)
     (*headref)=y;
    if(k==n)
     (*headref)=x;
}
int countnodes(node *head)
{
    int count=0;
    for(;head!=NULL;head=head-&gt;next)
     count++;
    return count;
}
int main()
{
    node *head=NULL;
    int i,n;
    for(i=8;i&gt;0;i--)
     push(&amp;head,i);
    printf(&quot;Initial list:\n&quot;);
    printlist(head);
    n=countnodes(head);
    for(i=1;i&lt;10;i++)
    {
        printf(&quot;For k=%d:\n&quot;,i);
        swapnode(&amp;head,i,n);
        printlist(head);
    }
    return 0;
}
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
</li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-19156">
        <div id="dsq-comment-header-19156" class="dsq-comment-header">
            <cite id="dsq-cite-19156">
                <span id="dsq-author-user-19156">Zohreh</span>
            </cite>
        </div>
        <div id="dsq-comment-body-19156" class="dsq-comment-body">
            <div id="dsq-comment-message-19156" class="dsq-comment-message"><p>This is a more modular approach. Only needs one time traversal of the list also.<br />
&#8212;&#8212;&#8212;&#8212;&#8211;<br />
void LList::swapKthNode(LList* &amp;head, int k) {<br />
	LList* p = head;<br />
	LList* p1 = head;<br />
	LList* p2 = head;<br />
	LList* preDummy = head;<br />
	LList* pre1 = head;<br />
	LList* pre2 = head;<br />
	int moves;<br />
	if(!moveToKth(p, k, preDummy, moves))<br />
		return;</p>
<p>	moveToKth(p1, k, pre1, moves);<br />
	moveToKth(p, INT_MAX, preDummy, moves);</p>
<p>	int dummy;<br />
	moveToKth(p2, moves, pre2, dummy);<br />
	swap(pre1-&gt;next, pre2-&gt;next);<br />
	swap(p1-&gt;next, p2-&gt;next);</p>
<p>}</p>
<p>int LList::moveToKth(LList* &amp;p, int k, LList* &amp;pre, int&amp; moves) {<br />
	moves = 0;<br />
	while( k-1 &gt; 0 ) {<br />
		if (p == NULL) {<br />
			return 0;<br />
		}<br />
		if (moves) {<br />
			pre = pre-&gt;next;<br />
		}<br />
		p = p-&gt;next;<br />
		k&#8211;;<br />
		moves++;<br />
	}<br />
	return moves;<br />
}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-19076">
        <div id="dsq-comment-header-19076" class="dsq-comment-header">
            <cite id="dsq-cite-19076">
                <span id="dsq-author-user-19076">u no guy</span>
            </cite>
        </div>
        <div id="dsq-comment-body-19076" class="dsq-comment-body">
            <div id="dsq-comment-message-19076" class="dsq-comment-message"><p>geeks!<br />
u no free() malloc&#8217;ed stuff and typedef struct?</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-18982">
        <div id="dsq-comment-header-18982" class="dsq-comment-header">
            <cite id="dsq-cite-18982">
                <span id="dsq-author-user-18982">gags</span>
            </cite>
        </div>
        <div id="dsq-comment-body-18982" class="dsq-comment-body">
            <div id="dsq-comment-message-18982" class="dsq-comment-message"><p>public void swap(ListNodeSingle node, int k) {<br />
		if (node == null || k &lt;= 0) {<br />
			return;<br />
		}</p>
<p>		int kthFromEnd = k &#8211; 1;// 8<br />
		int kthFromStart = k &#8211; 1;// 8<br />
		ListNodeSingle slow = node;<br />
		ListNodeSingle fast = node;<br />
		ListNodeSingle kth = null;<br />
		// to get the kth from the start<br />
		while (fast != null) {<br />
			if (kthFromStart == 0)<br />
				kth = fast;<br />
			kthFromStart&#8211;;<br />
			// to get the kth from the last<br />
			if (fast.getNext() != null) {<br />
				if (kthFromEnd &lt;= 0) {<br />
					slow = slow.getNext();<br />
				}<br />
				kthFromEnd&#8211;;<br />
			}<br />
			fast = fast.getNext();<br />
		}</p>
<p>		//check for null so that there is<br />
		if (kth != null &amp;&amp; slow != null) {<br />
			int temp = kth.getData();<br />
			kth.setData(slow.getData());<br />
			slow.setData(temp);<br />
		}<br />
	}</p>
</div>
        </div>

    </li><!-- #comment-## -->
</li><!-- #comment-## -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-18696">
        <div id="dsq-comment-header-18696" class="dsq-comment-header">
            <cite id="dsq-cite-18696">
                <span id="dsq-author-user-18696">Karshit</span>
            </cite>
        </div>
        <div id="dsq-comment-body-18696" class="dsq-comment-body">
            <div id="dsq-comment-message-18696" class="dsq-comment-message"><p>Hi all <img src="http://d2o58evtke57tz.cloudfront.net/wp-includes/images/smilies/icon_smile.gif" alt=":)" class="wp-smiley" /><br />
I have recently joined IIIT Allahabad for Engineering.<br />
Please assess my attempt to this problem.<br />
ps : I am a beginner.<br />
Constructive comments for improvement are welcome.</p>
<pre> <code language="C">
#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;cmath&gt;

using namespace std;

struct node {
    int data;
    node *next;
};

node* create(int n)
{
    int x;

    node *head, *temp;
    head = new node();

    cout &lt;&lt; &quot;\nEnter data:\n&quot;;
    cin &gt;&gt; x;

    head -&gt; data = x;
    head -&gt; next = NULL;

    temp = head;

    for (int i = 1; i &lt; n; i++) {
        cin &gt;&gt; x;

        head -&gt; next = new node();
        head = head -&gt; next;
        head -&gt; data = x;
        head -&gt; next = NULL;
    }

    return temp;
}

void print(node *head)
{
    if (head != NULL) {
        cout &lt;&lt; head -&gt; data &lt;&lt; &quot; -&gt; &quot;;
        print(head -&gt; next);
    }
}

int count(node *head)
{
    if (head == NULL) {
        return 0;
    }

    return 1 + count(head -&gt; next);
}

node* Kswap(node *head, int k) {
    int n = count(head);

    if (k &gt; n) {
        cout &lt;&lt; &quot;\nInvalid k\n&quot;;

        return NULL;
    }

    if (k == n - k + 1) {
        cout &lt;&lt; &quot;Same Node\n&quot;;

        return head;
    }

    if (k == 1 || k == n) {
        node *p = head, *q;

        while (head -&gt; next -&gt; next != NULL) {
            head = head -&gt; next;
        }

        q = head -&gt; next;
        q -&gt; next = p -&gt; next;
        head -&gt; next = p;
        p -&gt; next = NULL;

        return q;
    }

    if (n - k == k) {


        node *p = head, *q, *r;

        for (int i = 0; i &lt; k - 2 ; i++) {
            p = p -&gt; next;
        }

        q = p -&gt; next;
        r = q -&gt; next;

        p -&gt; next = r;
        q -&gt; next = r -&gt; next;
        r -&gt; next = q;

        return head;
    }

    if (n - k + 1 == k - 1) {
        node *p = head, *q, *r;

        for (int i = 0; i &lt; k - 3 ; i++) {
            p = p -&gt; next;
        }

        q = p -&gt; next;
        r = q -&gt; next;

        p -&gt; next = r;
        q -&gt; next = r -&gt; next;
        r -&gt; next = q;

        return head;
    }

    int a = n - k + 1;
    node *p = head, *q, *r, *s = head, *t, *u;

    for (int i = 0; i &lt; k - 2; i++) {
        p = p -&gt; next;
    }

    q = p -&gt; next;
    r = q -&gt; next;

    for (int i = 0; i &lt; a - 2; i++) {
        s = s -&gt; next;
    }

    t = s -&gt; next;
    u = t -&gt; next;

    p -&gt; next = t;
    t -&gt; next = r;
    s -&gt; next = q;
    q -&gt; next = u;

    return head;
}


int main()
{


    int n, k;

    node *head = NULL;

    cout &lt;&lt; &quot;Enter total number of Elements\n&quot;;
    cin &gt;&gt; n;

    head = create(n);

    cout &lt;&lt; &quot;\n\n&quot;;

    print(head);

    cout &lt;&lt; &quot;NULL\n&quot;;

    while(1) {

        cout &lt;&lt; &quot;\nEnter K to swap Kth node from beginning with Kth node from end\n&quot;;
        cin &gt;&gt; k;

        if (k &gt; n) {
            return 0;
        }

        head = Kswap(head, k);

        print(head);

        cout &lt;&lt; &quot;NULL\n\n&quot;;

    }
}

</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-18377">
        <div id="dsq-comment-header-18377" class="dsq-comment-header">
            <cite id="dsq-cite-18377">
http://chandanpuggal@gmail.com                <span id="dsq-author-user-18377">Chandan</span>
            </cite>
        </div>
        <div id="dsq-comment-body-18377" class="dsq-comment-body">
            <div id="dsq-comment-message-18377" class="dsq-comment-message"><p>if (k == n)<br />
        *head_ref = x; /* There should be y instead of x? */</p>
<p>Please tell why should head not point to y?</p>
<p>Correct me if i&#8217;m wrong..</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
</li><!-- #comment-## -->
</li><!-- #comment-## -->
    <li class="comment byuser comment-author-hitesh-dholaria odd alt thread-odd thread-alt depth-1" id="dsq-comment-18142">
        <div id="dsq-comment-header-18142" class="dsq-comment-header">
            <cite id="dsq-cite-18142">
                <span id="dsq-author-user-18142">Hitesh</span>
            </cite>
        </div>
        <div id="dsq-comment-body-18142" class="dsq-comment-body">
            <div id="dsq-comment-message-18142" class="dsq-comment-message"><p>Have a look at this out-of-box solution:</p>
<p>Time Complexity: O(n)<br />
Space Complexity: O(n) // Array is used to store the addresses of all the linked list nodes</p>
<pre> <code language="C">
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

typedef struct LinkedList {
	int data;
	struct LinkedList* next;
}Node;

// Size of the linked list
int SIZE=0;

// Create new node for insertion and return its address
Node* insert(int data) {
	Node* last=(Node *)malloc(sizeof(Node));
	last-&gt;data=data;
	last-&gt;next=NULL;
	return last;
}

// Create new linked list
// After creation, return pointer to very first node
Node* create(void) {
	int i=0;
	Node* first=NULL;
	Node* last=NULL;
	while(1) {
		printf(&quot;\n(Enter -1 to finish) Enter data: &quot;);
		scanf(&quot;%d&quot;,&amp;i);
		if(i==-1) {
			break;
		}
		SIZE++;
		if(SIZE==1) {
			first=insert(i);
			last=first;
		} else {
			last-&gt;next=insert(i);
			last=last-&gt;next;
		}
	}
	return first;
}

// Print linked list
void print(Node* node) {
	while(node) {
		printf(&quot;-&gt; %d &quot;,node-&gt;data);
		node=node-&gt;next;
	}
}

// Swap k-th linked list nodes from both ends
// Swap only pointers, not actual data
// After swapping, return pointer to very first node
Node* swap(Node* node, int k) {
	if(SIZE==0) {
		printf(&quot;\n\nERROR: Linked list is empty!&quot;);
		return node;
	} else if(k&lt;1 || k&gt;SIZE) {
		printf(&quot;\n\nERROR: Invalid swap position!&quot;);
		return node;
	} else if(k==SIZE-k+1) {
		// No need to swap!
		return node;
	} else {
		int i=1;
		// p is the array that holds pointers/addresses to the nodes of the original linked list
		Node* p[SIZE];

		Node* first=NULL;

		// left pointer points to the k-th node from the left side
		Node* left=NULL;

		// left pointer points to the k-th node from the left side
		Node* right=NULL;

		// Save first node's address for reuse
		first=node;

		// Loop through linked list for determining the left and right pointers
		while(node) {
			if(i==k) {
				left=node;
			}
			if(i==SIZE-k+1) {
				right=node;
			}
			node=node-&gt;next;
			i++;
		}

		// Reset node pointer to the very first node
		node=first;

		// Main swapping logic
		// Store linked list node pointers into an array
		// Also, swap left and right pointers in an array
		for(i=0;i&lt;SIZE;i++) {
			if(node==left) {
				p[i]=right;
			} else if(node==right) {
				p[i]=left;
			} else {
				p[i]=node;
			}
			node=node-&gt;next;
		}
		for(i=0;i&lt;SIZE-1;i++) {
			p[i]-&gt;next=p[i+1];
		}
		p[i]-&gt;next=NULL;
		return p[0];
	}
}

int main(){
	Node* first=create();

	printf(&quot;\nLinked list before swapping the nodes: &quot;);
	print(first);

	first=swap(first,3);

	printf(&quot;\n\nLinked list after swapping the nodes: &quot;);
	print(first);

	printf(&quot;\n\n&quot;);

	return 0;
}
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-2" id="dsq-comment-23653">
        <div id="dsq-comment-header-23653" class="dsq-comment-header">
            <cite id="dsq-cite-23653">
                <span id="dsq-author-user-23653">rk_roy</span>
            </cite>
        </div>
        <div id="dsq-comment-body-23653" class="dsq-comment-body">
            <div id="dsq-comment-message-23653" class="dsq-comment-message"><p>vry easy to understand :)&#8230;thnx</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-18137">
        <div id="dsq-comment-header-18137" class="dsq-comment-header">
            <cite id="dsq-cite-18137">
http://zebadiah.me                <span id="dsq-author-user-18137">Zeb</span>
            </cite>
        </div>
        <div id="dsq-comment-body-18137" class="dsq-comment-body">
            <div id="dsq-comment-message-18137" class="dsq-comment-message"><p>Yet another solution:</p>
<pre> <code language="C">
#include &lt;iostream&gt;

using namespace std;

class Node
{
public:
	int value;
	Node* next;

	Node(int value)
	{
		this-&gt;value = value;
		this-&gt;next = NULL;
	}

	static void printList(Node* first)
	{
		Node* currentNode = first;
		while(currentNode != NULL)
		{
			cout &lt;&lt; currentNode-&gt;value &lt;&lt; &quot; &quot;;
			currentNode = currentNode-&gt;next;
		}
		cout &lt;&lt; &quot;\n&quot;;
	}
};

Node* swapKthNodesFromStartAndEnd(Node* firstNode, int k)
{
	int c = 1;
	Node* swapNodeA = NULL;
	Node* lastNode = NULL;
	Node* nodeBeforeLastNode = NULL;

	Node* currentNode = firstNode;
	while(currentNode != NULL)
	{
		if(c == k)
		{
			swapNodeA = currentNode;
		}
		c++;

		if(currentNode-&gt;next != NULL &amp;&amp; currentNode-&gt;next-&gt;next == NULL)
		{
			nodeBeforeLastNode = currentNode;
			lastNode = currentNode-&gt;next;
		}
		currentNode = currentNode-&gt;next;
	}

	if(swapNodeA == NULL)
	{
		cout &lt;&lt; &quot;k out of bounds : (\n&quot;;
		
		return firstNode;
	}

	if(swapNodeA == firstNode || swapNodeA == lastNode)
	{
		lastNode-&gt;next = firstNode-&gt;next;
		firstNode-&gt;next = NULL;
		nodeBeforeLastNode-&gt;next = firstNode;

		return lastNode;
	}

	int listLength = c;
	c = 1;
	currentNode = firstNode;
	Node* swapNodeB = NULL;
	Node* nodeBeforeSwapNodeA = NULL;
	Node* nodeBeforeSwapNodeB = NULL;
	while(currentNode != NULL &amp;&amp; (nodeBeforeSwapNodeA == NULL || nodeBeforeSwapNodeB == NULL))
	{
		if(c == k-1)
		{
			nodeBeforeSwapNodeA = currentNode;
		}
		if(c == (listLength-k) - 1)
		{
			nodeBeforeSwapNodeB = currentNode;
			swapNodeB = currentNode-&gt;next;
		}

		c++;
		currentNode = currentNode-&gt;next;
	}

	// Swap the nodes
	nodeBeforeSwapNodeA-&gt;next = swapNodeB;
	nodeBeforeSwapNodeB-&gt;next = swapNodeA;
	Node* temp = swapNodeA-&gt;next;
	swapNodeA-&gt;next = swapNodeB-&gt;next;
	swapNodeB-&gt;next = temp;

	return firstNode;
}

int main()
{
	Node* currentNode = new Node(1);
	Node* firstNode = currentNode;

	// Load some data into the list
	for(int i = 2; i &lt;= 11; i++)
	{
		currentNode-&gt;next = new Node(i);
		currentNode = currentNode-&gt;next;
	}

	Node::printList(firstNode);

	for(int i = 0; i &lt;= 12; i++)
	{
		firstNode = swapKthNodesFromStartAndEnd(firstNode, i);
		Node::printList(firstNode);
	}

	cin.get();
}
</code> </pre>
<p>output is:<br />
1 2 3 4 5 6 7 8 9 10 11<br />
k out of bounds : (<br />
1 2 3 4 5 6 7 8 9 10 11<br />
11 2 3 4 5 6 7 8 9 10 1<br />
11 10 3 4 5 6 7 8 9 2 1<br />
11 10 9 4 5 6 7 8 3 2 1<br />
11 10 9 8 5 6 7 4 3 2 1<br />
11 10 9 8 7 6 5 4 3 2 1<br />
11 10 9 8 7 6 5 4 3 2 1<br />
11 10 9 8 5 6 7 4 3 2 1<br />
11 10 9 4 5 6 7 8 3 2 1<br />
11 10 3 4 5 6 7 8 9 2 1<br />
11 2 3 4 5 6 7 8 9 10 1<br />
1 2 3 4 5 6 7 8 9 10 11<br />
k out of bounds : (<br />
1 2 3 4 5 6 7 8 9 10 11</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-18107">
        <div id="dsq-comment-header-18107" class="dsq-comment-header">
            <cite id="dsq-cite-18107">
                <span id="dsq-author-user-18107">Prateek Sharma</span>
            </cite>
        </div>
        <div id="dsq-comment-body-18107" class="dsq-comment-body">
            <div id="dsq-comment-message-18107" class="dsq-comment-message"><p>Previous code has one test case missing,here is modified code with o(n) time and o(1) space complexity.Length of code can surely be reduced ..I just write every case separately</p>
<pre> <code language="C">
#include&lt;conio.h&gt;
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
struct Node {
       int value;
       struct Node *next;
       };
int insertAtEnd(struct Node *node,int val) {
    struct Node *temp;
    struct Node *ne;
    temp = node;
    while(temp-&gt;next!= NULL) {
          temp = temp-&gt;next;
}
    ne = (struct Node *) malloc(sizeof(struct Node));
    ne-&gt;value = val;
    ne-&gt;next = NULL;
    temp-&gt;next = ne;    
    return 0;                          
}         
int swappingKthNodeFromFirstandLast(struct Node *node,int k){
    struct Node *temp,*store,*first,*second,*prev;
    temp = node;
    int i,count = 0,token = 0;
    while(temp != NULL){
       count = count+1;
       temp = temp-&gt;next;
       }
    if (k &gt;count){
     printf(&quot;\nswapping not possible&quot;);
     return 0;}
    if (k == count or k==1){
     temp = node;
     while(temp-&gt;next-&gt;next != NULL){
        temp = temp-&gt;next;
        }                        
     temp-&gt;next-&gt;next = node;
     node = temp-&gt;next;
     temp-&gt;next = temp-&gt;next-&gt;next ;
     node-&gt;next = node-&gt;next-&gt;next;
     temp-&gt;next-&gt;next = NULL;
     printf(&quot;modified list is\n&quot;);
     temp = node;
     while(temp != NULL){
      printf(&quot;%d&quot;,temp-&gt;value);
      temp = temp-&gt;next;
      }return 0;}
    else{
         temp = node;
         for(i=2;i&lt;k;i++)                                   
           { temp = temp-&gt;next;
            }       
         int diff = count -k;
         store = node;
         for (i =1;i&lt;diff;i++){
             store = store-&gt;next;
             }
         if (temp-&gt;next == store){
            first = store-&gt;next-&gt;next;
            prev = temp-&gt;next;
            temp-&gt;next= store-&gt;next;
            temp-&gt;next-&gt;next = prev;
            temp-&gt;next-&gt;next-&gt;next = first;
            temp = node;  
            printf(&quot;\n Modified List is&quot;);
            while (temp != NULL){
             printf(&quot;%d&quot;, temp-&gt;value);
             temp = temp-&gt;next;}
             return 0;}
                                  
         else if (temp-&gt;next == store-&gt;next){
              printf(&quot;\n there is no need of modification&quot;);
            temp = node;
            while(temp != NULL)
            { printf(&quot;%d&quot;,temp-&gt;value);
            temp = temp-&gt;next;
            }
            return 0;}
         else{
         first = temp-&gt;next-&gt;next;
         second = store-&gt;next-&gt;next;
         if (temp == store-&gt;next){
              token = 1;}      
         prev = temp-&gt;next;
         temp-&gt;next = store-&gt;next;
         store-&gt;next = prev;
         temp-&gt;next-&gt;next = first;
         if (token == 1)
         {store-&gt;next-&gt;next = temp;}
         else{
         store-&gt;next-&gt;next = second;}
         temp = node;
         printf(&quot;\n Modified List is&quot;);
         while (temp != NULL){
             printf(&quot;%d&quot;, temp-&gt;value);
             temp = temp-&gt;next;
             }}return 0;}}
                               
int main() {
   int n,s,i =1; 
   struct Node *node,*temp;
   node = (struct Node *) malloc(sizeof(struct Node));
   printf(&quot;enter size of linked list&quot;);
   scanf(&quot;%d&quot;,&amp;s);
   printf(&quot;enter value of root node:\n&quot;);
   scanf(&quot;%d&quot;,&amp;n);
   node-&gt;value = n;
   node-&gt;next = NULL;
   while(i&lt;=s-1) {
   printf(&quot;enter next element of linked list\n&quot;);
   scanf(&quot;%d&quot;,&amp;n);
   insertAtEnd(node,n);
   i++;}   
   printf(&quot;enter value of K\n&quot;);
   scanf(&quot;%d&quot;,&amp;n);
   swappingKthNodeFromFirstandLast(node,n); 
   getch();
   return 0;
}                   
   
   

</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-18106">
        <div id="dsq-comment-header-18106" class="dsq-comment-header">
            <cite id="dsq-cite-18106">
                <span id="dsq-author-user-18106">atul</span>
            </cite>
        </div>
        <div id="dsq-comment-body-18106" class="dsq-comment-body">
            <div id="dsq-comment-message-18106" class="dsq-comment-message"><p>There is no need to count the number of nodes in the linked list.We can simply do in in one parse.</p>
<p>start=head;<br />
end=head;<br />
start_kth,end_kth;</p>
<p>while(inext;<br />
     i++;<br />
}</p>
<p>while(end)<br />
{<br />
    start=start-&gt;next;<br />
    end=end-&gt;next;<br />
}<br />
end_kth=start;</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-18102">
        <div id="dsq-comment-header-18102" class="dsq-comment-header">
            <cite id="dsq-cite-18102">
                <span id="dsq-author-user-18102">Prateek Sharma</span>
            </cite>
        </div>
        <div id="dsq-comment-body-18102" class="dsq-comment-body">
            <div id="dsq-comment-message-18102" class="dsq-comment-message"><p>c code with o(n)time complexity and o(1) space complexity&#8230;</p>
<pre> <code language="C">
#include&lt;conio.h&gt;
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
struct Node {
       int value;
       struct Node *next;
       };
int insertAtEnd(struct Node *node,int val) {
    struct Node *temp;
    struct Node *ne;
    temp = node;
    while(temp-&gt;next!= NULL) {
          temp = temp-&gt;next;
}
    ne = (struct Node *) malloc(sizeof(struct Node));
    ne-&gt;value = val;
    ne-&gt;next = NULL;
    temp-&gt;next = ne;    
    return 0;                          
}         
int swappingKthNodeFromFirstandLast(struct Node *node,int k){
    struct Node *temp,*store,*first,*second,*prev;
    temp = node;
    int i,count = 0;
    while(temp != NULL){
       count = count+1;
       temp = temp-&gt;next;
       }
    if (k &gt;count){
     printf(&quot;\nswapping not possible&quot;);
     return 0;}
    if (k == count){
     temp = node;
     while(temp-&gt;next-&gt;next != NULL){
        temp = temp-&gt;next;
        }                        
     temp-&gt;next-&gt;next = node;
     node = temp-&gt;next;
     temp-&gt;next = temp-&gt;next-&gt;next ;
     node-&gt;next = node-&gt;next-&gt;next;
     temp-&gt;next-&gt;next = NULL;
     printf(&quot;modified list is\n&quot;);
     temp = node;
     while(temp != NULL){
      printf(&quot;%d&quot;,temp-&gt;value);
      temp = temp-&gt;next;
      }}
    else{
         temp = node;
         for(i=2;i&lt;k;i++)                                   
           { temp = temp-&gt;next;
            }       
         int diff = count -k;
         store = node;
         for (i =1;i&lt;diff;i++){
             store = store-&gt;next;
             }
         if (temp-&gt;next == store){
            first = store-&gt;next-&gt;next;
            prev = temp-&gt;next;
            temp-&gt;next= store-&gt;next;
            temp-&gt;next-&gt;next = prev;
            temp-&gt;next-&gt;next-&gt;next = first;
            temp = node;  
            printf(&quot;\n Modified List is&quot;);
            while (temp != NULL){
             printf(&quot;%d&quot;, temp-&gt;value);
             temp = temp-&gt;next;}
             return 0;}
                                  
         if (temp-&gt;next == store-&gt;next){
              printf(&quot;\n there is no need of modification&quot;);
            temp = node;
            while(temp != NULL)
            { printf(&quot;%d&quot;,temp-&gt;value);
            temp = temp-&gt;next;
            }
            return 0;}
         else {
         first = temp-&gt;next-&gt;next;
         second = store-&gt;next-&gt;next;      
         prev = temp-&gt;next;
         temp-&gt;next = store-&gt;next;
         store-&gt;next = prev;
         temp-&gt;next-&gt;next = first;
         store-&gt;next-&gt;next = second;
         temp = node;
         printf(&quot;\n Modified List is&quot;);
         while (temp != NULL){
             printf(&quot;%d&quot;, temp-&gt;value);
             temp = temp-&gt;next;
             }}return 0;}}
                               
int main() {
   int n,s,i =1; 
   struct Node *node,*temp;
   node = (struct Node *) malloc(sizeof(struct Node));
   printf(&quot;enter size of linked list&quot;);
   scanf(&quot;%d&quot;,&amp;s);
   printf(&quot;enter value of root node:\n&quot;);
   scanf(&quot;%d&quot;,&amp;n);
   node-&gt;value = n;
   node-&gt;next = NULL;
   while(i&lt;=s-1) {
   printf(&quot;enter next element of linked list\n&quot;);
   scanf(&quot;%d&quot;,&amp;n);
   insertAtEnd(node,n);
   i++;}   
   printf(&quot;enter value of K\n&quot;);
   scanf(&quot;%d&quot;,&amp;n);
   swappingKthNodeFromFirstandLast(node,n); 
   getch();
   return 0;
}                   
   
   

</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-18075">
        <div id="dsq-comment-header-18075" class="dsq-comment-header">
            <cite id="dsq-cite-18075">
                <span id="dsq-author-user-18075">Subhajit</span>
            </cite>
        </div>
        <div id="dsq-comment-body-18075" class="dsq-comment-body">
            <div id="dsq-comment-message-18075" class="dsq-comment-message"><p>This code is wrong.<br />
consider the case:</p>
<p>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6     n=6   k=4</p>
<p>so x=4 x-&gt;prev=3<br />
   y=3 y-&gt;prev=2</p>
<p>y-&gt;prev=x is kool<br />
but x-&gt;prev=y is becoming a loop&#8230;u have to handle these cases explicitly. il share the corect code mean while.</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-geeksforgeeks bypostauthor even depth-2" id="dsq-comment-18076">
        <div id="dsq-comment-header-18076" class="dsq-comment-header">
            <cite id="dsq-cite-18076">
                <span id="dsq-author-user-18076">GeeksforGeeks</span>
            </cite>
        </div>
        <div id="dsq-comment-body-18076" class="dsq-comment-body">
            <div id="dsq-comment-message-18076" class="dsq-comment-message"><p>Please take a closer look at the code. It works for this case also.  See <a href="http://ideone.com/cfAY7m" rel="nofollow">http://ideone.com/cfAY7m</a> for a sample run.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-3" id="dsq-comment-18080">
        <div id="dsq-comment-header-18080" class="dsq-comment-header">
            <cite id="dsq-cite-18080">
                <span id="dsq-author-user-18080">Subhajit</span>
            </cite>
        </div>
        <div id="dsq-comment-body-18080" class="dsq-comment-body">
            <div id="dsq-comment-message-18080" class="dsq-comment-message"><p>my mistake&#8230;i overlooked it&#8230;.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-4" id="dsq-comment-18130">
        <div id="dsq-comment-header-18130" class="dsq-comment-header">
            <cite id="dsq-cite-18130">
                <span id="dsq-author-user-18130">gayathri</span>
            </cite>
        </div>
        <div id="dsq-comment-body-18130" class="dsq-comment-body">
            <div id="dsq-comment-message-18130" class="dsq-comment-message"><p>x-&gt;next=y-&gt;next makes a loop in this case..<br />
i.e at the end we have 2 lists<br />
1-&gt;2-&gt;4 with 4-&gt;next pointing to itself and 3-&gt;4-&gt;5</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt depth-3" id="dsq-comment-18133">
        <div id="dsq-comment-header-18133" class="dsq-comment-header">
            <cite id="dsq-cite-18133">
                <span id="dsq-author-user-18133">gayathri</span>
            </cite>
        </div>
        <div id="dsq-comment-body-18133" class="dsq-comment-body">
            <div id="dsq-comment-message-18133" class="dsq-comment-message"><p>x-&gt;next=y-&gt;next makes a loop in this case..<br />
i.e at the end we have 2 lists<br />
1-&gt;2-&gt;4 with 4-&gt;next pointing to itself and 3-&gt;5-&gt;6</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-18074">
        <div id="dsq-comment-header-18074" class="dsq-comment-header">
            <cite id="dsq-cite-18074">
                <span id="dsq-author-user-18074">jain</span>
            </cite>
        </div>
        <div id="dsq-comment-body-18074" class="dsq-comment-body">
            <div id="dsq-comment-message-18074" class="dsq-comment-message"><p>We can do it in a single scan<br />
1. find the kth node from start(with previous node) say x<br />
2.let y=x,z=head<br />
3.now in a loop make y=y-&gt;next and z=z-&gt;next until you reach the end from z. y then contains the kth node from end<br />
4.swap x and y<br />
5.check if k==1 or k==n and change head if required</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-18135">
        <div id="dsq-comment-header-18135" class="dsq-comment-header">
            <cite id="dsq-cite-18135">
http://zebadiah.me                <span id="dsq-author-user-18135">Zeb</span>
            </cite>
        </div>
        <div id="dsq-comment-body-18135" class="dsq-comment-body">
            <div id="dsq-comment-message-18135" class="dsq-comment-message"><p>I think you are overlooking the minor point that you don&#8217;t know the length of the list until you&#8217;ve done at least one run through. So there&#8217;s no way to know when you are k nodes from the end on the first pass. Unless I&#8217;m missing something it can&#8217;t be done with a single pass through the list.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-jainamit0909gmail-com even depth-3" id="dsq-comment-18166">
        <div id="dsq-comment-header-18166" class="dsq-comment-header">
            <cite id="dsq-cite-18166">
                <span id="dsq-author-user-18166">AMIT</span>
            </cite>
        </div>
        <div id="dsq-comment-body-18166" class="dsq-comment-body">
            <div id="dsq-comment-message-18166" class="dsq-comment-message"><p>there is no need to find the length of the list for finding kth node from end<br />
1.go to kth node from head<br />
2. now start one pointer from head and 2nd pointer from kth node from start and increment both till 2nd pointer reaches NULL<br />
3.when the 2nd pointer reaches NULL,1st pointer is kth node from end<br />
so,isn&#8217;t it a single scan??</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-4" id="dsq-comment-18173">
        <div id="dsq-comment-header-18173" class="dsq-comment-header">
            <cite id="dsq-cite-18173">
http://zebadiah.me                <span id="dsq-author-user-18173">Zeb</span>
            </cite>
        </div>
        <div id="dsq-comment-body-18173" class="dsq-comment-body">
            <div id="dsq-comment-message-18173" class="dsq-comment-message"><p>Ahh, now I see, sorry I was not getting that concept at all the first time I read through it. Thanks for the explanation. Also: neat trick.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even depth-2" id="dsq-comment-18186">
        <div id="dsq-comment-header-18186" class="dsq-comment-header">
            <cite id="dsq-cite-18186">
                <span id="dsq-author-user-18186">sahil gaur</span>
            </cite>
        </div>
        <div id="dsq-comment-body-18186" class="dsq-comment-body">
            <div id="dsq-comment-message-18186" class="dsq-comment-message"><p>i think you are absolutely right , apart from it should be y-&gt; next -&gt;next for 1st k node, so as to find the node before kth node for exchange. Rest is fine. Gr8 job <img src="http://d2o58evtke57tz.cloudfront.net/wp-includes/images/smilies/icon_smile.gif" alt=":)" class="wp-smiley" /></p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-jainamit0909gmail-com odd alt depth-3" id="dsq-comment-18204">
        <div id="dsq-comment-header-18204" class="dsq-comment-header">
            <cite id="dsq-cite-18204">
                <span id="dsq-author-user-18204">AMIT</span>
            </cite>
        </div>
        <div id="dsq-comment-body-18204" class="dsq-comment-body">
            <div id="dsq-comment-message-18204" class="dsq-comment-message"><p>yess.thats a part of coding.obviously to swap two nodes we need the nodes before them..also another way could be finding (k-1)th node from start and (k+1)th node from end,so that we can swap their next directly</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
            </ul>


        </div>

    </div>

<script type="text/javascript">
var disqus_url = 'http://www.geeksforgeeks.org/swap-kth-node-from-beginning-with-kth-node-from-end-in-a-linked-list/';
var disqus_identifier = '117603 http://www.geeksforgeeks.org/?p=117603';
var disqus_container_id = 'disqus_thread';
var disqus_shortname = 'geeksforgeeks';
var disqus_title = "Swap Kth node from beginning with Kth node from end in a Linked List";
var disqus_config_custom = window.disqus_config;
var disqus_config = function () {
    /*
    All currently supported events:
    onReady: fires when everything is ready,
    onNewComment: fires when a new comment is posted,
    onIdentify: fires when user is authenticated
    */
    
    
    this.language = '';
    
    if (disqus_config_custom) {
        disqus_config_custom.call(this);
    }
};

(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>

			</div>
	
					
			
			

		</div> <!-- end post -->	

<br></br>
	
</div> <!-- end content -->

<ul id="sidebar">
	<li id="text-19" class="widget widget_text">			<div class="textwidget"><script>
  (function() {
    var cx = '009682134359037907028:tj6eafkv_be';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//www.google.com/cse/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>

<style type="text/css">
  .gsc-control-cse {
    font-family: "Trebuchet MS", sans-serif;
    border-color: #E1F3DA;
    background-color: #E1F3DA;
  }
  input.gsc-input {
    border-color: #94CC7A;
  }
  input.gsc-search-button {
    border-color: #94CC7A;
    background-color: #AADA92;
  }
  .gsc-tabHeader.gsc-tabhInactive {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gsc-tabHeader.gsc-tabhActive {
    border-color: #A9DA92;
    background-color: #A9DA92;
  }
  .gsc-tabsArea {
    border-color: #A9DA92;
  }
  .gsc-webResult.gsc-result {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gsc-webResult.gsc-result:hover {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gs-webResult.gs-result a.gs-title:link,
  .gs-webResult.gs-result a.gs-title:link b {
    color: #009900;
  }
  .gs-webResult.gs-result a.gs-title:visited,
  .gs-webResult.gs-result a.gs-title:visited b {
    color: #009900;
  }
  .gs-webResult.gs-result a.gs-title:hover,
  .gs-webResult.gs-result a.gs-title:hover b {
    color: #003300;
  }
  .gs-webResult.gs-result a.gs-title:active,
  .gs-webResult.gs-result a.gs-title:active b {
    color: #009900;
  }
  .gsc-cursor-page {
    color: #009900;
  }
  a.gsc-trailing-more-results:link {
    color: #009900;
  }
  .gs-webResult.gs-result .gs-snippet {
    color: #454545;
  }
  .gs-webResult.gs-result .gs-visibleUrl {
    color: #33cc00;
  }
  .gs-webResult.gs-result .gs-visibleUrl-short {
    color: #33cc00;
  }
  .gs-webResult.gs-result .gs-visibleUrl-short {
    display: none;
  }
  .gs-webResult.gs-result .gs-visibleUrl-long {
    display: block;
  }
  .gsc-cursor-box {
    border-color: #A9DA92;
  }
  .gsc-results .gsc-cursor-page {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gsc-results .gsc-cursor-page.gsc-cursor-current-page {
    border-color: #A9DA92;
    background-color: #A9DA92;
  }
  .gs-promotion.gs-result {
    border-color: #94CC7A;
    background-color: #CBE8B4;
  }
  .gs-promotion.gs-result a.gs-title:link {
    color: #0066CC;
  }
  .gs-promotion.gs-result a.gs-title:visited {
    color: #0066CC;
  }
  .gs-promotion.gs-result a.gs-title:hover {
    color: #0066CC;
  }
  .gs-promotion.gs-result a.gs-title:active {
    color: #0066CC;
  }
  .gs-promotion.gs-result .gs-snippet {
    color: #454545;
  }
  .gs-promotion.gs-result .gs-visibleUrl,
  .gs-promotion.gs-result .gs-visibleUrl-short {
    color: #815FA7;
  }
</style>    </div>
		</li>
<li id="text-9" class="widget widget_text">			<div class="textwidget"><div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=138031159685820";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>

<div class="fb-like-box" data-href="https://www.facebook.com/pages/GeeksforGeeks/316764689022" data-width="250" data-height="170" data-colorscheme="light" data-show-faces="true" data-header="false" data-stream="false" data-show-border="false"></div></div>
		</li>
<li id="text-18" class="widget widget_text">			<div class="textwidget"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LargeRectangleSide -->
<ins class="adsbygoogle"
     style="display:inline-block;width:336px;height:280px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="1884636833"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
		</li>
<li id="text-13" class="widget widget_text">			<div class="textwidget"><ul><li><a href="http://www.geeksforgeeks.org/category/interview-experiences/">Interview Experiences</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/advance-data-structures">Advanced Data Structures</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/dynamic-programming">Dynamic Programming</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/Greedy-Algorithm/">Greedy Algorithms</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/backtracking">Backtracking</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/pattern-searching">Pattern Searching</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/divide-and-conquer">Divide & Conquer</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/MathematicalAlgo">Mathematical Algorithms</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/recursion">Recursion</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/geometric-algorithms/">Geometric Algorithms</a></li>
</ul></div>
		</li>
<li id="text-17" class="widget widget_text">			<div class="textwidget"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big 300x600 Sidebar -->
<ins class="adsbygoogle"
     style="display:inline-block;width:300px;height:600px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="4402736037"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
		</li>
<li id="text-14" class="widget widget_text"><h2 class="widgettitle">Popular Posts</h2>
			<div class="textwidget"><ul>
<li><a href="http://www.geeksforgeeks.org/write-a-c-program-to-print-all-permutations-of-a-given-string/">  All permutations of a given string </a></li>
<li><a href="http://www.geeksforgeeks.org/memory-layout-of-c-program/"> Memory Layout of C Programs</a> </li>
<li><a href="http://www.geeksforgeeks.org/understanding-extern-keyword-in-c/"> Understanding “extern” keyword in C</a> </li>
<li><a href="http://www.geeksforgeeks.org/median-of-two-sorted-arrays/">Median of two sorted arrays</a> </li>
<li><a href="http://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/"> Tree traversal without recursion and without stack! </a></li>
<li><a href="http://www.geeksforgeeks.org/structure-member-alignment-padding-and-data-packing/"> Structure Member Alignment, Padding and Data Packing</a> </li>
<li><a href="http://www.geeksforgeeks.org/write-a-function-to-get-the-intersection-point-of-two-linked-lists/"> Intersection point of two Linked Lists</a> </li>
<li><a href="http://www.geeksforgeeks.org/lowest-common-ancestor-in-a-binary-search-tree/"> Lowest Common Ancestor in a BST.</span></a> </li>
<li><a href="http://www.geeksforgeeks.org/a-program-to-check-if-a-binary-tree-is-bst-or-not/"> Check if a binary tree is BST or not</a> </li>
<li><a href="http://www.geeksforgeeks.org/sorted-linked-list-to-balanced-bst/"> Sorted Linked List to Balanced BST</a></li>
</ul></div>
		</li>
<li id="text-3" class="widget widget_text">			<div class="textwidget"><a href="https://twitter.com/GeeksforGeeks" class="twitter-follow-button" data-show-count="false">Follow @GeeksforGeeks</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>         


<!-- GOOGLE FEEDBURNER BUTTON-->
<a href="http://feeds.feedburner.com/Geeksforgeeks" title="Subscribe to my feed" rel="alternate" type="application/rss+xml"><img src="http://www.feedburner.com/fb/images/pub/feed-icon32x32.png" alt="" style="border:0"/></a><a href="http://feeds.feedburner.com/Geeksforgeeks" title="Subscribe to my feed" rel="alternate" type="application/rss+xml">Subscribe</a>

</div>
		</li>
<li id="text-21" class="widget widget_text"><h2 class="widgettitle">Recent Comments</h2>
			<div class="textwidget"><script type="text/javascript" src="http://geeksforgeeks.disqus.com//recent_comments_widget.js?num_items=6&hide_avatars=1&excerpt_length=50&hide_mods=0"></script></div>
		</li>
<li id="text-22" class="widget widget_text">			<div class="textwidget"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LinkAd -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:90px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="2606115235"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LinkAd -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:90px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="2606115235"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LinkAd -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:90px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="2606115235"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
		</li>

</ul>					  
		<div class="clear"></div>

		<div id="footer">
		
		    <div class="xhtml">
                        @geeksforgeeks, <a href="http://creativecommons.org/licenses/by-nc-nd/2.5/in/deed.en_US" title="Valid XHTML Strict 1.0">Some rights reserved</a>  <a href="http://www.geeksforgeeks.org/about/contact-us/"> &nbsp; &nbsp; &nbsp; &nbsp;Contact Us!</a>

		    </div>
		    
		    <div class="credits">
			  Powered by <a href="http://wordpress.org">WordPress </a> &amp; <a href="http://mootools.net/" title="Mootools JavaScript Framework">MooTools</a>, customized by geeksforgeeks team </div>
			  
		   <div class="clear"></div>						                            
		   
		</div> <!--end footer-->  
        
		        <script type="text/javascript">
        // <![CDATA[
        var disqus_shortname = 'geeksforgeeks';
        (function () {
            var nodes = document.getElementsByTagName('span');
            for (var i = 0, url; i < nodes.length; i++) {
                if (nodes[i].className.indexOf('dsq-postid') != -1) {
                    nodes[i].parentNode.setAttribute('data-disqus-identifier', nodes[i].getAttribute('rel'));
                    url = nodes[i].parentNode.href.split('#', 1);
                    if (url.length == 1) { url = url[0]; }
                    else { url = url[1]; }
                    nodes[i].parentNode.href = url + '#disqus_thread';
                }
            }
            var s = document.createElement('script'); 
            s.async = true;
            s.type = 'text/javascript';
            s.src = '//' + disqus_shortname + '.disqus.com/count.js';
            (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
        }());
        // ]]>
        </script>
        <script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/scripts/shCore.js?ver=3.0.9'></script>
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/scripts/shBrushCpp.js?ver=3.0.9'></script>
<script type='text/javascript'>
	(function(){
		var corecss = document.createElement('link');
		var themecss = document.createElement('link');
		var corecssurl = "http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/styles/shCore.css?ver=3.0.9";
		if ( corecss.setAttribute ) {
				corecss.setAttribute( "rel", "stylesheet" );
				corecss.setAttribute( "type", "text/css" );
				corecss.setAttribute( "href", corecssurl );
		} else {
				corecss.rel = "stylesheet";
				corecss.href = corecssurl;
		}
		document.getElementsByTagName("head")[0].insertBefore( corecss, document.getElementById("syntaxhighlighteranchor") );
		var themecssurl = "http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/styles/shThemeDefault.css?ver=3.0.9";
		if ( themecss.setAttribute ) {
				themecss.setAttribute( "rel", "stylesheet" );
				themecss.setAttribute( "type", "text/css" );
				themecss.setAttribute( "href", themecssurl );
		} else {
				themecss.rel = "stylesheet";
				themecss.href = themecssurl;
		}
		//document.getElementById("syntaxhighlighteranchor").appendChild(themecss);
		document.getElementsByTagName("head")[0].insertBefore( themecss, document.getElementById("syntaxhighlighteranchor") );
	})();
	SyntaxHighlighter.config.strings.expandSource = '+ expand source';
	SyntaxHighlighter.config.strings.help = '?';
	SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
	SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
	SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
	SyntaxHighlighter.defaults['gutter'] = false;
	SyntaxHighlighter.defaults['pad-line-numbers'] = true;
	SyntaxHighlighter.defaults['toolbar'] = false;
	SyntaxHighlighter.all();
</script>
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/bbpress/templates/default/js/editor.js?ver=2.5.4-5380'></script>
				  
		</div> <!--end wrapper-->
        <div id="ajaxSpinner"></div> <!--For AJAX spinner holder-->
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-12148232-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
	</body>

</html>
<!-- Dynamic page generated in 0.219 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2014-11-27 23:23:06 -->

<!-- Compression = gzip -->
<!-- super cache -->