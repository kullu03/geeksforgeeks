<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
       <title>Alternating split of a given Singly Linked List - GeeksforGeeks</title>
       <style type="text/css" media="screen">
          @import url('http://d2o58evtke57tz.cloudfront.net/wp-content/themes/minimoo/style.css');
    </style>
      <link href="http://d2o58evtke57tz.cloudfront.net/wp-content/themes/minimoo/favicon.ico" rel="shortcut icon" />    
    
<!-- This site is optimized with the Yoast WordPress SEO plugin v1.7.1 - https://yoast.com/wordpress/plugins/seo/ -->
<link rel="canonical" href="http://www.geeksforgeeks.org/alternating-split-of-a-given-singly-linked-list/" />
<meta property="og:locale" content="en_US" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Alternating split of a given Singly Linked List - GeeksforGeeks" />
<meta property="og:description" content="Write a function AlternatingSplit() that takes one list and divides up its nodes to make two smaller lists &#8216;a&#8217; and &#8216;b&#8217;. The sublists should be made from alternating elements in the original list. So if the original list is 0-&gt;1-&gt;0-&gt;1-&gt;0-&gt;1 then one sublist should be 0-&gt;0-&gt;0 and the other should be 1-&gt;1-&gt;1. Method 1(Simple) The &hellip;" />
<meta property="og:url" content="http://www.geeksforgeeks.org/alternating-split-of-a-given-singly-linked-list/" />
<meta property="og:site_name" content="GeeksforGeeks" />
<meta property="article:section" content="Linked Lists" />
<meta property="article:published_time" content="2010-05-23T10:08:35+00:00" />
<meta property="article:modified_time" content="2011-01-09T13:55:31+00:00" />
<meta property="og:updated_time" content="2011-01-09T13:55:31+00:00" />
<!-- / Yoast WordPress SEO plugin. -->

<link rel='stylesheet' id='wp-quicklatex-format-css'  href='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/wp-quicklatex/css/quicklatex-format.css?ver=4.0.1' type='text/css' media='all' />
<link rel='stylesheet' id='bbp-default-css'  href='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/bbpress/templates/default/css/bbpress.css?ver=2.5.4-5380' type='text/css' media='screen' />
<link rel='stylesheet' id='wp-pagenavi-css'  href='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/wp-pagenavi/pagenavi-css.css?ver=2.70' type='text/css' media='all' />
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-includes/js/jquery/jquery.js?ver=1.11.1'></script>
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-includes/js/jquery/jquery-migrate.min.js?ver=1.2.1'></script>
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/wp-quicklatex/js/wp-quicklatex-frontend.js?ver=1.0'></script>

<!-- Bad Behavior 2.2.16 run time: 1.506 ms -->
<script type="text/javascript">
<!--
function bb2_addLoadEvent(func) {
	var oldonload = window.onload;
	if (typeof window.onload != 'function') {
		window.onload = func;
	} else {
		window.onload = function() {
			oldonload();
			func();
		}
	}
}

bb2_addLoadEvent(function() {
	for ( i=0; i < document.forms.length; i++ ) {
		if (document.forms[i].method == 'post') {
			var myElement = document.createElement('input');
			myElement.setAttribute('type', 'hidden');
			myElement.name = 'bb2_screener_';
			myElement.value = '1417111088 210.212.53.139 172.19.11.169';
			document.forms[i].appendChild(myElement);
		}
	}
});
// --></script>
		<style type="text/css" id="syntaxhighlighteranchor"></style>
   <meta name="google-site-verification" content="rHK2v8_zzuAZQY8JHAzbllDN8u-aQxcn2Kqnp67Old0" />
</head>

<body>
<!-- o4dI0sCXUgoSONabbd8mbZ4SA3E -->    
    <div id="wrapper">
        <div class="blog-info">
                <h1 class="blog-title">
                <a href="http://www.geeksforgeeks.org" title="GeeksforGeeks">GeeksforGeeks</a>
            </h1>
       
            <div class="blog-description">
                A computer science portal for geeks            </div>
        </div>
        <b><p>  <h2 align="right"> <a href="http://geeksquiz.com/">GeeksQuiz</a></h2> 
   <a href="http://www.geeksforgeeks.org/wp-login.php">Login</a> 
         </p></b>  
         
         <div class="clear"></div>         
              
                     
            <div id="menu">   
                 <ul>
 <li><a href="http://www.geeksforgeeks.org">Home</a></li>
  <li><a href="http://www.geeksforgeeks.org/fundamentals-of-algorithms/">Algorithms</a></li>
 <li><a href="http://www.geeksforgeeks.org/data-structures/">DS</a></li>
  <li><a href="http://www.geeksforgeeks.org/gate-corner/">GATE</a></li>
  <li><a href="http://www.geeksforgeeks.org/about/interview-corner/">Interview Corner</a></li>
  <li><a href="http://www.geeksforgeeks.org/forums/">Q&A</a></li>
  <li><a href="http://www.geeksforgeeks.org/c/">C</a></li>
  <li><a href="http://www.geeksforgeeks.org/c-plus-plus/">C++</a></li>
  <li><a href="http://www.geeksforgeeks.org/java/">Java</a></li>
  <li><a href="http://www.geeksforgeeks.org/books/">Books</a></li>
  <li><a href="http://www.geeksforgeeks.org/contribute/">Contribute</a></li>
  <li><a href="http://www.geeksforgeeks.org/contribute/ask-a-question/">Ask a Q</a></li>
  <li><a href="http://www.geeksforgeeks.org/about/">About</a></li>
            </ul>

               
            <div class="clear"></div>     
        </div>
             <div id="navmenu">
				<ul id="menu" style="padding:0; margin:0;">
						<li class="cat-item cat-item-3"><a href="http://www.geeksforgeeks.org/category/c-arrays/" title="Questions regarding Arrays">Array</a>
</li>	

	<li class="cat-item cat-item-17"><a href="http://www.geeksforgeeks.org/category/bit-magic/" title="View all posts filed under Bit Magic">Bit Magic</a>
</li>
	<li class="cat-item cat-item-14"><a href="http://www.geeksforgeeks.org/category/c-puzzles/" title="View all posts filed under C/C++ Puzzles">C/C++</a>
</li>

<li class="cat-item cat-item-18"><a href="http://www.geeksforgeeks.org/category/articles/" title="View all posts filed under Articles">Articles</a>
</li>

	<li class="cat-item cat-item-67"><a href="http://www.geeksforgeeks.org/category/gfact/" title="View all posts filed under GFacts">GFacts</a>
</li>
	<li class="cat-item cat-item-8"><a href="http://www.geeksforgeeks.org/category/linked-list/" title="Linked List problems">Linked List</a>
</li>
	<li class="cat-item cat-item-66"><a href="http://www.geeksforgeeks.org/category/multiple-choice-question/" title="View all posts filed under MCQ">MCQ</a>

</li>
	<li class="cat-item cat-item-4"><a href="http://www.geeksforgeeks.org/category/c-programs/" title="Miscellaneous">Misc</a>
</li>
	<li class="cat-item cat-item-5"><a href="http://www.geeksforgeeks.org/category/program-output/" title="View all posts filed under Output">Output</a>
</li>
	<li class="cat-item cat-item-7"><a href="http://www.geeksforgeeks.org/category/c-strings/" title="Questions related to strings">String</a>
</li>
	<li class="cat-item cat-item-19"><a href="http://www.geeksforgeeks.org/category/tree/" title="View all posts filed under Trees">Tree</a>
</li>
	<li class="cat-item cat-item-19"><a href="http://www.geeksforgeeks.org/category/graph/" title="View all posts filed under Graph">Graph</a>
</li>
</ul>
        </div>
             <div id="content">	   	
	<div class="post" id="post">
							<div class="post-info">			
					<div class="post-title-info">
						<h2 class="post-title">Alternating split of a given Singly Linked List</h2>
					</div>			
					<div class="clear"></div>				  
				<div class="post-content" id="post-content">
					<p>Write a function AlternatingSplit() that takes one list and divides up its nodes to make two smaller lists &#8216;a&#8217; and &#8216;b&#8217;. The sublists should be made from alternating elements in the original list. So if the original list is 0->1->0->1->0->1 then one sublist should be 0->0->0 and the other should be 1->1->1. <span id="more-7621"></span></p>
<p><strong>Method 1(Simple)</strong><br />
The simplest approach iterates over the source list and pull nodes off the source and alternately put them at the front (or beginning) of &#8216;a&#8217; and b&#8217;. The only strange part is that the nodes will be in the reverse order that they occurred in the source list. Method 2 inserts the node at the end by keeping track of last node in sublists.</p>
<pre class="brush: cpp; title: ; notranslate" title="">
/*Program to alternatively split a linked list into two halves */
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;assert.h&gt;

/* Link list node */
struct node
{
    int data;
    struct node* next;
};

/* pull off the front node of the source and put it in dest */
void MoveNode(struct node** destRef, struct node** sourceRef) ;

/* Given the source list, split its nodes into two shorter lists.
  If we number the elements 0, 1, 2, ... then all the even elements
  should go in the first list, and all the odd elements in the second.
  The elements in the new lists may be in any order. */
void AlternatingSplit(struct node* source, struct node** aRef, 
                            struct node** bRef) 
{
  /* split the nodes of source to these 'a' and 'b' lists */
  struct node* a = NULL; 
  struct node* b = NULL;
  
  struct node* current = source;
  while (current != NULL) 
  {
    MoveNode(&amp;a, &amp;current); /* Move a node to list 'a' */
    if (current != NULL) 
    {
       MoveNode(&amp;b, &amp;current); /* Move a node to list 'b' */
    }
  }
  *aRef = a;
  *bRef = b;
}

/* Take the node from the front of the source, and move it to the front of the dest.
   It is an error to call this with the source list empty. 
   
   Before calling MoveNode():
   source == {1, 2, 3}   
   dest == {1, 2, 3}
      
   Affter calling MoveNode():
   source == {2, 3}      
   dest == {1, 1, 2, 3}      
*/
void MoveNode(struct node** destRef, struct node** sourceRef) 
{
  /* the front source node  */
  struct node* newNode = *sourceRef; 
  assert(newNode != NULL);
  
  /* Advance the source pointer */
  *sourceRef = newNode-&gt;next;
  
  /* Link the old dest off the new node */
  newNode-&gt;next = *destRef; 
  
  /* Move dest to point to the new node */
  *destRef = newNode; 
}

/* UTILITY FUNCTIONS */
/* Function to insert a node at the beginging of the linked list */
void push(struct node** head_ref, int new_data)
{
  /* allocate node */
  struct node* new_node =
            (struct node*) malloc(sizeof(struct node));

  /* put in the data  */
  new_node-&gt;data  = new_data;

  /* link the old list off the new node */
  new_node-&gt;next = (*head_ref);     

  /* move the head to point to the new node */
  (*head_ref)    = new_node;
}

/* Function to print nodes in a given linked list */
void printList(struct node *node)
{
  while(node!=NULL)
  {
   printf(&quot;%d &quot;, node-&gt;data);
   node = node-&gt;next;
  }
} 

/* Drier program to test above functions*/
int main()
{
  /* Start with the empty list */
  struct node* head = NULL;
  struct node* a = NULL;
  struct node* b = NULL;  

  /* Let us create a sorted linked list to test the functions
   Created linked list will be 0-&gt;1-&gt;2-&gt;3-&gt;4-&gt;5 */
  push(&amp;head, 5);
  push(&amp;head, 4);
  push(&amp;head, 3);
  push(&amp;head, 2);
  push(&amp;head, 1);                                    
  push(&amp;head, 0);  

  printf(&quot;\n Original linked List:  &quot;);
  printList(head); 

  /* Remove duplicates from linked list */
  AlternatingSplit(head, &amp;a, &amp;b); 

  printf(&quot;\n Resultant Linked List 'a' &quot;);
  printList(a);            

  printf(&quot;\n Resultant Linked List 'b' &quot;);
  printList(b);            

  getchar();
  return 0;
}
</pre>
<p>Time Complexity: O(n) where n is number of node in the given linked list.</p>
<p></br><br />
<strong>Method 2(Using Dummy Nodes)</strong><br />
Here is an alternative approach which builds the sub-lists in the same order as the source list. The code uses a temporary dummy header nodes for the &#8216;a&#8217; and &#8216;b&#8217; lists as they are being built. Each sublist has a &#8220;tail&#8221; pointer which points to its current last node â€” that way new nodes can be appended to the end of each list easily. The dummy nodes give the tail pointers something to point to initially. The dummy nodes are efficient in this case because they are temporary and allocated in the stack. Alternately, local &#8220;reference pointers&#8221; (which always points to the last pointer in the list instead of to the last node) could be used to avoid Dummy nodes. </p>
<pre class="brush: cpp; title: ; notranslate" title="">
void AlternatingSplit(struct node* source, struct node** aRef, 
                            struct node** bRef) 
{
  struct node aDummy;
  struct node* aTail = &amp;aDummy; /* points to the last node in 'a' */
  struct node bDummy;
  struct node* bTail = &amp;bDummy; /* points to the last node in 'b' */
  struct node* current = source;
  aDummy.next = NULL;
  bDummy.next = NULL;
  while (current != NULL) 
  {
    MoveNode(&amp;(aTail-&gt;next), &amp;current); /* add at 'a' tail */
    aTail = aTail-&gt;next; /* advance the 'a' tail */
    if (current != NULL) 
    {
      MoveNode(&amp;(bTail-&gt;next), &amp;current);
      bTail = bTail-&gt;next;
    }
  }
  *aRef = aDummy.next;
  *bRef = bDummy.next;
}
</pre>
<p>Time Complexity: O(n) where n is number of node in the given linked list.</p>
<p>Source: <a href="http://cslibrary.stanford.edu/105/LinkedListProblems.pdf">http://cslibrary.stanford.edu/105/LinkedListProblems.pdf</a></p>
<p>Please write comments if you find the above code/algorithm incorrect, or find better ways to solve the same problem.</p>
		
&nbsp;
&nbsp;
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle"
     style="display:inline-block;width:336px;height:280px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="4061219431"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>



&nbsp;
&nbsp;
&nbsp;
<h3>Related Topics:</h3><ul><li><a href="http://www.geeksforgeeks.org/given-linked-list-reverse-alternate-nodes-append-end/" title="Given a linked list, reverse alternate nodes and append at the end">Given a linked list, reverse alternate nodes and append at the end</a></li><li><a href="http://www.geeksforgeeks.org/pairwise-swap-elements-of-a-given-linked-list-by-changing-links/" title="Pairwise swap elements of a given linked list by changing links">Pairwise swap elements of a given linked list by changing links</a></li><li><a href="http://www.geeksforgeeks.org/self-organizing-list-set-1-introduction/" title="Self Organizing List | Set 1 (Introduction)">Self Organizing List | Set 1 (Introduction)</a></li><li><a href="http://www.geeksforgeeks.org/merge-a-linked-list-into-another-linked-list-at-alternate-positions/" title="Merge a linked list into another linked list at alternate positions">Merge a linked list into another linked list at alternate positions</a></li><li><a href="http://www.geeksforgeeks.org/quicksort-on-singly-linked-list/" title="QuickSort on Singly Linked List">QuickSort on Singly Linked List</a></li><li><a href="http://www.geeksforgeeks.org/delete-n-nodes-after-m-nodes-of-a-linked-list/" title="Delete N nodes after M nodes of a linked list">Delete N nodes after M nodes of a linked list</a></li><li><a href="http://www.geeksforgeeks.org/design-a-stack-with-find-middle-operation/" title="Design a stack with operations on middle element">Design a stack with operations on middle element</a></li><li><a href="http://www.geeksforgeeks.org/swap-kth-node-from-beginning-with-kth-node-from-end-in-a-linked-list/" title="Swap Kth node from beginning with Kth node from end in a Linked List">Swap Kth node from beginning with Kth node from end in a Linked List</a></li></ul>
<p></p> 
<div>
<iframe src="http://www.facebook.com/plugins/like.php?href=http%3A%2F%2Fwww.geeksforgeeks.org%2Falternating-split-of-a-given-singly-linked-list%2F&layout=button_count&show_faces=false&width=90&action=like&colorscheme=light" scrolling="no" frameborder="0" allowTransparency="true" style="border:none; overflow:hidden; width:90px; height:20px"></iframe>
<a href="http://twitter.com/share" class="twitter-share-button" data-url="http://www.geeksforgeeks.org/alternating-split-of-a-given-singly-linked-list/" data-text="Alternating split of a given Singly Linked List" data-count="horizontal" data-via="jakerutter">Tweet</a><script type="text/javascript" src="http://platform.twitter.com/widgets.js"></script>
<g:plusone size="medium" href="http://www.geeksforgeeks.org/alternating-split-of-a-given-singly-linked-list/"></g:plusone>
<!-- Place this render call where appropriate -->
<script type="text/javascript">
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script></div>





				</div>		  
			</div> <!-- end post main -->					
			<div class="post-meta">
				<div class="left"></div>				
				<div class="clear"></div>
			</div>			
        
			<div class="comments-main">		
 <b>Writing code in comment?</b> Please use <b><a href="http://ideone.com/">ideone.com</a></b> and share the link here.
				
<div id="disqus_thread">
            <div id="dsq-content">


            <ul id="dsq-comments">
                    <li class="comment even thread-even depth-1" id="dsq-comment-34658">
        <div id="dsq-comment-header-34658" class="dsq-comment-header">
            <cite id="dsq-cite-34658">
                <span id="dsq-author-user-34658">Mohan Rajoria</span>
            </cite>
        </div>
        <div id="dsq-comment-body-34658" class="dsq-comment-body">
            <div id="dsq-comment-message-34658" class="dsq-comment-message"><p>An alternate way is the same as deleting alternative nodes. We can add deleted nodes to new  list, by this way we&#8217;ll get solution for both the problem 1.Delete alternative nodes.<br />
2. Split alternative nodes into two list.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-34172">
        <div id="dsq-comment-header-34172" class="dsq-comment-header">
            <cite id="dsq-cite-34172">
                <span id="dsq-author-user-34172">Ankur Teotia</span>
            </cite>
        </div>
        <div id="dsq-comment-body-34172" class="dsq-comment-body">
            <div id="dsq-comment-message-34172" class="dsq-comment-message"><p>an easier way to do this would be to traverse the list and have a counter integer initialized to zero which would increment whenever a node would get traversed.</p>
<p>now if the counter is even then put the node in one list and if it is odd , put it in another list.</p>
<p>the complete code -&gt; <a href="http://ideone.com/CEN0ss" rel="nofollow">http://ideone.com/CEN0ss</a></p>
<p>here&#8217;s the code snippet of the modifield alternating split function.</p>
<p>struct node* b1 = NULL;</p>
<p>    struct node* a1= NULL;</p>
<p>void AlternatingSplit(struct node* source, struct node** aRef,</p>
<p>                            struct node** bRef)</p>
<p>{</p>
<p>  /* split the nodes of source to these &#8216;a&#8217; and &#8216;b&#8217; lists */</p>
<p>  struct node* a = NULL;</p>
<p>  struct node* b = NULL;</p>
<p>   int count = 0;</p>
<p>  struct node* current = source;</p>
<p>  while (current != NULL)</p>
<p>  {   a = current;</p>
<p>      b = current;</p>
<p>      current = current -&gt; next;</p>
<p>      count = count + 1;</p>
<p>      if(count%2==0){</p>
<p>            printf(&#8220;hello&#8221;);</p>
<p>        push(&amp;a1,a-&gt;data);  </p>
<p>      }else{</p>
<p>                      printf(&#8220;tello&#8221;);</p>
<p>         push(&amp;b1,a-&gt;data);</p>
<p>      }</p>
<p>  }</p>
<p>}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-33187">
        <div id="dsq-comment-header-33187" class="dsq-comment-header">
            <cite id="dsq-cite-33187">
                <span id="dsq-author-user-33187">Vishal</span>
            </cite>
        </div>
        <div id="dsq-comment-body-33187" class="dsq-comment-body">
            <div id="dsq-comment-message-33187" class="dsq-comment-message"><p>My below post will give the list as required but having the reference of the original list&#8230;<br />
So below program is just to print the expected output&#8230;<br />
no new memory allocations&#8230;</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-33186">
        <div id="dsq-comment-header-33186" class="dsq-comment-header">
            <cite id="dsq-cite-33186">
                <span id="dsq-author-user-33186">Vishal</span>
            </cite>
        </div>
        <div id="dsq-comment-body-33186" class="dsq-comment-body">
            <div id="dsq-comment-message-33186" class="dsq-comment-message"><p>void AlternatingSplit(Node *head, Node **evenlist,Node **oddlist)<br />
{<br />
    Node *temp = head;<br />
    Node *pevenlist = *evenlist;<br />
    Node *poddlist  = *oddlist;<br />
    int i =0;<br />
    while(temp)<br />
    {<br />
        if(i%2 == 0)<br />
        {<br />
            if(pevenlist){<br />
                pevenlist-&gt;next= temp;<br />
                pevenlist = pevenlist-&gt;next;}<br />
            else{</p>
<p>                pevenlist = temp;<br />
                *evenlist = pevenlist;<br />
            }<br />
        }else<br />
        {<br />
            if(poddlist){<br />
                poddlist-&gt;next= temp;<br />
                poddlist = poddlist-&gt;next;}<br />
            else<br />
            {<br />
                poddlist = temp;<br />
                *oddlist = poddlist;<br />
            }<br />
        }<br />
        temp = temp-&gt;next;<br />
        i++;<br />
    }</p>
<p>}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-32312">
        <div id="dsq-comment-header-32312" class="dsq-comment-header">
            <cite id="dsq-cite-32312">
                <span id="dsq-author-user-32312">Himanshu Dagar</span>
            </cite>
        </div>
        <div id="dsq-comment-body-32312" class="dsq-comment-body">
            <div id="dsq-comment-message-32312" class="dsq-comment-message"><p>whole source code from  dummy variable concept  is here(at below link)</p>
<p><a href="http://ideone.com/Xw7Wh1" rel="nofollow">http://ideone.com/Xw7Wh1</a></p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-31800">
        <div id="dsq-comment-header-31800" class="dsq-comment-header">
            <cite id="dsq-cite-31800">
                <span id="dsq-author-user-31800">bhavesh</span>
            </cite>
        </div>
        <div id="dsq-comment-body-31800" class="dsq-comment-body">
            <div id="dsq-comment-message-31800" class="dsq-comment-message"><p>#include</p>
<p>#include</p>
<p>#include</p>
<p>/* Link list node */</p>
<p>struct node</p>
<p>{</p>
<p>    int data;</p>
<p>    struct node* next;</p>
<p>};</p>
<p>/* pull off the front node of the source and put it in dest */</p>
<p>void MoveNode(struct node** destRef, struct node** sourceRef) ;</p>
<p>/* Given the source list, split its nodes into two shorter lists.</p>
<p>  If we number the elements 0, 1, 2, &#8230; then all the even elements</p>
<p>  should go in the first list, and all the odd elements in the second.</p>
<p>  The elements in the new lists may be in any order. */</p>
<p>void AlternatingSplit(struct node* source, struct node** aRef, </p>
<p>                            struct node** bRef) </p>
<p>{</p>
<p>  /* split the nodes of source to these &#8216;a&#8217; and &#8216;b&#8217; lists */</p>
<p>  struct node* a = NULL; </p>
<p>  struct node* b = NULL;</p>
<p>   int turn=1;</p>
<p>  struct node* current = source;</p>
<p>  while (current != NULL) </p>
<p>  {</p>
<p>  if(turn){</p>
<p>  turn=0;</p>
<p>  if(*aRef)</p>
<p>  {</p>
<p>  a-&gt;next=current;</p>
<p> a=current; </p>
<p> current=current-&gt;next;</p>
<p> //printf(&#8220;Start a1&#8243;);</p>
<p>  }</p>
<p>  else{</p>
<p>  *aRef=a=current;</p>
<p>  current=current-&gt;next;</p>
<p>  //printf(&#8220;Start a2&#8243;);</p>
<p>  }</p>
<p>  }</p>
<p>  else</p>
<p>  {</p>
<p>	turn=1;</p>
<p>  if(*bRef)</p>
<p>  {</p>
<p>  b-&gt;next=current;</p>
<p>  b=current;</p>
<p>  current=current-&gt;next;</p>
<p>  //printf(&#8220;Start b1&#8243;);</p>
<p>  }</p>
<p>  else{</p>
<p>  *bRef=b=current;</p>
<p>  current=current-&gt;next;</p>
<p>  //printf(&#8220;Start b2&#8243;);</p>
<p>  }</p>
<p>  }</p>
<p>}</p>
<p>a-&gt;next=NULL;</p>
<p>b-&gt;next=NULL;</p>
<p>}</p>
<p>/* UTILITY FUNCTIONS */</p>
<p>/* Function to insert a node at the beginging of the linked list */</p>
<p>void push(struct node** head_ref, int new_data)</p>
<p>{</p>
<p>  /* allocate node */</p>
<p>  struct node* new_node =</p>
<p>            (struct node*) malloc(sizeof(struct node));</p>
<p>  /* put in the data  */</p>
<p>  new_node-&gt;data  = new_data;</p>
<p>  /* link the old list off the new node */</p>
<p>  new_node-&gt;next = (*head_ref);     </p>
<p>  /* move the head to point to the new node */</p>
<p>  (*head_ref)    = new_node;</p>
<p>}</p>
<p>/* Function to print nodes in a given linked list */</p>
<p>void printList(struct node *node)</p>
<p>{</p>
<p>  while(node!=NULL)</p>
<p>  {</p>
<p>   printf(&#8220;%d &#8220;, node-&gt;data);</p>
<p>   node = node-&gt;next;</p>
<p>  }</p>
<p>} </p>
<p>/* Drier program to test above functions*/</p>
<p>int main()</p>
<p>{</p>
<p>  /* Start with the empty list */</p>
<p>  struct node* head = NULL;</p>
<p>  struct node* a = NULL;</p>
<p>  struct node* b = NULL;  </p>
<p>  /* Let us create a sorted linked list to test the functions</p>
<p>   Created linked list will be 0-&gt;1-&gt;2-&gt;3-&gt;4-&gt;5 */</p>
<p>  //push(&amp;head, 5);</p>
<p>  //push(&amp;head, 4);</p>
<p>  push(&amp;head, 3);</p>
<p>  push(&amp;head, 2);</p>
<p>  //push(&amp;head, 1);                                    </p>
<p>  //push(&amp;head, 0);  </p>
<p>  printf(&#8220;n Original linked List:  &#8220;);</p>
<p>  printList(head); </p>
<p>  /* Remove duplicates from linked list */</p>
<p>  AlternatingSplit(head, &amp;a, &amp;b); </p>
<p>  printf(&#8220;n Resultant Linked List &#8216;a&#8217; &#8220;);</p>
<p>  printList(a);            </p>
<p>  printf(&#8220;n Resultant Linked List &#8216;b&#8217; &#8220;);</p>
<p>  printList(b);            </p>
<p>  getchar();</p>
<p>  return 0;</p>
<p>}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-31725">
        <div id="dsq-comment-header-31725" class="dsq-comment-header">
            <cite id="dsq-cite-31725">
                <span id="dsq-author-user-31725">Marsha Donna</span>
            </cite>
        </div>
        <div id="dsq-comment-body-31725" class="dsq-comment-body">
            <div id="dsq-comment-message-31725" class="dsq-comment-message"><p><a href="http://ideone.com/JvD1UP" rel="nofollow">http://ideone.com/JvD1UP</a><br />
can this be simplified further</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-31141">
        <div id="dsq-comment-header-31141" class="dsq-comment-header">
            <cite id="dsq-cite-31141">
                <span id="dsq-author-user-31141">Vikash876</span>
            </cite>
        </div>
        <div id="dsq-comment-body-31141" class="dsq-comment-body">
            <div id="dsq-comment-message-31141" class="dsq-comment-message"><p>node * list_split_alternate(node *head)<br />
 {<br />
       node *sav, *retnode = head-&gt;next;<br />
       while(head-&gt;next!=NULL)<br />
       {<br />
            sav = head-&gt;next;<br />
            head-&gt;next = head-&gt;next-&gt;next;<br />
            head = sav;<br />
       }<br />
       sav-&gt;next = NULL;<br />
       return retnode;<br />
 }</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-27726">
        <div id="dsq-comment-header-27726" class="dsq-comment-header">
            <cite id="dsq-cite-27726">
                <span id="dsq-author-user-27726">ankit</span>
            </cite>
        </div>
        <div id="dsq-comment-body-27726" class="dsq-comment-body">
            <div id="dsq-comment-message-27726" class="dsq-comment-message"><p>#include<br />
#include </p>
<p>struct treeNode<br />
{<br />
    int val;<br />
    struct treeNode *next;</p>
<p>};<br />
struct treeNode *root=NULL;</p>
<p>struct treeNode *a=NULL;<br />
struct treeNode *b=NULL;</p>
<p>struct  treeNode*  getNode()<br />
{<br />
    return (struct treeNode*)malloc(sizeof(struct treeNode));<br />
}<br />
struct  treeNode* addNode(struct  treeNode* root,int val)<br />
{<br />
    struct treeNode *node=getNode();<br />
    node-&gt;val=val;<br />
    node-&gt;next=root;<br />
    root=node;<br />
    return root;<br />
}<br />
void printLinkList(struct  treeNode* root)<br />
{<br />
    struct treeNode *node=root;<br />
    printf(&#8220;n Link List :: &#8220;);<br />
    while(node!=NULL)<br />
    {<br />
        printf(&#8220;%d &#8220;, node-&gt;val);<br />
        node=node-&gt;next;<br />
    }<br />
}</p>
<p>void splitLinkListIntoTwo(struct treeNode * root)<br />
{<br />
    if(root==NULL)<br />
        return;</p>
<p>    struct treeNode *tempa=NULL;<br />
    struct treeNode *tempb=NULL;</p>
<p>    tempa=a=root;<br />
    if(root-&gt;next!=NULL)<br />
        tempb=b=root-&gt;next;</p>
<p>    if(a==NULL || b==NULL)<br />
        return;</p>
<p>    while(tempa-&gt;next!=NULL &amp;&amp; tempa-&gt;next-&gt;next!=NULL)<br />
    {<br />
        tempa-&gt;next=tempa-&gt;next-&gt;next;<br />
        tempb-&gt;next=tempb-&gt;next-&gt;next;</p>
<p>        tempa=tempa-&gt;next;<br />
        tempb=tempb-&gt;next;<br />
    }<br />
    tempa-&gt;next=NULL;<br />
}</p>
<p>int main()<br />
{<br />
    struct treeNode *root=NULL;<br />
    root=addNode(addNode(addNode(addNode(NULL,10),9),8),7);<br />
    printLinkList(root);</p>
<p>    splitLinkListIntoTwo(root);</p>
<p>    printLinkList(a);<br />
    printLinkList(b);</p>
<p>}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-27314">
        <div id="dsq-comment-header-27314" class="dsq-comment-header">
            <cite id="dsq-cite-27314">
                <span id="dsq-author-user-27314">GP</span>
            </cite>
        </div>
        <div id="dsq-comment-body-27314" class="dsq-comment-body">
            <div id="dsq-comment-message-27314" class="dsq-comment-message"><pre class="brush: cpp; title: ; notranslate" title="">

/* simple approach*/

void alternatingSplit(struct node** head_ref,struct node** head1,struct node** head2)

            {

                 if(*head_ref==NULL||(*head_ref)-&amp;gt;next==NULL)

                 return;

                 struct node* current=*head_ref;

                 struct node* nNext,*next;

                 *head1=*head_ref;

                 *head2=(*head_ref)-&amp;gt;next;

                 while(current!=NULL&amp;amp;&amp;amp;nNext!=NULL)

                 {

                                      next=current-&amp;gt;next;

                                      nNext=current-&amp;gt;next-&amp;gt;next;

                                      current-&amp;gt;next=nNext;

                                      current=next;

                                      }

                                      current-&amp;gt;next=NULL;

                  }

/* comment if any mistake*/

</pre>
</div>
        </div>

    </li><!-- #comment-## -->
</li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-22833">
        <div id="dsq-comment-header-22833" class="dsq-comment-header">
            <cite id="dsq-cite-22833">
                <span id="dsq-author-user-22833">Soumya Sengupta</span>
            </cite>
        </div>
        <div id="dsq-comment-body-22833" class="dsq-comment-body">
            <div id="dsq-comment-message-22833" class="dsq-comment-message"><p>split_list(struct node*head)<br />
{<br />
split_listUtil(struct node*head)<br />
{<br />
if(head==null)<br />
return;<br />
temp=head-&gt;next;<br />
if(temp==null)<br />
return;</p>
<p>struct node *new=(struct node*)malloc(sizeof(stuct node));<br />
new=temp;<br />
head-&gt;next=temp-next;<br />
new-&gt;next=split_listUtil(head-&gt;next);<br />
return new;<br />
}<br />
return head;<br />
}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-22831">
        <div id="dsq-comment-header-22831" class="dsq-comment-header">
            <cite id="dsq-cite-22831">
                <span id="dsq-author-user-22831">Soumya Sengupta</span>
            </cite>
        </div>
        <div id="dsq-comment-body-22831" class="dsq-comment-body">
            <div id="dsq-comment-message-22831" class="dsq-comment-message"><p>split_list(struct node*head)<br />
{<br />
split_listUtil(struct node*head)<br />
{<br />
if(head==null)<br />
return;<br />
temp=head-&gt;next;<br />
if(temp==null)<br />
return;</p>
<p>struct node *new=(struct node*)malloc(sizeof(stuct node));<br />
new=temp;<br />
head-&gt;next=temp-next;<br />
temp-&gt;next=split_listUtil(head-&gt;next);<br />
return temp;<br />
}<br />
return head;<br />
}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-22110">
        <div id="dsq-comment-header-22110" class="dsq-comment-header">
            <cite id="dsq-cite-22110">
                <span id="dsq-author-user-22110">Deepak</span>
            </cite>
        </div>
        <div id="dsq-comment-body-22110" class="dsq-comment-body">
            <div id="dsq-comment-message-22110" class="dsq-comment-message"><p>Here is third method.. just remove alternate node from original list and add to another list. In last we will find two sublists.. original list is not preserve..</p>
<pre> <code language="C"></code> </pre>
<p>/* Dividing a list into two sbulists where each list has<br />
alternate element of original list and only assumption made<br />
is we don&#8217;t need original list anymore  */</p>
<p>#include<br />
#include<br />
typedef struct node<br />
{<br />
int data;<br />
struct node *link;<br />
}list;<br />
void insert(list **,int);<br />
void show(list *);</p>
<p>/* In alternate function we just remove alternate element from original list and<br />
attach it to a sub list header. In last there will be two sublists (1) One that<br />
was original has become sublist having odd position elements, (2)sublist has all<br />
even position elements */</p>
<p>void alternate(list **org,list **sub)<br />
{<br />
list *temp;<br />
list *list1=(*org);<br />
list *list2=(*sub);<br />
list *header1,*header2;<br />
header1=(*org);             /* save header of first list */<br />
while(list1-&gt;link!=NULL)<br />
{<br />
temp=list1-&gt;link;<br />
list1-&gt;link=list1-&gt;link-&gt;link;<br />
list1=list1-&gt;link;<br />
if(list2==NULL)<br />
{<br />
temp-&gt;link=list2;<br />
list2=temp;<br />
header2=temp;/* save header of second list */<br />
}<br />
else<br />
{<br />
while(list2-&gt;link!=NULL)<br />
list2=list2-&gt;link;<br />
temp-&gt;link=list2-&gt;link;<br />
list2-&gt;link=temp;<br />
}<br />
(*org)=header1; /* assign address of first sublist header */<br />
(*sub)=header2; /* assign address of second sublist header */<br />
}<br />
}</p>
<p>/* utility functions */<br />
void insert(list **head, int value)<br />
{<br />
list *b;<br />
list *a;<br />
a=(list *)malloc(sizeof(list));<br />
a-&gt;data=value;<br />
if((*head)==NULL)<br />
{<br />
(*head)=a;<br />
a-&gt;link=NULL;<br />
}<br />
else<br />
{<br />
b=(*head);<br />
while(b-&gt;link!=NULL)<br />
b=b-&gt;link;<br />
b-&gt;link=a;<br />
a-&gt;link=NULL;<br />
}<br />
}<br />
void show(list *head)<br />
{<br />
if(head==NULL)<br />
printf(&#8220;\nlist is empty&#8221;);<br />
else<br />
while(head!=NULL)<br />
{<br />
printf(&#8220;\n\n%d&#8221;,head-&gt;data);<br />
head=head-&gt;link;<br />
}<br />
}</p>
<p>/* Main function */<br />
void main()<br />
{<br />
list *head1=NULL;<br />
list *head2=NULL;<br />
clrscr();<br />
insert(&amp;head1,2);<br />
insert(&amp;head1,32);<br />
insert(&amp;head1,26);<br />
insert(&amp;head1,42);<br />
insert(&amp;head1,21);<br />
insert(&amp;head1,48);<br />
insert(&amp;head1,132);<br />
printf(&#8220;\n\noriginal list is :\n\n&#8221;);<br />
show(head1);<br />
if(head1==NULL)<br />
printf(&#8220;\n\nList is empty&#8221;);<br />
else if(head1-&gt;link==NULL)<br />
printf(&#8220;\n\nList has only one element &#8220;);<br />
else<br />
{<br />
alternate(&amp;head1,&amp;head2);  /* Pass head of both lists, one is initially empty */<br />
printf(&#8220;\n\n&#8221;);<br />
printf(&#8220;\nFirst Sublist:&#8221;);<br />
show(head1);<br />
printf(&#8220;\n\nSecond sublist:&#8221;);<br />
show(head2);<br />
}<br />
getch();<br />
}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-omguptanitdgp odd alt thread-odd thread-alt depth-1" id="dsq-comment-20799">
        <div id="dsq-comment-header-20799" class="dsq-comment-header">
            <cite id="dsq-cite-20799">
                <span id="dsq-author-user-20799">omguptanitdgp</span>
            </cite>
        </div>
        <div id="dsq-comment-body-20799" class="dsq-comment-body">
            <div id="dsq-comment-message-20799" class="dsq-comment-message"><p>@geeksforgeeks<br />
here is an easy solution<br />
take two pointer ,one points to first node in the list and other<br />
points to second node initiaaly .now advance both pointer by next->next(means two times) and store nodes in two linked lists.</p>
<p>please inform me whether i m correct or not</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-2" id="dsq-comment-31726">
        <div id="dsq-comment-header-31726" class="dsq-comment-header">
            <cite id="dsq-cite-31726">
                <span id="dsq-author-user-31726">Marsha Donna</span>
            </cite>
        </div>
        <div id="dsq-comment-body-31726" class="dsq-comment-body">
            <div id="dsq-comment-message-31726" class="dsq-comment-message"><p>@omguptanitdgp<br />
see my code given above implements the same algorithm</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-20746">
        <div id="dsq-comment-header-20746" class="dsq-comment-header">
            <cite id="dsq-cite-20746">
                <span id="dsq-author-user-20746">Himanshu</span>
            </cite>
        </div>
        <div id="dsq-comment-body-20746" class="dsq-comment-body">
            <div id="dsq-comment-message-20746" class="dsq-comment-message"><p>/* we can use a bool variable which when true add nodes of source list to a and when false add nodes to the b list.<br />
#include<br />
#include<br />
#include<br />
#include<br />
using namespace std;</p>
<p>/* Link list node */<br />
struct node<br />
{<br />
    int data;<br />
    struct node* next;<br />
};</p>
<p>void AlternatingSplit(struct node* source, struct node** aRef,<br />
                      struct node** bRef)<br />
{<br />
    bool var=true;<br />
    struct node* temp1=NULL;<br />
    struct node *temp2=NULL;<br />
    struct node * curr=source;<br />
    struct node *temp=curr;<br />
    struct node *a=NULL;<br />
    struct node * b=NULL;<br />
    while(curr!=NULL )<br />
    {<br />
        if(var)<br />
        {<br />
            if(a==NULL)<br />
            {<br />
                a=curr;<br />
                curr=curr-&gt;next;<br />
                a-&gt;next=NULL;<br />
                temp1=a;<br />
            }<br />
            else<br />
            {</p>
<p>                temp1-&gt;next=curr;<br />
                temp1=curr;<br />
                curr=curr-&gt;next;<br />
                temp1-&gt;next=NULL;</p>
<p>            }</p>
<p>        }<br />
        else<br />
        {</p>
<p>            if(b==NULL)<br />
            {<br />
                b=curr;<br />
                curr=curr-&gt;next;<br />
                b-&gt;next=NULL;<br />
                temp2=b;<br />
            }<br />
            else<br />
            {</p>
<p>                temp2-&gt;next=curr;<br />
                temp2=curr;<br />
                curr=curr-&gt;next;<br />
                temp2-&gt;next=NULL;</p>
<p>            }</p>
<p>        }<br />
        var=!var;<br />
    }<br />
    *aRef=a;<br />
    *bRef=b;</p>
<p>}</p>
<p>void push(struct node** head_ref, int new_data)<br />
{</p>
<p>    struct node* new_node =(struct node*) malloc(sizeof(struct node));<br />
    new_node-&gt;data  = new_data;<br />
    new_node-&gt;next = (*head_ref);<br />
    (*head_ref)    = new_node;<br />
}</p>
<p>void printList(struct node *node)<br />
{<br />
    while(node!=NULL)<br />
    {<br />
        printf(&#8220;%d &#8220;, node-&gt;data);<br />
        node = node-&gt;next;<br />
    }<br />
}</p>
<p>/<br />
int main()<br />
{</p>
<p>    struct node* head = NULL;<br />
    struct node* a = NULL;<br />
    struct node* b = NULL;</p>
<p>    push(&amp;head,6);<br />
    push(&amp;head, 5);<br />
    push(&amp;head, 4);<br />
    push(&amp;head, 3);<br />
    push(&amp;head, 2);<br />
    push(&amp;head, 1);<br />
    push(&amp;head, 0);</p>
<p>    printf(&#8220;\n Original linked List:  &#8220;);<br />
    printList(head);</p>
<p>    /* Remove duplicates from linked list */<br />
    AlternatingSplit(head, &amp;a, &amp;b);</p>
<p>    printf(&#8220;\n Resultant Linked List &#8216;a&#8217; &#8220;);<br />
    printList(a);</p>
<p>    printf(&#8220;\n Resultant Linked List &#8216;b&#8217; &#8220;);<br />
    printList(b);</p>
<p>    getchar();<br />
    return 0;<br />
}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-20594">
        <div id="dsq-comment-header-20594" class="dsq-comment-header">
            <cite id="dsq-cite-20594">
                <span id="dsq-author-user-20594">lizard</span>
            </cite>
        </div>
        <div id="dsq-comment-body-20594" class="dsq-comment-body">
            <div id="dsq-comment-message-20594" class="dsq-comment-message"><p>I think the following code is fairly easy to understand and to code also and it do preserve the order of the elements. </p>
<pre> <code language="C">

void alternate(node *head,node **one,node **two)
{
    node *a=head,*b=head-&gt;nxt;
    *one=a;
    *two=b;
    while(b!=NULL)
    {
        a-&gt;nxt=b-&gt;nxt;
        a=b;
        b=a-&gt;nxt;
    }
}

</code> </pre>
<p>and will be called from main as: </p>
<pre> <code language="C">
    node *one,*two;
    alternate(head,&amp;one,&amp;two);
    print(one);  //function to print the list.
    cout&lt;&lt;endl;
    print(two); 
</code> </pre>
<p><img src="http://d2o58evtke57tz.cloudfront.net/wp-includes/images/smilies/icon_smile.gif" alt=":)" class="wp-smiley" /> Happy Coding</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-34378">
        <div id="dsq-comment-header-34378" class="dsq-comment-header">
            <cite id="dsq-cite-34378">
                <span id="dsq-author-user-34378">aishlnch</span>
            </cite>
        </div>
        <div id="dsq-comment-body-34378" class="dsq-comment-body">
            <div id="dsq-comment-message-34378" class="dsq-comment-message"><p>can anyone explain it to me please???</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment byuser comment-author-vibhu-tiwari even thread-even depth-1" id="dsq-comment-20487">
        <div id="dsq-comment-header-20487" class="dsq-comment-header">
            <cite id="dsq-cite-20487">
                <span id="dsq-author-user-20487">Vibhu Tiwari</span>
            </cite>
        </div>
        <div id="dsq-comment-body-20487" class="dsq-comment-body">
            <div id="dsq-comment-message-20487" class="dsq-comment-message"><p>@GeeksForGeeks i think it can also be done by the following method. It uses your link for deleting alternate nodes of a linked list. Now before freeing the node copy the node&#8217;s data to another linked list that contains these alternate nodes.At last just reverse the new linked list that we have made to get the alternative nodes in order.<br />
In the end just display the two lists.Below is the code</p>
<pre> <code language="C">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct node node_t;
struct node
{
    int data;
    node_t *next;
};
node_t *reverse(node_t *n)
{
    node_t *new_root=NULL;
    while(n)
    {
        node_t *next=n-&gt;next;
        n-&gt;next=new_root;
        new_root=n;
        n=next;
    }
    return new_root;
}
void push(node_t **head_ref,int data)
{
    node_t *n=(node_t *)malloc(sizeof(node_t));
    n-&gt;data=data;
    n-&gt;next=(*head_ref);
    (*head_ref)=n;
}
void push1(node_t **head_ref,int data)
{
    node_t *n=(node_t *)malloc(sizeof(node_t));
    n-&gt;data=data;
    n-&gt;next=(*head_ref);
   (*head_ref)=n;
}
void delAlt(node_t *head)
{
    node_t *prev=head;
    node_t *newList=NULL;
    node_t *n=head-&gt;next;
    while(prev!=NULL&amp;&amp;n!=NULL)
    {
        prev-&gt;next=n-&gt;next;
        push1(&amp;newList,n-&gt;data);
        free(n);
        prev=prev-&gt;next;
        if(prev!=NULL)
            n=prev-&gt;next;
    }
    node_t *a=reverse(newList);
    printList(a);
}
void printList(node_t *head)
{
    node_t *temp=head;
    while(temp!=NULL)
    {
        printf(&quot; %d &quot;,temp-&gt;data);
        temp=temp-&gt;next;
    }
}
int main()
{
    node_t *head=NULL;
    push(&amp;head,6);
    push(&amp;head,5);
    push(&amp;head,4);
    push(&amp;head,3);
    push(&amp;head,2);
    push(&amp;head,1);
    printList(head);
    printf(&quot;\n&quot;);
    delAlt(head);
    printf(&quot;\n&quot;);
    printList(head);

}

</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-20410">
        <div id="dsq-comment-header-20410" class="dsq-comment-header">
            <cite id="dsq-cite-20410">
                <span id="dsq-author-user-20410">Ankur</span>
            </cite>
        </div>
        <div id="dsq-comment-body-20410" class="dsq-comment-body">
            <div id="dsq-comment-message-20410" class="dsq-comment-message"><p>void split(node *temp,node **one,node **two)<br />
{<br />
if(temp==NULL)<br />
{<br />
*one =NULL;<br />
*two=NULL;<br />
return ;<br />
}<br />
node *ptr1=(node *)malloc(sizeof(node));<br />
node *ptr2=(node *)malloc(sizeof(node));<br />
*one=ptr1;<br />
*two=ptr2;<br />
ptr1-&gt;val=temp-&gt;val;<br />
if(temp-&gt;next)<br />
{<br />
ptr2-&gt;val=temp-&gt;next-&gt;val;<br />
split(temp-&gt;next-&gt;next,&amp;(ptr1-&gt;next),&amp;(ptr2-&gt;next));<br />
return ;<br />
}<br />
ptr1-&gt;next=NULL;<br />
*two=NULL;<br />
}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-19595">
        <div id="dsq-comment-header-19595" class="dsq-comment-header">
            <cite id="dsq-cite-19595">
                <span id="dsq-author-user-19595">Hanish Bansal</span>
            </cite>
        </div>
        <div id="dsq-comment-body-19595" class="dsq-comment-body">
            <div id="dsq-comment-message-19595" class="dsq-comment-message"><p>Here is one simple implementation without using Movenode function or dummy node :<br />
void AlternatingSplit(struct node* source, struct node** aRef,<br />
                            struct node** bRef)<br />
{<br />
  struct node *a, *b=NULL;<br />
  a=source;<br />
  if(a)<br />
      b=a-&gt;next;<br />
  *aRef = a;<br />
  *bRef = b;<br />
  while ( a &amp;&amp; b )<br />
  {<br />
      a-&gt;next=b-&gt;next;<br />
      a=a-&gt;next;<br />
      if(a)<br />
          b-&gt;next=a-&gt;next;<br />
      b=b-&gt;next;<br />
  }<br />
}</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-ronny odd alt depth-2" id="dsq-comment-20408">
        <div id="dsq-comment-header-20408" class="dsq-comment-header">
            <cite id="dsq-cite-20408">
                <span id="dsq-author-user-20408">Ronny</span>
            </cite>
        </div>
        <div id="dsq-comment-body-20408" class="dsq-comment-body">
            <div id="dsq-comment-message-20408" class="dsq-comment-message"><p>Even I thought this approach on reading this question.<br />
This is a neat and simple algorithm without using additional notes.<br />
Thanks for providing with code.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even depth-2" id="dsq-comment-22370">
        <div id="dsq-comment-header-22370" class="dsq-comment-header">
            <cite id="dsq-cite-22370">
                <span id="dsq-author-user-22370">lakshay</span>
            </cite>
        </div>
        <div id="dsq-comment-body-22370" class="dsq-comment-body">
            <div id="dsq-comment-message-22370" class="dsq-comment-message"><p>Exactly!<br />
Great approach hanish <img src="http://d2o58evtke57tz.cloudfront.net/wp-includes/images/smilies/icon_biggrin.gif" alt=":D" class="wp-smiley" /></p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-vikasnitt odd alt depth-2" id="dsq-comment-22538">
        <div id="dsq-comment-header-22538" class="dsq-comment-header">
            <cite id="dsq-cite-22538">
                <span id="dsq-author-user-22538">vikasnitt</span>
            </cite>
        </div>
        <div id="dsq-comment-body-22538" class="dsq-comment-body">
            <div id="dsq-comment-message-22538" class="dsq-comment-message"><p>Excellent approach hanish..:)</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even depth-2" id="dsq-comment-31933">
        <div id="dsq-comment-header-31933" class="dsq-comment-header">
            <cite id="dsq-cite-31933">
                <span id="dsq-author-user-31933">mualloc</span>
            </cite>
        </div>
        <div id="dsq-comment-body-31933" class="dsq-comment-body">
            <div id="dsq-comment-message-31933" class="dsq-comment-message"><p>First of all, thank you very much for your neat solution and also, I have developed your code for doubly linked lists. Sorry for the identifier names.</p>
<p>typedef struct node<br />
{<br />
    int data;<br />
    struct node *prev;<br />
    struct node *next;<br />
} node;</p>
<p>#define DATA(p) ((p)-&gt;data)<br />
#define NEXT(p) ((p)-&gt;next)<br />
#define PREV(p) ((p)-&gt;prev)</p>
<p>void split ( node* head, node **first, node **second )<br />
{<br />
    node* firstCurrent = head;<br />
    node* secondCurrent = NULL;<br />
    node* dummyforbprev = NULL;</p>
<p>    if ( firstCurrent )<br />
    {<br />
        secondCurrent = NEXT(firstCurrent);<br />
        if(secondCurrent)<br />
            PREV(secondCurrent)=NULL;<br />
    }</p>
<p>    *first = firstCurrent;<br />
    *second = secondCurrent;</p>
<p>    while ( firstCurrent &amp;&amp; secondCurrent )<br />
    {<br />
        NEXT(firstCurrent) = NEXT(secondCurrent);<br />
        dummyforbprev = PREV(firstCurrent);<br />
        firstCurrent = NEXT(firstCurrent);<br />
        if(firstCurrent)<br />
            PREV(firstCurrent) = PREV(secondCurrent);</p>
<p>        if ( firstCurrent )<br />
            NEXT(secondCurrent) = NEXT(firstCurrent);<br />
        PREV(secondCurrent) = dummyforbprev;<br />
        secondCurrent = NEXT(secondCurrent);<br />
    }</p>
<p>    if ( firstCurrent )<br />
        NEXT(firstCurrent) = NULL;</p>
<p>    if ( secondCurrent )<br />
        NEXT(secondCurrent) = NULL;<br />
}</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-19335">
        <div id="dsq-comment-header-19335" class="dsq-comment-header">
            <cite id="dsq-cite-19335">
                <span id="dsq-author-user-19335">hunter</span>
            </cite>
        </div>
        <div id="dsq-comment-body-19335" class="dsq-comment-body">
            <div id="dsq-comment-message-19335" class="dsq-comment-message"><p>while(p&amp;&amp;p-&gt;next)<br />
{<br />
temp=p-&gt;next;<br />
p-&gt;next=temp-&gt;next;<br />
temp-&gt;next=NULL;<br />
if(second==NULL)<br />
second=q=temp;<br />
else<br />
{<br />
q-&gt;next=temp;<br />
q=temp;<br />
}<br />
p=p-&gt;next;<br />
}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-ultimate_coder even thread-even depth-1" id="dsq-comment-19222">
        <div id="dsq-comment-header-19222" class="dsq-comment-header">
            <cite id="dsq-cite-19222">
                <span id="dsq-author-user-19222">ultimate_coder</span>
            </cite>
        </div>
        <div id="dsq-comment-body-19222" class="dsq-comment-body">
            <div id="dsq-comment-message-19222" class="dsq-comment-message"><p>I think its simpler to understand and easier one.<br />
head,head1 and head2 global variables.</p>
<p>1.Fisrt list head is head1.<br />
2.Second list head is head2.<br />
3.Original list head is head.</p>
<pre> <code language="C">
void splitlist(void)
{
    unsigned count=1;
    struct node *temp=head;
               //iterative loop
    while(temp)
    {
        if(count &amp; 1)         //check for even or odd
            push(&amp;head1,temp-&gt;data);   //odd to first list
        else push(&amp;head2,temp-&gt;data);  //even to second list
        temp=temp-&gt;next;
        ++count;          
    }
}

</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-20259">
        <div id="dsq-comment-header-20259" class="dsq-comment-header">
            <cite id="dsq-cite-20259">
                <span id="dsq-author-user-20259">beginner</span>
            </cite>
        </div>
        <div id="dsq-comment-body-20259" class="dsq-comment-body">
            <div id="dsq-comment-message-20259" class="dsq-comment-message"><p>very easy approach compared to al&#8230;thank u&#8230;.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even depth-2" id="dsq-comment-31727">
        <div id="dsq-comment-header-31727" class="dsq-comment-header">
            <cite id="dsq-cite-31727">
                <span id="dsq-author-user-31727">Marsha Donna</span>
            </cite>
        </div>
        <div id="dsq-comment-body-31727" class="dsq-comment-body">
            <div id="dsq-comment-message-31727" class="dsq-comment-message"><p>i think the question is to split 1 list into 2 separate lists..not create 2 lists using data present in the list..correct me if i m wrong</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment byuser comment-author-abhishek08aug odd alt thread-odd thread-alt depth-1" id="dsq-comment-17894">
        <div id="dsq-comment-header-17894" class="dsq-comment-header">
            <cite id="dsq-cite-17894">
                <span id="dsq-author-user-17894">abhishek08aug</span>
            </cite>
        </div>
        <div id="dsq-comment-body-17894" class="dsq-comment-body">
            <div id="dsq-comment-message-17894" class="dsq-comment-message"><pre> <code language="C">
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

struct node {
  int data;
  struct node * next;
};

void insert_node(struct node ** head_ref, int value) {
  struct node * head=*head_ref;
  struct node * new_node=NULL;
  if(head==NULL) {
    new_node=(struct node *)malloc(sizeof(struct node));
    new_node-&gt;data=value;
    new_node-&gt;next=NULL;
    *head_ref=new_node;
  } else {
    insert_node(&amp;head-&gt;next, value);
  }
}

void print_list(struct node * head) {
  struct node * current=head;
  while(current!=NULL) {
    printf(&quot;%d &quot;, current-&gt;data);
    current=current-&gt;next;
  }
  printf(&quot;\n&quot;);
}

struct node * split_list(struct node * head) {
  if(head==NULL) {
    return head;
  } else if(head-&gt;next==NULL) {
    return head-&gt;next;
  } else {
    struct node * second_list_head=head-&gt;next;
    struct node * first_list_node=head;
    struct node * second_list_node=head-&gt;next;
    while(second_list_node!=NULL) {
      first_list_node-&gt;next=second_list_node-&gt;next;
      if(first_list_node-&gt;next!=NULL) {
        second_list_node-&gt;next=first_list_node-&gt;next-&gt;next;
      }
      first_list_node=first_list_node-&gt;next;
      second_list_node=second_list_node-&gt;next;
    }
    return second_list_head;
  }
}

int main() {
  struct node * head=NULL;

  insert_node(&amp;head, 40);
  insert_node(&amp;head, 30);
  insert_node(&amp;head, 50);
  insert_node(&amp;head, 25);
  insert_node(&amp;head, 75);
  insert_node(&amp;head, 100);
  insert_node(&amp;head, 250);

  print_list(head);
  struct node * split_list_head=split_list(head);
  print_list(head);
  print_list(split_list_head);

  return 0;
}
</code> </pre>
<p>40 30 50 25 75 100 250<br />
40 50 75 250<br />
30 25 100</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-yatharth-sharma even thread-even depth-1" id="dsq-comment-16862">
        <div id="dsq-comment-header-16862" class="dsq-comment-header">
            <cite id="dsq-cite-16862">
                <span id="dsq-author-user-16862">yatharth.sharma</span>
            </cite>
        </div>
        <div id="dsq-comment-body-16862" class="dsq-comment-body">
            <div id="dsq-comment-message-16862" class="dsq-comment-message"><pre> <code language="C">


void alternate()
{
    
head1=head;
head2=head-&gt;next;
 node *t1=head1,*t2=head2;
while(t1!=NULL &amp;&amp; t2!=NULL)
 {       if(t1-&gt;next==NULL)
            break;
       t1-&gt;next=t2-&gt;next;
       t1=t1-&gt;next;
       if(t2-&gt;next==NULL)
       break;
       t2-&gt;next=t1-&gt;next;
       t2=t2-&gt;next; 
 }
     
}



</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-15809">
        <div id="dsq-comment-header-15809" class="dsq-comment-header">
            <cite id="dsq-cite-15809">
                <span id="dsq-author-user-15809">Shivam</span>
            </cite>
        </div>
        <div id="dsq-comment-body-15809" class="dsq-comment-body">
            <div id="dsq-comment-message-15809" class="dsq-comment-message"><p>void AlternatingSplit(struct node *source, struct node *a, struct node *b)     // where a is source and b is source-&gt;next.<br />
{<br />
if(a==NULL).<br />
return;.<br />
while(a-&gt;next!=NULL&amp;&amp;b-&gt;next!=NULL){<br />
a-&gt;next=a-&gt;next-&gt;next;<br />
a=a-&gt;next;<br />
b-&gt;next=b-&gt;next-&gt;next;<br />
b=b-&gt;next;<br />
}<br />
if(a-&gt;next!=NULL)<br />
a-&gt;next=NULL;<br />
}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-15774">
        <div id="dsq-comment-header-15774" class="dsq-comment-header">
            <cite id="dsq-cite-15774">
                <span id="dsq-author-user-15774">Nikin Kumar Jain</span>
            </cite>
        </div>
        <div id="dsq-comment-body-15774" class="dsq-comment-body">
            <div id="dsq-comment-message-15774" class="dsq-comment-message"><pre> <code language="C">
void addNode(node **sr, int data)
{
	node *temp = new node;
	temp-&gt;data = data;
	temp-&gt;next = NULL;
	if(*sr == NULL)
	{	
		*sr = temp;
		return;
	}
	else
	{
		while((*sr)-&gt;next != NULL)
			*sr = (*sr)-&gt;next;
		(*sr)-&gt;next = temp;
	}
}

void alternateSplits(node *sr, node **sr1, node **sr2)
{
	if(sr == NULL)
		return;
	while(sr != NULL)
	{
		addNode(sr1, sr-&gt;data);
		sr = sr-&gt;next;
		if(sr)
		{
			addNode(sr2, sr-&gt;data);
			sr = sr-&gt;next;
		}
	}
}
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-15150">
        <div id="dsq-comment-header-15150" class="dsq-comment-header">
            <cite id="dsq-cite-15150">
                <span id="dsq-author-user-15150">ramkumarp</span>
            </cite>
        </div>
        <div id="dsq-comment-body-15150" class="dsq-comment-body">
            <div id="dsq-comment-message-15150" class="dsq-comment-message"><pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */

void SplitAlt (Node* head, Node*&amp; hx, Node*&amp; hy){

  if (head == NULL || head -&gt; next == NULL){
        hx = head;
        hy = NULL;
        return;
  }
  hx = head;
  hy = head-&gt;next;

  Node *h1 = head;

  Node* h2 = head-&gt;next;

  while ( h1 != NULL &amp;&amp; h2 != NULL){

     if (h1-&gt;next != NULL){
        h1-&gt;next = h1-&gt;next-&gt;next;
     }
     
     if (h2-&gt;next != NULL ){
        h2-&gt;next = h2-&gt;next-&gt;next;
     }    
  
   h1 = h1-&gt;next;
   h2 = h2-&gt;next;
  }
return;
}
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
</li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-14196">
        <div id="dsq-comment-header-14196" class="dsq-comment-header">
            <cite id="dsq-cite-14196">
                <span id="dsq-author-user-14196">sush</span>
            </cite>
        </div>
        <div id="dsq-comment-body-14196" class="dsq-comment-body">
            <div id="dsq-comment-message-14196" class="dsq-comment-message"><p>There is no need to do so much. Alternating split can be written in this simple way.</p>
<pre> <code language="C">

void AlternatingSplit(struct node* h, struct node** a,struct node** b) 
							{
								if(h==NULL || h-&gt;next==NULL)
								{
									*a=h;*b=NULL;return;
								}
								*a=h;*b=h-&gt;next;
								AlternatingSplit((*b)-&gt;next,&amp;((*a)-&gt;next),&amp;((*b)-&gt;next));
							} 
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-13746">
        <div id="dsq-comment-header-13746" class="dsq-comment-header">
            <cite id="dsq-cite-13746">
                <span id="dsq-author-user-13746">PG</span>
            </cite>
        </div>
        <div id="dsq-comment-body-13746" class="dsq-comment-body">
            <div id="dsq-comment-message-13746" class="dsq-comment-message"><p>Any comment on this solution?</p>
<pre> <code language="C">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct node{
	int data;
	struct node *  next;
};

void pushfront(struct node **, int);
void print_list(struct node*);

void split_alternate_keep_original_list(struct node *, struct node **, struct node **);

int main(){
	struct node *head = NULL;
	struct node *head2 = NULL;
	struct node *head3 = NULL;

	pushfront(&amp;head, 7);
	pushfront(&amp;head, 6);
	pushfront(&amp;head, 5);
	pushfront(&amp;head, 4);
	pushfront(&amp;head, 3);
	pushfront(&amp;head, 2);
	pushfront(&amp;head, 1);

	print_list(head);


	split_alternate_keep_original_list(head, &amp;head2, &amp;head3);


	print_list(head2);
	print_list(head3);
}

void pushfront(struct node **head_ref, int data){
	
	
	struct node * newnode = (struct node*) malloc(sizeof(struct node));
	newnode-&gt;data = data;
	newnode-&gt;next = *head_ref;
	*head_ref = newnode;
}

void print_list(struct node *head){
	if(head){
		struct node * current = head;
		printf(&quot;\n&quot;);
		while(current!=NULL){
			printf(&quot;%d &quot;, current-&gt;data);
			current = current-&gt;next;
		}
	}
	else{
		printf(&quot;\nNull linked list.&quot;);
		return;
	}	
}

void split_alternate_keep_original_list(struct node *head, struct node **head2_ref, struct node **head3_ref){
	int count = 1;
	struct node * current = head;
	struct node dummy1;
	dummy1.next = NULL;
	struct node * tail1 = &amp;dummy1;

	struct node dummy2;
	dummy2.next = NULL;
	struct node *tail2 = &amp;dummy2;

	while(current!=NULL){
		if(count%2 != 0){
			pushfront(&amp;(tail1-&gt;next), current-&gt;data);
			tail1 = tail1-&gt;next;
			current = current-&gt;next;
			count++;
		}
		else{
			pushfront(&amp;(tail2-&gt;next), current-&gt;data);
			tail2 = tail2-&gt;next;
			current = current-&gt;next;
			count++;
		}
	}
	*head2_ref = dummy1.next;
	*head3_ref = dummy2.next;

}
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-12841">
        <div id="dsq-comment-header-12841" class="dsq-comment-header">
            <cite id="dsq-cite-12841">
                <span id="dsq-author-user-12841">himanshu</span>
            </cite>
        </div>
        <div id="dsq-comment-body-12841" class="dsq-comment-body">
            <div id="dsq-comment-message-12841" class="dsq-comment-message"><p>can be done using recursion like this easily&#8230;</p>
<p>void alternate_split(node *start,node *&amp;first,node *&amp;second)<br />
{<br />
	if(start==NULL)<br />
	{<br />
		first=NULL;second=NULL;return;<br />
	}<br />
	if(start-&gt;n==NULL)<br />
	{<br />
		first=start;second=NULL;return;<br />
	}<br />
	first=start;<br />
	second=start-&gt;n;<br />
	alternate_split(start-&gt;n-&gt;n,first-&gt;n,second-&gt;n);<br />
}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-11542">
        <div id="dsq-comment-header-11542" class="dsq-comment-header">
            <cite id="dsq-cite-11542">
                <span id="dsq-author-user-11542">Gurusimhe</span>
            </cite>
        </div>
        <div id="dsq-comment-body-11542" class="dsq-comment-body">
            <div id="dsq-comment-message-11542" class="dsq-comment-message"><p>What is the problem here in this code?<br />
When I give Input 1&#8211;&gt;0&#8211;&gt;1&#8211;&gt;0 it prints 1&#8211;&gt;0 and 0&#8211;&gt;1<br />
instead of 1&#8211;&gt;1 and 0&#8211;&gt;0 </p>
<p>void Altsplit( list *head, list **h1, list **h2)<br />
 {<br />
      if(head==NULL) return;<br />
      list *p = head;<br />
      *h1 = head; *h2 = head-&gt;next;</p>
<p>      while(p &amp;&amp; p-&gt;next)<br />
      {<br />
         list *t = p-&gt;next;<br />
         p-&gt;next = t-&gt;next;<br />
         p = t;<br />
      }<br />
 }</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-2" id="dsq-comment-11546">
        <div id="dsq-comment-header-11546" class="dsq-comment-header">
            <cite id="dsq-cite-11546">
                <span id="dsq-author-user-11546">Gurusimhe</span>
            </cite>
        </div>
        <div id="dsq-comment-body-11546" class="dsq-comment-body">
            <div id="dsq-comment-message-11546" class="dsq-comment-message"><p>Its working fine.My list was being modified.Please check if it has any other problem.<br />
Thanks,<br />
Gurusimhe</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-11511">
        <div id="dsq-comment-header-11511" class="dsq-comment-header">
            <cite id="dsq-cite-11511">
                <span id="dsq-author-user-11511">vick</span>
            </cite>
        </div>
        <div id="dsq-comment-body-11511" class="dsq-comment-body">
            <div id="dsq-comment-message-11511" class="dsq-comment-message"><p>its a recursive approach&#8230;n simple enough..<br />
plz comment if anything found wrong with the code..</p>
<pre> <code language="C">

void alternateSplit(node *q,node **a,node **b)
{
	if(q==NULL)return;
	
	node *aa,*bb;
	aa=q;
	bb=q-&gt;link;
	
	if(bb!=NULL)
	aa-&gt;link=bb-&gt;link;
	
	if(aa-&gt;link!=NULL)
	bb-&gt;link=aa-&gt;link-&gt;link;
	
	alternateSplit(aa-&gt;link,a,b);
	
	(*a)=aa;
	(*b)=bb;
	
	return;
	 
}
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-10836">
        <div id="dsq-comment-header-10836" class="dsq-comment-header">
            <cite id="dsq-cite-10836">
                <span id="dsq-author-user-10836">Manish Kumar</span>
            </cite>
        </div>
        <div id="dsq-comment-body-10836" class="dsq-comment-body">
            <div id="dsq-comment-message-10836" class="dsq-comment-message"><pre> <code language="C">
void AlternatingSplit(struct node* head, struct node** aRef, 
                            struct node** bRef) 
{
  /* split the nodes of source to these 'a' and 'b' lists */
  struct node* head1 = head; 
  struct node* head2 = head-&gt;next;
  struct node *s1 = head1;
  struct node *s2 = head2;
  struct node *p1,*p2;
  
  while(s1!=NULL &amp;&amp; s2!=NULL &amp;&amp; s2-&gt;next!=NULL &amp;&amp; s2-&gt;next-&gt;next!=NULL){
      p1=s2-&gt;next;
      p2=s2-&gt;next-&gt;next;
      s1-&gt;next=p1;
      s2-&gt;next=p2;
      s1=p1; s2=p2;
  }
  
  if(s1-&gt;next){
      s1-&gt;next=NULL;
  }
  if(s2-&gt;next){
      s1-&gt;next=s2-&gt;next;
      s2-&gt;next=NULL;
  }
   
  *aRef = head1;
  *bRef = head2;
}
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-9433">
        <div id="dsq-comment-header-9433" class="dsq-comment-header">
            <cite id="dsq-cite-9433">
                <span id="dsq-author-user-9433">shen</span>
            </cite>
        </div>
        <div id="dsq-comment-body-9433" class="dsq-comment-body">
            <div id="dsq-comment-message-9433" class="dsq-comment-message"><p>Recursive approach&#8230;.<br />
function will be called in giving start of the linked list  and pointer to the new start1 and start2 &#8230;</p>
<pre> <code language="C">
void alternativeSplit(node *s,node **s1, node **s2)
{
    if(s==NULL)
    {
        *s1=NULL;
        *s2=NULL;
        return;
    }
    node *a,*b,*temp;
    *s1=s;
    *s2=s-&gt;link;
    if(s-&gt;link!=NULL)
    {
        alternativeSplit(s-&gt;link-&gt;link,&amp;a,&amp;b);
        temp=s-&gt;link;
        s-&gt;link=a;
        temp-&gt;link=b;
    }
}
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-7155">
        <div id="dsq-comment-header-7155" class="dsq-comment-header">
            <cite id="dsq-cite-7155">
                <span id="dsq-author-user-7155">Ankur Garg</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7155" class="dsq-comment-body">
            <div id="dsq-comment-message-7155" class="dsq-comment-message"><p>A Recursive solution in O(n)</p>
<pre> <code language="C">
void AlternatingSplit(struct node* &amp;head, struct node* &amp;A,struct node* &amp;B){
  if(! head ){
    A=NULL;
    B=NULL;
    return;
  }
  if(! head-&gt;next ){
    A=head;
    B=NULL;
    return;
  }
  node* current=head;
  A=current;
  B=current-&gt;next;
  current=current-&gt;next-&gt;next;
  AlternatingSplit(current,A-&gt;next,B-&gt;next);
}
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-sudha odd alt thread-even depth-1" id="dsq-comment-6333">
        <div id="dsq-comment-header-6333" class="dsq-comment-header">
            <cite id="dsq-cite-6333">
                <span id="dsq-author-user-6333">Sudha Malpeddi</span>
            </cite>
        </div>
        <div id="dsq-comment-body-6333" class="dsq-comment-body">
            <div id="dsq-comment-message-6333" class="dsq-comment-message"><pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */

void copy(struct node *p, struct node **q)
{
	if(p!=NULL)
	{ 
		*q=(struct node*)malloc(sizeof(struct node)); 
		(*q)-&gt;num=p-&gt;num; 
		(*q)-&gt;next=NULL; 
		copy(p-&gt;next, &amp;((*q)-&gt;next)); 
		(*q)-&gt;arbit=p-&gt;arbit;
	}
}

</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-6018">
        <div id="dsq-comment-header-6018" class="dsq-comment-header">
            <cite id="dsq-cite-6018">
                <span id="dsq-author-user-6018">kamlesh meghwal</span>
            </cite>
        </div>
        <div id="dsq-comment-body-6018" class="dsq-comment-body">
            <div id="dsq-comment-message-6018" class="dsq-comment-message"><p>//p Points To Second Node And q Points To First Node<br />
q-&gt;next=p-&gt;next;<br />
while(p&amp;&amp;q)<br />
{<br />
 if(q-&gt;next)<br />
 p-&gt;next=q-&gt;next-&gt;next<br />
 else<br />
  p-&gt;next=Null<br />
}<br />
increament p And q i.e p=p-&gt;next,q=q-&gt;next</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-venki odd alt thread-even depth-1" id="dsq-comment-4656">
        <div id="dsq-comment-header-4656" class="dsq-comment-header">
            <cite id="dsq-cite-4656">
http://www.linkedin.com/in/ramanawithu                <span id="dsq-author-user-4656">Venki</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4656" class="dsq-comment-body">
            <div id="dsq-comment-message-4656" class="dsq-comment-message"><p>For Method 1, iterative code without &#8220;MoveNode&#8221; function. As @fuzz pointed passing pointers/dual pointers can create confusion.</p>
<pre> <code language="C">
void AlternatingSplit(struct node* source, struct node** aRef,
struct node** bRef)
{
    struct node** current_list = aRef;
    struct node* current_node = source;
    struct node* next_node = NULL;

    while (current_node != NULL)
    {
        next_node = current_node-&gt;next;
        current_node-&gt;next = (*current_list);
        (*current_list) = current_node;
        current_node = next_node;

        current_list = (current_list == aRef) ? bRef : aRef;
    }
}
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-venki even depth-2" id="dsq-comment-4660">
        <div id="dsq-comment-header-4660" class="dsq-comment-header">
            <cite id="dsq-cite-4660">
http://www.linkedin.com/in/ramanawithu                <span id="dsq-author-user-4660">Venki</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4660" class="dsq-comment-body">
            <div id="dsq-comment-message-4660" class="dsq-comment-message"><p>Removing if (ternary) condition inside the loop</p>
<pre> <code language="C">
void AlternatingSplit(struct node* source, struct node** aRef,
struct node** bRef)
{
    unsigned exor;
    struct node** current_list = aRef;
    struct node* current_node = source;
    struct node* next_node = NULL;
 
    /* Smarty compiler, don't warn me,
       I know what I am doing */
    exor = (unsigned)aRef ^ (unsigned)bRef;

    while (current_node != NULL)
    {
        next_node = current_node-&amp;gt;next;
        current_node-&amp;gt;next = (*current_list);
        (*current_list) = current_node;
        current_node = next_node;
 
        current_list = (struct node**)((unsigned)current_list ^ exor);
    }
}
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-3513">
        <div id="dsq-comment-header-3513" class="dsq-comment-header">
            <cite id="dsq-cite-3513">
                <span id="dsq-author-user-3513">Bandicoot</span>
            </cite>
        </div>
        <div id="dsq-comment-body-3513" class="dsq-comment-body">
            <div id="dsq-comment-message-3513" class="dsq-comment-message"><p>Sambasiva&#8217;s solution is both simpler and cleaner than either of the solutions provided above. Please include it as method 3.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-2" id="dsq-comment-3518">
        <div id="dsq-comment-header-3518" class="dsq-comment-header">
            <cite id="dsq-cite-3518">
                <span id="dsq-author-user-3518">R.Srinivasan</span>
            </cite>
        </div>
        <div id="dsq-comment-body-3518" class="dsq-comment-body">
            <div id="dsq-comment-message-3518" class="dsq-comment-message"><p>@Bandicoot<br />
Sambasiva&#8217;s program fails(&#8220;runtime error&#8221;) when the number of nodes is odd(1,3,etc), since temp=NULL(temp=p-&gt;next) when p becomes the last node and the illegal pointer Exception in &#8220;p-&gt;next=temp-&gt;next&#8221;.(temp=NULL).</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-3" id="dsq-comment-3524">
        <div id="dsq-comment-header-3524" class="dsq-comment-header">
            <cite id="dsq-cite-3524">
                <span id="dsq-author-user-3524">Bandicoot</span>
            </cite>
        </div>
        <div id="dsq-comment-body-3524" class="dsq-comment-body">
            <div id="dsq-comment-message-3524" class="dsq-comment-message"><p>My bad. You are right. Sambasiva should have added a if(!temp) conditional before trying to access either temp or temp-&gt;next. Apart from that, his soln is good.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-4" id="dsq-comment-7769">
        <div id="dsq-comment-header-7769" class="dsq-comment-header">
            <cite id="dsq-cite-7769">
http://sudhansu-codezone.blogspot.com                <span id="dsq-author-user-7769">Sudhansu</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7769" class="dsq-comment-body">
            <div id="dsq-comment-message-7769" class="dsq-comment-message"><p>list alternateNode(list head)<br />
{<br />
        list newlist = head-&gt;link;<br />
 /* newlist and head are two heads of required Lists */<br />
        list temp, p;<br />
//For Traversing the List</p>
<p>        for(p = head; p ; p = p-&gt;link)<br />
        {<br />
                temp = p-&gt;link;<br />
                if(!temp)<br />
                  p-&gt;link=temp;<br />
                else<br />
               { p-&gt;link = temp-&gt;link;</p>
<p>                if(temp-&gt;link)<br />
                        temp-&gt;link = temp-&gt;link-&gt;link;}<br />
        }</p>
<p>        return newlist;</p>
<p>}</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-3300">
        <div id="dsq-comment-header-3300" class="dsq-comment-header">
            <cite id="dsq-cite-3300">
                <span id="dsq-author-user-3300">sourabhjakhar</span>
            </cite>
        </div>
        <div id="dsq-comment-body-3300" class="dsq-comment-body">
            <div id="dsq-comment-message-3300" class="dsq-comment-message"><p>here is the recursive code<br />
.</p>
<pre> <code language="C">
struct * alternatesplit(struct node*head)
{
  struct node *result=NULL;
  struct node *result=head-&gt;next;
  head-&gt;next=head-&gt;next-&gt;next;
  result-&gt;next=alternatesplit(head-&gt;next);
  return result;
}
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-2271">
        <div id="dsq-comment-header-2271" class="dsq-comment-header">
            <cite id="dsq-cite-2271">
                <span id="dsq-author-user-2271">fuzz</span>
            </cite>
        </div>
        <div id="dsq-comment-body-2271" class="dsq-comment-body">
            <div id="dsq-comment-message-2271" class="dsq-comment-message"><p>I think the first solution is missing:</p>
<p>current = current-&gt;next statement after move statement!</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-geeksforgeeks bypostauthor odd alt depth-2" id="dsq-comment-2273">
        <div id="dsq-comment-header-2273" class="dsq-comment-header">
            <cite id="dsq-cite-2273">
                <span id="dsq-author-user-2273">GeeksforGeeks</span>
            </cite>
        </div>
        <div id="dsq-comment-body-2273" class="dsq-comment-body">
            <div id="dsq-comment-message-2273" class="dsq-comment-message"><p>If you take a closer look at MoveNode(), then you can see that it changes the current pointer.  That is why a pointer to current is passed.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-2126">
        <div id="dsq-comment-header-2126" class="dsq-comment-header">
            <cite id="dsq-cite-2126">
                <span id="dsq-author-user-2126">Usman</span>
            </cite>
        </div>
        <div id="dsq-comment-body-2126" class="dsq-comment-body">
            <div id="dsq-comment-message-2126" class="dsq-comment-message"><p>Here is an alternate solution that uses recursion. </p>
<p>Algorithm:</p>
<p>base case: if head is null return empty lists for both first and second. </p>
<p>recursive case: if head is not null, call split alternately again with head-&gt;next and store the first list returned into the second variable and the second list on first. append the first variable to head -&gt;next and return head as first while second is returned as is. </p>
<pre> <code language="C">
typedef struct LinkNode
{
	int data;
	struct LinkNode *next;
}LinkedNode;

void SplitAlternating(LinkedNode *head, LinkedNode **first, LinkedNode **second)
{
	if(!first ||!second)
		return;
	*first = NULL;
	*second = NULL;

	if (!head)
		return;
	SplitAlternating(head-&gt;next,second,first);
	head-&gt;next = *first;
	*first = head;
}</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-1717">
        <div id="dsq-comment-header-1717" class="dsq-comment-header">
            <cite id="dsq-cite-1717">
                <span id="dsq-author-user-1717">swami</span>
            </cite>
        </div>
        <div id="dsq-comment-body-1717" class="dsq-comment-body">
            <div id="dsq-comment-message-1717" class="dsq-comment-message"><pre> <code language="C">
void split(struct node *ptr)
{
  struct node *current;
  if(ptr==NULL)
   return ;
  current=ptr;
  while(current){
       q=current;
       current=current-&gt;next;
       q-&gt;next=a;
       a=q;
       if(currnet){
          q=current
          current=current-&gt;next;
          q-&gt;next=b;
          b=q;
       }
                       
  }

}
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-sambasiva even thread-even depth-1" id="dsq-comment-1384">
        <div id="dsq-comment-header-1384" class="dsq-comment-header">
            <cite id="dsq-cite-1384">
http://effprog.blogspot.com                <span id="dsq-author-user-1384">Sambasiva</span>
            </cite>
        </div>
        <div id="dsq-comment-body-1384" class="dsq-comment-body">
            <div id="dsq-comment-message-1384" class="dsq-comment-message"><pre> <code language="C">

list alternateNode(list l)
{
        Node *newlist = l-&gt;next;
        Node *temp, p;

        for(p = l; p ; p = p-&gt;next)
        {
                temp = p-&gt;next;
                p-&gt;next = temp-&gt;next;
                if(temp-&gt;next)
                        temp-&gt;next = temp-&gt;next-&gt;next;
        }

        return newlist;

}
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-sambasiva odd alt depth-2" id="dsq-comment-1385">
        <div id="dsq-comment-header-1385" class="dsq-comment-header">
            <cite id="dsq-cite-1385">
http://effprog.blogspot.com                <span id="dsq-author-user-1385">Sambasiva</span>
            </cite>
        </div>
        <div id="dsq-comment-body-1385" class="dsq-comment-body">
            <div id="dsq-comment-message-1385" class="dsq-comment-message"><pre> <code language="C">

list alternateNode(list l)
{
        Node *newlist = l-&gt;next;
        Node *temp, *p;

        for(p = l; p ; p = p-&gt;next)
        {
                temp = p-&gt;next;
                p-&gt;next = temp-&gt;next;
                if(temp-&gt;next)
                        temp-&gt;next = temp-&gt;next-&gt;next;
        }

        return newlist;

}
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-vinit even depth-2" id="dsq-comment-3953">
        <div id="dsq-comment-header-3953" class="dsq-comment-header">
            <cite id="dsq-cite-3953">
                <span id="dsq-author-user-3953">vinit</span>
            </cite>
        </div>
        <div id="dsq-comment-body-3953" class="dsq-comment-body">
            <div id="dsq-comment-message-3953" class="dsq-comment-message"><p>I guess, when you are at last node at that time this statement p-&gt;next = temp-&gt;next; will crash the program as p-&gt;next is NULL.<br />
Please correct me if i am wrong.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment byuser comment-author-abhimanu odd alt thread-odd thread-alt depth-1" id="dsq-comment-1211">
        <div id="dsq-comment-header-1211" class="dsq-comment-header">
            <cite id="dsq-cite-1211">
                <span id="dsq-author-user-1211">abhimanu</span>
            </cite>
        </div>
        <div id="dsq-comment-body-1211" class="dsq-comment-body">
            <div id="dsq-comment-message-1211" class="dsq-comment-message"><p>Alternate Solution:</p>
<p>Pass the head pointer and head-&gt;next pointer to AlternatingSplit() function.</p>
<pre> <code language="C">
/* Given the head pointer and head-&gt;next pointer. split the list into two.
  If we number the elements 0, 1, 2, ... then all the even elements
  should go in the first list(head_), and all the odd elements in the second(head_sn). */
void AlternatingSplit(struct node** head_s, struct node** head_sn)
{
   
  struct node* current1 = *head_s;
  struct node* current2 = *head_sn;
  while (current1 &amp;&amp; current2)
  {
	  if (current1-&gt;next) {
		  current1-&gt;next = current1-&gt;next-&gt;next;
		  current1 = current1-&gt;next;
	  }

	  if (current2-&gt;next) {
		  current2-&gt;next = current2-&gt;next-&gt;next;
		  current2 = current2-&gt;next;
	  }
  }
//this is done to take care of cases when number of elements are odd/even
    if (current1 != NULL)
    {
	    current1-&gt;next=NULL;
    }
    if (current2 != NULL)
    {
	    current2-&gt;next=NULL;
    }
}</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-abhimanu even thread-even depth-1" id="dsq-comment-1210">
        <div id="dsq-comment-header-1210" class="dsq-comment-header">
            <cite id="dsq-cite-1210">
                <span id="dsq-author-user-1210">abhimanu</span>
            </cite>
        </div>
        <div id="dsq-comment-body-1210" class="dsq-comment-body">
            <div id="dsq-comment-message-1210" class="dsq-comment-message"><p>The output of Method 1(Simple) is as follows:<br />
 Original linked List:  0 1 2 3 4 5<br />
 Resultant Linked List &#8216;a&#8217; 4 2 0<br />
 Resultant Linked List &#8216;b&#8217; 5 3 1</p>
<p>The code should be corrected to give o/p in correct order.</p>
<pre> <code language="C">

void AlternatingSplit(struct node* source, struct node** aRef,
                            struct node** bRef)
{
  /* split the nodes of source to these 'a' and 'b' lists */
  struct node* a = NULL;
  struct node* b = NULL;

// prev_a is used to store the 'a' pointer
  struct node* prev_a = a;
// prev_b is used to store the 'b' pointer
  struct node* prev_b = b;
  bool flag=true;
 
  struct node* current = source;
  while (current != NULL)
  {
    MoveNode(&amp;a, &amp;current); /* Move a node to list 'a' */
    if (current != NULL)
    {
       MoveNode(&amp;b, &amp;current); /* Move a node to list 'b' */
    }
    if (flag) {
	    prev_a=a;
	    prev_b=b;
	    flag=false;
    }
  }
  *aRef = prev_a;
  *bRef = prev_b;
}

void MoveNode(struct node** destRef, struct node** sourceRef)
{
  /* the front source node  */
  struct node* newNode = *sourceRef;
  assert(newNode != NULL);
 
  /* Advance the source pointer */
  *sourceRef = newNode-&gt;next;
 
  /* Link the old dest off the new node */
  newNode-&gt;next = NULL;
 
  /* Move dest to point to the new node */
  if (*destRef != NULL) {
	  (*destRef)-&gt;next = newNode;
  }
  *destRef = newNode;
}</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
            </ul>


        </div>

    </div>

<script type="text/javascript">
var disqus_url = 'http://www.geeksforgeeks.org/alternating-split-of-a-given-singly-linked-list/';
var disqus_identifier = '7621 http://geeksforgeeks.org/?p=7621';
var disqus_container_id = 'disqus_thread';
var disqus_shortname = 'geeksforgeeks';
var disqus_title = "Alternating split of a given Singly Linked List";
var disqus_config_custom = window.disqus_config;
var disqus_config = function () {
    /*
    All currently supported events:
    onReady: fires when everything is ready,
    onNewComment: fires when a new comment is posted,
    onIdentify: fires when user is authenticated
    */
    
    
    this.language = '';
    
    if (disqus_config_custom) {
        disqus_config_custom.call(this);
    }
};

(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>

			</div>
	
					
			
			

		</div> <!-- end post -->	

<br></br>
	
</div> <!-- end content -->

<ul id="sidebar">
	<li id="text-19" class="widget widget_text">			<div class="textwidget"><script>
  (function() {
    var cx = '009682134359037907028:tj6eafkv_be';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//www.google.com/cse/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>

<style type="text/css">
  .gsc-control-cse {
    font-family: "Trebuchet MS", sans-serif;
    border-color: #E1F3DA;
    background-color: #E1F3DA;
  }
  input.gsc-input {
    border-color: #94CC7A;
  }
  input.gsc-search-button {
    border-color: #94CC7A;
    background-color: #AADA92;
  }
  .gsc-tabHeader.gsc-tabhInactive {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gsc-tabHeader.gsc-tabhActive {
    border-color: #A9DA92;
    background-color: #A9DA92;
  }
  .gsc-tabsArea {
    border-color: #A9DA92;
  }
  .gsc-webResult.gsc-result {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gsc-webResult.gsc-result:hover {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gs-webResult.gs-result a.gs-title:link,
  .gs-webResult.gs-result a.gs-title:link b {
    color: #009900;
  }
  .gs-webResult.gs-result a.gs-title:visited,
  .gs-webResult.gs-result a.gs-title:visited b {
    color: #009900;
  }
  .gs-webResult.gs-result a.gs-title:hover,
  .gs-webResult.gs-result a.gs-title:hover b {
    color: #003300;
  }
  .gs-webResult.gs-result a.gs-title:active,
  .gs-webResult.gs-result a.gs-title:active b {
    color: #009900;
  }
  .gsc-cursor-page {
    color: #009900;
  }
  a.gsc-trailing-more-results:link {
    color: #009900;
  }
  .gs-webResult.gs-result .gs-snippet {
    color: #454545;
  }
  .gs-webResult.gs-result .gs-visibleUrl {
    color: #33cc00;
  }
  .gs-webResult.gs-result .gs-visibleUrl-short {
    color: #33cc00;
  }
  .gs-webResult.gs-result .gs-visibleUrl-short {
    display: none;
  }
  .gs-webResult.gs-result .gs-visibleUrl-long {
    display: block;
  }
  .gsc-cursor-box {
    border-color: #A9DA92;
  }
  .gsc-results .gsc-cursor-page {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gsc-results .gsc-cursor-page.gsc-cursor-current-page {
    border-color: #A9DA92;
    background-color: #A9DA92;
  }
  .gs-promotion.gs-result {
    border-color: #94CC7A;
    background-color: #CBE8B4;
  }
  .gs-promotion.gs-result a.gs-title:link {
    color: #0066CC;
  }
  .gs-promotion.gs-result a.gs-title:visited {
    color: #0066CC;
  }
  .gs-promotion.gs-result a.gs-title:hover {
    color: #0066CC;
  }
  .gs-promotion.gs-result a.gs-title:active {
    color: #0066CC;
  }
  .gs-promotion.gs-result .gs-snippet {
    color: #454545;
  }
  .gs-promotion.gs-result .gs-visibleUrl,
  .gs-promotion.gs-result .gs-visibleUrl-short {
    color: #815FA7;
  }
</style>    </div>
		</li>
<li id="text-9" class="widget widget_text">			<div class="textwidget"><div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=138031159685820";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>

<div class="fb-like-box" data-href="https://www.facebook.com/pages/GeeksforGeeks/316764689022" data-width="250" data-height="170" data-colorscheme="light" data-show-faces="true" data-header="false" data-stream="false" data-show-border="false"></div></div>
		</li>
<li id="text-18" class="widget widget_text">			<div class="textwidget"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LargeRectangleSide -->
<ins class="adsbygoogle"
     style="display:inline-block;width:336px;height:280px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="1884636833"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
		</li>
<li id="text-13" class="widget widget_text">			<div class="textwidget"><ul><li><a href="http://www.geeksforgeeks.org/category/interview-experiences/">Interview Experiences</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/advance-data-structures">Advanced Data Structures</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/dynamic-programming">Dynamic Programming</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/Greedy-Algorithm/">Greedy Algorithms</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/backtracking">Backtracking</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/pattern-searching">Pattern Searching</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/divide-and-conquer">Divide & Conquer</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/MathematicalAlgo">Mathematical Algorithms</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/recursion">Recursion</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/geometric-algorithms/">Geometric Algorithms</a></li>
</ul></div>
		</li>
<li id="text-17" class="widget widget_text">			<div class="textwidget"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big 300x600 Sidebar -->
<ins class="adsbygoogle"
     style="display:inline-block;width:300px;height:600px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="4402736037"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
		</li>
<li id="text-14" class="widget widget_text"><h2 class="widgettitle">Popular Posts</h2>
			<div class="textwidget"><ul>
<li><a href="http://www.geeksforgeeks.org/write-a-c-program-to-print-all-permutations-of-a-given-string/">  All permutations of a given string </a></li>
<li><a href="http://www.geeksforgeeks.org/memory-layout-of-c-program/"> Memory Layout of C Programs</a> </li>
<li><a href="http://www.geeksforgeeks.org/understanding-extern-keyword-in-c/"> Understanding â€œexternâ€ keyword in C</a> </li>
<li><a href="http://www.geeksforgeeks.org/median-of-two-sorted-arrays/">Median of two sorted arrays</a> </li>
<li><a href="http://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/"> Tree traversal without recursion and without stack! </a></li>
<li><a href="http://www.geeksforgeeks.org/structure-member-alignment-padding-and-data-packing/"> Structure Member Alignment, Padding and Data Packing</a> </li>
<li><a href="http://www.geeksforgeeks.org/write-a-function-to-get-the-intersection-point-of-two-linked-lists/"> Intersection point of two Linked Lists</a> </li>
<li><a href="http://www.geeksforgeeks.org/lowest-common-ancestor-in-a-binary-search-tree/"> Lowest Common Ancestor in a BST.</span></a> </li>
<li><a href="http://www.geeksforgeeks.org/a-program-to-check-if-a-binary-tree-is-bst-or-not/"> Check if a binary tree is BST or not</a> </li>
<li><a href="http://www.geeksforgeeks.org/sorted-linked-list-to-balanced-bst/"> Sorted Linked List to Balanced BST</a></li>
</ul></div>
		</li>
<li id="text-3" class="widget widget_text">			<div class="textwidget"><a href="https://twitter.com/GeeksforGeeks" class="twitter-follow-button" data-show-count="false">Follow @GeeksforGeeks</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>         


<!-- GOOGLE FEEDBURNER BUTTON-->
<a href="http://feeds.feedburner.com/Geeksforgeeks" title="Subscribe to my feed" rel="alternate" type="application/rss+xml"><img src="http://www.feedburner.com/fb/images/pub/feed-icon32x32.png" alt="" style="border:0"/></a><a href="http://feeds.feedburner.com/Geeksforgeeks" title="Subscribe to my feed" rel="alternate" type="application/rss+xml">Subscribe</a>

</div>
		</li>
<li id="text-21" class="widget widget_text"><h2 class="widgettitle">Recent Comments</h2>
			<div class="textwidget"><script type="text/javascript" src="http://geeksforgeeks.disqus.com//recent_comments_widget.js?num_items=6&hide_avatars=1&excerpt_length=50&hide_mods=0"></script></div>
		</li>
<li id="text-22" class="widget widget_text">			<div class="textwidget"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LinkAd -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:90px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="2606115235"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LinkAd -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:90px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="2606115235"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LinkAd -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:90px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="2606115235"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
		</li>

</ul>					  
		<div class="clear"></div>

		<div id="footer">
		
		    <div class="xhtml">
                        @geeksforgeeks, <a href="http://creativecommons.org/licenses/by-nc-nd/2.5/in/deed.en_US" title="Valid XHTML Strict 1.0">Some rights reserved</a>  <a href="http://www.geeksforgeeks.org/about/contact-us/"> &nbsp; &nbsp; &nbsp; &nbsp;Contact Us!</a>

		    </div>
		    
		    <div class="credits">
			  Powered by <a href="http://wordpress.org">WordPress </a> &amp; <a href="http://mootools.net/" title="Mootools JavaScript Framework">MooTools</a>, customized by geeksforgeeks team </div>
			  
		   <div class="clear"></div>						                            
		   
		</div> <!--end footer-->  
        
		        <script type="text/javascript">
        // <![CDATA[
        var disqus_shortname = 'geeksforgeeks';
        (function () {
            var nodes = document.getElementsByTagName('span');
            for (var i = 0, url; i < nodes.length; i++) {
                if (nodes[i].className.indexOf('dsq-postid') != -1) {
                    nodes[i].parentNode.setAttribute('data-disqus-identifier', nodes[i].getAttribute('rel'));
                    url = nodes[i].parentNode.href.split('#', 1);
                    if (url.length == 1) { url = url[0]; }
                    else { url = url[1]; }
                    nodes[i].parentNode.href = url + '#disqus_thread';
                }
            }
            var s = document.createElement('script'); 
            s.async = true;
            s.type = 'text/javascript';
            s.src = '//' + disqus_shortname + '.disqus.com/count.js';
            (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
        }());
        // ]]>
        </script>
        <script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/scripts/shCore.js?ver=3.0.9'></script>
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/scripts/shBrushCpp.js?ver=3.0.9'></script>
<script type='text/javascript'>
	(function(){
		var corecss = document.createElement('link');
		var themecss = document.createElement('link');
		var corecssurl = "http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/styles/shCore.css?ver=3.0.9";
		if ( corecss.setAttribute ) {
				corecss.setAttribute( "rel", "stylesheet" );
				corecss.setAttribute( "type", "text/css" );
				corecss.setAttribute( "href", corecssurl );
		} else {
				corecss.rel = "stylesheet";
				corecss.href = corecssurl;
		}
		document.getElementsByTagName("head")[0].insertBefore( corecss, document.getElementById("syntaxhighlighteranchor") );
		var themecssurl = "http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/styles/shThemeDefault.css?ver=3.0.9";
		if ( themecss.setAttribute ) {
				themecss.setAttribute( "rel", "stylesheet" );
				themecss.setAttribute( "type", "text/css" );
				themecss.setAttribute( "href", themecssurl );
		} else {
				themecss.rel = "stylesheet";
				themecss.href = themecssurl;
		}
		//document.getElementById("syntaxhighlighteranchor").appendChild(themecss);
		document.getElementsByTagName("head")[0].insertBefore( themecss, document.getElementById("syntaxhighlighteranchor") );
	})();
	SyntaxHighlighter.config.strings.expandSource = '+ expand source';
	SyntaxHighlighter.config.strings.help = '?';
	SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
	SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
	SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
	SyntaxHighlighter.defaults['gutter'] = false;
	SyntaxHighlighter.defaults['pad-line-numbers'] = true;
	SyntaxHighlighter.defaults['toolbar'] = false;
	SyntaxHighlighter.all();
</script>
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/bbpress/templates/default/js/editor.js?ver=2.5.4-5380'></script>
				  
		</div> <!--end wrapper-->
        <div id="ajaxSpinner"></div> <!--For AJAX spinner holder-->
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-12148232-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
	</body>

</html>
<!-- Dynamic page generated in 0.237 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2014-11-27 23:28:08 -->

<!-- Compression = gzip -->
<!-- super cache -->