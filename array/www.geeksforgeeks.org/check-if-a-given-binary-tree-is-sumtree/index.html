<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
       <title>Check if a given Binary Tree is SumTree - GeeksforGeeks</title>
       <style type="text/css" media="screen">
          @import url('http://d2o58evtke57tz.cloudfront.net/wp-content/themes/minimoo/style.css');
    </style>
      <link href="http://d2o58evtke57tz.cloudfront.net/wp-content/themes/minimoo/favicon.ico" rel="shortcut icon" />    
    
<!-- This site is optimized with the Yoast WordPress SEO plugin v1.7.1 - https://yoast.com/wordpress/plugins/seo/ -->
<link rel="canonical" href="http://www.geeksforgeeks.org/check-if-a-given-binary-tree-is-sumtree/" />
<meta property="og:locale" content="en_US" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Check if a given Binary Tree is SumTree - GeeksforGeeks" />
<meta property="og:description" content="Write a function that returns true if the given Binary Tree is SumTree else false. A SumTree is a Binary Tree where the value of a node is equal to sum of the nodes present in its left subtree and right subtree. An empty tree is SumTree and sum of an empty tree can be &hellip;" />
<meta property="og:url" content="http://www.geeksforgeeks.org/check-if-a-given-binary-tree-is-sumtree/" />
<meta property="og:site_name" content="GeeksforGeeks" />
<meta property="article:section" content="Trees" />
<meta property="article:published_time" content="2011-05-04T21:17:24+00:00" />
<meta property="article:modified_time" content="2011-05-06T16:15:54+00:00" />
<meta property="og:updated_time" content="2011-05-06T16:15:54+00:00" />
<!-- / Yoast WordPress SEO plugin. -->

<link rel='stylesheet' id='wp-quicklatex-format-css'  href='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/wp-quicklatex/css/quicklatex-format.css?ver=4.0.1' type='text/css' media='all' />
<link rel='stylesheet' id='bbp-default-css'  href='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/bbpress/templates/default/css/bbpress.css?ver=2.5.4-5380' type='text/css' media='screen' />
<link rel='stylesheet' id='wp-pagenavi-css'  href='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/wp-pagenavi/pagenavi-css.css?ver=2.70' type='text/css' media='all' />
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-includes/js/jquery/jquery.js?ver=1.11.1'></script>
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-includes/js/jquery/jquery-migrate.min.js?ver=1.2.1'></script>
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/wp-quicklatex/js/wp-quicklatex-frontend.js?ver=1.0'></script>

<!-- Bad Behavior 2.2.16 run time: 1.508 ms -->
<script type="text/javascript">
<!--
function bb2_addLoadEvent(func) {
	var oldonload = window.onload;
	if (typeof window.onload != 'function') {
		window.onload = func;
	} else {
		window.onload = function() {
			oldonload();
			func();
		}
	}
}

bb2_addLoadEvent(function() {
	for ( i=0; i < document.forms.length; i++ ) {
		if (document.forms[i].method == 'post') {
			var myElement = document.createElement('input');
			myElement.setAttribute('type', 'hidden');
			myElement.name = 'bb2_screener_';
			myElement.value = '1417111082 103.38.68.104';
			document.forms[i].appendChild(myElement);
		}
	}
});
// --></script>
		<style type="text/css" id="syntaxhighlighteranchor"></style>
   <meta name="google-site-verification" content="rHK2v8_zzuAZQY8JHAzbllDN8u-aQxcn2Kqnp67Old0" />
</head>

<body>
<!-- o4dI0sCXUgoSONabbd8mbZ4SA3E -->    
    <div id="wrapper">
        <div class="blog-info">
                <h1 class="blog-title">
                <a href="http://www.geeksforgeeks.org" title="GeeksforGeeks">GeeksforGeeks</a>
            </h1>
       
            <div class="blog-description">
                A computer science portal for geeks            </div>
        </div>
        <b><p>  <h2 align="right"> <a href="http://geeksquiz.com/">GeeksQuiz</a></h2> 
   <a href="http://www.geeksforgeeks.org/wp-login.php">Login</a> 
         </p></b>  
         
         <div class="clear"></div>         
              
                     
            <div id="menu">   
                 <ul>
 <li><a href="http://www.geeksforgeeks.org">Home</a></li>
  <li><a href="http://www.geeksforgeeks.org/fundamentals-of-algorithms/">Algorithms</a></li>
 <li><a href="http://www.geeksforgeeks.org/data-structures/">DS</a></li>
  <li><a href="http://www.geeksforgeeks.org/gate-corner/">GATE</a></li>
  <li><a href="http://www.geeksforgeeks.org/about/interview-corner/">Interview Corner</a></li>
  <li><a href="http://www.geeksforgeeks.org/forums/">Q&A</a></li>
  <li><a href="http://www.geeksforgeeks.org/c/">C</a></li>
  <li><a href="http://www.geeksforgeeks.org/c-plus-plus/">C++</a></li>
  <li><a href="http://www.geeksforgeeks.org/java/">Java</a></li>
  <li><a href="http://www.geeksforgeeks.org/books/">Books</a></li>
  <li><a href="http://www.geeksforgeeks.org/contribute/">Contribute</a></li>
  <li><a href="http://www.geeksforgeeks.org/contribute/ask-a-question/">Ask a Q</a></li>
  <li><a href="http://www.geeksforgeeks.org/about/">About</a></li>
            </ul>

               
            <div class="clear"></div>     
        </div>
             <div id="navmenu">
				<ul id="menu" style="padding:0; margin:0;">
						<li class="cat-item cat-item-3"><a href="http://www.geeksforgeeks.org/category/c-arrays/" title="Questions regarding Arrays">Array</a>
</li>	

	<li class="cat-item cat-item-17"><a href="http://www.geeksforgeeks.org/category/bit-magic/" title="View all posts filed under Bit Magic">Bit Magic</a>
</li>
	<li class="cat-item cat-item-14"><a href="http://www.geeksforgeeks.org/category/c-puzzles/" title="View all posts filed under C/C++ Puzzles">C/C++</a>
</li>

<li class="cat-item cat-item-18"><a href="http://www.geeksforgeeks.org/category/articles/" title="View all posts filed under Articles">Articles</a>
</li>

	<li class="cat-item cat-item-67"><a href="http://www.geeksforgeeks.org/category/gfact/" title="View all posts filed under GFacts">GFacts</a>
</li>
	<li class="cat-item cat-item-8"><a href="http://www.geeksforgeeks.org/category/linked-list/" title="Linked List problems">Linked List</a>
</li>
	<li class="cat-item cat-item-66"><a href="http://www.geeksforgeeks.org/category/multiple-choice-question/" title="View all posts filed under MCQ">MCQ</a>

</li>
	<li class="cat-item cat-item-4"><a href="http://www.geeksforgeeks.org/category/c-programs/" title="Miscellaneous">Misc</a>
</li>
	<li class="cat-item cat-item-5"><a href="http://www.geeksforgeeks.org/category/program-output/" title="View all posts filed under Output">Output</a>
</li>
	<li class="cat-item cat-item-7"><a href="http://www.geeksforgeeks.org/category/c-strings/" title="Questions related to strings">String</a>
</li>
	<li class="cat-item cat-item-19"><a href="http://www.geeksforgeeks.org/category/tree/" title="View all posts filed under Trees">Tree</a>
</li>
	<li class="cat-item cat-item-19"><a href="http://www.geeksforgeeks.org/category/graph/" title="View all posts filed under Graph">Graph</a>
</li>
</ul>
        </div>
             <div id="content">	   	
	<div class="post" id="post">
							<div class="post-info">			
					<div class="post-title-info">
						<h2 class="post-title">Check if a given Binary Tree is SumTree</h2>
					</div>			
					<div class="clear"></div>				  
				<div class="post-content" id="post-content">
					<p>Write a function that returns true if the given Binary Tree is SumTree else false. A SumTree is a Binary Tree where the value of a node is equal to sum of the nodes present in its left subtree and right subtree. <span id="more-12186"></span>An empty tree is SumTree and sum of an empty tree can be considered as 0. A leaf node is also considered as SumTree.</p>
<p>Following is an example of SumTree.</p>
<pre>
          26
        /   \
      10     3
    /    \     \
  4      6      3</pre>
<p><strong>Method 1 ( Simple ) </strong><br />
Get the sum of nodes in left subtree and right subtree.  Check if the sum calculated is equal to root&#8217;s data.  Also, recursively check if the left and right subtrees are SumTrees.</p>
<pre class="brush: cpp; title: ; notranslate" title="">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

/* A binary tree node has data, left child and right child */
struct node
{
    int data;
    struct node* left;
    struct node* right;
};

/* A utility function to get the sum of values in tree with root
  as root */
int sum(struct node *root)
{
   if(root == NULL)
     return 0;
   return sum(root-&gt;left) + root-&gt;data + sum(root-&gt;right);
}

/* returns 1 if sum property holds for the given
    node and both of its children */
int isSumTree(struct node* node)
{
    int ls, rs;

    /* If node is NULL or it's a leaf node then
       return true */
    if(node == NULL ||
            (node-&gt;left == NULL &amp;&amp; node-&gt;right == NULL))
        return 1;

   /* Get sum of nodes in left and right subtrees */
   ls = sum(node-&gt;left);
   rs = sum(node-&gt;right);

   /* if the node and both of its children satisfy the
       property return 1 else 0*/
    if((node-&gt;data == ls + rs)&amp;&amp;
            isSumTree(node-&gt;left) &amp;&amp;
            isSumTree(node-&gt;right))
        return 1;

   return 0;
}

/*
 Helper function that allocates a new node
 with the given data and NULL left and right
 pointers.
*/
struct node* newNode(int data)
{
    struct node* node =
        (struct node*)malloc(sizeof(struct node));
    node-&gt;data = data;
    node-&gt;left = NULL;
    node-&gt;right = NULL;
    return(node);
}

/* Driver program to test above function */
int main()
{
    struct node *root  = newNode(26);
    root-&gt;left         = newNode(10);
    root-&gt;right        = newNode(3);
    root-&gt;left-&gt;left   = newNode(4);
    root-&gt;left-&gt;right  = newNode(6);
    root-&gt;right-&gt;right = newNode(3);
    if(isSumTree(root))
        printf(&quot;The given tree is a SumTree &quot;);
    else
        printf(&quot;The given tree is not a SumTree &quot;);

    getchar();
    return 0;
}
</pre>
<p>Time Complexity: O(n^2) in worst case.  Worst case occurs for a skewed tree. </p>
<p><strong>Method 2 ( Tricky ) </strong><br />
The Method 1 uses sum() to get the sum of nodes in left and right subtrees.  The method 2 uses following rules to get the sum directly.<br />
1) If the node is a leaf node then sum of subtree rooted with this node is equal to value of this node.<br />
2) If the node is not a leaf node then sum of subtree rooted with this node is twice the value of this node (Assuming that the tree rooted with this node is SumTree).</p>
<pre class="brush: cpp; title: ; notranslate" title="">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

/* A binary tree node has data, left child and right child */
struct node
{
    int data;
    struct node* left;
    struct node* right;
};

/* Utillity function to check if the given node is leaf or not */
int isLeaf(struct node *node)
{
    if(node == NULL)
        return 0;
    if(node-&gt;left == NULL &amp;&amp; node-&gt;right == NULL)
        return 1;
    return 0;
}

/* returns 1 if SumTree property holds for the given
    tree */
int isSumTree(struct node* node)
{
    int ls; // for sum of nodes in left subtree
    int rs; // for sum of nodes in right subtree

    /* If node is NULL or it's a leaf node then
       return true */
    if(node == NULL || isLeaf(node))
        return 1;

    if( isSumTree(node-&gt;left) &amp;&amp; isSumTree(node-&gt;right))
    {
        // Get the sum of nodes in left subtree
        if(node-&gt;left == NULL)
            ls = 0;
        else if(isLeaf(node-&gt;left))
            ls = node-&gt;left-&gt;data;
        else
            ls = 2*(node-&gt;left-&gt;data);

        // Get the sum of nodes in right subtree
        if(node-&gt;right == NULL)
            rs = 0;
        else if(isLeaf(node-&gt;right))
            rs = node-&gt;right-&gt;data;
        else
            rs = 2*(node-&gt;right-&gt;data);

        /* If root's data is equal to sum of nodes in left
           and right subtrees then return 1 else return 0*/
        return(node-&gt;data == ls + rs);
    }

    return 0;
}

/* Helper function that allocates a new node
 with the given data and NULL left and right
 pointers.
*/
struct node* newNode(int data)
{
    struct node* node =
        (struct node*)malloc(sizeof(struct node));
    node-&gt;data = data;
    node-&gt;left = NULL;
    node-&gt;right = NULL;
    return(node);
}

/* Driver program to test above function */
int main()
{
    struct node *root  = newNode(26);
    root-&gt;left         = newNode(10);
    root-&gt;right        = newNode(3);
    root-&gt;left-&gt;left   = newNode(4);
    root-&gt;left-&gt;right  = newNode(6);
    root-&gt;right-&gt;right = newNode(3);
    if(isSumTree(root))
        printf(&quot;The given tree is a SumTree &quot;);
    else
        printf(&quot;The given tree is not a SumTree &quot;);

    getchar();
    return 0;
}
</pre>
<p>Time Complexity: O(n)</p>
<p>Please write comments if you find the above codes/algorithms incorrect, or find other ways to solve the same problem.</p>
		
&nbsp;
&nbsp;
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle"
     style="display:inline-block;width:336px;height:280px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="4061219431"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>



&nbsp;
&nbsp;
&nbsp;
<h3>Related Topics:</h3><ul><li><a href="http://www.geeksforgeeks.org/perfect-binary-tree-specific-level-order-traversal/" title="Perfect Binary Tree Specific Level Order Traversal">Perfect Binary Tree Specific Level Order Traversal</a></li><li><a href="http://www.geeksforgeeks.org/print-nodes-top-view-binary-tree/" title="Print Nodes in Top View of Binary Tree">Print Nodes in Top View of Binary Tree</a></li><li><a href="http://www.geeksforgeeks.org/k-dimensional-tree/" title="K Dimensional Tree">K Dimensional Tree</a></li><li><a href="http://www.geeksforgeeks.org/convert-binary-tree-threaded-binary-tree/" title="Convert a Binary Tree to Threaded binary tree">Convert a Binary Tree to Threaded binary tree</a></li><li><a href="http://www.geeksforgeeks.org/serialize-deserialize-n-ary-tree/" title="Serialize and Deserialize an N-ary Tree">Serialize and Deserialize an N-ary Tree</a></li><li><a href="http://www.geeksforgeeks.org/serialize-deserialize-binary-tree/" title="Serialize and Deserialize a Binary Tree">Serialize and Deserialize a Binary Tree</a></li><li><a href="http://www.geeksforgeeks.org/given-binary-tree-print-nodes-two-given-level-numbers/" title="Print nodes between two given level numbers of a binary tree">Print nodes between two given level numbers of a binary tree</a></li><li><a href="http://www.geeksforgeeks.org/find-height-binary-tree-represented-parent-array/" title="Find Height of Binary Tree represented by Parent array">Find Height of Binary Tree represented by Parent array</a></li></ul>
<p></p> 
<div>
<iframe src="http://www.facebook.com/plugins/like.php?href=http%3A%2F%2Fwww.geeksforgeeks.org%2Fcheck-if-a-given-binary-tree-is-sumtree%2F&layout=button_count&show_faces=false&width=90&action=like&colorscheme=light" scrolling="no" frameborder="0" allowTransparency="true" style="border:none; overflow:hidden; width:90px; height:20px"></iframe>
<a href="http://twitter.com/share" class="twitter-share-button" data-url="http://www.geeksforgeeks.org/check-if-a-given-binary-tree-is-sumtree/" data-text="Check if a given Binary Tree is SumTree" data-count="horizontal" data-via="jakerutter">Tweet</a><script type="text/javascript" src="http://platform.twitter.com/widgets.js"></script>
<g:plusone size="medium" href="http://www.geeksforgeeks.org/check-if-a-given-binary-tree-is-sumtree/"></g:plusone>
<!-- Place this render call where appropriate -->
<script type="text/javascript">
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script></div>





				</div>		  
			</div> <!-- end post main -->					
			<div class="post-meta">
				<div class="left"></div>				
				<div class="clear"></div>
			</div>			
        
			<div class="comments-main">		
 <b>Writing code in comment?</b> Please use <b><a href="http://ideone.com/">ideone.com</a></b> and share the link here.
				
<div id="disqus_thread">
            <div id="dsq-content">


            <ul id="dsq-comments">
                    <li class="comment even thread-even depth-1" id="dsq-comment-27125">
        <div id="dsq-comment-header-27125" class="dsq-comment-header">
            <cite id="dsq-cite-27125">
                <span id="dsq-author-user-27125">NoobTreeCoder</span>
            </cite>
        </div>
        <div id="dsq-comment-body-27125" class="dsq-comment-body">
            <div id="dsq-comment-message-27125" class="dsq-comment-message"><p>How about this code &#8230; its O(n)<br />
<code><br />
int isSumTree(node *root,int *sum){<br />
if(root==NULL){<br />
*sum=0;<br />
return(1);<br />
}<br />
if(root-&gt;left==NULL &amp;&amp; root-&gt;right==NULL){<br />
*sum=root-&gt;data;<br />
return(1);<br />
}<br />
int lsum,rsum;<br />
if(isSumTree(root-&gt;left,&amp;lsum) &amp;&amp;<br />
isSumTree(root-&gt;right,&amp;rsum) &amp;&amp;<br />
lsum+rsum=root-&gt;data){<br />
*sum=lsum+rsum+root-&gt;data;<br />
return(1);<br />
}<br />
return(0);<br />
}<br />
</code></p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-27151">
        <div id="dsq-comment-header-27151" class="dsq-comment-header">
            <cite id="dsq-cite-27151">
                <span id="dsq-author-user-27151">hary</span>
            </cite>
        </div>
        <div id="dsq-comment-body-27151" class="dsq-comment-body">
            <div id="dsq-comment-message-27151" class="dsq-comment-message"><p>I think the above solution is also good and it has less condition checking, the only thing I would have done differently is </p>
<p>if(isSumTree(root-&gt;left,&amp;lsum) &amp;&amp;<br />
isSumTree(root-&gt;right,&amp;rsum)){<br />
*sum=lsum+rsum+root-&gt;data;<br />
return (lsum+rsum=root-&gt;data);<br />
}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even depth-2" id="dsq-comment-27152">
        <div id="dsq-comment-header-27152" class="dsq-comment-header">
            <cite id="dsq-cite-27152">
                <span id="dsq-author-user-27152">hary</span>
            </cite>
        </div>
        <div id="dsq-comment-body-27152" class="dsq-comment-body">
            <div id="dsq-comment-message-27152" class="dsq-comment-message"><p>I think the above solution is also good and it has less condition checking, the only thing I would have done differently is </p>
<p>if(isSumTree(root-&gt;left,&amp;lsum) &amp;&amp;<br />
isSumTree(root-&gt;right,&amp;rsum)){<br />
*sum=lsum+rsum+root-&gt;data;<br />
return (lsum+rsum=root-&gt;data);<br />
}</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-3" id="dsq-comment-27153">
        <div id="dsq-comment-header-27153" class="dsq-comment-header">
            <cite id="dsq-cite-27153">
                <span id="dsq-author-user-27153">hary</span>
            </cite>
        </div>
        <div id="dsq-comment-body-27153" class="dsq-comment-body">
            <div id="dsq-comment-message-27153" class="dsq-comment-message"><p>Forgot to add double equality in the return statement i.e. return (lsum+rsum == root-&gt;data)</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even depth-2" id="dsq-comment-32221">
        <div id="dsq-comment-header-32221" class="dsq-comment-header">
            <cite id="dsq-cite-32221">
                <span id="dsq-author-user-32221">CoderBoy</span>
            </cite>
        </div>
        <div id="dsq-comment-body-32221" class="dsq-comment-body">
            <div id="dsq-comment-message-32221" class="dsq-comment-message"><p>I want to point out that if you see we used same strategy in converting Diameter,Height-Balance Verification solutions of O(n^2) to O(n)&#8230;Cool <img src="http://d2o58evtke57tz.cloudfront.net/wp-includes/images/smilies/icon_smile.gif" alt=":)" class="wp-smiley" /> Isn&#8217;t it???</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment byuser comment-author-abhisheksingh odd alt thread-odd thread-alt depth-1" id="dsq-comment-24823">
        <div id="dsq-comment-header-24823" class="dsq-comment-header">
            <cite id="dsq-cite-24823">
                <span id="dsq-author-user-24823">AbhishekSingh</span>
            </cite>
        </div>
        <div id="dsq-comment-body-24823" class="dsq-comment-body">
            <div id="dsq-comment-message-24823" class="dsq-comment-message"><p>why does the method 1 solution returns 1 for the case when binary tree contains only root node? How does this satisfies the sum property?</p>
<pre> <code language="C">
int isSumTree(struct node* node)
{
    int ls, rs;
 
    /* If node is NULL or it's a leaf node then
       return true */
    if(node == NULL ||
            (node-&gt;left == NULL &amp;&amp; node-&gt;right == NULL))
        return 1;
 
   /* Get sum of nodes in left and right subtrees */
   ls = sum(node-&gt;left);
   rs = sum(node-&gt;right);
 
   /* if the node and both of its children satisfy the
       property return 1 else 0*/
    if((node-&gt;data == ls + rs)&amp;&amp;
            isSumTree(node-&gt;left) &amp;&amp;
            isSumTree(node-&gt;right))
        return 1;
 
   return 0;
}
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-abhisheksingh even thread-even depth-1" id="dsq-comment-24819">
        <div id="dsq-comment-header-24819" class="dsq-comment-header">
            <cite id="dsq-cite-24819">
                <span id="dsq-author-user-24819">AbhishekSingh</span>
            </cite>
        </div>
        <div id="dsq-comment-body-24819" class="dsq-comment-body">
            <div id="dsq-comment-message-24819" class="dsq-comment-message"><p>why does the code in method 1 returns 1 for the case when only root node is present in the binary tree? How does this satisfy the sum property?</p>
<pre> <code language="C">
int isSumTree(struct node* node)
{
    int ls, rs;
 
    /* If node is NULL or it's a leaf node then
       return true */
    if(node == NULL ||
            (node-&gt;left == NULL &amp;&amp; node-&gt;right == NULL))
        return 1;
 
   /* Get sum of nodes in left and right subtrees */
   ls = sum(node-&gt;left);
   rs = sum(node-&gt;right);
 
   /* if the node and both of its children satisfy the
       property return 1 else 0*/
    if((node-&gt;data == ls + rs)&amp;&amp;
            isSumTree(node-&gt;left) &amp;&amp;
            isSumTree(node-&gt;right))
        return 1;
 
   return 0;
}
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-19694">
        <div id="dsq-comment-header-19694" class="dsq-comment-header">
            <cite id="dsq-cite-19694">
                <span id="dsq-author-user-19694">Akhil</span>
            </cite>
        </div>
        <div id="dsq-comment-body-19694" class="dsq-comment-body">
            <div id="dsq-comment-message-19694" class="dsq-comment-message"><p>An O(n) small self explanatory precise code. </p>
<pre> <code language="C">
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
struct tree
{
    int info;
    struct tree *l;
    struct tree *r;
};
typedef struct tree *Tree;

Tree newNode(int num)
{
    Tree temp = (Tree)malloc(sizeof(struct tree));
    temp-&gt;info = num;
    temp-&gt;l = NULL;
    temp-&gt;r = NULL;
    return temp;
}

int isSumTree(Tree root)
{
    if(!root)
        return 0;
    if(!root-&gt;l &amp;&amp; !root-&gt;r)
        return root-&gt;info;
    int ls = isSumTree(root-&gt;l);
    int rs = isSumTree(root-&gt;r);
    if(ls!=-1 &amp;&amp; rs!=-1 &amp;&amp; root-&gt;info == ls+rs)
        return root-&gt;info+ls+rs;
    return -1;
}
int main()
{
    struct tree *root  = newNode(26);
    root-&gt;l = newNode(10);
    root-&gt;r = newNode(3);
    root-&gt;l-&gt;l = newNode(4);
    root-&gt;l-&gt;r = newNode(6);
    root-&gt;r-&gt;r = newNode(3);
    if(isSumTree(root)!=-1)
        printf(&quot;YES\n&quot;);
    else printf(&quot;NO&quot;);
    return 0;
}


</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-ronny even depth-2" id="dsq-comment-20807">
        <div id="dsq-comment-header-20807" class="dsq-comment-header">
            <cite id="dsq-cite-20807">
                <span id="dsq-author-user-20807">Ronny</span>
            </cite>
        </div>
        <div id="dsq-comment-body-20807" class="dsq-comment-body">
            <div id="dsq-comment-message-20807" class="dsq-comment-message"><p>Thumbs up..Cool</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-denial odd alt depth-2" id="dsq-comment-20943">
        <div id="dsq-comment-header-20943" class="dsq-comment-header">
            <cite id="dsq-cite-20943">
                <span id="dsq-author-user-20943">denial</span>
            </cite>
        </div>
        <div id="dsq-comment-body-20943" class="dsq-comment-body">
            <div id="dsq-comment-message-20943" class="dsq-comment-message"><p>Where is Admin ? This solution works perfect. I tried this. Hey people Do comment if something is wrong.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even depth-2" id="dsq-comment-21003">
        <div id="dsq-comment-header-21003" class="dsq-comment-header">
            <cite id="dsq-cite-21003">
                <span id="dsq-author-user-21003">Geek86</span>
            </cite>
        </div>
        <div id="dsq-comment-body-21003" class="dsq-comment-body">
            <div id="dsq-comment-message-21003" class="dsq-comment-message"><p>It will fail in the following case : BTree with</p>
<p>root &#8216;7&#8217; and with left child &#8216;7&#8217; and right child &#8216;0&#8217;</p>
<p>Correct me If I am wrong.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-3" id="dsq-comment-21006">
        <div id="dsq-comment-header-21006" class="dsq-comment-header">
            <cite id="dsq-cite-21006">
                <span id="dsq-author-user-21006">Geek86</span>
            </cite>
        </div>
        <div id="dsq-comment-body-21006" class="dsq-comment-body">
            <div id="dsq-comment-message-21006" class="dsq-comment-message"><p>Correction from above</p>
<p>It will fail in the following case : BTree with</p>
<p>root &#8216;7&#8217; and with left child &#8216;7&#8217; and NO right child</p>
<p>Correct me If I am wrong.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-4" id="dsq-comment-21010">
        <div id="dsq-comment-header-21010" class="dsq-comment-header">
            <cite id="dsq-cite-21010">
                <span id="dsq-author-user-21010">Akhil</span>
            </cite>
        </div>
        <div id="dsq-comment-body-21010" class="dsq-comment-body">
            <div id="dsq-comment-message-21010" class="dsq-comment-message"><p>This would work.</p>
<pre> <code language="C">
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
struct tree
{
    int info;
    struct tree *l;
    struct tree *r;
};
typedef struct tree *Tree;
 
Tree newNode(int num)
{
    Tree temp = (Tree)malloc(sizeof(struct tree));
    temp-&gt;info = num;
    temp-&gt;l = NULL;
    temp-&gt;r = NULL;
    return temp;
}
 
int isSumTree(Tree root)
{
    if(!root)
        return 0;
    if(!root-&gt;l &amp;&amp; !root-&gt;r)
        return root-&gt;info;
    int ls = isSumTree(root-&gt;l);
    int rs = isSumTree(root-&gt;r);
    if(ls!=-1 &amp;&amp; rs!=-1 &amp;&amp; root-&gt;info == ls+rs)
        return root-&gt;info+ls+rs;
    else if(ls==-1)
        return root-&gt;info+rs;
    else if(rs==-1)
        return root-&gt;info+ls;
    else
    return -1;
}
int main()
{
    struct tree *root  = newNode(26);
    root-&gt;l = newNode(10);
    root-&gt;r = newNode(3);
    root-&gt;l-&gt;l = newNode(4);
    root-&gt;l-&gt;r = newNode(6);
    root-&gt;r-&gt;r = newNode(3);
    if(isSumTree(root)!=-1)
        printf(&quot;YES\n&quot;);
    else printf(&quot;NO&quot;);
    return 0;
}
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-5" id="dsq-comment-22130">
        <div id="dsq-comment-header-22130" class="dsq-comment-header">
            <cite id="dsq-cite-22130">
                <span id="dsq-author-user-22130">Rahul</span>
            </cite>
        </div>
        <div id="dsq-comment-body-22130" class="dsq-comment-body">
            <div id="dsq-comment-message-22130" class="dsq-comment-message"><p>Why did you change the code? I guess the one you posted earlier was also working in the example suggested by Geek86</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even depth-5" id="dsq-comment-22490">
        <div id="dsq-comment-header-22490" class="dsq-comment-header">
            <cite id="dsq-cite-22490">
                <span id="dsq-author-user-22490">Akhil</span>
            </cite>
        </div>
        <div id="dsq-comment-body-22490" class="dsq-comment-body">
            <div id="dsq-comment-message-22490" class="dsq-comment-message"><p>yes, you are right. It will work then also. <img src="http://d2o58evtke57tz.cloudfront.net/wp-includes/images/smilies/icon_smile.gif" alt=":)" class="wp-smiley" /></p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt depth-2" id="dsq-comment-29394">
        <div id="dsq-comment-header-29394" class="dsq-comment-header">
            <cite id="dsq-cite-29394">
                <span id="dsq-author-user-29394">Sreenivas Doosa</span>
            </cite>
        </div>
        <div id="dsq-comment-body-29394" class="dsq-comment-body">
            <div id="dsq-comment-message-29394" class="dsq-comment-message"><p>This solution works perfectly.. Nice and simple.. <img src="http://d2o58evtke57tz.cloudfront.net/wp-includes/images/smilies/icon_smile.gif" alt=":)" class="wp-smiley" /></p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-19151">
        <div id="dsq-comment-header-19151" class="dsq-comment-header">
            <cite id="dsq-cite-19151">
                <span id="dsq-author-user-19151">Ujjwal</span>
            </cite>
        </div>
        <div id="dsq-comment-body-19151" class="dsq-comment-body">
            <div id="dsq-comment-message-19151" class="dsq-comment-message"><pre> <code language="C">
Cant the solution be approached using tree's inorder and preorder traversal.??
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-abhishek08aug odd alt thread-odd thread-alt depth-1" id="dsq-comment-18303">
        <div id="dsq-comment-header-18303" class="dsq-comment-header">
            <cite id="dsq-cite-18303">
                <span id="dsq-author-user-18303">abhishek08aug</span>
            </cite>
        </div>
        <div id="dsq-comment-body-18303" class="dsq-comment-body">
            <div id="dsq-comment-message-18303" class="dsq-comment-message"><p>C++ code:</p>
<pre> <code language="C">
#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;
using namespace std;
  
class tree_node {
  private:
    int data;
    tree_node * left;
    tree_node * right;
  public:
    tree_node() {
      left=NULL;
      right=NULL;
    }
    void set_data(int data) {
      this-&gt;data=data;
    }
    int get_data() {
      return this-&gt;data;
    }
    void set_left(tree_node * left) {
      this-&gt;left=left;
    }
    tree_node * get_left() {
      return this-&gt;left;
    }
    void set_right(tree_node * right) {
      this-&gt;right=right;
    }
    tree_node * get_right() {
      return this-&gt;right;
    }
    tree_node ** get_left_ref() {
      return &amp;(this-&gt;left);
    }
    tree_node ** get_right_ref() {
      return &amp;(this-&gt;right);
    }
};
  
class tree {
  private:
    tree_node * root;
    int size;
    void _recursive_insert(tree_node ** root_ref, int value);
    void _print_preorder(tree_node * root);
    void _print_inorder(tree_node * root);
    void _print_postorder(tree_node * root);
    int _find_size(tree_node * root);
    int _are_identical(tree_node * tn1, tree_node * tn2);
    int _find_height(tree_node * root);
    void _delete_tree(tree_node ** root);
    void _mirror(tree_node * root);
    void _print_paths(tree_node * root, int * path_nodes, int next_vacant_position);
    void _print_array(int * array, int len);
    tree_node * _lowest_common_ancestor(tree_node * parent, tree_node * root, int a, int b);
    tree_node * _find_node(tree_node * root, int value);
    tree_node * _min_node(tree_node * root);
    void _print_level_order(tree_node * root);
    int _count_leaf_nodes(tree_node * root);
    int _is_bst(tree_node * root);
    int _children_sum(tree_node * root);
    void _ensure_children_sum(tree_node * root);
    int _diameter(tree_node * root);
    int _is_height_balanced(tree_node * root);
    int _leaf_path_sum(tree_node * root, int num);
    void _double_tree(tree_node * root);
    int _width(tree_node * root, int height, int level, int initialize_width_array);
    int _maximum(int array[], int len);
    void _print_k_distance_nodes(tree_node * root, int k, int distance);
    tree_node * _kth_smallest_element(tree_node * root, int k);
    int _get_level(tree_node * root, int key, int level);
    int _print_ancestors(tree_node * root, int key);
    void _print_keys_in_range(tree_node * root, int r1, int r2);
    int _is_sum_tree(tree_node * root);
  public:
    tree() {
      root=NULL;
      size=0;
    }
    void insert(int value);
    void recursive_insert(int value);
    void print_preorder();
    void print_inorder();
    void print_postorder();
    int find_size();
    int get_size() {
      return this-&gt;size;
    }
    int are_identical(tree t);
    int find_height();
    void delete_tree();
    void mirror();
    void print_paths();
    tree_node * lowest_common_ancestor(int a, int b);
    tree_node * find_node(int value);
    tree_node * min_node();
    void print_level_order();
    int count_leaf_nodes();
    int is_bst();
    int children_sum();
    void ensure_children_sum();
    int diameter();
    int is_height_balanced();
    int leaf_path_sum(int num);
    void double_tree();
    int width();
    void print_k_distance_nodes(int k);
    tree_node * kth_smallest_element(int k);
    int get_level(int key);
    void print_ancestors(int key);
    void print_keys_in_range(int r1, int r2);
    int is_sum_tree();
};
  
void tree::insert(int value) {
  if(root==NULL) {
    root=new tree_node;
    root-&gt;set_data(value);
  } else {
    tree_node * parent=NULL;
    tree_node * current=root;
    tree_node * new_node=new tree_node;
    new_node-&gt;set_data(value);
    while(current!=NULL) {
      if(value&lt;=current-&gt;get_data()) {
        parent=current;
        current=current-&gt;get_left();
      } else {
        parent=current;
        current=current-&gt;get_right();
      }
    }
    if(value&lt;=parent-&gt;get_data() &amp;&amp; parent-&gt;get_left()==NULL) {
      parent-&gt;set_left(new_node);
    } else if(value&gt;parent-&gt;get_data() &amp;&amp; parent-&gt;get_right()==NULL) {
      parent-&gt;set_right(new_node);
    }
  }
  size++;
}
  
void tree::recursive_insert(int value) {
  _recursive_insert(&amp;root, value);
  size++;
}
  
void tree::_recursive_insert(tree_node ** root_ref, int value) {
  if(*root_ref==NULL) {
    tree_node * new_node=new tree_node;
    new_node-&gt;set_data(value);
    *root_ref=new_node;  
  } else {
    if(value&lt;=(*root_ref)-&gt;get_data()) {
      _recursive_insert((*root_ref)-&gt;get_left_ref(), value);
    } else {
      _recursive_insert((*root_ref)-&gt;get_right_ref(), value);
    }
  }
}
  
void tree::print_preorder() {
  if(root==NULL) {
    return;
  }
  _print_preorder(root);
  cout&lt;&lt;endl;
}
  
void tree::_print_preorder(tree_node * root) {
  if(root==NULL) {
    return;
  }
  cout&lt;&lt;root-&gt;get_data()&lt;&lt;&quot; &quot;;
  if(root-&gt;get_left()!=NULL)
    _print_preorder(root-&gt;get_left());
  if(root-&gt;get_right()!=NULL)
    _print_preorder(root-&gt;get_right());
}
  
void tree::print_inorder() {
  if(root==NULL) {
    return;
  }
  _print_inorder(root);
  cout&lt;&lt;endl;
}
  
void tree::_print_inorder(tree_node * root) {
  if(root==NULL) {
    return;
  }
  if(root-&gt;get_left()!=NULL)
    _print_inorder(root-&gt;get_left());
  cout&lt;&lt;root-&gt;get_data()&lt;&lt;&quot; &quot;;
  if(root-&gt;get_right()!=NULL)
    _print_inorder(root-&gt;get_right());
}
  
void tree::print_postorder() {
  if(root==NULL) {
    return;
  }
  _print_postorder(root);
  cout&lt;&lt;endl;
}
  
void tree::_print_postorder(tree_node * root) {
  if(root==NULL) {
    return;
  }
  if(root-&gt;get_left()!=NULL)
    _print_postorder(root-&gt;get_left());
  if(root-&gt;get_right()!=NULL)
    _print_postorder(root-&gt;get_right());
  cout&lt;&lt;root-&gt;get_data()&lt;&lt;&quot; &quot;;
}
 
int tree::find_size() {
  return _find_size(root);
}
 
int tree::_find_size(tree_node * root) {
  if(root==NULL) {
    return 0;
  } else {
    return 1+_find_size(root-&gt;get_left())+_find_size(root-&gt;get_right());
  }
}
 
int tree::are_identical(tree t) {
  return _are_identical(this-&gt;root, t.root);
}
 
int tree::_are_identical(tree_node * tn1, tree_node * tn2) {
  if(tn1==NULL &amp;&amp; tn2==NULL) {
    return 1;
  } else if((tn1==NULL &amp;&amp; tn2!=NULL) || (tn1!=NULL &amp;&amp; tn2==NULL) || (tn1-&gt;get_data()!=tn2-&gt;get_data())) {
    return 0;
  } else {
    return _are_identical(tn1-&gt;get_left(), tn2-&gt;get_left()) &amp;&amp; _are_identical(tn1-&gt;get_right(), tn2-&gt;get_right());
  }
}
 
int tree::find_height() {
  return _find_height(root);
}
 
int tree::_find_height(tree_node * root) {
  if(root==NULL) {
    return 0;
  }
  else {
    return 1+max(_find_height(root-&gt;get_left()), _find_height(root-&gt;get_right()));
  }
}
 
void tree::delete_tree() {
  _delete_tree(&amp;root);
  size=0;
}
 
void tree::_delete_tree(tree_node ** root) {
  if(*root==NULL) {
    return;
  } else {
    if((*root)-&gt;get_left()!=NULL) {
      _delete_tree((*root)-&gt;get_left_ref());
    }
    if((*root)-&gt;get_right()!=NULL) {
      _delete_tree((*root)-&gt;get_right_ref());
    }
    delete(*root);
    *root=NULL;
  }
}
 
/* alternate _delete_tree */
/*
void tree::_delete_tree(tree_node ** root) {
  if(*root==NULL) {
    return;
  } else {
    if((*root)-&gt;get_left()!=NULL) {
      tree_node * left_ref=(*root)-&gt;get_left();
      _delete_tree(&amp;left_ref);
    }
    if((*root)-&gt;get_right()!=NULL) {
      tree_node * right_ref=(*root)-&gt;get_right();
      _delete_tree(&amp;right_ref);
    }
    delete(*root);
    *root=NULL;
  }
}
*/
 
void tree::mirror() {
  _mirror(root);
}
 
void tree::_mirror(tree_node * root) {
  if(root==NULL) {
    return;
  }
 
  tree_node * temp=root-&gt;get_left();
  root-&gt;set_left(root-&gt;get_right());
  root-&gt;set_right(temp);
  _mirror(root-&gt;get_left());
  _mirror(root-&gt;get_right());
}
 
void tree::print_paths(){
   int max_path_length=find_height();
   int * path_nodes=(int *)calloc(sizeof(int), max_path_length);
  _print_paths(root, path_nodes, 0);
}
 
void tree::_print_paths(tree_node * root, int * path_nodes, int next_vacant_position){
  if(root==NULL) {
    return;
  } else if(root-&gt;get_left()==NULL &amp;&amp; root-&gt;get_right()==NULL) {
    *(path_nodes+next_vacant_position)=root-&gt;get_data();
    _print_array(path_nodes, next_vacant_position);
  } else {
    *(path_nodes+next_vacant_position)=root-&gt;get_data();
    _print_paths(root-&gt;get_left(), path_nodes, next_vacant_position+1);
    _print_paths(root-&gt;get_right(), path_nodes, next_vacant_position+1);
  }
}
 
void tree::_print_array(int * array, int len) {
  int i;
  for(i=0; i&lt;=len; i++) {
    cout&lt;&lt;*(array+i)&lt;&lt;&quot; &quot;;
  }
  cout&lt;&lt;endl;
}
 
tree_node * tree::find_node(int value) {
  return _find_node(root, value);
}
 
tree_node * tree::_find_node(tree_node * root, int value) {
  if(root==NULL || root-&gt;get_data()==value) {
    return root;
  } else if(value&lt;=root-&gt;get_data()) {
    return _find_node(root-&gt;get_left(), value);
  } else {
    return _find_node(root-&gt;get_right(), value);
  }
}
 
tree_node * tree::lowest_common_ancestor(int a, int b) {
  return _lowest_common_ancestor(NULL, root, a, b);
}
 
tree_node * tree::_lowest_common_ancestor(tree_node * parent, tree_node * root, int a, int b) {
  if(root==NULL) {
    return root;
  } else if((root-&gt;get_data()==a &amp;&amp; (root-&gt;get_left()-&gt;get_data()==b || root-&gt;get_right()-&gt;get_data()==b))
             || (root-&gt;get_data()==b &amp;&amp; (root-&gt;get_left()-&gt;get_data()==a || root-&gt;get_right()-&gt;get_data()==a))) {
    return parent;
  } else if((_find_node(root-&gt;get_left(), a)!=NULL &amp;&amp; _find_node(root-&gt;get_right(), b)!=NULL)
        || (_find_node(root-&gt;get_left(), b)!=NULL &amp;&amp; _find_node(root-&gt;get_right(), a)!=NULL)) {
    return root;
  } else if(_find_node(root-&gt;get_left(), a)!=NULL &amp;&amp; _find_node(root-&gt;get_left(), b)!=NULL) {
    return _lowest_common_ancestor(root, root-&gt;get_left(), a, b);
  } else if(_find_node(root-&gt;get_right(), a)!=NULL &amp;&amp; _find_node(root-&gt;get_right(), b)!=NULL) {
    return _lowest_common_ancestor(root, root-&gt;get_right(), a, b);
  } else {
    return NULL;
  }
}
 
tree_node * tree::min_node() {
  return _min_node(root);
}
 
tree_node * tree::_min_node(tree_node * root) {
  if(root==NULL || root-&gt;get_left()==NULL) {
    return root;
  } else {
    return _min_node(root-&gt;get_left());
  }
}
 
int tree::count_leaf_nodes() {
  return _count_leaf_nodes(root);
}
 
int tree::_count_leaf_nodes(tree_node * root) {
  if(root==NULL) {
    return 0;
  } else if(root-&gt;get_left()==NULL &amp;&amp; root-&gt;get_right()==NULL) {
    return 1;
  } else {
    return _count_leaf_nodes(root-&gt;get_left())+_count_leaf_nodes(root-&gt;get_right());
  }
}
 
 
int tree::is_bst() {
  return _is_bst(root);
}
 
int tree::_is_bst(tree_node * root) {
  static tree_node * previous=NULL;
  if(root==NULL) {
    return 1;
  } else {
    if(!_is_bst(root-&gt;get_left())) {
      return 0;
    }
    if(previous!=NULL &amp;&amp; (previous-&gt;get_data())&gt;(root-&gt;get_data())) {
      return 0;
    }
    previous=root;
    if(!_is_bst(root-&gt;get_right())) {
      return 0;
    }   
  }
}
 
int tree::children_sum() {
  return _children_sum(root);
}
 
int tree::_children_sum(tree_node * root) {
  if(root==NULL) {
    return 1;
  }
  if(root-&gt;get_left()==NULL &amp;&amp; root-&gt;get_right()==NULL) {
    return 1;
  }
  else if(_children_sum(root-&gt;get_left()) &amp;&amp; _children_sum(root-&gt;get_right())){
    int left_data;
    int right_data;
    if(root-&gt;get_left()!=NULL) {
      left_data=root-&gt;get_left()-&gt;get_data();
    } else {
      left_data=0;
    }
    if(root-&gt;get_right()!=NULL) {
      right_data=root-&gt;get_right()-&gt;get_data();
    } else {
      right_data=0;
    }
 
    if(left_data+right_data==root-&gt;get_data()) {
      return 1;
    } else {
      return 0;
    }
  } else {
    return 0;
  }
}
 
void tree::ensure_children_sum() {
  _ensure_children_sum(root);
}
 
void tree::_ensure_children_sum(tree_node * root) {
  if(root==NULL || (root-&gt;get_left()==NULL &amp;&amp; root-&gt;get_right()==NULL)) {
    return;
  } else {
    _ensure_children_sum(root-&gt;get_left());
    _ensure_children_sum(root-&gt;get_right());
    int left_data;
    int right_data;
    if(root-&gt;get_left()!=NULL) {
      left_data=root-&gt;get_left()-&gt;get_data();
    } else {
      left_data=0;
    }
    if(root-&gt;get_right()!=NULL) {
      right_data=root-&gt;get_right()-&gt;get_data();
    } else {
      right_data=0;
    }
    root-&gt;set_data(left_data+right_data);
  }
}
 
int tree::diameter() {
  return _diameter(root);
}
 
int tree::_diameter(tree_node * root) {
  if(root==NULL) {
    return 0;
  } else {
    return max(_find_height(root-&gt;get_left())+_find_height(root-&gt;get_right())+1, max(_diameter(root-&gt;get_left()), _diameter(root-&gt;get_left())));
  }
}
 
int tree::is_height_balanced() {
  return _is_height_balanced(root);
}
 
int tree::_is_height_balanced(tree_node * root) {
  if(root==NULL) {
    return 1;
  } else {
    int left_height=_find_height(root-&gt;get_left());
    int right_height=_find_height(root-&gt;get_right());
    if(abs(left_height-right_height)&lt;=1 &amp;&amp; _is_height_balanced(root-&gt;get_left()) &amp;&amp; _is_height_balanced(root-&gt;get_left())) {
      return 1;
    } else {
      return 0;
    }
  }
}
 
int tree::leaf_path_sum(int sum) {
  return _leaf_path_sum(root, sum);
}
 
int tree::_leaf_path_sum(tree_node * root, int sum) {
  if(root==NULL) {
    return 0;
  } else if(root-&gt;get_data()==sum &amp;&amp; root-&gt;get_left()==NULL &amp;&amp; root-&gt;get_right()==NULL) {
    return 1;
  } else {
    return _leaf_path_sum(root-&gt;get_left(), sum-root-&gt;get_data()) || _leaf_path_sum(root-&gt;get_right(), sum-root-&gt;get_data());
  }
}
 
void tree::double_tree() {
  _double_tree(root);
}
 
void tree::_double_tree(tree_node * root) {
  if(root==NULL) {
    return;
  } else {
    tree_node * new_node=new tree_node;
    new_node-&gt;set_data(root-&gt;get_data());
    tree_node * root_left=root-&gt;get_left();
    root-&gt;set_left(new_node);
    new_node-&gt;set_left(root_left);
    _double_tree(root_left);
    _double_tree(root-&gt;get_right());
  }
}
 
int tree::width() {
  int height=find_height();
  return _width(root, height, 0, 1);
}
 
int tree::_width(tree_node * root, int height, int level, int initialize_width_array) {
  static int width[]={0};
  if(initialize_width_array==1) {
    int i;
    for(i=0; i&lt;height; i++) {
      width[i]=0; 
    }
  }
  if(root==NULL) {
    width[level]=width[level]+0;
  } else {
    width[level]=width[level]+1;
    _width(root-&gt;get_left(), height, level+1, 0);
    _width(root-&gt;get_right(), height, level+1, 0);
  }
  return _maximum(width, height);
}
 
int tree::_maximum(int array[], int len) {
  int i;
  int max=array[0];
  for(i=1; i&lt;len; i++) {
    if(array[i]&gt;max) {
      max=array[i];
    }
  }
  return max;
}
 
void tree::print_k_distance_nodes(int k) {
  _print_k_distance_nodes(root, k, 0);
  cout&lt;&lt;endl;
}
 
void tree::_print_k_distance_nodes(tree_node * root, int k, int distance) {
  if(root==NULL) {
    return;
  } else if(distance==k) {
    cout&lt;&lt;root-&gt;get_data()&lt;&lt;&quot; &quot;;
  } else {
    _print_k_distance_nodes(root-&gt;get_left(), k, distance+1);
    _print_k_distance_nodes(root-&gt;get_right(), k, distance+1);
  }
}
 
tree_node * tree::kth_smallest_element(int k) {
  return _kth_smallest_element(root, k);
}
 
tree_node * tree::_kth_smallest_element(tree_node * root, int k) {
  if(root==NULL) {
    return root;
  } else {
    int left_size=_find_size(root-&gt;get_left());
    if(left_size==k-1) {
      return root;
    } else if(left_size&gt;=k) {
      return _kth_smallest_element(root-&gt;get_left(), k);
    } else {
      return _kth_smallest_element(root-&gt;get_right(), k-left_size-1);
    }
  }
}

int tree::get_level(int key) {
  return _get_level(root, key, 1);
}

int tree::_get_level(tree_node * root, int key, int level) {
  if(root==NULL) {
      return 0;
  } else if(root-&gt;get_data()==key) {
      return level;
  }
  else {
          return _get_level(root-&gt;get_left(), key, level+1)+_get_level(root-&gt;get_right(), key, level+1);
  }
}

void tree::print_ancestors(int key){
    _print_ancestors(root, key);
    cout&lt;&lt;endl;
}
    
int tree::_print_ancestors(tree_node * root, int key) {
    if(root==NULL) {
        return 0;
    } else if(root-&gt;get_data()==key) {
      return 1;
    } else {
        if(_print_ancestors(root-&gt;get_left(), key) || _print_ancestors(root-&gt;get_right(), key)) {
            cout&lt;&lt;root-&gt;get_data()&lt;&lt;&quot; &quot;;
            return 1;
        }
    }
}

void tree::print_keys_in_range(int r1, int r2) {
    _print_keys_in_range(root, r1, r2);
    cout&lt;&lt;endl;
}

void tree::_print_keys_in_range(tree_node * root, int r1, int r2) {
    if(root==NULL) {
        return;
    }
    if(root-&gt;get_left()!=NULL) {
        _print_keys_in_range(root-&gt;get_left(), r1, r2);
    }
    if(root-&gt;get_data()&gt;=r1 &amp;&amp; root-&gt;get_data()&lt;=r2) {
        cout&lt;&lt;root-&gt;get_data()&lt;&lt;&quot; &quot;;
    }
    if(root-&gt;get_right()!=NULL) {
        _print_keys_in_range(root-&gt;get_right(), r1, r2);
    }
}

int tree::is_sum_tree() {
    return _is_sum_tree(root);
}

int tree::_is_sum_tree(tree_node * root) {
  if(root==NULL) {
    return 1;
  }
  tree_node * left=root-&gt;get_left();
  tree_node * right=root-&gt;get_right();
  if(left==NULL &amp;&amp; right==NULL) {
      return 1;
  }
  int left_value;
  int right_value;
  if(left==NULL) {
    left_value=0; 
  } else {
    left_value=left-&gt;get_data();
  }
  if(right==NULL) {
    right_value=0; 
  } else {
    right_value=right-&gt;get_data();
  }
  if(left_value+right_value!=root-&gt;get_data() || !_is_sum_tree(left) || !_is_sum_tree(right)) {
      return 0;
  } else {
      return 1;
  }
}

int main() {
  tree t1;
 
  t1.recursive_insert(20);
  t1.recursive_insert(10);
  t1.insert(30);
  t1.insert(8);
  t1.recursive_insert(12);
  t1.recursive_insert(28);
  t1.recursive_insert(32);
  t1.recursive_insert(6);
  t1.recursive_insert(9);
  t1.recursive_insert(50);
  t1.insert(14);
  t1.insert(26);
 
  t1.print_inorder();
 
  if(t1.is_sum_tree()) {
      cout&lt;&lt;&quot;Sum tree!&quot;&lt;&lt;endl;
  } else {
      cout&lt;&lt;&quot;Not a sum tree!&quot;&lt;&lt;endl;
  }
  
  tree t2;
 
  t2.recursive_insert(20);
  t2.recursive_insert(20);
  
  t2.print_inorder();
 
  if(t2.is_sum_tree()) {
      cout&lt;&lt;&quot;Sum tree!&quot;&lt;&lt;endl;
  } else {
      cout&lt;&lt;&quot;Not a sum tree!&quot;&lt;&lt;endl;
  }
  
  return 0;
}
</code> </pre>
<p>6 8 9 10 12 14 20 26 28 30 32 50<br />
Not a sum tree!<br />
20 20<br />
Sum tree!</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-17897">
        <div id="dsq-comment-header-17897" class="dsq-comment-header">
            <cite id="dsq-cite-17897">
                <span id="dsq-author-user-17897">Sreenivas Doosa</span>
            </cite>
        </div>
        <div id="dsq-comment-body-17897" class="dsq-comment-body">
            <div id="dsq-comment-message-17897" class="dsq-comment-message"><p>Please check this simple one. Works in O(n). Please correct if anything wrong with this.</p>
<pre> <code language="C">

bool isSumTree(struct node* root, int* sum)
{
  if(root == NULL)
  {
    *sum = 0;
    return true;
  }

  int leftSum, rightSum;

  isSumTree(root-&gt;left, &amp;leftSum);
  isSumTree(root-&gt;right, &amp;rightSum);

  *sum = leftSum + rightSum + root-&gt;data;

  if(leftSum + rightSum == root-&gt;data)
    return true;
  else
    return false;
}

</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-19695">
        <div id="dsq-comment-header-19695" class="dsq-comment-header">
            <cite id="dsq-cite-19695">
                <span id="dsq-author-user-19695">Akhil</span>
            </cite>
        </div>
        <div id="dsq-comment-body-19695" class="dsq-comment-body">
            <div id="dsq-comment-message-19695" class="dsq-comment-message"><p>Changing the function prototype is usually undesirable.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-16687">
        <div id="dsq-comment-header-16687" class="dsq-comment-header">
            <cite id="dsq-cite-16687">
                <span id="dsq-author-user-16687">rohit</span>
            </cite>
        </div>
        <div id="dsq-comment-body-16687" class="dsq-comment-body">
            <div id="dsq-comment-message-16687" class="dsq-comment-message"><p>int sumtree(struct node *root,int *fl)<br />
{<br />
int p1=0,p2=0;<br />
if((root-&gt;left==NULL)&amp;&amp;(root-&gt;right==NULL))<br />
return(root-&gt;data);<br />
if(root-&gt;left!=NULL)<br />
p1=sumtree(root-&gt;left,fl);<br />
if(root-&gt;right!=NULL)<br />
p2=sumtree(root-&gt;right,fl);<br />
if(root-&gt;data==p1+p2)<br />
return(root-&gt;data+p1+p2);<br />
else *fl=1;<br />
}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-14579">
        <div id="dsq-comment-header-14579" class="dsq-comment-header">
            <cite id="dsq-cite-14579">
                <span id="dsq-author-user-14579">anand</span>
            </cite>
        </div>
        <div id="dsq-comment-body-14579" class="dsq-comment-body">
            <div id="dsq-comment-message-14579" class="dsq-comment-message"><p>public class CheckIfGivenBTisST {</p>
<p>	public static void main(String[] args){<br />
		Node root = new Node(46);<br />
		root.left = new Node(10);<br />
		root.right = new Node(13);<br />
		root.left.left = new Node(4);<br />
		root.left.right = new Node(6);<br />
		root.right.right = new Node(3);<br />
		root.right.left = new Node(5);<br />
		root.right.left.left = new Node(5);</p>
<p>		System.out.println(getSumTree(root)!= -1);<br />
	}</p>
<p>	private static int getSumTree(Node root) {<br />
		if(root == null)<br />
			return 0;<br />
		else{<br />
			int lt = getSumTree(root.left);<br />
			int rt = getSumTree(root.right);</p>
<p>			if(root.left == null &amp;&amp; root.right == null)<br />
				return 0;<br />
			else if(lt == -1 || rt == -1)<br />
				return -1;<br />
			else{<br />
				if(root.data == lt + rt+ (root.left!=null?root.left.data:0) + (root.right!=null?root.right.data:0)){<br />
					return root.data;<br />
				}else{<br />
					return -1;<br />
				}<br />
			}<br />
		}<br />
	}<br />
}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-11570">
        <div id="dsq-comment-header-11570" class="dsq-comment-header">
            <cite id="dsq-cite-11570">
                <span id="dsq-author-user-11570">Manish Dipankar</span>
            </cite>
        </div>
        <div id="dsq-comment-body-11570" class="dsq-comment-body">
            <div id="dsq-comment-message-11570" class="dsq-comment-message"><pre> <code language="C">

int issumtree(struct node* root)
{
	if(root == NULL)
		return 1;
	if(root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL)
		return 1;
	else if((root-&gt;left != NULL &amp;&amp; root-&gt;right !=NULL))
	{
	if((root-&gt;data == root-&gt;left-&gt;data + root-&gt;right-&gt;data) &amp;&amp;
			issumtree(root-&gt;left) &amp;&amp;
			issumtree(root-&gt;right))
		return 1;
	else 
		return 0;
	}
}
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-10500">
        <div id="dsq-comment-header-10500" class="dsq-comment-header">
            <cite id="dsq-cite-10500">
                <span id="dsq-author-user-10500">Gaurav</span>
            </cite>
        </div>
        <div id="dsq-comment-body-10500" class="dsq-comment-body">
            <div id="dsq-comment-message-10500" class="dsq-comment-message"><p>int SumTree(struct node *p){<br />
int temp=0;<br />
if(p!=NULL){<br />
	if(p-&gt;left==NULL &amp;&amp; p-&gt;right==NULL)<br />
		return p-&gt;data;<br />
	if(p-&gt;data==(temp=SumTree(p-&gt;left)+SumTree(p-&gt;right)))<br />
		return 2*temp;<br />
	return -1;  // Not a SumTree<br />
	}<br />
return 0;<br />
}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-6100">
        <div id="dsq-comment-header-6100" class="dsq-comment-header">
            <cite id="dsq-cite-6100">
                <span id="dsq-author-user-6100">sandesh</span>
            </cite>
        </div>
        <div id="dsq-comment-body-6100" class="dsq-comment-body">
            <div id="dsq-comment-message-6100" class="dsq-comment-message"><p>Take preorder of the tree and except first element take the sum of remaining and check whether it is same or not.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-6879">
        <div id="dsq-comment-header-6879" class="dsq-comment-header">
            <cite id="dsq-cite-6879">
                <span id="dsq-author-user-6879">rahul</span>
            </cite>
        </div>
        <div id="dsq-comment-body-6879" class="dsq-comment-body">
            <div id="dsq-comment-message-6879" class="dsq-comment-message"><p>will your idea work if the preorder traversal of the tree is 26 10 4 5 4 3?</p>
<p>regards!!</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-5121">
        <div id="dsq-comment-header-5121" class="dsq-comment-header">
            <cite id="dsq-cite-5121">
                <span id="dsq-author-user-5121">ayan_2587</span>
            </cite>
        </div>
        <div id="dsq-comment-body-5121" class="dsq-comment-body">
            <div id="dsq-comment-message-5121" class="dsq-comment-message"><p>Just do a Breadth first traversal, and as you pass the node, check if the root value is equal to sum of the left and the right child.<br />
In case of leaf nodes, the root value itself would be the sum.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-4980">
        <div id="dsq-comment-header-4980" class="dsq-comment-header">
            <cite id="dsq-cite-4980">
http://www.crazylearner.com/                <span id="dsq-author-user-4980">student</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4980" class="dsq-comment-body">
            <div id="dsq-comment-message-4980" class="dsq-comment-message"><p>what about this solution?</p>
<pre> <code language="C">
int checksumtree(struct node *t){
if (t &amp;&amp; !(t-&gt;right) &amp;&amp; !(t-&gt;left))
return t-&gt;data;
if (!t)
return 0;


if(t-&gt;data==(checksumtree(t-&gt;left)) + (checksumtree(t-&gt;right)))
        return 2*t-&gt;data;
        else
        return 0;

}
int main(){

/*
* Initialization 
*/
if (checksumtree(t))

cout&lt;&lt;&quot;TRUE&quot;;

else

cout&lt;&lt;&quot;FALSE&quot;;

} 
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-4769">
        <div id="dsq-comment-header-4769" class="dsq-comment-header">
            <cite id="dsq-cite-4769">
                <span id="dsq-author-user-4769">Bala</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4769" class="dsq-comment-body">
            <div id="dsq-comment-message-4769" class="dsq-comment-message"><pre> <code language="C">

/* 
   Algorithm:
   1) Use bottom up approach
   2) Get the sum of root's sub trees and compare with root value
   3) Handle the base conditions
*/

int isSumTree(sturct node *root)
{
    int sum = 0;
    return(isSumTreeHelper(root, &amp;sum));
}

int isSumTreeHelper(struct node *root, int *sum)
{
    int left_tree_sum = 0, right_tree_sum = 0;
    int is_left = 0, is_right = 0;
    
    // base conditions
    if (NULL == root) {
//     *sum = *sum + 0; // do you need this :) , well, it's not required ..
     return (1); // return SUCCESS
    }
    
    if ((NULL == root-&gt;left) &amp;&amp; (NULL == root-&gt;right)) {// if it is a leaf node
       *sum = *sum + (root-&gt;data);
       return (1);
    }
    
    is_left = isSumTreeHelper(root-&gt;left, &amp;left_tree_sum);
    
    is_right = isSumTreeHelper(root-&gt;right, &amp;right_tree_sum);
       
    *sum = left_tree_sum + root-&gt;data + right_tree_sum;
    
    return (is_left &amp;&amp; is_right &amp;&amp; (root-&gt;data == left_tree_sum + right_tree_sum));                      
             
}

/*
 * if left sub tree is not a sum tree, do we need to validate the right sub tree?
 * Well, it's not required, we can avoid the right sub tree validation. The below change does the same.
 *
 */
 
  if (is_left) {  
    is_right = isSumTreeHelper(root-&gt;right, &amp;right_tree_sum);
  }
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-4766">
        <div id="dsq-comment-header-4766" class="dsq-comment-header">
            <cite id="dsq-cite-4766">
                <span id="dsq-author-user-4766">Ankur</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4766" class="dsq-comment-body">
            <div id="dsq-comment-message-4766" class="dsq-comment-message"><p>Another O(n) solution</p>
<p>int checkSumTree(struct node* root){<br />
	int sum ;<br />
	if(root == NULL || isLeaf(root) ){<br />
		return 1;<br />
	}</p>
<p>	 if(checkSumTree(root-&gt;left) &amp;&amp; checkSumTree(root-&gt;right)){<br />
		if(root-&gt;left!=NULL &amp;&amp; root-&gt;right!=NULL){<br />
			sum = root-&gt;data &#8211; root-&gt;left-&gt;data &#8211; root-&gt;right-&gt;data;<br />
		}<br />
		if(root-&gt;left!=NULL &amp;&amp; root-&gt;right==NULL){<br />
			sum = root-&gt;data &#8211; root-&gt;left-&gt;data;<br />
		}<br />
		if(root-&gt;left==NULL &amp;&amp; root-&gt;right!=NULL){<br />
			sum = root-&gt;data &#8211; root-&gt;right-&gt;data ;<br />
		}<br />
		if(sum ==0){<br />
			return 1;<br />
		}<br />
		else{<br />
			return 0;<br />
	    }<br />
		return 1;<br />
     }<br />
     else<br />
        return 0;<br />
}
<pre> <code language="C"></code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-4765">
        <div id="dsq-comment-header-4765" class="dsq-comment-header">
            <cite id="dsq-cite-4765">
                <span id="dsq-author-user-4765">Ankur</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4765" class="dsq-comment-body">
            <div id="dsq-comment-message-4765" class="dsq-comment-message"><p>Another solution in O(n) </p>
<p>int checkSumTree(struct node* root){<br />
	int sum ;<br />
	if(root == NULL || isLeaf(root) ){<br />
		return 1;<br />
	}</p>
<p>	 if(checkSumTree(root-&gt;left) &amp;&amp; checkSumTree(root-&gt;right)){<br />
		if(root-&gt;left!=NULL &amp;&amp; root-&gt;right!=NULL){<br />
			sum = root-&gt;data &#8211; root-&gt;left-&gt;data &#8211; root-&gt;right-&gt;data;<br />
		}<br />
		if(root-&gt;left!=NULL &amp;&amp; root-&gt;right==NULL){<br />
			sum = root-&gt;data &#8211; root-&gt;left-&gt;data;<br />
		}<br />
		if(root-&gt;left==NULL &amp;&amp; root-&gt;right!=NULL){<br />
			sum = root-&gt;data &#8211; root-&gt;right-&gt;data ;<br />
		}<br />
		if(sum ==0){<br />
			return 1;<br />
		}<br />
		else{<br />
			return 0;<br />
	    }<br />
		return 1;<br />
     }<br />
     else<br />
        return 0;<br />
}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-red odd alt thread-odd thread-alt depth-1" id="dsq-comment-4662">
        <div id="dsq-comment-header-4662" class="dsq-comment-header">
            <cite id="dsq-cite-4662">
                <span id="dsq-author-user-4662">red</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4662" class="dsq-comment-body">
            <div id="dsq-comment-message-4662" class="dsq-comment-message"><p>just traverse the tree in postorder and the call to the left subtree and the right subtree return the respective sum of the values in the left and right subtrees.<br />
compare this value with the current node. whenever the value doesnt match break and print &#8216;is not a sum tree&#8217;.<br />
else print is a sum tree.<br />
takes O(n)</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-2" id="dsq-comment-4876">
        <div id="dsq-comment-header-4876" class="dsq-comment-header">
            <cite id="dsq-cite-4876">
                <span id="dsq-author-user-4876">mitul</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4876" class="dsq-comment-body">
            <div id="dsq-comment-message-4876" class="dsq-comment-message"><p>that&#8217;s what the second solution is doing &#8230;<br />
take a good look returning sum=2*(node-&gt;data) is same as adding sum to the node-&gt;data value..!!<br />
there&#8217;s isn&#8217;t any flaw in yr comment but the approach is already suggested</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-4414">
        <div id="dsq-comment-header-4414" class="dsq-comment-header">
            <cite id="dsq-cite-4414">
http://www.tanmayonrun.blogspot.com                <span id="dsq-author-user-4414">Tanmay Chakrabarty</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4414" class="dsq-comment-body">
            <div id="dsq-comment-message-4414" class="dsq-comment-message"><p>Hi. I solved the problem with a little limitation. I used my own depth first search method to find out the sum. You can visit it in the following link</p>
<p><a href="http://tanmayonrun.blogspot.com/2011/06/binary-tree-is-sum-tree-or-not.html" rel="nofollow">Computer Programming: Binary Tree is Sum tree or Not</a></p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-baskin even thread-odd thread-alt depth-1" id="dsq-comment-4146">
        <div id="dsq-comment-header-4146" class="dsq-comment-header">
            <cite id="dsq-cite-4146">
                <span id="dsq-author-user-4146">baskin</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4146" class="dsq-comment-body">
            <div id="dsq-comment-message-4146" class="dsq-comment-message"><p>How about this?</p>
<p>// Inner class<br />
class Result {<br />
    private boolean isSumTree;<br />
    private int subTreeSum;<br />
}</p>
<p>public static Result sumTree(Node node) {<br />
    if (node == null{<br />
        return new Result(true, 0);<br />
    }<br />
    if (node.left == null &amp;&amp; node.right == null) {<br />
        return new Result(true, node.data);<br />
    }<br />
    Result lr = sumTree(node.left);  // result for left subtree<br />
    Result rr = sumTree(node.right); // result for right subtree<br />
    return new Result( lr.isSumTree &amp;&amp; rr.isSumTree &amp;&amp;<br />
                 (node.data == lr.subTreeSum + rr.subTreeSum),<br />
                 node.data + lr.subTreeSum + rr.subTreeSum);<br />
}</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-baskin odd alt depth-2" id="dsq-comment-4147">
        <div id="dsq-comment-header-4147" class="dsq-comment-header">
            <cite id="dsq-cite-4147">
                <span id="dsq-author-user-4147">baskin</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4147" class="dsq-comment-body">
            <div id="dsq-comment-message-4147" class="dsq-comment-message"><p>How do i edit the update.<br />
Correction:<br />
&lt;&gt; return new Result(return lr.isSumTree &amp;&amp; rr.isSumTree &amp;&amp; (node.data == lr.subTreeSum + rr.subTreeSum), node.data + lr.subTreeSum + rr.subTreeSum);</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-geeksforgeeks even depth-3" id="dsq-comment-4149">
        <div id="dsq-comment-header-4149" class="dsq-comment-header">
            <cite id="dsq-cite-4149">
                <span id="dsq-author-user-4149">GeeksforGeeks</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4149" class="dsq-comment-body">
            <div id="dsq-comment-message-4149" class="dsq-comment-message"><p>@baskin:  Modification by users is currently not supported. We have modified your originial comment with the suggested change. Please let us know if the modified code looks fine.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-baskin odd alt depth-4" id="dsq-comment-4150">
        <div id="dsq-comment-header-4150" class="dsq-comment-header">
            <cite id="dsq-cite-4150">
                <span id="dsq-author-user-4150">baskin</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4150" class="dsq-comment-body">
            <div id="dsq-comment-message-4150" class="dsq-comment-message"><p>Looks fine. nitpicking warning: indentation can be improved though.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-4113">
        <div id="dsq-comment-header-4113" class="dsq-comment-header">
            <cite id="dsq-cite-4113">
http://shashank7s.blogspot.com                <span id="dsq-author-user-4113">WgpShashank</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4113" class="dsq-comment-body">
            <div id="dsq-comment-message-4113" class="dsq-comment-message"><pre> <code language="C">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
 
/* A binary tree node has data, pointer to left child
   and a pointer to right child */
struct node
{
     int data;
     struct node* left;
     struct node* right;
};
 
/* Helper function that allocates a new node with the
   given data and NULL left and right pointers. */
struct node* newNode(int data)
{
     struct node* node = (struct node*)
                                  malloc(sizeof(struct node));
     node-&gt;data = data;
     node-&gt;left = NULL;
     node-&gt;right = NULL;
 
     return(node);
}
 
 
struct node* sumSubTree(struct node** root)
{
int LeftOld,RightOld;
struct node *l,*r;
if((*root) == NULL || ((*root) -&gt; left== NULL &amp;&amp; (*root)-&gt;right == NULL))
return NULL;
else
{
LeftOld = (*root)-&gt;left-&gt;data;
RightOld = (*root)-&gt;right-&gt;data;
l = sumSubTree(&amp;(*root )-&gt;left);
r = sumSubTree(&amp;(*root)-&gt;right);
(*root)-&gt;data = LeftOld + RightOld;
if(!l)
(*root)-&gt;data += l-&gt;data;
if(!r)
(*root)-&gt;data += r-&gt;data;
return *root;
}
 
}
 
/* Given a binary tree, print its nodes in inorder*/
void printPreorder(struct node* node)
{
     if (node == NULL)
          return;
 
     /* first print data of node */
     printf(&quot;%d &quot;, node-&gt;data); 
 
     /* then recur on left sutree */
     printPreorder(node-&gt;left); 
 
     /* now recur on right subtree */
     printPreorder(node-&gt;right);
}   
 
int main()
{
     struct node *root  = newNode(1);
     root-&gt;left             = newNode(2);
     root-&gt;right           = newNode(3);
     root-&gt;left-&gt;left     = newNode(4);
     root-&gt;left-&gt;right   = newNode(5);
 
     root=sumSubTree(&amp;root);
 
     printf(&quot;\n Preorder traversal of binary tree is \n&quot;);
     printPreorder(root);
 
     
 
     getchar();
     return 0;
}
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-4114">
        <div id="dsq-comment-header-4114" class="dsq-comment-header">
            <cite id="dsq-cite-4114">
http://shashank7s.blogspot.com                <span id="dsq-author-user-4114">WgpShashank</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4114" class="dsq-comment-body">
            <div id="dsq-comment-message-4114" class="dsq-comment-message"><p>My Code  is extended version of above program..in above we are only checking whether given tree is sumtree or not ..but my program is converting given tree into its sumTree so basically its replacing root node value with sum of it &#8220;left &amp; right subtree&#8221; its completely new program. </p>
<p>GeeksForGeeks Please Post it as Separate Post..</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-4027">
        <div id="dsq-comment-header-4027" class="dsq-comment-header">
            <cite id="dsq-cite-4027">
                <span id="dsq-author-user-4027">Vishakha</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4027" class="dsq-comment-body">
            <div id="dsq-comment-message-4027" class="dsq-comment-message"><p>Wouldn&#8217;t this be an easy one?</p>
<pre> <code language="C">
int hasPathSum(struct node* node, int sum) {
  // return true if we run out of tree and sum==0
  if (node == NULL) {
    return(sum == 0);
  }
  else {
    // otherwise check both subtrees
    int subSum = sum - node-&gt;data;
    return(hasPathSum(node-&gt;left, subSum) ||
           hasPathSum(node-&gt;right, subSum));
  }
}
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-sandeep bypostauthor odd alt depth-2" id="dsq-comment-4029">
        <div id="dsq-comment-header-4029" class="dsq-comment-header">
            <cite id="dsq-cite-4029">
                <span id="dsq-author-user-4029">Sandeep</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4029" class="dsq-comment-body">
            <div id="dsq-comment-message-4029" class="dsq-comment-message"><p>@Vishakha: Please take a closer look at the problem.  The solution given by you doesn&#8217;t work for this, it is for a differnt problem.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-4021">
        <div id="dsq-comment-header-4021" class="dsq-comment-header">
            <cite id="dsq-cite-4021">
                <span id="dsq-author-user-4021">Ankit</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4021" class="dsq-comment-body">
            <div id="dsq-comment-message-4021" class="dsq-comment-message"><p>Solution using recursion : </p>
<pre> <code language="C">
void SubTreeSum(Treenode *ptr, int *Sum)
{

	if(ptr-&gt;left!=null)
	{ 
		SubTreeSum(ptr-&gt;left, Sum);		
	}

	if(ptr-&gt;right!=null)
	{ 
		SubTreeSum(ptr-&gt;right, Sum);
	}
	Sum+= [ptr].Value;     
}

bool IsSumTree(TreeNode *root, int * Sum)
{
	if(root-&gt;left != null)
	{
		if(SubTreeSum(root-&gt;left, Sum)!=[root-&gt;left].Value)
			return false;
		else 
			Sum += [root-&gt;left].Value;
	}
	if(root-&gt;right != null)
	{
		if(SubTreeSum(root-&gt;right, Sum)!=[root-&gt;right].Value)
			return false;
		else
			Sum += [root-&gt;right].Value;
	}
	if(root.Value==Sum)
		return true;
	else 
		return false;
}

void main()
{
	bool isSumTree= isSumTree(root, 0);
}
</code> </pre>
<p>It will ensure if the subtree itself is not Sum Tree, will immediately return false;</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-adityaork odd alt thread-odd thread-alt depth-1" id="dsq-comment-4000">
        <div id="dsq-comment-header-4000" class="dsq-comment-header">
            <cite id="dsq-cite-4000">
                <span id="dsq-author-user-4000">adityaork</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4000" class="dsq-comment-body">
            <div id="dsq-comment-message-4000" class="dsq-comment-message"><p>it can done easily in O(n) using recursive calls to left and right subtree </p>
<pre> <code language="C">
int sum(tree * t)
{
if(t==NULL) return 0;
if(leaf(t))
  return t-&gt;value;
int ls=sum(t-&gt;left),rs=sum(t-&gt;right);
if(ls==-1 || rs==-1 || t!=ls+rs) return -1;
else if(t-&gt;value==ls+rs) return 2*t-&gt;value;
}</code> </pre>
<p>if sum return -1 then its not a sumtree<br />
else it is</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-2" id="dsq-comment-14830">
        <div id="dsq-comment-header-14830" class="dsq-comment-header">
            <cite id="dsq-cite-14830">
                <span id="dsq-author-user-14830">vasu</span>
            </cite>
        </div>
        <div id="dsq-comment-body-14830" class="dsq-comment-body">
            <div id="dsq-comment-message-14830" class="dsq-comment-message"><p>This logic does not work if the binary tree has -1 as the node value itself</p>
<p>      4<br />
   3      -1<br />
3      -1</p>
<p>This logic would return false whereas this is a sum tree</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-3996">
        <div id="dsq-comment-header-3996" class="dsq-comment-header">
            <cite id="dsq-cite-3996">
                <span id="dsq-author-user-3996">Jim</span>
            </cite>
        </div>
        <div id="dsq-comment-body-3996" class="dsq-comment-body">
            <div id="dsq-comment-message-3996" class="dsq-comment-message"><p>How about use a pointer to return the sum of the current node, and its left and right subtrees besides the return value of isSumTree()?<br />
For example, we declare int isSumTree(struct node* node, int *Sum)? Is it prohibited? If it is allowed, we don&#8217;t need the Sum() method in method 1.</p>
</div>
        </div>

    </li><!-- #comment-## -->
            </ul>


        </div>

    </div>

<script type="text/javascript">
var disqus_url = 'http://www.geeksforgeeks.org/check-if-a-given-binary-tree-is-sumtree/';
var disqus_identifier = '12186 http://geeksforgeeks.org/?p=12186';
var disqus_container_id = 'disqus_thread';
var disqus_shortname = 'geeksforgeeks';
var disqus_title = "Check if a given Binary Tree is SumTree";
var disqus_config_custom = window.disqus_config;
var disqus_config = function () {
    /*
    All currently supported events:
    onReady: fires when everything is ready,
    onNewComment: fires when a new comment is posted,
    onIdentify: fires when user is authenticated
    */
    
    
    this.language = '';
    
    if (disqus_config_custom) {
        disqus_config_custom.call(this);
    }
};

(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>

			</div>
	
					
			
			

		</div> <!-- end post -->	

<br></br>
	
</div> <!-- end content -->

<ul id="sidebar">
	<li id="text-19" class="widget widget_text">			<div class="textwidget"><script>
  (function() {
    var cx = '009682134359037907028:tj6eafkv_be';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//www.google.com/cse/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>

<style type="text/css">
  .gsc-control-cse {
    font-family: "Trebuchet MS", sans-serif;
    border-color: #E1F3DA;
    background-color: #E1F3DA;
  }
  input.gsc-input {
    border-color: #94CC7A;
  }
  input.gsc-search-button {
    border-color: #94CC7A;
    background-color: #AADA92;
  }
  .gsc-tabHeader.gsc-tabhInactive {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gsc-tabHeader.gsc-tabhActive {
    border-color: #A9DA92;
    background-color: #A9DA92;
  }
  .gsc-tabsArea {
    border-color: #A9DA92;
  }
  .gsc-webResult.gsc-result {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gsc-webResult.gsc-result:hover {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gs-webResult.gs-result a.gs-title:link,
  .gs-webResult.gs-result a.gs-title:link b {
    color: #009900;
  }
  .gs-webResult.gs-result a.gs-title:visited,
  .gs-webResult.gs-result a.gs-title:visited b {
    color: #009900;
  }
  .gs-webResult.gs-result a.gs-title:hover,
  .gs-webResult.gs-result a.gs-title:hover b {
    color: #003300;
  }
  .gs-webResult.gs-result a.gs-title:active,
  .gs-webResult.gs-result a.gs-title:active b {
    color: #009900;
  }
  .gsc-cursor-page {
    color: #009900;
  }
  a.gsc-trailing-more-results:link {
    color: #009900;
  }
  .gs-webResult.gs-result .gs-snippet {
    color: #454545;
  }
  .gs-webResult.gs-result .gs-visibleUrl {
    color: #33cc00;
  }
  .gs-webResult.gs-result .gs-visibleUrl-short {
    color: #33cc00;
  }
  .gs-webResult.gs-result .gs-visibleUrl-short {
    display: none;
  }
  .gs-webResult.gs-result .gs-visibleUrl-long {
    display: block;
  }
  .gsc-cursor-box {
    border-color: #A9DA92;
  }
  .gsc-results .gsc-cursor-page {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gsc-results .gsc-cursor-page.gsc-cursor-current-page {
    border-color: #A9DA92;
    background-color: #A9DA92;
  }
  .gs-promotion.gs-result {
    border-color: #94CC7A;
    background-color: #CBE8B4;
  }
  .gs-promotion.gs-result a.gs-title:link {
    color: #0066CC;
  }
  .gs-promotion.gs-result a.gs-title:visited {
    color: #0066CC;
  }
  .gs-promotion.gs-result a.gs-title:hover {
    color: #0066CC;
  }
  .gs-promotion.gs-result a.gs-title:active {
    color: #0066CC;
  }
  .gs-promotion.gs-result .gs-snippet {
    color: #454545;
  }
  .gs-promotion.gs-result .gs-visibleUrl,
  .gs-promotion.gs-result .gs-visibleUrl-short {
    color: #815FA7;
  }
</style>    </div>
		</li>
<li id="text-9" class="widget widget_text">			<div class="textwidget"><div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=138031159685820";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>

<div class="fb-like-box" data-href="https://www.facebook.com/pages/GeeksforGeeks/316764689022" data-width="250" data-height="170" data-colorscheme="light" data-show-faces="true" data-header="false" data-stream="false" data-show-border="false"></div></div>
		</li>
<li id="text-18" class="widget widget_text">			<div class="textwidget"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LargeRectangleSide -->
<ins class="adsbygoogle"
     style="display:inline-block;width:336px;height:280px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="1884636833"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
		</li>
<li id="text-13" class="widget widget_text">			<div class="textwidget"><ul><li><a href="http://www.geeksforgeeks.org/category/interview-experiences/">Interview Experiences</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/advance-data-structures">Advanced Data Structures</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/dynamic-programming">Dynamic Programming</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/Greedy-Algorithm/">Greedy Algorithms</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/backtracking">Backtracking</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/pattern-searching">Pattern Searching</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/divide-and-conquer">Divide & Conquer</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/MathematicalAlgo">Mathematical Algorithms</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/recursion">Recursion</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/geometric-algorithms/">Geometric Algorithms</a></li>
</ul></div>
		</li>
<li id="text-17" class="widget widget_text">			<div class="textwidget"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big 300x600 Sidebar -->
<ins class="adsbygoogle"
     style="display:inline-block;width:300px;height:600px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="4402736037"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
		</li>
<li id="text-14" class="widget widget_text"><h2 class="widgettitle">Popular Posts</h2>
			<div class="textwidget"><ul>
<li><a href="http://www.geeksforgeeks.org/write-a-c-program-to-print-all-permutations-of-a-given-string/">  All permutations of a given string </a></li>
<li><a href="http://www.geeksforgeeks.org/memory-layout-of-c-program/"> Memory Layout of C Programs</a> </li>
<li><a href="http://www.geeksforgeeks.org/understanding-extern-keyword-in-c/"> Understanding extern keyword in C</a> </li>
<li><a href="http://www.geeksforgeeks.org/median-of-two-sorted-arrays/">Median of two sorted arrays</a> </li>
<li><a href="http://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/"> Tree traversal without recursion and without stack! </a></li>
<li><a href="http://www.geeksforgeeks.org/structure-member-alignment-padding-and-data-packing/"> Structure Member Alignment, Padding and Data Packing</a> </li>
<li><a href="http://www.geeksforgeeks.org/write-a-function-to-get-the-intersection-point-of-two-linked-lists/"> Intersection point of two Linked Lists</a> </li>
<li><a href="http://www.geeksforgeeks.org/lowest-common-ancestor-in-a-binary-search-tree/"> Lowest Common Ancestor in a BST.</span></a> </li>
<li><a href="http://www.geeksforgeeks.org/a-program-to-check-if-a-binary-tree-is-bst-or-not/"> Check if a binary tree is BST or not</a> </li>
<li><a href="http://www.geeksforgeeks.org/sorted-linked-list-to-balanced-bst/"> Sorted Linked List to Balanced BST</a></li>
</ul></div>
		</li>
<li id="text-3" class="widget widget_text">			<div class="textwidget"><a href="https://twitter.com/GeeksforGeeks" class="twitter-follow-button" data-show-count="false">Follow @GeeksforGeeks</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>         


<!-- GOOGLE FEEDBURNER BUTTON-->
<a href="http://feeds.feedburner.com/Geeksforgeeks" title="Subscribe to my feed" rel="alternate" type="application/rss+xml"><img src="http://www.feedburner.com/fb/images/pub/feed-icon32x32.png" alt="" style="border:0"/></a><a href="http://feeds.feedburner.com/Geeksforgeeks" title="Subscribe to my feed" rel="alternate" type="application/rss+xml">Subscribe</a>

</div>
		</li>
<li id="text-21" class="widget widget_text"><h2 class="widgettitle">Recent Comments</h2>
			<div class="textwidget"><script type="text/javascript" src="http://geeksforgeeks.disqus.com//recent_comments_widget.js?num_items=6&hide_avatars=1&excerpt_length=50&hide_mods=0"></script></div>
		</li>
<li id="text-22" class="widget widget_text">			<div class="textwidget"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LinkAd -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:90px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="2606115235"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LinkAd -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:90px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="2606115235"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LinkAd -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:90px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="2606115235"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
		</li>

</ul>					  
		<div class="clear"></div>

		<div id="footer">
		
		    <div class="xhtml">
                        @geeksforgeeks, <a href="http://creativecommons.org/licenses/by-nc-nd/2.5/in/deed.en_US" title="Valid XHTML Strict 1.0">Some rights reserved</a>  <a href="http://www.geeksforgeeks.org/about/contact-us/"> &nbsp; &nbsp; &nbsp; &nbsp;Contact Us!</a>

		    </div>
		    
		    <div class="credits">
			  Powered by <a href="http://wordpress.org">WordPress </a> &amp; <a href="http://mootools.net/" title="Mootools JavaScript Framework">MooTools</a>, customized by geeksforgeeks team </div>
			  
		   <div class="clear"></div>						                            
		   
		</div> <!--end footer-->  
        
		        <script type="text/javascript">
        // <![CDATA[
        var disqus_shortname = 'geeksforgeeks';
        (function () {
            var nodes = document.getElementsByTagName('span');
            for (var i = 0, url; i < nodes.length; i++) {
                if (nodes[i].className.indexOf('dsq-postid') != -1) {
                    nodes[i].parentNode.setAttribute('data-disqus-identifier', nodes[i].getAttribute('rel'));
                    url = nodes[i].parentNode.href.split('#', 1);
                    if (url.length == 1) { url = url[0]; }
                    else { url = url[1]; }
                    nodes[i].parentNode.href = url + '#disqus_thread';
                }
            }
            var s = document.createElement('script'); 
            s.async = true;
            s.type = 'text/javascript';
            s.src = '//' + disqus_shortname + '.disqus.com/count.js';
            (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
        }());
        // ]]>
        </script>
        <script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/scripts/shCore.js?ver=3.0.9'></script>
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/scripts/shBrushCpp.js?ver=3.0.9'></script>
<script type='text/javascript'>
	(function(){
		var corecss = document.createElement('link');
		var themecss = document.createElement('link');
		var corecssurl = "http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/styles/shCore.css?ver=3.0.9";
		if ( corecss.setAttribute ) {
				corecss.setAttribute( "rel", "stylesheet" );
				corecss.setAttribute( "type", "text/css" );
				corecss.setAttribute( "href", corecssurl );
		} else {
				corecss.rel = "stylesheet";
				corecss.href = corecssurl;
		}
		document.getElementsByTagName("head")[0].insertBefore( corecss, document.getElementById("syntaxhighlighteranchor") );
		var themecssurl = "http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/styles/shThemeDefault.css?ver=3.0.9";
		if ( themecss.setAttribute ) {
				themecss.setAttribute( "rel", "stylesheet" );
				themecss.setAttribute( "type", "text/css" );
				themecss.setAttribute( "href", themecssurl );
		} else {
				themecss.rel = "stylesheet";
				themecss.href = themecssurl;
		}
		//document.getElementById("syntaxhighlighteranchor").appendChild(themecss);
		document.getElementsByTagName("head")[0].insertBefore( themecss, document.getElementById("syntaxhighlighteranchor") );
	})();
	SyntaxHighlighter.config.strings.expandSource = '+ expand source';
	SyntaxHighlighter.config.strings.help = '?';
	SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
	SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
	SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
	SyntaxHighlighter.defaults['gutter'] = false;
	SyntaxHighlighter.defaults['pad-line-numbers'] = true;
	SyntaxHighlighter.defaults['toolbar'] = false;
	SyntaxHighlighter.all();
</script>
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/bbpress/templates/default/js/editor.js?ver=2.5.4-5380'></script>
				  
		</div> <!--end wrapper-->
        <div id="ajaxSpinner"></div> <!--For AJAX spinner holder-->
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-12148232-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
	</body>

</html>
<!-- Dynamic page generated in 0.218 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2014-11-27 23:28:02 -->

<!-- Compression = gzip -->
<!-- super cache -->