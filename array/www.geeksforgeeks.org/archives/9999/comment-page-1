<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
       <title>Inorder Successor in Binary Search Tree - GeeksforGeeks</title>
       <style type="text/css" media="screen">
          @import url('http://d2o58evtke57tz.cloudfront.net/wp-content/themes/minimoo/style.css');
    </style>
      <link href="http://d2o58evtke57tz.cloudfront.net/wp-content/themes/minimoo/favicon.ico" rel="shortcut icon" />    
    
<!-- This site is optimized with the Yoast WordPress SEO plugin v1.7.1 - https://yoast.com/wordpress/plugins/seo/ -->
<link rel="canonical" href="http://www.geeksforgeeks.org/inorder-successor-in-binary-search-tree/" />
<meta property="og:locale" content="en_US" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Inorder Successor in Binary Search Tree - GeeksforGeeks" />
<meta property="og:description" content="In Binary Tree, Inorder successor of a node is the next node in Inorder traversal of the Binary Tree. Inorder Successor is NULL for the last node in Inoorder traversal. In Binary Search Tree, Inorder Successor of an input node can also be defined as the node with the smallest key greater than the key &hellip;" />
<meta property="og:url" content="http://www.geeksforgeeks.org/inorder-successor-in-binary-search-tree/" />
<meta property="og:site_name" content="GeeksforGeeks" />
<meta property="article:section" content="Trees" />
<meta property="article:published_time" content="2011-02-11T11:29:58+00:00" />
<meta property="article:modified_time" content="2013-05-12T12:42:54+00:00" />
<meta property="og:updated_time" content="2013-05-12T12:42:54+00:00" />
<meta property="og:image" content="http://geeksforgeeks.org/wp-content/uploads/2009/09/BST_LCA.gif" />
<!-- / Yoast WordPress SEO plugin. -->

<link rel='stylesheet' id='wp-quicklatex-format-css'  href='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/wp-quicklatex/css/quicklatex-format.css?ver=4.0.1' type='text/css' media='all' />
<link rel='stylesheet' id='bbp-default-css'  href='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/bbpress/templates/default/css/bbpress.css?ver=2.5.4-5380' type='text/css' media='screen' />
<link rel='stylesheet' id='wp-pagenavi-css'  href='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/wp-pagenavi/pagenavi-css.css?ver=2.70' type='text/css' media='all' />
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-includes/js/jquery/jquery.js?ver=1.11.1'></script>
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-includes/js/jquery/jquery-migrate.min.js?ver=1.2.1'></script>
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/wp-quicklatex/js/wp-quicklatex-frontend.js?ver=1.0'></script>

<!-- Bad Behavior 2.2.16 run time: 1.500 ms -->
<script type="text/javascript">
<!--
function bb2_addLoadEvent(func) {
	var oldonload = window.onload;
	if (typeof window.onload != 'function') {
		window.onload = func;
	} else {
		window.onload = function() {
			oldonload();
			func();
		}
	}
}

bb2_addLoadEvent(function() {
	for ( i=0; i < document.forms.length; i++ ) {
		if (document.forms[i].method == 'post') {
			var myElement = document.createElement('input');
			myElement.setAttribute('type', 'hidden');
			myElement.name = 'bb2_screener_';
			myElement.value = '1417111267 210.212.53.139 172.19.11.169';
			document.forms[i].appendChild(myElement);
		}
	}
});
// --></script>
		<style type="text/css" id="syntaxhighlighteranchor"></style>
   <meta name="google-site-verification" content="rHK2v8_zzuAZQY8JHAzbllDN8u-aQxcn2Kqnp67Old0" />
</head>

<body>
<!-- o4dI0sCXUgoSONabbd8mbZ4SA3E -->    
    <div id="wrapper">
        <div class="blog-info">
                <h1 class="blog-title">
                <a href="http://www.geeksforgeeks.org" title="GeeksforGeeks">GeeksforGeeks</a>
            </h1>
       
            <div class="blog-description">
                A computer science portal for geeks            </div>
        </div>
        <b><p>  <h2 align="right"> <a href="http://geeksquiz.com/">GeeksQuiz</a></h2> 
   <a href="http://www.geeksforgeeks.org/wp-login.php">Login</a> 
         </p></b>  
         
         <div class="clear"></div>         
              
                     
            <div id="menu">   
                 <ul>
 <li><a href="http://www.geeksforgeeks.org">Home</a></li>
  <li><a href="http://www.geeksforgeeks.org/fundamentals-of-algorithms/">Algorithms</a></li>
 <li><a href="http://www.geeksforgeeks.org/data-structures/">DS</a></li>
  <li><a href="http://www.geeksforgeeks.org/gate-corner/">GATE</a></li>
  <li><a href="http://www.geeksforgeeks.org/about/interview-corner/">Interview Corner</a></li>
  <li><a href="http://www.geeksforgeeks.org/forums/">Q&A</a></li>
  <li><a href="http://www.geeksforgeeks.org/c/">C</a></li>
  <li><a href="http://www.geeksforgeeks.org/c-plus-plus/">C++</a></li>
  <li><a href="http://www.geeksforgeeks.org/java/">Java</a></li>
  <li><a href="http://www.geeksforgeeks.org/books/">Books</a></li>
  <li><a href="http://www.geeksforgeeks.org/contribute/">Contribute</a></li>
  <li><a href="http://www.geeksforgeeks.org/contribute/ask-a-question/">Ask a Q</a></li>
  <li><a href="http://www.geeksforgeeks.org/about/">About</a></li>
            </ul>

               
            <div class="clear"></div>     
        </div>
             <div id="navmenu">
				<ul id="menu" style="padding:0; margin:0;">
						<li class="cat-item cat-item-3"><a href="http://www.geeksforgeeks.org/category/c-arrays/" title="Questions regarding Arrays">Array</a>
</li>	

	<li class="cat-item cat-item-17"><a href="http://www.geeksforgeeks.org/category/bit-magic/" title="View all posts filed under Bit Magic">Bit Magic</a>
</li>
	<li class="cat-item cat-item-14"><a href="http://www.geeksforgeeks.org/category/c-puzzles/" title="View all posts filed under C/C++ Puzzles">C/C++</a>
</li>

<li class="cat-item cat-item-18"><a href="http://www.geeksforgeeks.org/category/articles/" title="View all posts filed under Articles">Articles</a>
</li>

	<li class="cat-item cat-item-67"><a href="http://www.geeksforgeeks.org/category/gfact/" title="View all posts filed under GFacts">GFacts</a>
</li>
	<li class="cat-item cat-item-8"><a href="http://www.geeksforgeeks.org/category/linked-list/" title="Linked List problems">Linked List</a>
</li>
	<li class="cat-item cat-item-66"><a href="http://www.geeksforgeeks.org/category/multiple-choice-question/" title="View all posts filed under MCQ">MCQ</a>

</li>
	<li class="cat-item cat-item-4"><a href="http://www.geeksforgeeks.org/category/c-programs/" title="Miscellaneous">Misc</a>
</li>
	<li class="cat-item cat-item-5"><a href="http://www.geeksforgeeks.org/category/program-output/" title="View all posts filed under Output">Output</a>
</li>
	<li class="cat-item cat-item-7"><a href="http://www.geeksforgeeks.org/category/c-strings/" title="Questions related to strings">String</a>
</li>
	<li class="cat-item cat-item-19"><a href="http://www.geeksforgeeks.org/category/tree/" title="View all posts filed under Trees">Tree</a>
</li>
	<li class="cat-item cat-item-19"><a href="http://www.geeksforgeeks.org/category/graph/" title="View all posts filed under Graph">Graph</a>
</li>
</ul>
        </div>
             <div id="content">	   	
	<div class="post" id="post">
							<div class="post-info">			
					<div class="post-title-info">
						<h2 class="post-title">Inorder Successor in Binary Search Tree</h2>
					</div>			
					<div class="clear"></div>				  
				<div class="post-content" id="post-content">
					<p>In Binary Tree, Inorder successor of a node is the next node in Inorder traversal of the Binary Tree. Inorder Successor is NULL for the last node in Inoorder traversal.<span id="more-9999"></span><br />
In Binary Search Tree, Inorder Successor of <!--more-->an input node can also be defined as the node with the smallest key greater than the key of input node.  So, it is sometimes important to find next node in sorted order.</p>
<p><a href="http://geeksforgeeks.org/wp-content/uploads/2009/09/BST_LCA.gif"><img src="http://geeksforgeeks.org/wp-content/uploads/2009/09/BST_LCA.gif" alt="" width="259" height="218" class="aligncenter size-full wp-image-1346" /></a></p>
<p>In the above diagram, inorder successor of <strong>8 </strong>is <strong>10</strong>, inorder successor of <strong>10 </strong>is <strong>12 </strong>and inorder successor of <strong>14 </strong>is <strong>20</strong>.</p>
<p><strong>Method 1 (Uses Parent Pointer) </strong><br />
In this method, we assume that every node has parent pointer. </p>
<p>The Algorithm is divided into two cases on the basis of right subtree of the input node being empty or not.</p>
<p>Input: <em>node, root</em> // <em>node </em> is the node whose Inorder successor is needed.<br />
output: <em>succ </em>// <em>succ </em>is Inorder successor of <em>node</em>.</p>
<p><strong>1)</strong> If right subtree of <em>node </em> is not <em>NULL</em>, then <em>succ </em>lies in right subtree. Do following.<br />
Go to right subtree and return the node with minimum key value in right subtree.<br />
<strong>2) </strong>If right sbtree of <em>node </em>is NULL, then <em>succ </em>is one of the ancestors. Do following.<br />
Travel up using the parent pointer until you see a node which is left child of it&#8217;s parent. The parent of such a node is the <em>succ</em>.</p>
<p><strong>Implementation</strong><br />
Note that the function to find InOrder Successor is highlighted (with gray background) in below code.</p>
<pre class="brush: cpp; highlight: [16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]; title: ; notranslate" title="">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
 
/* A binary tree node has data, pointer to left child
   and a pointer to right child */
struct node
{
    int data;
    struct node* left;
    struct node* right;
    struct node* parent;
};

struct node * minValue(struct node* node); 

struct node * inOrderSuccessor(struct node *root, struct node *n)
{
  // step 1 of the above algorithm 
  if( n-&gt;right != NULL )
    return minValue(n-&gt;right);

  // step 2 of the above algorithm
  struct node *p = n-&gt;parent;
  while(p != NULL &amp;&amp; n == p-&gt;right)
  {
     n = p;
     p = p-&gt;parent;
  }
  return p;
}

/* Given a non-empty binary search tree, return the minimum data  
    value found in that tree. Note that the entire tree does not need
    to be searched. */
struct node * minValue(struct node* node) {
  struct node* current = node;
 
  /* loop down to find the leftmost leaf */
  while (current-&gt;left != NULL) {
    current = current-&gt;left;
  }
  return current;
}

/* Helper function that allocates a new node with the given data and 
    NULL left and right pointers. */
struct node* newNode(int data)
{
  struct node* node = (struct node*)
                       malloc(sizeof(struct node));
  node-&gt;data   = data;
  node-&gt;left   = NULL;
  node-&gt;right  = NULL;
  node-&gt;parent = NULL;
  
  return(node);
}

/* Give a binary search tree and a number, inserts a new node with    
    the given number in the correct place in the tree. Returns the new
    root pointer which the caller should then use (the standard trick to 
    avoid using reference parameters). */
struct node* insert(struct node* node, int data)
{
  /* 1. If the tree is empty, return a new,
      single node */
  if (node == NULL)
    return(newNode(data));
  else
  {
    struct node *temp;  

    /* 2. Otherwise, recur down the tree */
    if (data &lt;= node-&gt;data)
    {    
         temp = insert(node-&gt;left, data);
         node-&gt;left  = temp;
         temp-&gt;parent= node;
    }
    else
    {
        temp = insert(node-&gt;right, data);
        node-&gt;right = temp;
        temp-&gt;parent = node;
    }    
 
    /* return the (unchanged) node pointer */
    return node;
  }
} 
 
/* Driver program to test above functions*/
int main()
{
  struct node* root = NULL, *temp, *succ, *min;

  //creating the tree given in the above diagram
  root = insert(root, 20);
  root = insert(root, 8);
  root = insert(root, 22);
  root = insert(root, 4);
  root = insert(root, 12);
  root = insert(root, 10);  
  root = insert(root, 14);    
  temp = root-&gt;left-&gt;right-&gt;right;

  succ =  inOrderSuccessor(root, temp);
  if(succ !=  NULL)
    printf(&quot;\n Inorder Successor of %d is %d &quot;, temp-&gt;data, succ-&gt;data);    
  else
    printf(&quot;\n Inorder Successor doesn't exit&quot;);

  getchar();
  return 0;
}
</pre>
<p>Output of the above program:<br />
<em>Inorder Successor of 14 is 20</em></p>
<p>Time Complexity: O(h) where h is height of tree.</p>
<p></br><br />
<strong>Method 2 (Search from root) </strong><br />
Parent pointer is NOT needed in this algorithm.  The Algorithm is divided into two cases on the basis of right subtree of the input node being empty or not.</p>
<p>Input: <em>node, root</em> // <em>node </em> is the node whose Inorder successor is needed.<br />
output: <em>succ </em>// <em>succ </em>is Inorder successor of <em>node</em>.</p>
<p><strong>1)</strong> If right subtree of <em>node </em> is not <em>NULL</em>, then <em>succ </em>lies in right subtree. Do following.<br />
Go to right subtree and return the node with minimum key value in right subtree.<br />
<strong>2) </strong>If right sbtree of <em>node </em>is NULL, then start from root and us search like technique. Do following.<br />
Travel down the tree, if a node&#8217;s data is greater than root&#8217;s data then go right side, otherwise go to left side.</p>
<pre class="brush: cpp; highlight: [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]; title: ; notranslate" title="">
struct node * inOrderSuccessor(struct node *root, struct node *n)
{
    // step 1 of the above algorithm
    if( n-&gt;right != NULL )
        return minValue(n-&gt;right);

    struct node *succ = NULL;

    // Start from root and search for successor down the tree
    while (root != NULL)
    {
        if (n-&gt;data &lt; root-&gt;data)
        {
            succ = root;
            root = root-&gt;left;
        }
        else if (n-&gt;data &gt; root-&gt;data)
            root = root-&gt;right;
        else
           break;
    }

    return succ;
}
</pre>
<p>Thanks to <a href="http://www.geeksforgeeks.org/archives/9999/comment-page-1#comment-3466">R.Srinivasan</a> for suggesting this method.</p>
<p>Time Complexity: O(h) where h is height of tree.</p>
<p>References:<br />
<a href="http://net.pku.edu.cn/~course/cs101/2007/resource/Intro2Algorithm/book6/chap13.htm">http://net.pku.edu.cn/~course/cs101/2007/resource/Intro2Algorithm/book6/chap13.htm</a></p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
		
&nbsp;
&nbsp;
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle"
     style="display:inline-block;width:336px;height:280px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="4061219431"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>



&nbsp;
&nbsp;
&nbsp;
<h3>Related Topics:</h3><ul><li><a href="http://www.geeksforgeeks.org/perfect-binary-tree-specific-level-order-traversal/" title="Perfect Binary Tree Specific Level Order Traversal">Perfect Binary Tree Specific Level Order Traversal</a></li><li><a href="http://www.geeksforgeeks.org/print-nodes-top-view-binary-tree/" title="Print Nodes in Top View of Binary Tree">Print Nodes in Top View of Binary Tree</a></li><li><a href="http://www.geeksforgeeks.org/k-dimensional-tree/" title="K Dimensional Tree">K Dimensional Tree</a></li><li><a href="http://www.geeksforgeeks.org/convert-binary-tree-threaded-binary-tree/" title="Convert a Binary Tree to Threaded binary tree">Convert a Binary Tree to Threaded binary tree</a></li><li><a href="http://www.geeksforgeeks.org/serialize-deserialize-n-ary-tree/" title="Serialize and Deserialize an N-ary Tree">Serialize and Deserialize an N-ary Tree</a></li><li><a href="http://www.geeksforgeeks.org/serialize-deserialize-binary-tree/" title="Serialize and Deserialize a Binary Tree">Serialize and Deserialize a Binary Tree</a></li><li><a href="http://www.geeksforgeeks.org/given-binary-tree-print-nodes-two-given-level-numbers/" title="Print nodes between two given level numbers of a binary tree">Print nodes between two given level numbers of a binary tree</a></li><li><a href="http://www.geeksforgeeks.org/find-height-binary-tree-represented-parent-array/" title="Find Height of Binary Tree represented by Parent array">Find Height of Binary Tree represented by Parent array</a></li></ul>
<p></p> 
<div>
<iframe src="http://www.facebook.com/plugins/like.php?href=http%3A%2F%2Fwww.geeksforgeeks.org%2Finorder-successor-in-binary-search-tree%2F&layout=button_count&show_faces=false&width=90&action=like&colorscheme=light" scrolling="no" frameborder="0" allowTransparency="true" style="border:none; overflow:hidden; width:90px; height:20px"></iframe>
<a href="http://twitter.com/share" class="twitter-share-button" data-url="http://www.geeksforgeeks.org/inorder-successor-in-binary-search-tree/" data-text="Inorder Successor in Binary Search Tree" data-count="horizontal" data-via="jakerutter">Tweet</a><script type="text/javascript" src="http://platform.twitter.com/widgets.js"></script>
<g:plusone size="medium" href="http://www.geeksforgeeks.org/inorder-successor-in-binary-search-tree/"></g:plusone>
<!-- Place this render call where appropriate -->
<script type="text/javascript">
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script></div>





				</div>		  
			</div> <!-- end post main -->					
			<div class="post-meta">
				<div class="left"></div>				
				<div class="clear"></div>
			</div>			
        
			<div class="comments-main">		
 <b>Writing code in comment?</b> Please use <b><a href="http://ideone.com/">ideone.com</a></b> and share the link here.
				
<div id="disqus_thread">
            <div id="dsq-content">


            <ul id="dsq-comments">
                    <li class="comment even thread-even depth-1" id="dsq-comment-33990">
        <div id="dsq-comment-header-33990" class="dsq-comment-header">
            <cite id="dsq-cite-33990">
                <span id="dsq-author-user-33990">Guest</span>
            </cite>
        </div>
        <div id="dsq-comment-body-33990" class="dsq-comment-body">
            <div id="dsq-comment-message-33990" class="dsq-comment-message"><p>//inorderSuccessorContinue = 0 where 0 means to continue and 1 means to discontinue</p>
<p>//inorderSuccessorContinue is a global variable of type int</p>
<p>void inorderSuccessor(struct node *root, int key)</p>
<p>{</p>
<p>	if (root != NULL) {	</p>
<p>		if (inorderSuccessorContinue != 1)	</p>
<p>			inorderSuccessor(root-&gt;left, key);</p>
<p>		if (root-&gt;key &gt; key &amp;&amp; inorderSuccessorContinue != 1) {</p>
<p>			cout &lt;key &lt;right, key);</p>
<p>	}</p>
<p>}</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-33991">
        <div id="dsq-comment-header-33991" class="dsq-comment-header">
            <cite id="dsq-cite-33991">
                <span id="dsq-author-user-33991">Naimish Agarwal</span>
            </cite>
        </div>
        <div id="dsq-comment-body-33991" class="dsq-comment-body">
            <div id="dsq-comment-message-33991" class="dsq-comment-message"><p>I feel its perfectly correct. Please verify and comment.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-31790">
        <div id="dsq-comment-header-31790" class="dsq-comment-header">
            <cite id="dsq-cite-31790">
                <span id="dsq-author-user-31790">KS</span>
            </cite>
        </div>
        <div id="dsq-comment-body-31790" class="dsq-comment-body">
            <div id="dsq-comment-message-31790" class="dsq-comment-message"><p>hello geeksforgeeks,</p>
<p>few things: in method1 above, dont we need to consider first whether the node for which we are trying to find out successor is present in the tree or not?</p>
<p>&#8211; in the function insert(), it is better to send the address of the node itself without having a return type, otherwise after a newnode is being inserted we are unncessarily adjusting parent pointers for the nodes which are already there in place. </p>
<p>-Thanks&#8230;</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-31112">
        <div id="dsq-comment-header-31112" class="dsq-comment-header">
            <cite id="dsq-cite-31112">
                <span id="dsq-author-user-31112">anonymous</span>
            </cite>
        </div>
        <div id="dsq-comment-body-31112" class="dsq-comment-body">
            <div id="dsq-comment-message-31112" class="dsq-comment-message"><p>Instead of this, what we can do is keep track of previously visited element and do a reverse inorder traversal( Right Root Left). As soon as we encounter the key, we know that the previous element was the inorder successor.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-30447">
        <div id="dsq-comment-header-30447" class="dsq-comment-header">
            <cite id="dsq-cite-30447">
                <span id="dsq-author-user-30447">Jayagopi</span>
            </cite>
        </div>
        <div id="dsq-comment-body-30447" class="dsq-comment-body">
            <div id="dsq-comment-message-30447" class="dsq-comment-message"><p>inorder_successor(struct tree*root,int  num)</p>
<p>{</p>
<p>  static int flag=0;</p>
<p>  inorder_successor(root-&gt;left,num);</p>
<p>  if(root-&gt;data==num)</p>
<p>    flag=1;</p>
<p>  if(flag==2)</p>
<p>  {</p>
<p>     print(&#8220;%d&#8221;,root-&gt;data);</p>
<p>     flag=0;</p>
<p>  }</p>
<p>if(flag)</p>
<p>   flag++;</p>
<p>  inorder_successor(root-&gt;right,num);</p>
<p>}</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-33427">
        <div id="dsq-comment-header-33427" class="dsq-comment-header">
            <cite id="dsq-cite-33427">
                <span id="dsq-author-user-33427">Guest</span>
            </cite>
        </div>
        <div id="dsq-comment-body-33427" class="dsq-comment-body">
            <div id="dsq-comment-message-33427" class="dsq-comment-message"><p>Made some minor changes <img src="http://d2o58evtke57tz.cloudfront.net/wp-includes/images/smilies/icon_smile.gif" alt=":)" class="wp-smiley" /> code seems to be working ok</p>
<p>void inorder_successor(struct node* root,int num)</p>
<p>{</p>
<p>static int flag=0;</p>
<p>if(root)</p>
<p>{</p>
<p>inorder_successor(root-&gt;left,num);</p>
<p>if(flag)</p>
<p>{</p>
<p>printf(&#8220;%dn&#8221;,root-&gt;data);</p>
<p>flag=0;</p>
<p>}</p>
<p>if(root-&gt;data==num) flag=1;</p>
<p>inorder_successor(root-&gt;right,num);</p>
<p>}</p>
<p>}</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-29263">
        <div id="dsq-comment-header-29263" class="dsq-comment-header">
            <cite id="dsq-cite-29263">
                <span id="dsq-author-user-29263">GuestPost</span>
            </cite>
        </div>
        <div id="dsq-comment-body-29263" class="dsq-comment-body">
            <div id="dsq-comment-message-29263" class="dsq-comment-message"><p>awesome!!</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-28611">
        <div id="dsq-comment-header-28611" class="dsq-comment-header">
            <cite id="dsq-cite-28611">
                <span id="dsq-author-user-28611">gb</span>
            </cite>
        </div>
        <div id="dsq-comment-body-28611" class="dsq-comment-body">
            <div id="dsq-comment-message-28611" class="dsq-comment-message"><p>Inorder Successor of a binary tree : </p>
<p><a href="http://rajneesh2k10.wordpress.com/2011/06/25/inorder-successor/" rel="nofollow">http://rajneesh2k10.wordpress.com/2011/06/25/inorder-successor/</a></p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-28508">
        <div id="dsq-comment-header-28508" class="dsq-comment-header">
            <cite id="dsq-cite-28508">
                <span id="dsq-author-user-28508">pavansrinivas</span>
            </cite>
        </div>
        <div id="dsq-comment-body-28508" class="dsq-comment-body">
            <div id="dsq-comment-message-28508" class="dsq-comment-message"><p>Code in JAVA of a binary tree<br />
   Validate me&#8230;<br />
<code></p>
<p>	void inOrderSuccesor(int key){</p>
<p>		Stack s = new Stack();<br />
		Node temp = root;<br />
		while(true){</p>
<p>			while(temp!=null){<br />
				s.push(temp);<br />
				temp = temp.left;<br />
			}<br />
			if(s.isEmpty()){<br />
				break;<br />
			}<br />
			temp = s.pop();<br />
			if(temp.i==key){<br />
				if(temp.right==null){<br />
					if(!s.isEmpty()){<br />
			        	System.out.print(s.peek().i+"    ");<br />
					}else{<br />
						System.out.print("Does not Exist    ");<br />
					}<br />
				}else{<br />
					Node temp2 = temp.right;<br />
					Node prev = temp2;<br />
					while(temp2!=null){<br />
						prev = temp2;<br />
						temp2 = temp2.left;<br />
					}<br />
					System.out.print(prev.i+"    ");<br />
				}<br />
				return;<br />
			}<br />
			temp = temp.right;<br />
		}</p>
<p>}</p>
<p></code></p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-30792">
        <div id="dsq-comment-header-30792" class="dsq-comment-header">
            <cite id="dsq-cite-30792">
                <span id="dsq-author-user-30792">Nikhil Agrawal</span>
            </cite>
        </div>
        <div id="dsq-comment-body-30792" class="dsq-comment-body">
            <div id="dsq-comment-message-30792" class="dsq-comment-message"><p>Your Code is perfect working for all types of tress. </p>
<p>Great !!</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-28487">
        <div id="dsq-comment-header-28487" class="dsq-comment-header">
            <cite id="dsq-cite-28487">
                <span id="dsq-author-user-28487">psg tech student</span>
            </cite>
        </div>
        <div id="dsq-comment-body-28487" class="dsq-comment-body">
            <div id="dsq-comment-message-28487" class="dsq-comment-message"><p>your code doesnt work for right skew tree</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-27573">
        <div id="dsq-comment-header-27573" class="dsq-comment-header">
            <cite id="dsq-cite-27573">
                <span id="dsq-author-user-27573">vikram</span>
            </cite>
        </div>
        <div id="dsq-comment-body-27573" class="dsq-comment-body">
            <div id="dsq-comment-message-27573" class="dsq-comment-message"><p>In method 2 , the function inOrderSuccessor is assuming that the node n is exists in the tree.</p>
<p>When n does not exists in the tree, this function may return some successor. Probably it is missing following statement at the end</p>
<p>	if ( root != NULL )<br />
  return succ;<br />
else<br />
  return NULL;</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-26770">
        <div id="dsq-comment-header-26770" class="dsq-comment-header">
            <cite id="dsq-cite-26770">
                <span id="dsq-author-user-26770">vanathi</span>
            </cite>
        </div>
        <div id="dsq-comment-body-26770" class="dsq-comment-body">
            <div id="dsq-comment-message-26770" class="dsq-comment-message"><p>First we traverse the Right subtree node and left subtree and keep track the previosuly visited node.If you see the node which inorder successor to be found, return pre node.</p>
<p>private void inOrderSuccessor(Node tree,Node node){<br />
		if(tree == null) return;<br />
	   inOrderSuccessor(tree.right,node);<br />
	   if(node.data == tree.data){<br />
		   System.out.println(pre.data);<br />
	   }pre = tree;<br />
	   inOrderSuccessor(tree.left,node);<br />
	}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-24793">
        <div id="dsq-comment-header-24793" class="dsq-comment-header">
            <cite id="dsq-cite-24793">
                <span id="dsq-author-user-24793">Law kumar</span>
            </cite>
        </div>
        <div id="dsq-comment-body-24793" class="dsq-comment-body">
            <div id="dsq-comment-message-24793" class="dsq-comment-message"><p>just traverse the list in reverse-inorder by keeping track the previous node until given node not found.if found, return prev node and not a inorder-succesor</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-2" id="dsq-comment-27744">
        <div id="dsq-comment-header-27744" class="dsq-comment-header">
            <cite id="dsq-cite-27744">
                <span id="dsq-author-user-27744">zedus</span>
            </cite>
        </div>
        <div id="dsq-comment-body-27744" class="dsq-comment-body">
            <div id="dsq-comment-message-27744" class="dsq-comment-message"><p>While your solution will work, the time complexity of it is O(n).<br />
The offered solution in this page is O(logn),<br />
It&#8217;s quite a dramatic difference.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-22415">
        <div id="dsq-comment-header-22415" class="dsq-comment-header">
            <cite id="dsq-cite-22415">
                <span id="dsq-author-user-22415">Vaibhav Gupta</span>
            </cite>
        </div>
        <div id="dsq-comment-body-22415" class="dsq-comment-body">
            <div id="dsq-comment-message-22415" class="dsq-comment-message"><p>#include<br />
int arr[100];<br />
int len=0;<br />
struct node<br />
{<br />
    int data;<br />
    struct node *left;<br />
    struct node *right;<br />
};<br />
struct node* newNode(int data)<br />
{<br />
    struct node *temp = (struct node*)malloc(sizeof(struct node));<br />
    temp-&gt;data = data;<br />
    temp-&gt;left = NULL;<br />
    temp-&gt;right = NULL;</p>
<p>    return temp;<br />
}</p>
<p>void inorder(struct node *root)<br />
{<br />
     if(root)<br />
     {<br />
             inorder(root-&gt;left);<br />
             arr[len++]=root-&gt;data;<br />
             inorder(root-&gt;right);<br />
     }<br />
}<br />
void find(struct node *a)<br />
{<br />
     int i;<br />
     for(i=0;idata)<br />
                       printf(&#8220;%d&#8221;,arr[i+1]);<br />
     }<br />
}    </p>
<p>int main()<br />
{<br />
  struct node* root = NULL, *temp, *succ, *min;</p>
<p>  //creating the tree given in the above diagram<br />
  root = newNode(20);<br />
    root-&gt;left = newNode(8);<br />
    root-&gt;right = newNode(22);<br />
    root-&gt;left-&gt;left = newNode(4);<br />
    root-&gt;left-&gt;right = newNode(12);<br />
    root-&gt;left-&gt;right-&gt;left = newNode(10);<br />
    root-&gt;left-&gt;right-&gt;right = newNode(14);<br />
  temp = root-&gt;left-&gt;right-&gt;right;<br />
  inorder(root);<br />
  find(temp);<br />
  getchar();<br />
  return 0;<br />
}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-suryabhan even thread-even depth-1" id="dsq-comment-21654">
        <div id="dsq-comment-header-21654" class="dsq-comment-header">
            <cite id="dsq-cite-21654">
                <span id="dsq-author-user-21654">suryabhan</span>
            </cite>
        </div>
        <div id="dsq-comment-body-21654" class="dsq-comment-body">
            <div id="dsq-comment-message-21654" class="dsq-comment-message"><pre> <code language="C">
void InorderSuccessor(struct node *s)
{
    if(s)
    {
        s=s-&gt;r;
        if(!s)
            printf(&quot;no Inorder Successor&quot;);
        else
        {
            while(s-&gt;l)
                s=s-&gt;l;
            printf(&quot;Inorder Successor =%d&quot;,s-&gt;data);

        }
    }
}
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-20279">
        <div id="dsq-comment-header-20279" class="dsq-comment-header">
            <cite id="dsq-cite-20279">
                <span id="dsq-author-user-20279">sush</span>
            </cite>
        </div>
        <div id="dsq-comment-body-20279" class="dsq-comment-body">
            <div id="dsq-comment-message-20279" class="dsq-comment-message"><pre> <code language="C"> 
struct node * inOrderSuccessor(struct node *root, struct node *n,struct node **ans)//saves inorder successor in ans
{
	static int bit=0;
  if(root == NULL)
	 return NULL;
  inOrderSuccessor(root-&gt;left,n,ans);

  if(bit)
  {*ans=root;bit=0;}
  if(n==root)
	  bit=1;
  inOrderSuccessor(root-&gt;right,n,ans);
  
}
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-akshat215 even thread-even depth-1" id="dsq-comment-19968">
        <div id="dsq-comment-header-19968" class="dsq-comment-header">
            <cite id="dsq-cite-19968">
                <span id="dsq-author-user-19968">akshat gupta</span>
            </cite>
        </div>
        <div id="dsq-comment-body-19968" class="dsq-comment-body">
            <div id="dsq-comment-message-19968" class="dsq-comment-message"><p>IDEA:DO Inorder Travesal,<br />
     After finding the &#8216;n&#8217; node, &#8220;set a Flag&#8221;<br />
     Upcoming Node will be Inorder Successor<br />
  //C Code//<br />
  struct node* InorderSuccessor(struct node*head,struct node*n)<br />
  {<br />
      static int flag=0;<br />
      /*Base Case*/<br />
      if(head==NULL)<br />
      {<br />
          printf(&#8220;No Successor&#8221;);<br />
          return;<br />
      }<br />
      if(head->left!=NULL)<br />
        InorderSuccessor(head->left,n);</p>
<p>      if(head == n)<br />
        flag=1;<br />
      else if(flag==1)<br />
        return(head);</p>
<p>      if(head->right!=NULL)<br />
        InorderSuccessor(head->right,n);<br />
}</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-akshat215 odd alt depth-2" id="dsq-comment-19969">
        <div id="dsq-comment-header-19969" class="dsq-comment-header">
            <cite id="dsq-cite-19969">
                <span id="dsq-author-user-19969">akshat gupta</span>
            </cite>
        </div>
        <div id="dsq-comment-body-19969" class="dsq-comment-body">
            <div id="dsq-comment-message-19969" class="dsq-comment-message"><p>T(n) = O(n)</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-19544">
        <div id="dsq-comment-header-19544" class="dsq-comment-header">
            <cite id="dsq-cite-19544">
                <span id="dsq-author-user-19544">koduru</span>
            </cite>
        </div>
        <div id="dsq-comment-body-19544" class="dsq-comment-body">
            <div id="dsq-comment-message-19544" class="dsq-comment-message"><pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
<p>#include<br />
#include</p>
<p>typedef struct treeNode{<br />
    int data;<br />
    struct treeNode* left;<br />
    struct treeNode* right;<br />
}treeNode;<br />
int flag=0;<br />
treeNode* newNode(int data)<br />
{<br />
    treeNode* node=(treeNode*)malloc(sizeof(treeNode));<br />
    node-&gt;data=data;<br />
    node-&gt;left=node-&gt;right=NULL;<br />
    return node;<br />
}<br />
void printInorder(treeNode* node)<br />
{<br />
    if (node == NULL)<br />
        return;<br />
    printInorder(node-&gt;left);<br />
    printf(&#8220;%d &#8220;, node-&gt;data);<br />
    printInorder(node-&gt;right);<br />
}<br />
void IOS(treeNode* root,int key)<br />
{<br />
    if(!root) return;</p>
<p>    IOS(root-&gt;left , key);</p>
<p>    if(flag==1)<br />
    {<br />
        printf(&#8220;the inorder succesor is %d\n&#8221;,root-&gt;data);<br />
        flag=0;<br />
        return;<br />
    }<br />
    if(root-&gt;data == key)<br />
        flag=1;</p>
<p>    IOS(root-&gt;right,key);<br />
}<br />
main()<br />
{<br />
    int key;<br />
    treeNode *root = newNode(6);<br />
    root-&gt;left        = newNode(10);<br />
    root-&gt;right       = newNode(2);<br />
    root-&gt;left-&gt;left  = newNode(1);<br />
    root-&gt;left-&gt;right = newNode(3);<br />
    root-&gt;right-&gt;right = newNode(12);<br />
    root-&gt;right-&gt;left = newNode(7);<br />
    printInorder(root);<br />
    printf(&#8220;\nenter key value \n&#8221;);<br />
    scanf(&#8220;%d&#8221;,&amp;key);<br />
    IOS(root,key);<br />
}</p>
<p>My code gives correct output.<br />
Can it be even optimized.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-19073">
        <div id="dsq-comment-header-19073" class="dsq-comment-header">
            <cite id="dsq-cite-19073">
                <span id="dsq-author-user-19073">max</span>
            </cite>
        </div>
        <div id="dsq-comment-body-19073" class="dsq-comment-body">
            <div id="dsq-comment-message-19073" class="dsq-comment-message"><p>int lca(struct tree *t,int d)<br />
{<br />
	struct stack *s;<br />
	s=(struct stack *)malloc(sizeof(struct stack));<br />
	s-&gt;index=-1;</p>
<p>	while(1)<br />
	{<br />
		while(t)<br />
		{<br />
			push(s,t);<br />
			t=t-&gt;l;<br />
		}</p>
<p>		if(isempty(s))<br />
		{<br />
			printf(&#8220;given element is not present in the given tree so LCA can&#8217;t be found in it\n&#8221;);<br />
			return -1;<br />
		}<br />
		t=pop(s);</p>
<p>		if(t-&gt;data==d)<br />
		{<br />
			if(t-&gt;l==NULL)<br />
            {   if(isempty(s))<br />
                    return -1;<br />
                else<br />
                    return (pop(s)-&gt;data);<br />
            }<br />
			else<br />
			{<br />
				t=t-&gt;r;<br />
				while(t-&gt;l!=NULL)<br />
					t=t-&gt;l;<br />
				return t-&gt;data;<br />
			}<br />
		}<br />
		t=t-&gt;r;</p>
<p>	}</p>
<p>}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-18467">
        <div id="dsq-comment-header-18467" class="dsq-comment-header">
            <cite id="dsq-cite-18467">
                <span id="dsq-author-user-18467">prity</span>
            </cite>
        </div>
        <div id="dsq-comment-body-18467" class="dsq-comment-body">
            <div id="dsq-comment-message-18467" class="dsq-comment-message"><p>This code is working for btree as well as BST if i m not wrong.</p>
<pre> <code language="C">
/* #include&lt;stdio.h&gt; 
#include&lt;conio.h&gt;
#include&lt;stdlib.h&gt;
struct btree
{
       int data;
       struct btree *left;
       struct btree *right;
};
void inorder(struct btree*p,int target)
{
               if(p==NULL) return;   
                 if(p-&gt;left!=NULL)
                 {
                                  if(p-&gt;left-&gt;data==target)
                                  {
                                                           printf(&quot;%d &quot;,p-&gt;data); 
                                                           return;
                                  }
                                  inorder(p-&gt;left,target);
                 }
                 if(p-&gt;right!=NULL)
                 {
                                   if(p-&gt;right-&gt;data==target)
                                   {
                                                             printf(&quot;%d &quot;,p-&gt;data);
                                                             return;
                                   }
                                   inorder(p-&gt;right,target);
                 }
                 
                 
    
}

struct btree* newNode(int data)
{
  struct btree* node = (struct btree*)malloc(sizeof(struct btree));
  node-&gt;data = data;
  node-&gt;left = NULL;
  node-&gt;right = NULL;
 
  return(node);
}
int main()
{
 struct btree *head=NULL;
 int n;
                 head = newNode(7);
                 head-&gt;left        = newNode(4);
                 head-&gt;right       = newNode(9);
                 head-&gt;left-&gt;left  = newNode(2);
                 head-&gt;left-&gt;right = newNode(5);
                 head-&gt;right-&gt;left  = newNode(8);
                 head-&gt;right-&gt;right = newNode(10);
                 head-&gt;left-&gt;left-&gt;left=newNode(1);
                 head-&gt;left-&gt;left-&gt;right = newNode(3);
                 head-&gt;right-&gt;right-&gt;left = newNode(12);
                 head-&gt;right-&gt;right-&gt;right = newNode(15);
                 printf(&quot;\nEnter the target:&quot;);
                 scanf(&quot;%d&quot;,&amp;n);         
                 inorder(head,n);
                    getch();
    return 0;
}
 */
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-18368">
        <div id="dsq-comment-header-18368" class="dsq-comment-header">
            <cite id="dsq-cite-18368">
                <span id="dsq-author-user-18368">Priyanka K</span>
            </cite>
        </div>
        <div id="dsq-comment-body-18368" class="dsq-comment-body">
            <div id="dsq-comment-message-18368" class="dsq-comment-message"><pre> <code language="C">
//traversing in reverse inorder fashion
node* inSucc(node *root,int k){
      static node* succ=NULL;
      if(!root)
               return NULL;
      node *t=inSucc(root-&gt;right,k);
      if(t)
           return t;
      if(root-&gt;data==k)
                       return succ;
      succ=root;
      return inSucc(root-&gt;left,k);
}
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-16523">
        <div id="dsq-comment-header-16523" class="dsq-comment-header">
            <cite id="dsq-cite-16523">
                <span id="dsq-author-user-16523">Navneet</span>
            </cite>
        </div>
        <div id="dsq-comment-body-16523" class="dsq-comment-body">
            <div id="dsq-comment-message-16523" class="dsq-comment-message"><pre> <code language="C">





struct node* inorder_successor(int num,node *root,node *par,node *leftpar)
{
	if(root==NULL)
	{
		return NULL;
	}
	
	else
	{
		if(root-&gt;data&gt;num)
		{
			inorder_successor(num,root-&gt;left,root,root);
		}
		else if(root-&gt;data&lt;num)
		{
			inorder_successor(num,root-&gt;right,root,leftpar);
		}
		else
		{//cout&lt;&lt;&quot;found&quot;&lt;&lt;par-&gt;data&lt;&lt;&quot;  &quot;&lt;&lt;leftpar-&gt;data&lt;&lt;endl;
			if(par==NULL&amp;&amp;root-&gt;data==num)
			{
				if(root-&gt;right!=NULL)
				{
					temp=root-&gt;right;
					while(temp-&gt;left!=NULL)
					{
						temp=temp-&gt;left;
					}
					return temp;
				}
				else
				return NULL;
			}
			
			else if(par-&gt;left==root)
			{
				if(root-&gt;right!=NULL)
				{
					temp=root-&gt;right;
					while(temp-&gt;left!=NULL)
					temp=temp-&gt;left;
					return temp;
				}
				else
				{
					return leftpar;
				}		
			}
			
			else if(par-&gt;right==root)
			{
				if(root-&gt;right!=NULL)
				{
					temp=root-&gt;right;
					while(temp-&gt;left!=NULL)
					temp=temp-&gt;left;
					cout&lt;&lt;temp-&gt;data;
					return temp;
				}
				else
				{
					return leftpar;
				}
			}
			
			
		}
		
		
	}
}


</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-16522">
        <div id="dsq-comment-header-16522" class="dsq-comment-header">
            <cite id="dsq-cite-16522">
                <span id="dsq-author-user-16522">Navneet</span>
            </cite>
        </div>
        <div id="dsq-comment-body-16522" class="dsq-comment-body">
            <div id="dsq-comment-message-16522" class="dsq-comment-message"><pre> <code language="C">
struct node* inorder_successor(int num,node *root,node *par,node *leftpar)
{
	if(root==NULL)
	{
		return NULL;
	}
	
	else
	{
		if(root-&gt;data&gt;num)
		{
			inorder_successor(num,root-&gt;left,root,root);
		}
		else if(root-&gt;data&lt;num)
		{
			inorder_successor(num,root-&gt;right,root,leftpar);
		}
		else
		{//cout&lt;&lt;&quot;found&quot;&lt;&lt;par-&gt;data&lt;&lt;&quot;  &quot;&lt;&lt;leftpar-&gt;data&lt;&lt;endl;
			if(par==NULL&amp;&amp;root-&gt;data==num)
			{
				if(root-&gt;right!=NULL)
				{
					temp=root-&gt;right;
					while(temp-&gt;left!=NULL)
					{
						temp=temp-&gt;left;
					}
					return temp;
				}
				else
				return NULL;
			}
			
			else if(par-&gt;left==root)
			{
				if(root-&gt;right!=NULL)
				{
					temp=root-&gt;right;
					while(temp-&gt;left!=NULL)
					temp=temp-&gt;left;
					return temp;
				}
				else
				{
					return leftpar;
				}		
			}
			
			else if(par-&gt;right==root)
			{
				if(root-&gt;right!=NULL)
				{
					temp=root-&gt;right;
					while(temp-&gt;left!=NULL)
					temp=temp-&gt;left;
					cout&lt;&lt;temp-&gt;data;
					return temp;
				}
				else
				{
					return leftpar;
				}
			}
			
			
		}
		
		
	}
}


</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-16399">
        <div id="dsq-comment-header-16399" class="dsq-comment-header">
            <cite id="dsq-cite-16399">
                <span id="dsq-author-user-16399">Saurabh Tiwari</span>
            </cite>
        </div>
        <div id="dsq-comment-body-16399" class="dsq-comment-body">
            <div id="dsq-comment-message-16399" class="dsq-comment-message"><pre> <code language="Java">
public class InorderSuccessorBST {

	public static boolean IS_NEXT_ELEM_SUCCESSOR = false;
	public static boolean BREAK_LOOP = false;
	
	public static void inorderSuccessor(Node root, int value){
		if(!BREAK_LOOP){
			if(root == null) return;
			inorderSuccessor(root.left, value);
			
			if(IS_NEXT_ELEM_SUCCESSOR){
				System.out.println(&quot;Inorder Successor of Node &quot; + value + &quot; is : &quot; + root.value);
				BREAK_LOOP = true;
				IS_NEXT_ELEM_SUCCESSOR = false;
			}
			
			if(root.value == value){
				IS_NEXT_ELEM_SUCCESSOR = true;
			}
			
			inorderSuccessor(root.right, value);
		}
	}
	
	public static void main(String[] args) {
		Node root = Node.dummyBST();
		RecursiveTreeTraversal.inorder(root);
		inorderSuccessor(root, 3);
	}
}

</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-15204">
        <div id="dsq-comment-header-15204" class="dsq-comment-header">
            <cite id="dsq-cite-15204">
                <span id="dsq-author-user-15204">Gopal</span>
            </cite>
        </div>
        <div id="dsq-comment-body-15204" class="dsq-comment-body">
            <div id="dsq-comment-message-15204" class="dsq-comment-message"><p>Solved using stack</p>
<p>public static int nextInOrderSuccessor(Node root,int n)<br />
	{<br />
		if(root == null)<br />
			return -1;</p>
<p>		Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;();<br />
		stack.add(root);</p>
<p>		while(!stack.isEmpty())<br />
		{<br />
			Node peek = stack.peek();<br />
			if(peek.n == n)<br />
			{<br />
				if(peek.right != null)<br />
				{<br />
					Node node = peek.right;<br />
					while(node.left != null)<br />
					{<br />
						node = node.left;<br />
					}<br />
					return node.n;<br />
				}<br />
				else<br />
				{<br />
					stack.pop();//remove peek element<br />
					if(stack.isEmpty())<br />
						return -1;<br />
					return stack.pop().n;<br />
				}<br />
			}<br />
			else if(peek.n &gt; n)<br />
			{<br />
				if(peek.left != null)<br />
					stack.push(peek.left);<br />
				else<br />
					return -1;<br />
			}<br />
			else<br />
			{<br />
				if(peek.right != null)<br />
				{<br />
					stack.pop();//remove current small element<br />
					stack.push(peek.right);<br />
				}<br />
				else<br />
					return -1;<br />
			}<br />
		}<br />
		return -1;<br />
	}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-cyberwolf even thread-odd thread-alt depth-1" id="dsq-comment-15151">
        <div id="dsq-comment-header-15151" class="dsq-comment-header">
            <cite id="dsq-cite-15151">
                <span id="dsq-author-user-15151">cyberWolf</span>
            </cite>
        </div>
        <div id="dsq-comment-body-15151" class="dsq-comment-body">
            <div id="dsq-comment-message-15151" class="dsq-comment-message"><p>Travel in Inorder manner and look for the first node which is bigger than the value whose successor is to be found.</p>
<pre> <code language="C">
treeNode* findInorderSucc(treeNode* x, int val)
{
        if(x)
        {   
                treeNode* temp = findInorderSucc(x-&gt;left, val);
                if(temp == NULL)
                {       if(x-&gt;data&gt;val)
                        return x;
                }   
                else
                        return temp;

                return findInorderSucc(x-&gt;right, val);
        }   
        return NULL;
}

</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-13722">
        <div id="dsq-comment-header-13722" class="dsq-comment-header">
            <cite id="dsq-cite-13722">
http://pnadityalabs.com/                <span id="dsq-author-user-13722">Aditya</span>
            </cite>
        </div>
        <div id="dsq-comment-body-13722" class="dsq-comment-body">
            <div id="dsq-comment-message-13722" class="dsq-comment-message"><p>Perform inorder traversal which gives elements in a sorted order and use binary search to find the element and obviously the next element is the (greatest)successor and previous element is the (smallest) successor </p>
<p>package solved;</p>
<p>import java.util.*;</p>
<p>public class InorderSucessorOfBST {</p>
<p>    class Node{<br />
        Node left;<br />
        Node right;<br />
        Integer data;<br />
    }<br />
    Node tree;<br />
    List&lt;Integer&gt; nodes = new ArrayList&lt;Integer&gt;();<br />
    public void add(int data){<br />
        tree = add_node(tree,data);<br />
    }<br />
    public Node add_node(Node tree , int d){</p>
<p>        if(tree == null){<br />
            tree = new Node();<br />
            tree.left = null;<br />
            tree.right = null;<br />
            tree.data = d;<br />
        }<br />
        else if (d &lt;= tree.data){<br />
          tree.left =  add_node(tree.left,d);<br />
        }else{<br />
          tree.right =  add_node(tree.right,d);<br />
        }</p>
<p>        return tree;<br />
    }<br />
    public void inorder(){<br />
           in(tree);<br />
    }<br />
    public void in(Node t){<br />
          if(t != null){<br />
              in(t.left);<br />
              nodes.add(t.data);<br />
              in(t.right);<br />
          }<br />
    }<br />
    public void findSuccessor(int n){<br />
             if(nodes.contains(n)){<br />
               int temp = Collections.binarySearch(nodes, n);<br />
               System.out.println(&quot;Success &quot;+nodes.get(temp+1));<br />
             }else<br />
                 System.out.println(&quot;Does not exsist&quot;);<br />
    }<br />
    public static void main(String &#8230;s){</p>
<p>        InorderSucessorOfBST t = new InorderSucessorOfBST();</p>
<p>        t.add(20);<br />
        t.add(8);<br />
        t.add(22);<br />
        t.add(4);<br />
        t.add(12);<br />
        t.add(10);<br />
        t.add(14);<br />
        t.inorder();<br />
        t.findSuccessor(8);<br />
    }</p>
<p>}</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-shek8034 even depth-2" id="dsq-comment-19892">
        <div id="dsq-comment-header-19892" class="dsq-comment-header">
            <cite id="dsq-cite-19892">
                <span id="dsq-author-user-19892">shek8034</span>
            </cite>
        </div>
        <div id="dsq-comment-body-19892" class="dsq-comment-body">
            <div id="dsq-comment-message-19892" class="dsq-comment-message"><p>Yes correctly said.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-9375">
        <div id="dsq-comment-header-9375" class="dsq-comment-header">
            <cite id="dsq-cite-9375">
                <span id="dsq-author-user-9375">Ashu</span>
            </cite>
        </div>
        <div id="dsq-comment-body-9375" class="dsq-comment-body">
            <div id="dsq-comment-message-9375" class="dsq-comment-message"><pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
void getSucc(node *root,node *n,node **succ,int* val){
	if(root==NULL) return;
	if(n-&gt;data&lt;root-&gt;data)
	getSucc(root-&gt;left,n,succ,val);
	if(*val &amp;&amp; (*succ)!=NULL) return;
	if(*val){
		 *succ=root; 
		return; 
	}
	if(root==n) *val=1;
	if(n-&gt;data&gt;=root-&gt;data)
	getSucc(root-&gt;right,n,succ,val);
}
void nextSucc(node *root,node *n){
	
	node *succ=NULL;
	int val=0;
	getSucc(root,n,&amp;succ,&amp;val);
	if(succ!=NULL)
	cout&lt;&lt;succ-&gt;data&lt;&lt;&quot;\n&quot;;
}
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-2" id="dsq-comment-9376">
        <div id="dsq-comment-header-9376" class="dsq-comment-header">
            <cite id="dsq-cite-9376">
                <span id="dsq-author-user-9376">Ashu</span>
            </cite>
        </div>
        <div id="dsq-comment-body-9376" class="dsq-comment-body">
            <div id="dsq-comment-message-9376" class="dsq-comment-message"><p>recursive solution without parent pointer<br />
Time complexity o(h)</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-7902">
        <div id="dsq-comment-header-7902" class="dsq-comment-header">
            <cite id="dsq-cite-7902">
                <span id="dsq-author-user-7902">Abhishek</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7902" class="dsq-comment-body">
            <div id="dsq-comment-message-7902" class="dsq-comment-message"><p>Solution without the need of a parent pointer. Please reply if its wrong. Basically it traverses the tree inorder. While traversing a node, it checks a global flag node_found. If node_found is true, it returns the node it is currently traversing as the required inorder successor and sets another global flag successor_found.</p>
<pre> <code language="C">
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

typedef struct tree_node {
  struct tree_node *left;
  int data;
  struct tree_node *right;
}tree_node;

static int node_found = 0;
static int successor_found = 0;

void BST_insert(tree_node **root, int data);
void inorder_successor_wrapper(tree_node *root, int node_data);
tree_node *inorder_successor(tree_node *node, int node_data);

void main() {
  tree_node *root = NULL, *ptr = NULL;
  BST_insert(&amp;root, 20);
  BST_insert(&amp;root, 8);
  BST_insert(&amp;root, 22);
  BST_insert(&amp;root, 4);
  BST_insert(&amp;root, 12);
  BST_insert(&amp;root, 10);
  BST_insert(&amp;root, 14);

  inorder_successor_wrapper(root, 4);
  inorder_successor_wrapper(root, 8);
  inorder_successor_wrapper(root, 10);
  inorder_successor_wrapper(root, 12);
  inorder_successor_wrapper(root, 14);
  inorder_successor_wrapper(root, 20);
  inorder_successor_wrapper(root, 22);
  inorder_successor_wrapper(root, 1);
}

void BST_insert(tree_node **root, int data) {
  tree_node *temp = NULL, *ptr = NULL;

  if(*root == NULL) {
    *root = malloc(sizeof(tree_node));
    (*root)-&gt;data = data;
    (*root)-&gt;left = NULL;
    (*root)-&gt;right = NULL;
    return;
  }

  ptr = *root;

  while(1) {
    /* node already exists. return. */
    if(ptr-&gt;data == data) {
      return;
    }

    if(data &lt; ptr-&gt;data) {
      if(ptr-&gt;left == NULL) {
        temp = malloc(sizeof(tree_node));
        temp-&gt;data = data;
        temp-&gt;left = NULL;
        temp-&gt;right = NULL;
        ptr-&gt;left = temp;
        return;
      }
      ptr = ptr-&gt;left;
    } else {
      if(ptr-&gt;right == NULL) {
        temp = malloc(sizeof(tree_node));
        temp-&gt;data = data;
        temp-&gt;left = NULL;
        temp-&gt;right = NULL;
        ptr-&gt;right = temp;
        return;
      }
      ptr = ptr-&gt;right;
    }
  }
}


void inorder_successor_wrapper(tree_node *root, int node_data) {
  tree_node *result = NULL;
  if(root == NULL) {
    printf(&quot;\nTree is empty&quot;);
    return;
  }

  result = inorder_successor(root, node_data);

  if(node_found) {
    if(successor_found) {
      printf(&quot;\nInorder successor of %d is %d\n&quot;, node_data, result-&gt;data);
    } else {
      printf(&quot;\nThere is no inorder successor to the node %d\n&quot;, node_data);
    }
  } else {
    printf(&quot;\nNode %d not found\n&quot;, node_data);
  }

  node_found = 0;
  successor_found = 0;
  return;
}


tree_node *inorder_successor(tree_node *node, int node_data) {
  tree_node *result = NULL;

  if(node == NULL) {
    return NULL;
  }

  result = inorder_successor(node-&gt;left, node_data);
  if(successor_found) {
    return result;
  }

  /*Process this node*/

  if(node_found) {
    successor_found = 1;
    return node;
  }
  if(node-&gt;data == node_data) {
    node_found = 1;
  }

  result = inorder_successor(node-&gt;right, node_data);
  if(successor_found) {
    return result;
  } else {
    return NULL;
  }
}



</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-naddy even thread-odd thread-alt depth-1" id="dsq-comment-7087">
        <div id="dsq-comment-header-7087" class="dsq-comment-header">
            <cite id="dsq-cite-7087">
                <span id="dsq-author-user-7087">naddy</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7087" class="dsq-comment-body">
            <div id="dsq-comment-message-7087" class="dsq-comment-message"><pre> <code language="C">
node *insucc(node *root, node *n)
{
node *t;
t=max(root-&gt;right);
if(n-&gt;data==t-&gt;data)
return NULL;
if(n-&gt;right!=NULL)
return min(n-&gt;right);
else
{
if(n-&gt;info &lt; parent-&gt;info)
return parent;
else
return root;
}}
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-6832">
        <div id="dsq-comment-header-6832" class="dsq-comment-header">
            <cite id="dsq-cite-6832">
                <span id="dsq-author-user-6832">TUHIN</span>
            </cite>
        </div>
        <div id="dsq-comment-body-6832" class="dsq-comment-body">
            <div id="dsq-comment-message-6832" class="dsq-comment-message"><pre> <code language="C">
/* #include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#define MAXST 1024
#define TRUE 1
#define FALSE 0
typedef struct btree
 {
     int info;
     struct btree *left;
     struct btree *right;
 }BST;

struct stack_t
{
    int top;
    BST *val[MAXST];
};
typedef struct stack_t *stack;

stack s_create()
{
    stack p;
    p=(stack)malloc(sizeof(struct stack_t));
    if(p==NULL)
    {
        printf(&quot;\ncannot allocate memory:&quot;);
        exit(0);
    }
    else
    {
        p-&gt;top=-1;
        return p;
    }
}

int s_empty(stack s)
{
    return(s-&gt;top==-1);
}
int s_full(stack s)
{
    return (s-&gt;top==MAXST-1);
}
void push(stack s,BST *ptr)
{
    if(!(s_full(s)))
    {
        s-&gt;val[++(s-&gt;top)]=ptr;
    }
    else printf(&quot;\nstack overflow:&quot;);
}
BST *pop(stack s)
{
    BST *temp;
    if(!(s_empty(s)))
    {
        temp=s-&gt;val[s-&gt;top];
        (s-&gt;top)--;
        return temp;
    }
    else {
        printf(&quot;\nstack underflow:&quot;);

         }
}

void create_tree(BST **tree)
 {
     *tree=NULL;
 }

 void insertelement(BST **tree,int item)
 {
     if(*tree==NULL)
     {
     *tree = (BST*)malloc(sizeof(BST));
     (*tree)-&gt;info = item;
     (*tree)-&gt;left = NULL;
     (*tree)-&gt;right= NULL;
     }
     else
     {
         if(item&lt; (*tree)-&gt;info)
         {
             insertelement(&amp;((*tree)-&gt;left),item);
         }
         else
         {
             insertelement(&amp;((*tree)-&gt;right),item);
         }
     }
 }

 BST*find_min(BST *tree)
{
    if((tree==NULL)||(tree-&gt;left==NULL))
    return tree;
    else
    find_min(tree-&gt;left);
}

/*void inordersuccessor(BST *root,int key)
{

    stack s = s_create();
    BST *ptr;
    BST *ptr1;
    push(s,NULL);
    ptr=root;
    int done = FALSE;
    while(!done)
    {
    while(ptr!=NULL)
    {
        push(s,ptr);
        ptr=ptr-&gt;left;
    }
    ptr = pop(s);
    int flag = TRUE;
    while((ptr!=NULL)&amp;&amp;(flag=TRUE))
    {
        if((ptr-&gt;right==NULL)&amp;&amp;(ptr-&gt;info==key))
        {
            ptr1 = pop(s);
            printf(&quot;the inorder succesor is %d&quot;,ptr1-&gt;info);
            break;
        }
        else if((ptr-&gt;right!=NULL)&amp;&amp;(ptr-&gt;info==key))
        {
            ptr=ptr-&gt;right;
            ptr1 = find_min(ptr);
            printf(&quot;the inorder succesor is %d&quot;,ptr1-&gt;info);
        }
        else if(ptr-&gt;right!=NULL)
        {
            ptr=ptr-&gt;right;
            flag=FALSE;
        }
        else
        ptr=pop(s);

    }

        if(ptr-&gt;right!=NULL)
        {
            ptr=ptr-&gt;right;
            flag=FALSE;
        }
        else
        {
            ptr=pop(s);
        }
   }
   if(ptr==NULL)
   {
       done=TRUE;
   }
        }*/


void inordersuccessor(BST *root,int key)
{

    stack s = s_create();
    BST *ptr;
    BST *ptr1;
    push(s,NULL);
    ptr=root;
    int done = FALSE;
    while(!done)
    {
    while(ptr!=NULL)
    {
        push(s,ptr);
        ptr=ptr-&gt;left;
    }
    ptr = pop(s);
    int flag = TRUE;
    while((ptr!=NULL)&amp;&amp;(flag=TRUE))
    {
        if(ptr-&gt;info==key)
        {
            if(ptr-&gt;right==NULL)
            {
            ptr1 = pop(s);
            printf(&quot;the inorder succesor is %d&quot;,ptr1-&gt;info);
            }
        else if(ptr-&gt;right!=NULL)
        {
            ptr=ptr-&gt;right;
            ptr1 = find_min(ptr);
            printf(&quot;the inorder succesor is %d&quot;,ptr1-&gt;info);
        }
        }
        if(ptr-&gt;info!=key)
        {
            if(ptr-&gt;right!=NULL)
            {
            ptr=ptr-&gt;right;
            flag=FALSE;
            }
        else
        ptr=pop(s);

        }
   }
   if(ptr==NULL)
   {
       done=TRUE;
   }
        }
}

int main()
 {
    BST *root;
    int element;
    create_tree(&amp;root);
    int choice;
    printf(&quot;create the  tree\n&quot;);
    while(1)
    {
        printf(&quot;enter 1 to enter elements\nenter 2 to break\n&quot;);
        scanf(&quot;%d&quot;,&amp;choice);
        if(choice==1)
        {
                    printf(&quot;enter the element\n&quot;);
                    scanf(&quot;%d&quot;,&amp;element);
                    insertelement(&amp;root,element);

        }

        if(choice==2)
            {
                break;
            }
    }
  printf(&quot;enter the element whose successor you want to find\n&quot;);
  scanf(&quot;%d&quot;,&amp;element);
  inordersuccessor(root,element);
 }

Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-6392">
        <div id="dsq-comment-header-6392" class="dsq-comment-header">
            <cite id="dsq-cite-6392">
                <span id="dsq-author-user-6392">Prateek Caire</span>
            </cite>
        </div>
        <div id="dsq-comment-body-6392" class="dsq-comment-body">
            <div id="dsq-comment-message-6392" class="dsq-comment-message"><p>Without using parent pointer</p>
<pre> <code language="C">
n: node whose successor needs to be found
FM(): Find min val in a tree
rt: root
s: successor
S(r, n)
	if(n-&gt;r)
		return FM(n-&gt;r)
	else
		while(rt)
			if(n-&gt;d &lt; r-&gt;d)
				s = rt-&gt;d
				rt = rt-&gt;l
			if(n-&gt;d &gt; r-&gt;d)
				rt = rt-&gt;r
			else
				break
	        return s		
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-cracker odd alt thread-even depth-1" id="dsq-comment-5595">
        <div id="dsq-comment-header-5595" class="dsq-comment-header">
            <cite id="dsq-cite-5595">
http://algods-cracker.blogspot.com/                <span id="dsq-author-user-5595">Cracker</span>
            </cite>
        </div>
        <div id="dsq-comment-body-5595" class="dsq-comment-body">
            <div id="dsq-comment-message-5595" class="dsq-comment-message"><p><a href="http://algods-cracker.blogspot.com/2011/10/amazon-question-set-inorder-successor.html" rel="nofollow">http://algods-cracker.blogspot.com/2011/10/amazon-question-set-inorder-successor.html</a><a href="http://algods-cracker.blogspot.com/2011/10/amazon-question-set-inorder-successor.html" rel="nofollow"></a></p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-4485">
        <div id="dsq-comment-header-4485" class="dsq-comment-header">
            <cite id="dsq-cite-4485">
                <span id="dsq-author-user-4485">R.Srinivasan</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4485" class="dsq-comment-body">
            <div id="dsq-comment-message-4485" class="dsq-comment-message"><pre> <code language="C">
//The following code finds the inOrderPredecessor of a given node and it 
// is not using parent pointer.

struct node * inOrderPredecessor(struct node *root, struct node *n) 
{     
      if( n-&gt;left  !=  NULL )
          return maxValue(n-&gt;left);
      struct node *pred=NULL;
      while(root)
      {
          if(n-&gt;data &lt;  root-&gt;data) 
               root=root-&gt;left;
          else if(n-&gt;data &gt;  root-&gt;data)
          {
               pred=root;
               root=root-&gt;right;  
          }     
          else
               break;
     }
     return pred;
}
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-7060">
        <div id="dsq-comment-header-7060" class="dsq-comment-header">
            <cite id="dsq-cite-7060">
                <span id="dsq-author-user-7060">Rajesh</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7060" class="dsq-comment-body">
            <div id="dsq-comment-message-7060" class="dsq-comment-message"><p>Above code fails when the key is the node with Max value.<br />
Below is my solution</p>
<pre> <code language="C">
int inorderPredecessor(struct node *root, struct node *node)
{
	struct node *pred = NULL;

	if(node-&gt;rchild != NULL)
		return minOf(node-&gt;rchild);	
	
	while(root)
	{
		if(node-&gt;data &lt; root-&gt;data)
		{
			pred = root;
			root = root-&gt;lchild;
		}
		else
		{
			if(node-&gt;data &gt; root-&gt;data)
			{				
				root = root-&gt;rchild;

				if(node-&gt;data &lt; root-&gt;data)
					pred = root;
			}
			else
				break;
		}
	}

	if(pred!=NULL)
		return pred-&gt;data;
	else
		return -1;
}
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-4474">
        <div id="dsq-comment-header-4474" class="dsq-comment-header">
            <cite id="dsq-cite-4474">
                <span id="dsq-author-user-4474">vivek</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4474" class="dsq-comment-body">
            <div id="dsq-comment-message-4474" class="dsq-comment-message"><p>my solution:</p>
<pre> <code language="C">
node *inOrderSuccessor(node *root, int in_data, int &amp;flag)
{
    node *rNode = NULL;

    if(root-&gt;left )
        rNode = inOrderSuccessor(root-&gt;left, in_data, flag);
    if(rNode)
        return rNode;
    if(flag)
    {
        return root;
        flag =0;
    }
    if(root-&gt;data == in_data)
    {
        flag = 1;
    }
    if(root-&gt;right )
        rNode = inOrderSuccessor(root-&gt;right, in_data, flag);
    return rNode;
}
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-4441">
        <div id="dsq-comment-header-4441" class="dsq-comment-header">
            <cite id="dsq-cite-4441">
                <span id="dsq-author-user-4441">Ritesh</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4441" class="dsq-comment-body">
            <div id="dsq-comment-message-4441" class="dsq-comment-message"><pre> <code language="C">struct _node{
  struct _node *l, *r;
  int d; 
}; 

typedef struct _node Node;
typedef Node* pNode;


pNode bst_min(pNode n){
  pNode result = n;
  while(result-&gt;l){
    result = result-&gt;l;
  }
  return result;
}


//Iterative implementation of inorder successor with explicit stack
// and without parent pointer
pNode bst_inorder_succ(pNode root, pNode n){
  list&lt;pNode&gt; stack;
  pNode current = root;
  do{
    while(current){
      stack.push_back(current);
      current = current-&gt;l;
    }
    if(!stack.empty()){
      current = stack.back();
      stack.pop_back();
      if(current){
        if(current-&gt;d == n-&gt;d){//found node;
          if(current-&gt;r){ // case 1
            cout &lt;&lt; &quot;1&quot; &lt;&lt; endl;
            return bst_min(current-&gt;r);
          }
          else{ // stack has the closes ancestor of N in the left;
            cout &lt;&lt; &quot;2&quot; &lt;&lt; endl;
            return stack.back();
          }
        }
        current = current-&gt;r;
      }
    }
  }while(current || !stack.empty());
  return NULL;
}


//Test function to print out in-order sequence 
void print_in_order_driver(){
  pNode next = bst_min(r_c);
  pNode succ = NULL;
  while(next){
    if(next){
      succ = bst_inorder_succ(r_c,next);
      cout &lt;&lt; next-&gt;d &lt;&lt; &quot; : &quot; &lt;&lt; (succ ? succ-&gt;d : -1)  &lt;&lt; endl;

      if(next == succ)
        break;
    }
    next = succ;
  }
}</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-rajneesh2k10 even thread-even depth-1" id="dsq-comment-4148">
        <div id="dsq-comment-header-4148" class="dsq-comment-header">
            <cite id="dsq-cite-4148">
                <span id="dsq-author-user-4148">Rajneesh</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4148" class="dsq-comment-body">
            <div id="dsq-comment-message-4148" class="dsq-comment-message"><p>Hello every one!<br />
I just want to share my code for finding &#8220;In-order Successor&#8221; of any node in ANY binary tree WITHOUT parent pointer. The tree need NOT be a BST. This algorithm returns the address of the inorder successor of any node identified by the key value passed with O(logn) time complexity. Complexity increases to O(n) for the worst case (when the tree is skewed). Please correct me with the time complexity part (as I am weak at it. :)).</p>
<pre> <code language="C">
typedef struct Node      //Basic structure of my tree node
{
	int data;
	Node *left,*right;
} Node;

Node *findRightSuccessor(Node *root)
{
	while (root-&gt;left)
		root=root-&gt;left;
	return root;
}

Node *inorderSuccessor(Node *root, int key, Node *parent)
{
	if (root==NULL)
		return 0;
	if (root-&gt;data == key)
	{
		if (root-&gt;right)
			return findRightSuccessor(root-&gt;right);
		else
			return parent;
	}
	Node *left=inorderSuccessor(root-&gt;left,key,root);
	if (left)
		return left;
	return inorderSuccessor(root-&gt;right,key,parent);
}

Node *inorderSuccessor(Node *root, int key)
{
	return inorderSuccessor(root,key,NULL);
}
</code> </pre>
<p>The function visible to end user is the last one. Which in turns calls an overloaded version of itself.<br />
If you find it worth, I&#8217;ll post the explanation for the above code too. Just comment if you need the explanation.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-4202">
        <div id="dsq-comment-header-4202" class="dsq-comment-header">
            <cite id="dsq-cite-4202">
                <span id="dsq-author-user-4202">SAm</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4202" class="dsq-comment-body">
            <div id="dsq-comment-message-4202" class="dsq-comment-message"><p>Couldnt understand wats happng in the last 3 lines and how do u get the parent</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-rajneesh2k10 even depth-3" id="dsq-comment-4206">
        <div id="dsq-comment-header-4206" class="dsq-comment-header">
            <cite id="dsq-cite-4206">
                <span id="dsq-author-user-4206">Rajneesh</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4206" class="dsq-comment-body">
            <div id="dsq-comment-message-4206" class="dsq-comment-message"><p>by Last three lines in the function you mean:<br />
if (left)<br />
 return left;<br />
return inorderSuccessor(root-&gt;right,key,parent);</p>
<p>Explanation:<br />
If your key value is not found, then either the key value can be found in the left subtree or the right subtree or possibly nowhere in the tree.<br />
Crux of the algorithm is: If a key value is found and the node has a right subtree then it has to be found out by the function findRightSuccessor. If it doesn&#8217;t have right child then the &#8220;parent&#8221; pointer passed to the function holds the address of the inorder successor.<br />
So, in above line if left has a non-zero value from the call:<br />
Node *left = inorderSuccessor(root-&gt;right,key,parent);<br />
that means it has got the address of the inorder successor and hence return it. Otherwise we need to search the right subtree and hence we do that.<br />
On point to note here is, whenever we are making a recursive call to the left subtree we are updating the &#8220;parent&#8221; pointer by the address of current node this is because this node is inorder successor of the last element of the left subtree. Whenever we are making a recursive call to right subtree we pass the same parent pointer because for the right subtree current node is not going to be the inorder successor anyway. <img src="http://d2o58evtke57tz.cloudfront.net/wp-includes/images/smilies/icon_smile.gif" alt=":)" class="wp-smiley" /><br />
Hope I am helpful.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-4" id="dsq-comment-5729">
        <div id="dsq-comment-header-5729" class="dsq-comment-header">
            <cite id="dsq-cite-5729">
                <span id="dsq-author-user-5729">Arul</span>
            </cite>
        </div>
        <div id="dsq-comment-body-5729" class="dsq-comment-body">
            <div id="dsq-comment-message-5729" class="dsq-comment-message"><p>Very nice&#8230;</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even depth-4" id="dsq-comment-6385">
        <div id="dsq-comment-header-6385" class="dsq-comment-header">
            <cite id="dsq-cite-6385">
                <span id="dsq-author-user-6385">Kaustubh</span>
            </cite>
        </div>
        <div id="dsq-comment-body-6385" class="dsq-comment-body">
            <div id="dsq-comment-message-6385" class="dsq-comment-message"><p>Are you sure that returning parent is correct approach if there is no right subtree? The inorder successor, as per my understanding, should be the parent of closest ancestor that is the left child of its parent.<br />
Sorry if that sounds confusing <img src="http://d2o58evtke57tz.cloudfront.net/wp-includes/images/smilies/icon_smile.gif" alt=":)" class="wp-smiley" /></p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-3531">
        <div id="dsq-comment-header-3531" class="dsq-comment-header">
            <cite id="dsq-cite-3531">
                <span id="dsq-author-user-3531">Areeb Ahmad</span>
            </cite>
        </div>
        <div id="dsq-comment-body-3531" class="dsq-comment-body">
            <div id="dsq-comment-message-3531" class="dsq-comment-message"><pre> <code language="C">

/* it's working fine for me, except cases for root node and external elements 
  are not present */ 
check(struct node *bt, int tgt)
{
    if (bt == NULL)  return;
    if (bt-&gt;left-&gt;data == tgt) {
       printf(&quot;%d&quot;,bt-&gt;data);
       return;
    }
    check(bt-&gt;left, tgt);
    if( bt-&gt;right-&gt;data == tgt ){
       printf(&quot;%d&quot;,bt-&gt;data);
       return;
    }
    check(bt-&gt;right,tgt);
}
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-3455">
        <div id="dsq-comment-header-3455" class="dsq-comment-header">
            <cite id="dsq-cite-3455">
http://www.wgpshashank.co.cc                <span id="dsq-author-user-3455">Shashank Mani Narayan</span>
            </cite>
        </div>
        <div id="dsq-comment-body-3455" class="dsq-comment-body">
            <div id="dsq-comment-message-3455" class="dsq-comment-message"><p>Ok GeeksForGeeks I have Written The Program for the In-order Predecessor Please let me know if any test case is missing<br />
Algorithm developed by myself ..Add This program as a Separate Post In Tree Section ..The Only Question I Have That Can&#8217;t We do it without Parent Pointer or not.?? Please Reply </p>
<pre> <code language="C">
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
 
/* A binary tree node has data, pointer to left child
   and a pointer to right child */
struct node
{
    int data;
    struct node* left;
    struct node* right;
    struct node* parent;
};
 
struct node*  minValue(struct node* node); 
 
int isLeaf(struct node* root)
{
  if(root-&gt;left==NULL &amp;&amp; root-&gt;right==NULL)
  return 1;
 
 return 0;
}
 
struct node* inOrderSuccessor(struct node *root, struct node *n)
{
  // step 1 of the above algorithm
  
  if(n==minValue(root))
  {
     printf(&quot;No Inorder Predecessor Possible&quot;);
     return NULL;
  }
 
  if( n-&gt;left != NULL )
    return n-&gt;left;
  
  struct node *p =n-&gt;parent; 
  if( n!=minValue(root) &amp;&amp; n == p-&gt;right)
   return p;
 
  p=NULL;
  // step 2 of the above algorithm
  p = n-&gt;parent;
  while(n!=minValue(root) &amp;&amp; n == p-&gt;left &amp;&amp; p!=NULL)   {
     n = p;
     p = p-&gt;parent;
  }
  return p;
}
 
/* Given a non-empty binary search tree, return the minimum data
    value found in that tree. Note that the entire tree does not need
    to be searched. */
struct node* minValue(struct node* node) 
{
  struct node* current = node;
 
  /* loop down to find the leftmost leaf */
  while (current-&gt;left != NULL) {
    current = current-&gt;left;
  }
  return current;
}
 
/* Helper function that allocates a new node with the given data and
    NULL left and right pointers. */
struct node* newNode(int data)
{
  struct node* node = (struct node*)
                       malloc(sizeof(struct node));
  node-&gt;data   = data;
  node-&gt;left   = NULL;
  node-&gt;right  = NULL;
  node-&gt;parent = NULL;
 
  return(node);
}
 
/* Give a binary search tree and a number, inserts a new node with
    the given number in the correct place in the tree. Returns the new
    root pointer which the caller should then use (the standard trick to
    avoid using reference parameters). */
struct node* insert(struct node* node, int data)
{
  /* 1. If the tree is empty, return a new,
      single node */
  if (node == NULL)
    return(newNode(data));
  else
  {
    struct node *temp;  
 
    /* 2. Otherwise, recur down the tree */
    if (data data)
    {
         temp = insert(node-&gt;left, data);
         node-&gt;left  = temp;
         temp-&gt;parent= node;
    }
    else
    {
        temp = insert(node-&gt;right, data);
        node-&gt;right = temp;
        temp-&gt;parent = node;
    }    
 
    /* return the (unchanged) node pointer */
    return node;
  }
} 
 
/* Driver program to test above functions*/
int main()
{
  struct node* root = NULL, *temp, *succ ;
 
  //creating the tree given in the above diagram
  root = insert(root, 20);
  root = insert(root, 8);
  root = insert(root, 22);
  root = insert(root, 4);
  root = insert(root, 12);
  root = insert(root, 10);
  root = insert(root, 14);
  temp = root-&gt;left-&gt;right-&gt;right;
 
  succ =  inOrderSuccessor(root, temp);
  if(succ !=  NULL)
    printf(&quot;\n Inorder Successor of %d is %d &quot;, temp-&gt;data, succ-&gt;data);
  getchar();
  return 0;
}
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-3461">
        <div id="dsq-comment-header-3461" class="dsq-comment-header">
            <cite id="dsq-cite-3461">
                <span id="dsq-author-user-3461">R.Srinivasan</span>
            </cite>
        </div>
        <div id="dsq-comment-body-3461" class="dsq-comment-body">
            <div id="dsq-comment-message-3461" class="dsq-comment-message"><p>Shashank:<br />
          There is no need of &#8220;parent&#8221; pointer for finding &#8220;inorder successor or predecessor&#8221;. I have added code below which finds the &#8220;inorder successor&#8221; without using &#8220;parent&#8221; pointer.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-sandeep even depth-3" id="dsq-comment-3462">
        <div id="dsq-comment-header-3462" class="dsq-comment-header">
            <cite id="dsq-cite-3462">
                <span id="dsq-author-user-3462">Sandeep</span>
            </cite>
        </div>
        <div id="dsq-comment-body-3462" class="dsq-comment-body">
            <div id="dsq-comment-message-3462" class="dsq-comment-message"><p>@Shashank Mani Narayan and @R.Srinivasan</p>
<p>Yes, we can find Inorder Successor without parent pointer. If we do not have parent pointer and right subtree is NULL, then we can do search for the minimum number greater than the given node&#8217;s data.  But, this approach takes O(n) time in worst case where n is the number of nodes. The parent pointer approach takes O(h) time where h is the height of tree.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-4" id="dsq-comment-3466">
        <div id="dsq-comment-header-3466" class="dsq-comment-header">
            <cite id="dsq-cite-3466">
                <span id="dsq-author-user-3466">R.Srinivasan</span>
            </cite>
        </div>
        <div id="dsq-comment-body-3466" class="dsq-comment-body">
            <div id="dsq-comment-message-3466" class="dsq-comment-message"><p>@Sandeep</p>
<p>The following code takes 0(h) time where h is the height of the tree and importantly, it is not using &#8220;parent&#8221; pointer.</p>
<pre> <code language="C">
struct node * inOrderSuccessor(struct node *root, struct node *n)
{   
    if( n-&gt;right != NULL ) 
        return minValue(n-&gt;right);                   
    struct node *succ=NULL;
    while(root)
    {
        if(n-&gt;datadata &lt; root-&gt;data)
        {
            succ=root;
            root=root-&gt;left;
        }
        else if(n-&gt;data &gt; root-&gt;data)
            root=root-&gt;right;
        else
           break;
    }
    return succ;
}
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-5" id="dsq-comment-3474">
        <div id="dsq-comment-header-3474" class="dsq-comment-header">
            <cite id="dsq-cite-3474">
                <span id="dsq-author-user-3474">Shashank Mani Narayan</span>
            </cite>
        </div>
        <div id="dsq-comment-body-3474" class="dsq-comment-body">
            <div id="dsq-comment-message-3474" class="dsq-comment-message"><p>@sgrnivasan&#8230;you have missed a test case</p>
<p>that you have to check if the leaf is right most leaf then inorder successor not possible </p>
<p>..correct me if m wrong</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt depth-5" id="dsq-comment-3476">
        <div id="dsq-comment-header-3476" class="dsq-comment-header">
            <cite id="dsq-cite-3476">
                <span id="dsq-author-user-3476">R.Srinivasan</span>
            </cite>
        </div>
        <div id="dsq-comment-body-3476" class="dsq-comment-body">
            <div id="dsq-comment-message-3476" class="dsq-comment-message"><p>@Shashank Mani </p>
<p>I have tested all cases including the rightmost leaf. If the inorder successor is not posibble then the code will return &#8220;NULL&#8221;.(See the initialization of &#8220;succ=NULL&#8221; in the code).</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even depth-5" id="dsq-comment-4420">
        <div id="dsq-comment-header-4420" class="dsq-comment-header">
            <cite id="dsq-cite-4420">
                <span id="dsq-author-user-4420">Rahul</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4420" class="dsq-comment-body">
            <div id="dsq-comment-message-4420" class="dsq-comment-message"><p>@R.Srinivasan s gud algo man, can u think how we can find inorder predecessor without using parent pointer ..reply asap.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-geeksforgeeks odd alt depth-5" id="dsq-comment-7156">
        <div id="dsq-comment-header-7156" class="dsq-comment-header">
            <cite id="dsq-cite-7156">
                <span id="dsq-author-user-7156">GeeksforGeeks</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7156" class="dsq-comment-body">
            <div id="dsq-comment-message-7156" class="dsq-comment-message"><p>@R.Srinivasan: Thanks for suggesting a new approach.  We have added this to the original post.  Keep it up!!</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even depth-5" id="dsq-comment-18144">
        <div id="dsq-comment-header-18144" class="dsq-comment-header">
            <cite id="dsq-cite-18144">
                <span id="dsq-author-user-18144">rahul</span>
            </cite>
        </div>
        <div id="dsq-comment-body-18144" class="dsq-comment-body">
            <div id="dsq-comment-message-18144" class="dsq-comment-message"><p>@GeeksforGeeks:</p>
<p>In second method we don&#8217;t need the parent pointer but you mentioned in the beginning of the post that &#8220;Parent pointer is needed in this algorithm&#8221;. Please correct that.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-geeksforgeeks odd alt depth-5" id="dsq-comment-18145">
        <div id="dsq-comment-header-18145" class="dsq-comment-header">
            <cite id="dsq-cite-18145">
                <span id="dsq-author-user-18145">GeeksforGeeks</span>
            </cite>
        </div>
        <div id="dsq-comment-body-18145" class="dsq-comment-body">
            <div id="dsq-comment-message-18145" class="dsq-comment-message"><p>@rahul: Thanks for pointing this out.  We have corrected it/</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-rakshify even depth-5" id="dsq-comment-18427">
        <div id="dsq-comment-header-18427" class="dsq-comment-header">
            <cite id="dsq-cite-18427">
                <span id="dsq-author-user-18427">rakshify</span>
            </cite>
        </div>
        <div id="dsq-comment-body-18427" class="dsq-comment-body">
            <div id="dsq-comment-message-18427" class="dsq-comment-message"><p>I think there are two problems in this answer:-<br />
1) This will fail in following case:<br />
Suppose we have following insertions in our tree:-<br />
root = insert(root, 10);<br />
root = insert(root, 10);<br />
root = insert(root, 10);<br />
root = insert(root, 10);<br />
root = insert(root, 10);<br />
our tree will have an inorder as:<br />
10->10->10->10->10<br />
Now if we have to find in order successor of 3rd 10(which should be 4th 10), it&#8217;ll give NULL as answer.</p>
<p>2) You&#8217;ve changed the root pointer, which is bad for future usage.</p>
<p>Seeing the two points, i suggest slight modification:-</p>
<pre> <code language="C">
struct node * inOrderSuccessor(struct node *root, struct node *n)
{   
    struct node *succ = NULL, *temp;
    if( n-&gt;right != NULL ) 
        return minValue(n-&gt;right);                   
    temp = root;
    while(temp != NULL &amp;&amp; temp != n)
    {
        if(n-&gt;datadata &lt;= temp-&gt;data)
        {
            succ=temp;
            temp=temp-&gt;left;
        }
        else
            temp=temp-&gt;right;
    }
    return succ;
}
</code> </pre>
<p>Please correct me if I&#8217;m wrong.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-3453">
        <div id="dsq-comment-header-3453" class="dsq-comment-header">
            <cite id="dsq-cite-3453">
http://www.wgpshashank.co.cc                <span id="dsq-author-user-3453">Shashank Mani Narayan</span>
            </cite>
        </div>
        <div id="dsq-comment-body-3453" class="dsq-comment-body">
            <div id="dsq-comment-message-3453" class="dsq-comment-message"><p>algo for in-order predecessor</p>
<p>step-1 1st if its is the leftmost leaf of bst then their is no inorder predecessor<br />
step-2 else if left child  of corresponding node is not zero then left child of a node is in-order predecessor </p>
<p>step 3 //requires loop<br />
else if node is not the leftmost leaf and it does not have a left subtree then inorder predecessor will its parent </p>
<p>Request from geeksforgeeks to update the same article just update a new function inorderPredecessor(struct node *root, struct node *n)</p>
<p>so that people can find both solution at the same place also try to expend the solution for preorder &amp; postorder successor &amp; predecessor</p>
<p>Please Check above algo..before implementing it.</p>
<p>Thanks<br />
Shashank</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-2" id="dsq-comment-4005">
        <div id="dsq-comment-header-4005" class="dsq-comment-header">
            <cite id="dsq-cite-4005">
                <span id="dsq-author-user-4005">aimless</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4005" class="dsq-comment-body">
            <div id="dsq-comment-message-4005" class="dsq-comment-message"><p>step-2 else if left child of corresponding node is not zero then left child of a node is in-order predecessor </p>
<p>is not correct, as predecessor may be rightmost child of the left child.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-3450">
        <div id="dsq-comment-header-3450" class="dsq-comment-header">
            <cite id="dsq-cite-3450">
                <span id="dsq-author-user-3450">Algo_boy</span>
            </cite>
        </div>
        <div id="dsq-comment-body-3450" class="dsq-comment-body">
            <div id="dsq-comment-message-3450" class="dsq-comment-message"><p>@geeksforgeek can&#8217;t we do inorder successor or in-order predecessor without using parent pointer why you hav used extra parent pointer ..please reply &amp; if possible plz try to give code with out using parent pointer</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-3438">
        <div id="dsq-comment-header-3438" class="dsq-comment-header">
            <cite id="dsq-cite-3438">
                <span id="dsq-author-user-3438">R.Srinivasan</span>
            </cite>
        </div>
        <div id="dsq-comment-body-3438" class="dsq-comment-body">
            <div id="dsq-comment-message-3438" class="dsq-comment-message"><pre> <code language="C">
struct node * inOrderSuccessor(struct node *root, struct node *n) 
{
  static int flag=0;
  struct node * succ=NULL;
  if(root!=NULL)
  {
      if(flag != 2)
          succ= inOrderSuccessor(root-&gt;left,n);
      if(root==n)
          flag=1;
      else if(flag ==1)
      {
          flag=2;
          succ=root;
      }     
      if(flag != 2)
          succ= inOrderSuccessor(root-&gt;right,n);
  }
  return succ; 
}
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-3306">
        <div id="dsq-comment-header-3306" class="dsq-comment-header">
            <cite id="dsq-cite-3306">
                <span id="dsq-author-user-3306">KP</span>
            </cite>
        </div>
        <div id="dsq-comment-body-3306" class="dsq-comment-body">
            <div id="dsq-comment-message-3306" class="dsq-comment-message"><p>Hi Venki</p>
<p>Keep up the good work. Just wanted to suggest a change in the code. In the algorithm we have to stop until we have found a left child but in the code you are checking for the right child. Can you please check and correct it.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-sandeep even depth-2" id="dsq-comment-3318">
        <div id="dsq-comment-header-3318" class="dsq-comment-header">
            <cite id="dsq-cite-3318">
                <span id="dsq-author-user-3318">Sandeep</span>
            </cite>
        </div>
        <div id="dsq-comment-body-3318" class="dsq-comment-body">
            <div id="dsq-comment-message-3318" class="dsq-comment-message"><p>@KP: Please take a closer look at the algorithm and code. The loop stops when either p is NULL (When n becomes root) or n is left child of its parent p. The loop continues when n is right child of p.</p>
<pre> <code language="C">  struct node *p = n-&gt;parent;
  while(p != NULL &amp;&amp; n == p-&gt;right)
  {
     n = p;
     p = p-&gt;parent;
  }</code> </pre>
<p>I think following could also work.</p>
<pre> <code language="C">  struct node *p = n-&gt;parent;
  while(p != NULL &amp;&amp; n != p-&gt;left) 
  {
     n = p;
     p = p-&gt;parent;
  }</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-venki odd alt depth-2" id="dsq-comment-3321">
        <div id="dsq-comment-header-3321" class="dsq-comment-header">
            <cite id="dsq-cite-3321">
http://www.linkedin.com/in/ramanawithu                <span id="dsq-author-user-3321">Venki</span>
            </cite>
        </div>
        <div id="dsq-comment-body-3321" class="dsq-comment-body">
            <div id="dsq-comment-message-3321" class="dsq-comment-message"><p>@KP, thanks. I hope Sandeep clarified your question.</p>
<p>@Lutger, thanks, inorder predecessor is also an option. Content for another post :).</p>
<p>@Praveen, thanks for pointing. The free up operation is decoupled from delete function. The caller (more precisely memory management of application) should take care of free up. Our primary objective is algorithm.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-3263">
        <div id="dsq-comment-header-3263" class="dsq-comment-header">
            <cite id="dsq-cite-3263">
                <span id="dsq-author-user-3263">geek</span>
            </cite>
        </div>
        <div id="dsq-comment-body-3263" class="dsq-comment-body">
            <div id="dsq-comment-message-3263" class="dsq-comment-message"><p>Cormen book uses Inorder Successor for deletion of node in BST. This implementation uses parent pointer and the algo for inorder successor given in cormen also uses parent pointer. Many other books have algo to delete node without having parent pointer as part of tree node. Please explain?</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-venki odd alt depth-2" id="dsq-comment-3264">
        <div id="dsq-comment-header-3264" class="dsq-comment-header">
            <cite id="dsq-cite-3264">
http://www.linkedin.com/in/ramanawithu                <span id="dsq-author-user-3264">Venki</span>
            </cite>
        </div>
        <div id="dsq-comment-body-3264" class="dsq-comment-body">
            <div id="dsq-comment-message-3264" class="dsq-comment-message"><p>@Geek,<br />
CLRS follows modular approach in designing algorithms and data structures. If you see, pseudo code of inorder successor and predecessor were given prior to delete. </p>
<p>The deletion approach is non-trivial. If the node have only one child, or no children it is quite easy. If the node contains two children, we need to retain the BST property even after node deletion.</p>
<p><strong>Algorithm for deleting node with two children:</strong><br />
Since the node has two children, we need to replace the contents of a node from the right or left subtrees. The left subtree can have nodes with smaller values than the root. Only option is right subtree.</p>
<p>Which element in right subtree? Obviously, to maintain the BST property it should be inorder successor, i.e. minimum element of right subtree. Certainly, a minimum node in any binary tree will not have left node. Now the problem decomposed to trivial case of node with one child.</p>
<p>Given below is working code (just integrate with above program given by Sandeep). Note that I haven&#8217;t used any parent pointer.</p>
<pre> <code language="C">

struct node* deleteNode(struct node* root, int key)
{
    if( NULL != root )
    {
        if( key &lt; root-&gt;data )
        {
            // Traverse left subtree
            root-&gt;left = deleteNode(root-&gt;left, key);
        }
        else if( key &gt; root-&gt;data )
        {
            // Traverse left subtree
            root-&gt;right = deleteNode(root-&gt;right, key);
        }
        else
        {
            // This is the node to be deleted
            if( (NULL == root-&gt;left) || (NULL == root-&gt;right) )
            {
                // node with only one child or no children
                root = root-&gt;left ? root-&gt;left : root-&gt;right;
            }
            else
            {
                // node with two children
                
                // Get smallest in the right subtree and
                struct node* temp = minValue(root-&gt;right);

                // replace the node
                root-&gt;data = temp-&gt;data;
                // delete the inorder successor
                // definitely it will not have left node
                // so it will be simple delete ends at the
                // above if clause (trivial case)
                root-&gt;right = deleteNode(root-&gt;right, temp-&gt;data);
            }
        }
    }

    return root;
}
</code> </pre>
<p>Analyse the program at runtime with some sample inputs. Especially the last else clause and recursion call in that block.</p>
<p>You can observe that having parent pointer is more efficient than traversing tree over and over again.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-3" id="dsq-comment-3276">
        <div id="dsq-comment-header-3276" class="dsq-comment-header">
            <cite id="dsq-cite-3276">
                <span id="dsq-author-user-3276">Lutger</span>
            </cite>
        </div>
        <div id="dsq-comment-body-3276" class="dsq-comment-body">
            <div id="dsq-comment-message-3276" class="dsq-comment-message"><p>Venki, we can also take the inorder predecessor (in the left subtree) rather that the successor to maintain BST properties. The same logic applies.</p>
<p>The wikipedia article on binary search trees has a decent explanation too.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt depth-3" id="dsq-comment-3304">
        <div id="dsq-comment-header-3304" class="dsq-comment-header">
            <cite id="dsq-cite-3304">
                <span id="dsq-author-user-3304">Praveen</span>
            </cite>
        </div>
        <div id="dsq-comment-body-3304" class="dsq-comment-body">
            <div id="dsq-comment-message-3304" class="dsq-comment-message"><p>you are not doing free().</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment byuser comment-author-venki even thread-even depth-1" id="dsq-comment-3262">
        <div id="dsq-comment-header-3262" class="dsq-comment-header">
            <cite id="dsq-cite-3262">
http://www.linkedin.com/in/ramanawithu                <span id="dsq-author-user-3262">Venki</span>
            </cite>
        </div>
        <div id="dsq-comment-body-3262" class="dsq-comment-body">
            <div id="dsq-comment-message-3262" class="dsq-comment-message"><p>Nice post.</p>
<p>If the node not having right subtree, the inorder successor can be found by climbing up the tree on the paths of right children, till we encounter a first node having larger key than input node&#8217;s key.</p>
<p>However, we don&#8217;t need any key comparisons to climb up the tree because of BST property. Traverse up until a node which is left child of its parent. And that parent node is inorder successor.</p>
</div>
        </div>

    </li><!-- #comment-## -->
            </ul>


        </div>

    </div>

<script type="text/javascript">
var disqus_url = 'http://www.geeksforgeeks.org/inorder-successor-in-binary-search-tree/';
var disqus_identifier = '9999 http://geeksforgeeks.org/?p=9999';
var disqus_container_id = 'disqus_thread';
var disqus_shortname = 'geeksforgeeks';
var disqus_title = "Inorder Successor in Binary Search Tree";
var disqus_config_custom = window.disqus_config;
var disqus_config = function () {
    /*
    All currently supported events:
    onReady: fires when everything is ready,
    onNewComment: fires when a new comment is posted,
    onIdentify: fires when user is authenticated
    */
    
    
    this.language = '';
    
    if (disqus_config_custom) {
        disqus_config_custom.call(this);
    }
};

(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>

			</div>
	
					
			
			

		</div> <!-- end post -->	

<br></br>
	
</div> <!-- end content -->

<ul id="sidebar">
	<li id="text-19" class="widget widget_text">			<div class="textwidget"><script>
  (function() {
    var cx = '009682134359037907028:tj6eafkv_be';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//www.google.com/cse/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>

<style type="text/css">
  .gsc-control-cse {
    font-family: "Trebuchet MS", sans-serif;
    border-color: #E1F3DA;
    background-color: #E1F3DA;
  }
  input.gsc-input {
    border-color: #94CC7A;
  }
  input.gsc-search-button {
    border-color: #94CC7A;
    background-color: #AADA92;
  }
  .gsc-tabHeader.gsc-tabhInactive {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gsc-tabHeader.gsc-tabhActive {
    border-color: #A9DA92;
    background-color: #A9DA92;
  }
  .gsc-tabsArea {
    border-color: #A9DA92;
  }
  .gsc-webResult.gsc-result {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gsc-webResult.gsc-result:hover {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gs-webResult.gs-result a.gs-title:link,
  .gs-webResult.gs-result a.gs-title:link b {
    color: #009900;
  }
  .gs-webResult.gs-result a.gs-title:visited,
  .gs-webResult.gs-result a.gs-title:visited b {
    color: #009900;
  }
  .gs-webResult.gs-result a.gs-title:hover,
  .gs-webResult.gs-result a.gs-title:hover b {
    color: #003300;
  }
  .gs-webResult.gs-result a.gs-title:active,
  .gs-webResult.gs-result a.gs-title:active b {
    color: #009900;
  }
  .gsc-cursor-page {
    color: #009900;
  }
  a.gsc-trailing-more-results:link {
    color: #009900;
  }
  .gs-webResult.gs-result .gs-snippet {
    color: #454545;
  }
  .gs-webResult.gs-result .gs-visibleUrl {
    color: #33cc00;
  }
  .gs-webResult.gs-result .gs-visibleUrl-short {
    color: #33cc00;
  }
  .gs-webResult.gs-result .gs-visibleUrl-short {
    display: none;
  }
  .gs-webResult.gs-result .gs-visibleUrl-long {
    display: block;
  }
  .gsc-cursor-box {
    border-color: #A9DA92;
  }
  .gsc-results .gsc-cursor-page {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gsc-results .gsc-cursor-page.gsc-cursor-current-page {
    border-color: #A9DA92;
    background-color: #A9DA92;
  }
  .gs-promotion.gs-result {
    border-color: #94CC7A;
    background-color: #CBE8B4;
  }
  .gs-promotion.gs-result a.gs-title:link {
    color: #0066CC;
  }
  .gs-promotion.gs-result a.gs-title:visited {
    color: #0066CC;
  }
  .gs-promotion.gs-result a.gs-title:hover {
    color: #0066CC;
  }
  .gs-promotion.gs-result a.gs-title:active {
    color: #0066CC;
  }
  .gs-promotion.gs-result .gs-snippet {
    color: #454545;
  }
  .gs-promotion.gs-result .gs-visibleUrl,
  .gs-promotion.gs-result .gs-visibleUrl-short {
    color: #815FA7;
  }
</style>    </div>
		</li>
<li id="text-9" class="widget widget_text">			<div class="textwidget"><div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=138031159685820";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>

<div class="fb-like-box" data-href="https://www.facebook.com/pages/GeeksforGeeks/316764689022" data-width="250" data-height="170" data-colorscheme="light" data-show-faces="true" data-header="false" data-stream="false" data-show-border="false"></div></div>
		</li>
<li id="text-18" class="widget widget_text">			<div class="textwidget"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LargeRectangleSide -->
<ins class="adsbygoogle"
     style="display:inline-block;width:336px;height:280px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="1884636833"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
		</li>
<li id="text-13" class="widget widget_text">			<div class="textwidget"><ul><li><a href="http://www.geeksforgeeks.org/category/interview-experiences/">Interview Experiences</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/advance-data-structures">Advanced Data Structures</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/dynamic-programming">Dynamic Programming</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/Greedy-Algorithm/">Greedy Algorithms</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/backtracking">Backtracking</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/pattern-searching">Pattern Searching</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/divide-and-conquer">Divide & Conquer</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/MathematicalAlgo">Mathematical Algorithms</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/recursion">Recursion</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/geometric-algorithms/">Geometric Algorithms</a></li>
</ul></div>
		</li>
<li id="text-17" class="widget widget_text">			<div class="textwidget"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big 300x600 Sidebar -->
<ins class="adsbygoogle"
     style="display:inline-block;width:300px;height:600px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="4402736037"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
		</li>
<li id="text-14" class="widget widget_text"><h2 class="widgettitle">Popular Posts</h2>
			<div class="textwidget"><ul>
<li><a href="http://www.geeksforgeeks.org/write-a-c-program-to-print-all-permutations-of-a-given-string/">  All permutations of a given string </a></li>
<li><a href="http://www.geeksforgeeks.org/memory-layout-of-c-program/"> Memory Layout of C Programs</a> </li>
<li><a href="http://www.geeksforgeeks.org/understanding-extern-keyword-in-c/"> Understanding extern keyword in C</a> </li>
<li><a href="http://www.geeksforgeeks.org/median-of-two-sorted-arrays/">Median of two sorted arrays</a> </li>
<li><a href="http://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/"> Tree traversal without recursion and without stack! </a></li>
<li><a href="http://www.geeksforgeeks.org/structure-member-alignment-padding-and-data-packing/"> Structure Member Alignment, Padding and Data Packing</a> </li>
<li><a href="http://www.geeksforgeeks.org/write-a-function-to-get-the-intersection-point-of-two-linked-lists/"> Intersection point of two Linked Lists</a> </li>
<li><a href="http://www.geeksforgeeks.org/lowest-common-ancestor-in-a-binary-search-tree/"> Lowest Common Ancestor in a BST.</span></a> </li>
<li><a href="http://www.geeksforgeeks.org/a-program-to-check-if-a-binary-tree-is-bst-or-not/"> Check if a binary tree is BST or not</a> </li>
<li><a href="http://www.geeksforgeeks.org/sorted-linked-list-to-balanced-bst/"> Sorted Linked List to Balanced BST</a></li>
</ul></div>
		</li>
<li id="text-3" class="widget widget_text">			<div class="textwidget"><a href="https://twitter.com/GeeksforGeeks" class="twitter-follow-button" data-show-count="false">Follow @GeeksforGeeks</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>         


<!-- GOOGLE FEEDBURNER BUTTON-->
<a href="http://feeds.feedburner.com/Geeksforgeeks" title="Subscribe to my feed" rel="alternate" type="application/rss+xml"><img src="http://www.feedburner.com/fb/images/pub/feed-icon32x32.png" alt="" style="border:0"/></a><a href="http://feeds.feedburner.com/Geeksforgeeks" title="Subscribe to my feed" rel="alternate" type="application/rss+xml">Subscribe</a>

</div>
		</li>
<li id="text-21" class="widget widget_text"><h2 class="widgettitle">Recent Comments</h2>
			<div class="textwidget"><script type="text/javascript" src="http://geeksforgeeks.disqus.com//recent_comments_widget.js?num_items=6&hide_avatars=1&excerpt_length=50&hide_mods=0"></script></div>
		</li>
<li id="text-22" class="widget widget_text">			<div class="textwidget"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LinkAd -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:90px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="2606115235"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LinkAd -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:90px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="2606115235"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LinkAd -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:90px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="2606115235"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
		</li>

</ul>					  
		<div class="clear"></div>

		<div id="footer">
		
		    <div class="xhtml">
                        @geeksforgeeks, <a href="http://creativecommons.org/licenses/by-nc-nd/2.5/in/deed.en_US" title="Valid XHTML Strict 1.0">Some rights reserved</a>  <a href="http://www.geeksforgeeks.org/about/contact-us/"> &nbsp; &nbsp; &nbsp; &nbsp;Contact Us!</a>

		    </div>
		    
		    <div class="credits">
			  Powered by <a href="http://wordpress.org">WordPress </a> &amp; <a href="http://mootools.net/" title="Mootools JavaScript Framework">MooTools</a>, customized by geeksforgeeks team </div>
			  
		   <div class="clear"></div>						                            
		   
		</div> <!--end footer-->  
        
		        <script type="text/javascript">
        // <![CDATA[
        var disqus_shortname = 'geeksforgeeks';
        (function () {
            var nodes = document.getElementsByTagName('span');
            for (var i = 0, url; i < nodes.length; i++) {
                if (nodes[i].className.indexOf('dsq-postid') != -1) {
                    nodes[i].parentNode.setAttribute('data-disqus-identifier', nodes[i].getAttribute('rel'));
                    url = nodes[i].parentNode.href.split('#', 1);
                    if (url.length == 1) { url = url[0]; }
                    else { url = url[1]; }
                    nodes[i].parentNode.href = url + '#disqus_thread';
                }
            }
            var s = document.createElement('script'); 
            s.async = true;
            s.type = 'text/javascript';
            s.src = '//' + disqus_shortname + '.disqus.com/count.js';
            (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
        }());
        // ]]>
        </script>
        <script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/scripts/shCore.js?ver=3.0.9'></script>
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/scripts/shBrushCpp.js?ver=3.0.9'></script>
<script type='text/javascript'>
	(function(){
		var corecss = document.createElement('link');
		var themecss = document.createElement('link');
		var corecssurl = "http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/styles/shCore.css?ver=3.0.9";
		if ( corecss.setAttribute ) {
				corecss.setAttribute( "rel", "stylesheet" );
				corecss.setAttribute( "type", "text/css" );
				corecss.setAttribute( "href", corecssurl );
		} else {
				corecss.rel = "stylesheet";
				corecss.href = corecssurl;
		}
		document.getElementsByTagName("head")[0].insertBefore( corecss, document.getElementById("syntaxhighlighteranchor") );
		var themecssurl = "http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/styles/shThemeDefault.css?ver=3.0.9";
		if ( themecss.setAttribute ) {
				themecss.setAttribute( "rel", "stylesheet" );
				themecss.setAttribute( "type", "text/css" );
				themecss.setAttribute( "href", themecssurl );
		} else {
				themecss.rel = "stylesheet";
				themecss.href = themecssurl;
		}
		//document.getElementById("syntaxhighlighteranchor").appendChild(themecss);
		document.getElementsByTagName("head")[0].insertBefore( themecss, document.getElementById("syntaxhighlighteranchor") );
	})();
	SyntaxHighlighter.config.strings.expandSource = '+ expand source';
	SyntaxHighlighter.config.strings.help = '?';
	SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
	SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
	SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
	SyntaxHighlighter.defaults['gutter'] = false;
	SyntaxHighlighter.defaults['pad-line-numbers'] = true;
	SyntaxHighlighter.defaults['toolbar'] = false;
	SyntaxHighlighter.all();
</script>
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/bbpress/templates/default/js/editor.js?ver=2.5.4-5380'></script>
				  
		</div> <!--end wrapper-->
        <div id="ajaxSpinner"></div> <!--For AJAX spinner holder-->
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-12148232-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
	</body>

</html>
<!-- Dynamic page generated in 0.244 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2014-11-27 23:31:07 -->

<!-- Compression = gzip -->
<!-- super cache -->