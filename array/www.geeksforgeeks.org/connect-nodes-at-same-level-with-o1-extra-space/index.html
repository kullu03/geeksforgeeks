<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
       <title>Connect nodes at same level using constant extra space - GeeksforGeeks</title>
       <style type="text/css" media="screen">
          @import url('http://d2o58evtke57tz.cloudfront.net/wp-content/themes/minimoo/style.css');
    </style>
      <link href="http://d2o58evtke57tz.cloudfront.net/wp-content/themes/minimoo/favicon.ico" rel="shortcut icon" />    
    
<!-- This site is optimized with the Yoast WordPress SEO plugin v1.7.1 - https://yoast.com/wordpress/plugins/seo/ -->
<link rel="canonical" href="http://www.geeksforgeeks.org/connect-nodes-at-same-level-with-o1-extra-space/" />
<meta property="og:locale" content="en_US" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Connect nodes at same level using constant extra space - GeeksforGeeks" />
<meta property="og:description" content="Write a function to connect all the adjacent nodes at the same level in a binary tree. Structure of the given Binary Tree node is like following. Initially, all the nextRight pointers point to garbage values. Your function should set these pointers to point next right for each node. You can use only constant extra &hellip;" />
<meta property="og:url" content="http://www.geeksforgeeks.org/connect-nodes-at-same-level-with-o1-extra-space/" />
<meta property="og:site_name" content="GeeksforGeeks" />
<meta property="article:section" content="Trees" />
<meta property="article:published_time" content="2012-01-12T13:45:11+00:00" />
<meta property="article:modified_time" content="2012-01-20T09:56:03+00:00" />
<meta property="og:updated_time" content="2012-01-20T09:56:03+00:00" />
<!-- / Yoast WordPress SEO plugin. -->

<link rel='stylesheet' id='wp-quicklatex-format-css'  href='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/wp-quicklatex/css/quicklatex-format.css?ver=4.0.1' type='text/css' media='all' />
<link rel='stylesheet' id='bbp-default-css'  href='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/bbpress/templates/default/css/bbpress.css?ver=2.5.4-5380' type='text/css' media='screen' />
<link rel='stylesheet' id='wp-pagenavi-css'  href='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/wp-pagenavi/pagenavi-css.css?ver=2.70' type='text/css' media='all' />
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-includes/js/jquery/jquery.js?ver=1.11.1'></script>
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-includes/js/jquery/jquery-migrate.min.js?ver=1.2.1'></script>
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/wp-quicklatex/js/wp-quicklatex-frontend.js?ver=1.0'></script>

<!-- Bad Behavior 2.2.16 run time: 1.498 ms -->
<script type="text/javascript">
<!--
function bb2_addLoadEvent(func) {
	var oldonload = window.onload;
	if (typeof window.onload != 'function') {
		window.onload = func;
	} else {
		window.onload = function() {
			oldonload();
			func();
		}
	}
}

bb2_addLoadEvent(function() {
	for ( i=0; i < document.forms.length; i++ ) {
		if (document.forms[i].method == 'post') {
			var myElement = document.createElement('input');
			myElement.setAttribute('type', 'hidden');
			myElement.name = 'bb2_screener_';
			myElement.value = '1417111196 210.212.53.139 172.19.11.169';
			document.forms[i].appendChild(myElement);
		}
	}
});
// --></script>
		<style type="text/css" id="syntaxhighlighteranchor"></style>
   <meta name="google-site-verification" content="rHK2v8_zzuAZQY8JHAzbllDN8u-aQxcn2Kqnp67Old0" />
</head>

<body>
<!-- o4dI0sCXUgoSONabbd8mbZ4SA3E -->    
    <div id="wrapper">
        <div class="blog-info">
                <h1 class="blog-title">
                <a href="http://www.geeksforgeeks.org" title="GeeksforGeeks">GeeksforGeeks</a>
            </h1>
       
            <div class="blog-description">
                A computer science portal for geeks            </div>
        </div>
        <b><p>  <h2 align="right"> <a href="http://geeksquiz.com/">GeeksQuiz</a></h2> 
   <a href="http://www.geeksforgeeks.org/wp-login.php">Login</a> 
         </p></b>  
         
         <div class="clear"></div>         
              
                     
            <div id="menu">   
                 <ul>
 <li><a href="http://www.geeksforgeeks.org">Home</a></li>
  <li><a href="http://www.geeksforgeeks.org/fundamentals-of-algorithms/">Algorithms</a></li>
 <li><a href="http://www.geeksforgeeks.org/data-structures/">DS</a></li>
  <li><a href="http://www.geeksforgeeks.org/gate-corner/">GATE</a></li>
  <li><a href="http://www.geeksforgeeks.org/about/interview-corner/">Interview Corner</a></li>
  <li><a href="http://www.geeksforgeeks.org/forums/">Q&A</a></li>
  <li><a href="http://www.geeksforgeeks.org/c/">C</a></li>
  <li><a href="http://www.geeksforgeeks.org/c-plus-plus/">C++</a></li>
  <li><a href="http://www.geeksforgeeks.org/java/">Java</a></li>
  <li><a href="http://www.geeksforgeeks.org/books/">Books</a></li>
  <li><a href="http://www.geeksforgeeks.org/contribute/">Contribute</a></li>
  <li><a href="http://www.geeksforgeeks.org/contribute/ask-a-question/">Ask a Q</a></li>
  <li><a href="http://www.geeksforgeeks.org/about/">About</a></li>
            </ul>

               
            <div class="clear"></div>     
        </div>
             <div id="navmenu">
				<ul id="menu" style="padding:0; margin:0;">
						<li class="cat-item cat-item-3"><a href="http://www.geeksforgeeks.org/category/c-arrays/" title="Questions regarding Arrays">Array</a>
</li>	

	<li class="cat-item cat-item-17"><a href="http://www.geeksforgeeks.org/category/bit-magic/" title="View all posts filed under Bit Magic">Bit Magic</a>
</li>
	<li class="cat-item cat-item-14"><a href="http://www.geeksforgeeks.org/category/c-puzzles/" title="View all posts filed under C/C++ Puzzles">C/C++</a>
</li>

<li class="cat-item cat-item-18"><a href="http://www.geeksforgeeks.org/category/articles/" title="View all posts filed under Articles">Articles</a>
</li>

	<li class="cat-item cat-item-67"><a href="http://www.geeksforgeeks.org/category/gfact/" title="View all posts filed under GFacts">GFacts</a>
</li>
	<li class="cat-item cat-item-8"><a href="http://www.geeksforgeeks.org/category/linked-list/" title="Linked List problems">Linked List</a>
</li>
	<li class="cat-item cat-item-66"><a href="http://www.geeksforgeeks.org/category/multiple-choice-question/" title="View all posts filed under MCQ">MCQ</a>

</li>
	<li class="cat-item cat-item-4"><a href="http://www.geeksforgeeks.org/category/c-programs/" title="Miscellaneous">Misc</a>
</li>
	<li class="cat-item cat-item-5"><a href="http://www.geeksforgeeks.org/category/program-output/" title="View all posts filed under Output">Output</a>
</li>
	<li class="cat-item cat-item-7"><a href="http://www.geeksforgeeks.org/category/c-strings/" title="Questions related to strings">String</a>
</li>
	<li class="cat-item cat-item-19"><a href="http://www.geeksforgeeks.org/category/tree/" title="View all posts filed under Trees">Tree</a>
</li>
	<li class="cat-item cat-item-19"><a href="http://www.geeksforgeeks.org/category/graph/" title="View all posts filed under Graph">Graph</a>
</li>
</ul>
        </div>
             <div id="content">	   	
	<div class="post" id="post">
							<div class="post-info">			
					<div class="post-title-info">
						<h2 class="post-title">Connect nodes at same level using constant extra space</h2>
					</div>			
					<div class="clear"></div>				  
				<div class="post-content" id="post-content">
					<p>Write a function to connect all the adjacent nodes at the same level in a binary tree. Structure of the given Binary Tree node is like following.<span id="more-16952"></span></p>
<pre class="brush: cpp; title: ; notranslate" title="">
struct node {
  int data;
  struct node* left;
  struct node* right;
  struct node* nextRight;
}
</pre>
<p>Initially, all the nextRight pointers point to garbage values. Your function should set these pointers to point next right for each node. You can use only constant extra space.</p>
<p>Example</p>
<pre>
Input Tree
       A
      / \
     B   C
    / \   \
   D   E   F

Output Tree
       A--->NULL
      / \
     B-->C-->NULL
    / \   \
   D-->E-->F-->NULL
</pre>
<p>We discussed two different approaches to do it in the <a href="http://www.geeksforgeeks.org/archives/8631">previous post</a>. The auxiliary space required in both of those approaches is not constant.  Also, the method 2 discussed there only works for complete Binary Tree.  </p>
<p>In this post, we will first modify the method 2 to make it work for all kind of trees.  After that, we will remove recursion from this method so that the extra space becomes constant.</p>
<p><strong>A Recursive Solution</strong><br />
In the method 2 of previous post, we traversed the nodes in pre order fashion.  Instead of traversing in Pre Order fashion (root, left, right), if we traverse the nextRight node before the left and right children (root, nextRight, left), then we can make sure that all nodes at level i have the nextRight set, before the level i+1 nodes.  Let us consider the following example (same example as <a href="http://www.geeksforgeeks.org/archives/8631">previous post</a>).  The method 2 fails for right child of node 4.  In this method, we make sure that all nodes at the 4&#8217;s level (level 2) have nextRight set, before we try to set the nextRight of 9.  So when we set the nextRight of 9, we search for a nonleaf node on right side of node 4 (getNextRight() does this for us).</p>
<pre>
            1            -------------- Level 0
          /    \
        2        3       -------------- Level 1
       / \      /  \
      4   5    6    7    -------------- Level 2
     / \           / \
    8   9        10   11 -------------- Level 3
</pre>
<pre class="brush: cpp; highlight: [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75]; title: ; notranslate" title="">
void connectRecur(struct node* p);
struct node *getNextRight(struct node *p);

// Sets the nextRight of root and calls connectRecur() for other nodes
void connect (struct node *p)
{
    // Set the nextRight for root
    p-&gt;nextRight = NULL;

    // Set the next right for rest of the nodes (other than root)
    connectRecur(p);
}

/* Set next right of all descendents of p. This function makes sure that
nextRight of nodes ar level i is set before level i+1 nodes. */
void connectRecur(struct node* p)
{
    // Base case
    if (!p)
       return;

    /* Before setting nextRight of left and right children, set nextRight
    of children of other nodes at same level (because we can access 
    children of other nodes using p's nextRight only) */
    if (p-&gt;nextRight != NULL)
       connectRecur(p-&gt;nextRight);

    /* Set the nextRight pointer for p's left child */
    if (p-&gt;left)
    {
       if (p-&gt;right)
       {
           p-&gt;left-&gt;nextRight = p-&gt;right;
           p-&gt;right-&gt;nextRight = getNextRight(p);
       }
       else
           p-&gt;left-&gt;nextRight = getNextRight(p);

       /* Recursively call for next level nodes.  Note that we call only
       for left child. The call for left child will call for right child */
       connectRecur(p-&gt;left);
    }

    /* If left child is NULL then first node of next level will either be
      p-&gt;right or getNextRight(p) */
    else if (p-&gt;right)
    {
        p-&gt;right-&gt;nextRight = getNextRight(p);
        connectRecur(p-&gt;right);
    }
    else
       connectRecur(getNextRight(p));
}

/* This function returns the leftmost child of nodes at the same level as p.
   This function is used to getNExt right of p's right child
   If right child of p is NULL then this can also be used for the left child */
struct node *getNextRight(struct node *p)
{
    struct node *temp = p-&gt;nextRight;

    /* Traverse nodes at p's level and find and return
       the first node's first child */
    while(temp != NULL)
    {
        if(temp-&gt;left != NULL)
            return temp-&gt;left;
        if(temp-&gt;right != NULL)
            return temp-&gt;right;
        temp = temp-&gt;nextRight;
    }

    // If all the nodes at p's level are leaf nodes then return NULL
    return NULL;
}

</pre>
<p></br><br />
<strong>An Iterative Solution </strong><br />
The recursive approach discussed above can be easily converted to iterative.  In the iterative version, we use nested loop. The outer loop, goes through all the levels and the inner loop goes through all the nodes at every level.  This solution uses constant space.</p>
<pre class="brush: cpp; highlight: [34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80]; title: ; notranslate" title="">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct node
{
    int data;
    struct node *left;
    struct node *right;
    struct node *nextRight;
};

/* This function returns the leftmost child of nodes at the same level as p.
   This function is used to getNExt right of p's right child
   If right child of is NULL then this can also be sued for the left child */
struct node *getNextRight(struct node *p)
{
    struct node *temp = p-&gt;nextRight;

    /* Traverse nodes at p's level and find and return
       the first node's first child */
    while (temp != NULL)
    {
        if (temp-&gt;left != NULL)
            return temp-&gt;left;
        if (temp-&gt;right != NULL)
            return temp-&gt;right;
        temp = temp-&gt;nextRight;
    }

    // If all the nodes at p's level are leaf nodes then return NULL
    return NULL;
}

/* Sets nextRight of all nodes of a tree with root as p */
void connect(struct node* p)
{
    struct node *temp;

    if (!p)
      return;

    // Set nextRight for root
    p-&gt;nextRight = NULL;

    // set nextRight of all levels one by one
    while (p != NULL)
    {
        struct node *q = p;

        /* Connect all childrem nodes of p and children nodes of all other nodes
          at same level as p */
        while (q != NULL)
        {
            // Set the nextRight pointer for p's left child
            if (q-&gt;left)
            {
                // If q has right child, then right child is nextRight of
                // p and we also need to set nextRight of right child
                if (q-&gt;right)
                    q-&gt;left-&gt;nextRight = q-&gt;right;
                else
                    q-&gt;left-&gt;nextRight = getNextRight(q);
            }

            if (q-&gt;right)
                q-&gt;right-&gt;nextRight = getNextRight(q);

            // Set nextRight for other nodes in pre order fashion
            q = q-&gt;nextRight;
        }

        // start from the first node of next level
        if (p-&gt;left)
           p = p-&gt;left;
        else if (p-&gt;right)
           p = p-&gt;right;
        else
           p = getNextRight(p);
    }
}

/* UTILITY FUNCTIONS */
/* Helper function that allocates a new node with the
   given data and NULL left and right pointers. */
struct node* newnode(int data)
{
    struct node* node = (struct node*)
                        malloc(sizeof(struct node));
    node-&gt;data = data;
    node-&gt;left = NULL;
    node-&gt;right = NULL;
    node-&gt;nextRight = NULL;

    return(node);
}

/* Driver program to test above functions*/
int main()
{

    /* Constructed binary tree is
              10
            /   \
          8      2
        /         \
      3            90
    */
    struct node *root = newnode(10);
    root-&gt;left        = newnode(8);
    root-&gt;right       = newnode(2);
    root-&gt;left-&gt;left  = newnode(3);
    root-&gt;right-&gt;right       = newnode(90);

    // Populates nextRight pointer in all nodes
    connect(root);

    // Let us check the values of nextRight pointers
    printf(&quot;Following are populated nextRight pointers in the tree &quot;
           &quot;(-1 is printed if there is no nextRight) \n&quot;);
    printf(&quot;nextRight of %d is %d \n&quot;, root-&gt;data,
           root-&gt;nextRight? root-&gt;nextRight-&gt;data: -1);
    printf(&quot;nextRight of %d is %d \n&quot;, root-&gt;left-&gt;data,
           root-&gt;left-&gt;nextRight? root-&gt;left-&gt;nextRight-&gt;data: -1);
    printf(&quot;nextRight of %d is %d \n&quot;, root-&gt;right-&gt;data,
           root-&gt;right-&gt;nextRight? root-&gt;right-&gt;nextRight-&gt;data: -1);
    printf(&quot;nextRight of %d is %d \n&quot;, root-&gt;left-&gt;left-&gt;data,
           root-&gt;left-&gt;left-&gt;nextRight? root-&gt;left-&gt;left-&gt;nextRight-&gt;data: -1);
    printf(&quot;nextRight of %d is %d \n&quot;, root-&gt;right-&gt;right-&gt;data,
           root-&gt;right-&gt;right-&gt;nextRight? root-&gt;right-&gt;right-&gt;nextRight-&gt;data: -1);

    getchar();
    return 0;
}
</pre>
<p>Output:</p>
<pre>
Following are populated nextRight pointers in the tree (-1 is printed if 
there is no nextRight)
nextRight of 10 is -1
nextRight of 8 is 2
nextRight of 2 is -1
nextRight of 3 is 90
nextRight of 90 is -1
</pre>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
		
&nbsp;
&nbsp;
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle"
     style="display:inline-block;width:336px;height:280px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="4061219431"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>



&nbsp;
&nbsp;
&nbsp;
<h3>Related Topics:</h3><ul><li><a href="http://www.geeksforgeeks.org/perfect-binary-tree-specific-level-order-traversal/" title="Perfect Binary Tree Specific Level Order Traversal">Perfect Binary Tree Specific Level Order Traversal</a></li><li><a href="http://www.geeksforgeeks.org/print-nodes-top-view-binary-tree/" title="Print Nodes in Top View of Binary Tree">Print Nodes in Top View of Binary Tree</a></li><li><a href="http://www.geeksforgeeks.org/k-dimensional-tree/" title="K Dimensional Tree">K Dimensional Tree</a></li><li><a href="http://www.geeksforgeeks.org/convert-binary-tree-threaded-binary-tree/" title="Convert a Binary Tree to Threaded binary tree">Convert a Binary Tree to Threaded binary tree</a></li><li><a href="http://www.geeksforgeeks.org/serialize-deserialize-n-ary-tree/" title="Serialize and Deserialize an N-ary Tree">Serialize and Deserialize an N-ary Tree</a></li><li><a href="http://www.geeksforgeeks.org/serialize-deserialize-binary-tree/" title="Serialize and Deserialize a Binary Tree">Serialize and Deserialize a Binary Tree</a></li><li><a href="http://www.geeksforgeeks.org/given-binary-tree-print-nodes-two-given-level-numbers/" title="Print nodes between two given level numbers of a binary tree">Print nodes between two given level numbers of a binary tree</a></li><li><a href="http://www.geeksforgeeks.org/find-height-binary-tree-represented-parent-array/" title="Find Height of Binary Tree represented by Parent array">Find Height of Binary Tree represented by Parent array</a></li></ul>
<p></p> 
<div>
<iframe src="http://www.facebook.com/plugins/like.php?href=http%3A%2F%2Fwww.geeksforgeeks.org%2Fconnect-nodes-at-same-level-with-o1-extra-space%2F&layout=button_count&show_faces=false&width=90&action=like&colorscheme=light" scrolling="no" frameborder="0" allowTransparency="true" style="border:none; overflow:hidden; width:90px; height:20px"></iframe>
<a href="http://twitter.com/share" class="twitter-share-button" data-url="http://www.geeksforgeeks.org/connect-nodes-at-same-level-with-o1-extra-space/" data-text="Connect nodes at same level using constant extra space" data-count="horizontal" data-via="jakerutter">Tweet</a><script type="text/javascript" src="http://platform.twitter.com/widgets.js"></script>
<g:plusone size="medium" href="http://www.geeksforgeeks.org/connect-nodes-at-same-level-with-o1-extra-space/"></g:plusone>
<!-- Place this render call where appropriate -->
<script type="text/javascript">
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script></div>





				</div>		  
			</div> <!-- end post main -->					
			<div class="post-meta">
				<div class="left"></div>				
				<div class="clear"></div>
			</div>			
        
			<div class="comments-main">		
 <b>Writing code in comment?</b> Please use <b><a href="http://ideone.com/">ideone.com</a></b> and share the link here.
				
<div id="disqus_thread">
            <div id="dsq-content">


            <ul id="dsq-comments">
                    <li class="comment even thread-even depth-1" id="dsq-comment-31995">
        <div id="dsq-comment-header-31995" class="dsq-comment-header">
            <cite id="dsq-cite-31995">
                <span id="dsq-author-user-31995">Tushar K Gupta</span>
            </cite>
        </div>
        <div id="dsq-comment-body-31995" class="dsq-comment-body">
            <div id="dsq-comment-message-31995" class="dsq-comment-message"><p>We do not need the extra function getNextRight(struct node *p), and logic can be simplified very easily.Simply do a level order traversal , using a queue (order is left to right).  Keep a prevNode pointer to the first node of every level, when we get next node on same level , point prevNode -&gt;rightconnect to current and modify prevNode to current.<br />
Only thing is while initializing the nodes , we have to set rightconnect = NULL else we can do simple modification in below code.</p>
<p>void LevelOrderTraverse(node * root)<br />
{<br />
    if(root == NULL)<br />
           return;<br />
     queue qTree ;<br />
     qTree.push(root);</p>
<p>     while(qTree.size() &gt; 0)<br />
     {<br />
node * prevNode = NULL ;<br />
            int nSize = qTree.size();<br />
            for(int nIndex = 0 ; nIndex nextRight = temp; }<br />
                        prevNode = temp ;<br />
                        if(temp-&gt;left)<br />
                                  qTree.push(temp-&gt;left);<br />
                       if(temp-&gt;right)<br />
                                   qTree.push(temp-&gt;right);<br />
              }<br />
       }<br />
}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-31302">
        <div id="dsq-comment-header-31302" class="dsq-comment-header">
            <cite id="dsq-cite-31302">
                <span id="dsq-author-user-31302">abi</span>
            </cite>
        </div>
        <div id="dsq-comment-body-31302" class="dsq-comment-body">
            <div id="dsq-comment-message-31302" class="dsq-comment-message"><p>what is the worst case time complexity?</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-31122">
        <div id="dsq-comment-header-31122" class="dsq-comment-header">
            <cite id="dsq-cite-31122">
                <span id="dsq-author-user-31122">wgpshashank</span>
            </cite>
        </div>
        <div id="dsq-comment-body-31122" class="dsq-comment-body">
            <div id="dsq-comment-message-31122" class="dsq-comment-message"><p>We need to calculate the getNextRight if we can make sure while doing preorder traversal , that nextRight will be set correct node.Check the below code and let me know if anything wrong in that.</p>
<p>#include<br />
#include </p>
<p>/* A binary tree node has data, pointer to left child<br />
   and a pointer to right child */<br />
struct node<br />
{<br />
    int data;<br />
    struct node* left;<br />
    struct node* right;<br />
    struct node* nextRight;</p>
<p>};</p>
<p>/* Helper function that allocates a new node with the<br />
   given data and NULL left and right pointers. */<br />
struct node* newNode(int data)<br />
{<br />
  struct node* node = (struct node*)<br />
                       malloc(sizeof(struct node));<br />
  node-&gt;data = data;<br />
  node-&gt;left = NULL;<br />
  node-&gt;right = NULL;<br />
  node-&gt;nextRight=NULL;<br />
  return(node);<br />
}</p>
<p>void connect(struct node* p) {<br />
  if (!p)<br />
  return;</p>
<p>  if (p-&gt;left)<br />
  {<br />
    if(p-&gt;right)//its necessary else NULL Pointer Exception<br />
          p-&gt;left-&gt;nextRight = p-&gt;right;</p>
<p>    else if(p-&gt;nextRight)<br />
    {<br />
        if(p-&gt;nextRight-&gt;left)/// we can add one more if(p-&gt;nextRight)<br />
          p-&gt;left-&gt;nextRight=p-&gt;nextRight-&gt;left;<br />
        else if(p-&gt;nextRight-&gt;right)<br />
          p-&gt;left-&gt;nextRight=p-&gt;nextRight-&gt;right;<br />
    }<br />
    else<br />
         p-&gt;left-&gt;nextRight=NULL;//if all are null except that node at that level<br />
  }</p>
<p>  if (p-&gt;right)<br />
  {<br />
    if(p-&gt;nextRight)<br />
    {<br />
        if(p-&gt;nextRight-&gt;left)//skipping checking the root null or not<br />
            p-&gt;right-&gt;nextRight =p-&gt;nextRight-&gt;left;<br />
        else if(p-&gt;nextRight-&gt;right)//skipping checking the root null or not<br />
            p-&gt;right-&gt;nextRight =p-&gt;nextRight-&gt;right;<br />
    }<br />
    else<br />
             p-&gt;right-&gt;nextRight=NULL;<br />
  }<br />
  connect(p-&gt;left);<br />
  connect(p-&gt;right);<br />
}</p>
<p>/* Driver program to test above functions*/<br />
int main()<br />
{<br />
  struct node *root = newNode(1);<br />
  root-&gt;left        = newNode(2);<br />
  root-&gt;right       = newNode(3);<br />
  root-&gt;left-&gt;left  = newNode(4);<br />
  root-&gt;left-&gt;right  = newNode(5);<br />
  root-&gt;right-&gt;left= newNode(6);<br />
  root-&gt;right-&gt;right= newNode(7);<br />
  root-&gt;left-&gt;left-&gt;left  = newNode(8);<br />
  root-&gt;left-&gt;left-&gt;right  = newNode(9);<br />
  root-&gt;left-&gt;right-&gt;left  = newNode(10);<br />
  root-&gt;left-&gt;right-&gt;right  = newNode(11);<br />
  root-&gt;right-&gt;left-&gt;left= newNode(12);<br />
  root-&gt;right-&gt;left-&gt;right= newNode(13);<br />
  root-&gt;right-&gt;right-&gt;left= newNode(14);<br />
  root-&gt;right-&gt;right-&gt;right= newNode(15); </p>
<p>  connect(root);</p>
<p>  printf( &#8221; %d %d %d &#8220;, root-&gt;left-&gt;nextRight-&gt;data,root-&gt;left-&gt;right-&gt;nextRight-&gt;data,root-&gt;right-&gt;left-&gt;nextRight-&gt;data);<br />
  printf(&#8221; %d %d %d &#8220;,root-&gt;left-&gt;left-&gt;left-&gt;nextRight-&gt;data,root-&gt;left-&gt;left-&gt;right-&gt;nextRight-&gt;data,root-&gt;right-&gt;right-&gt;left-&gt;nextRight-&gt;data);//,root-&gt;right-&gt;right-&gt;right-&gt;nextRight-&gt;data); it will be null </p>
<p>  getchar();<br />
  return 0;<br />
}</p>
<p>Run Here<br />
<a href="http://ideone.com/V1v5mX" rel="nofollow">http://ideone.com/V1v5mX</a></p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-28403">
        <div id="dsq-comment-header-28403" class="dsq-comment-header">
            <cite id="dsq-cite-28403">
                <span id="dsq-author-user-28403">Yash</span>
            </cite>
        </div>
        <div id="dsq-comment-body-28403" class="dsq-comment-body">
            <div id="dsq-comment-message-28403" class="dsq-comment-message"><p>Here is my Implementation:</p>
<p>Add nodes at each level to vector followed by NULL that stands for end of a level. Set nextRight to the next element in vector until u get a null. After setting the nextrights of a level, simply process each element and add its node to the end of the vector and repeat the process.</p>
<p>void connetNodeAtLevels(node * head) {</p>
<p>    vector queue;<br />
    int processingIndex=0,levelIndex;</p>
<p>    queue.push_back(head);<br />
    queue.push_back(NULL);</p>
<p>    while(queue[processingIndex]) {</p>
<p>        levelIndex = processingIndex;<br />
        while(queue[levelIndex]) {<br />
            queue[levelIndex]-&gt;nextRight = queue[levelIndex+1];<br />
            levelIndex++;<br />
        }</p>
<p>        while(queue[processingIndex]) {<br />
                if(queue[processingIndex]-&gt;left)<br />
                queue.push_back(queue[processingIndex]-&gt;left);<br />
            if(queue[processingIndex]-&gt;right)<br />
                queue.push_back(queue[processingIndex]-&gt;right);<br />
            processingIndex++;<br />
        }</p>
<p>        queue.push_back(NULL);<br />
        processingIndex++; //Move processing Index beyond NULL<br />
    }</p>
<p>return;<br />
}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-28220">
        <div id="dsq-comment-header-28220" class="dsq-comment-header">
            <cite id="dsq-cite-28220">
                <span id="dsq-author-user-28220">what&#8217;s in a name</span>
            </cite>
        </div>
        <div id="dsq-comment-body-28220" class="dsq-comment-body">
            <div id="dsq-comment-message-28220" class="dsq-comment-message"><p>#include</p>
<p>#include</p>
<p>#include</p>
<p>class node{</p>
<p>	public:</p>
<p>		int val;</p>
<p>		class node *left;</p>
<p>		class node *right;</p>
<p>		class node *next;</p>
<p>};</p>
<p>typedef class node *NODEPTR;</p>
<p>NODEPTR newnode(int val){</p>
<p>	NODEPTR ptr = new node();</p>
<p>	ptr-&gt;val = val;</p>
<p>	ptr-&gt;left = NULL;</p>
<p>	ptr-&gt;right = NULL;</p>
<p>	ptr-&gt;next = NULL;</p>
<p>	return ptr;</p>
<p>}</p>
<p>NODEPTR findRight(NODEPTR root){</p>
<p>	while(root){</p>
<p>		if(root-&gt;left != NULL){</p>
<p>			return root-&gt;left;</p>
<p>		}</p>
<p>		if(root-&gt;right != NULL){</p>
<p>			return root-&gt;right;</p>
<p>		}</p>
<p>		root = root-&gt;next;</p>
<p>	}	</p>
<p>}</p>
<p>void connectLevel(NODEPTR root){</p>
<p>	if(root == NULL) return;</p>
<p>	if(root-&gt;next != NULL){</p>
<p>		connectLevel(root-&gt;next);</p>
<p>	}</p>
<p>	if(root-&gt;left != NULL){</p>
<p>		if(root-&gt;right != NULL){</p>
<p>			root-&gt;left-&gt;next = root-&gt;right;</p>
<p>			root-&gt;right-&gt;next = findRight(root-&gt;next);</p>
<p>		}else{</p>
<p>			root-&gt;left-&gt;next = findRight(root-&gt;next);</p>
<p>		}</p>
<p>		connectLevel(root-&gt;left);</p>
<p>	}</p>
<p>	else if(root-&gt;right != NULL){</p>
<p>		root-&gt;right-&gt;next = findRight(root-&gt;next);</p>
<p>		connectLevel(root-&gt;right);</p>
<p>	}else </p>
<p>		connectLevel(root-&gt;right);</p>
<p>}</p>
<p>void printRight(NODEPTR root){</p>
<p>	if(root == NULL) {</p>
<p>		printf(&#8220;n&#8221;);</p>
<p>		return;</p>
<p>	}</p>
<p>	printf(&#8220;%d &#8221; , root-&gt;val);</p>
<p>	printRight(root-&gt;next);</p>
<p>}</p>
<p>void printLevel(NODEPTR root){</p>
<p>	if(root == NULL) return;</p>
<p>	printf(&#8220;%d &#8221; , root-&gt;val);</p>
<p>	printRight(root-&gt;next);	</p>
<p>	if(root-&gt;left != NULL){</p>
<p>		printLevel(root-&gt;left);</p>
<p>	}else if(root-&gt;right != NULL){</p>
<p>		printLevel(root-&gt;right);</p>
<p>	}else{</p>
<p>		printLevel(findRight(root-&gt;next));</p>
<p>	}</p>
<p>}</p>
<p>int main(){</p>
<p>	//Make the tree with root</p>
<p>	struct node *root = newnode(10);</p>
<p>	root-&gt;left        = newnode(8);</p>
<p>	root-&gt;right       = newnode(2);</p>
<p>	root-&gt;left-&gt;left  = newnode(3);</p>
<p>	root-&gt;right-&gt;right       = newnode(90);</p>
<p>	connectLevel(root);</p>
<p>	printLevel(root);</p>
<p>}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-27570">
        <div id="dsq-comment-header-27570" class="dsq-comment-header">
            <cite id="dsq-cite-27570">
                <span id="dsq-author-user-27570">numid</span>
            </cite>
        </div>
        <div id="dsq-comment-body-27570" class="dsq-comment-body">
            <div id="dsq-comment-message-27570" class="dsq-comment-message"><p>//We can use two queues instead for simplicity,this is a simple solution</p>
<p>#include</p>
<p>typedef struct node</p>
<p>{</p>
<p>    int data;</p>
<p>    struct node *right,*left,*sibling;</p>
<p>}node;</p>
<p>void sibling(node **root)</p>
<p>{</p>
<p>    if(*root==NULL)</p>
<p>        return;</p>
<p>    node *queue1[10],*queue2[10],*temp,*prev;</p>
<p>    int f1,f2,r1,r2;</p>
<p>    f1=f2=r1=r2=0;</p>
<p>    temp=*root;</p>
<p>    queue1[r1++]=temp;</p>
<p>    while(f1&lt;r1 || f2&lt;r2)</p>
<p>    {</p>
<p>        temp=queue1[f1];</p>
<p>        prev=NULL;</p>
<p>        while(f1left)</p>
<p>                queue2[r2++]=temp-&gt;left;</p>
<p>            if(temp-&gt;right)</p>
<p>                queue2[r2++]=temp-&gt;right;</p>
<p>            if(prev)</p>
<p>                prev-&gt;sibling=temp;</p>
<p>            temp-&gt;sibling=NULL;</p>
<p>            prev=temp;</p>
<p>            f1++;</p>
<p>            if(f1&lt;r1)</p>
<p>                temp=queue1[f1];</p>
<p>        }</p>
<p>        temp=queue2[f2];</p>
<p>        prev=NULL;</p>
<p>        while(f2left)</p>
<p>                queue1[r1++]=temp-&gt;left;</p>
<p>            if(temp-&gt;right)</p>
<p>                queue1[r1++]=temp-&gt;right;</p>
<p>            if(prev)</p>
<p>                prev-&gt;sibling=temp;</p>
<p>            temp-&gt;sibling=NULL;</p>
<p>            prev=temp;</p>
<p>            f2++;</p>
<p>            if(f2left=temp-&gt;right=NULL;</p>
<p>    temp-&gt;data=num;</p>
<p>    return temp;</p>
<p>}</p>
<p>void pre_sib(node *root)</p>
<p>{</p>
<p>    if(root)</p>
<p>    {</p>
<p>        printf(&#8220;t%d&#8221;,root-&gt;data);</p>
<p>        if(root-&gt;sibling)</p>
<p>            printf(&#8221;   sib-&gt;%d&#8221;,root-&gt;sibling-&gt;data);</p>
<p>        pre_sib(root-&gt;left);</p>
<p>        pre_sib(root-&gt;right);</p>
<p>    }</p>
<p>}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-27013">
        <div id="dsq-comment-header-27013" class="dsq-comment-header">
            <cite id="dsq-cite-27013">
                <span id="dsq-author-user-27013">venkat</span>
            </cite>
        </div>
        <div id="dsq-comment-body-27013" class="dsq-comment-body">
            <div id="dsq-comment-message-27013" class="dsq-comment-message"><p>/* Set next right of all descendents of p. This function makes sure that<br />
nextRight of nodes ar level i is set before level i+1 nodes. */<br />
void connectRecur(struct node* p)<br />
{<br />
    // Base case<br />
    if (!p)<br />
       return;</p>
<p>    /* Before setting nextRight of left and right children, set nextRight<br />
    of children of other nodes at same level (because we can access<br />
    children of other nodes using p&#8217;s nextRight only) */<br />
    if (p-&gt;nextRight != NULL)<br />
       connectRecur(p-&gt;nextRight);</p>
<p>    /* Set the nextRight pointer for p&#8217;s left child */<br />
    if (p-&gt;left)<br />
    {<br />
       if (p-&gt;right)<br />
       {<br />
           p-&gt;left-&gt;nextRight = p-&gt;right;<br />
           p-&gt;right-&gt;nextRight = getNextRight(p);<br />
       }<br />
       else<br />
           p-&gt;left-&gt;nextRight = getNextRight(p);</p>
<p>       /* Recursively call for next level nodes.  Note that we call only<br />
       for left child. The call for left child will call for right child */<br />
       connectRecur(p-&gt;left);<br />
    }</p>
<p>    /* If left child is NULL then first node of next level will either be<br />
      p-&gt;right or getNextRight(p) */<br />
    else if (p-&gt;right)<br />
    {<br />
        p-&gt;right-&gt;nextRight = getNextRight(p);<br />
        connectRecur(p-&gt;right);<br />
    }<br />
    else<br />
       connectRecur(getNextRight(p));<br />
}</p>
<p>I think in the above function provided,<br />
&#8221; Else part (   else<br />
                       connectRecur(getNextRight(p));<br />
                    )&#8221; is not required, as that subtree is already have nodes of level are connected.</p>
<p>Let me know if I am   correct.  I think that for first solution the complexity for the worst case will be O(n^2).</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-28440">
        <div id="dsq-comment-header-28440" class="dsq-comment-header">
            <cite id="dsq-cite-28440">
                <span id="dsq-author-user-28440">pavan</span>
            </cite>
        </div>
        <div id="dsq-comment-body-28440" class="dsq-comment-body">
            <div id="dsq-comment-message-28440" class="dsq-comment-message"><p>code in java  &#8230;.pls validate me&#8230;i used level order traversal &#8230;.</p>
<p>void fillRight(){<br />
        Node temp = root;<br />
        Queue q = new LinkedList();<br />
        q.add(temp);<br />
        q.add(null);</p>
<p>        while (!q.isEmpty()) {<br />
            temp = q.remove();<br />
            if(temp == null){<br />
                if(!q.isEmpty()){<br />
                    q.add(null);<br />
                }<br />
            }</p>
<p>            else{<br />
                    temp.rightSibling = q.peek();<br />
                if (temp.leftChild != null) {<br />
                    q.add(temp.leftChild);<br />
                }</p>
<p>                if (temp.rightChild != null) {<br />
                    q.add(temp.rightChild);<br />
                }<br />
            }<br />
    }</p>
<p>    }</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even depth-2" id="dsq-comment-28513">
        <div id="dsq-comment-header-28513" class="dsq-comment-header">
            <cite id="dsq-cite-28513">
                <span id="dsq-author-user-28513">hary</span>
            </cite>
        </div>
        <div id="dsq-comment-body-28513" class="dsq-comment-body">
            <div id="dsq-comment-message-28513" class="dsq-comment-message"><p>Hey Venkat, I agree to the fact that the else part i.e.</p>
<p>&#8221; Else part (   else<br />
                       connectRecur(getNextRight(p));<br />
                    )&#8221;<br />
is not required as it is already processed in the very beginning of the recursion.<br />
Further, it&#8217;s inefficient in the sense that many of the nodes in the tree are processed multiple times &#8211; as and how recursion goes deep &#8211; this will become more inefficient. I believe the iterative version is much more efficient than the recursive approach.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-27012">
        <div id="dsq-comment-header-27012" class="dsq-comment-header">
            <cite id="dsq-cite-27012">
                <span id="dsq-author-user-27012">venkat</span>
            </cite>
        </div>
        <div id="dsq-comment-body-27012" class="dsq-comment-body">
            <div id="dsq-comment-message-27012" class="dsq-comment-message"><p>/* Set next right of all descendents of p. This function makes sure that<br />
nextRight of nodes ar level i is set before level i+1 nodes. */<br />
void connectRecur(struct node* p)<br />
{<br />
    // Base case<br />
    if (!p)<br />
       return;</p>
<p>    /* Before setting nextRight of left and right children, set nextRight<br />
    of children of other nodes at same level (because we can access<br />
    children of other nodes using p&#8217;s nextRight only) */<br />
    if (p-&gt;nextRight != NULL)<br />
       connectRecur(p-&gt;nextRight);</p>
<p>    /* Set the nextRight pointer for p&#8217;s left child */<br />
    if (p-&gt;left)<br />
    {<br />
       if (p-&gt;right)<br />
       {<br />
           p-&gt;left-&gt;nextRight = p-&gt;right;<br />
           p-&gt;right-&gt;nextRight = getNextRight(p);<br />
       }<br />
       else<br />
           p-&gt;left-&gt;nextRight = getNextRight(p);</p>
<p>       /* Recursively call for next level nodes.  Note that we call only<br />
       for left child. The call for left child will call for right child */<br />
       connectRecur(p-&gt;left);<br />
    }</p>
<p>    /* If left child is NULL then first node of next level will either be<br />
      p-&gt;right or getNextRight(p) */<br />
    else if (p-&gt;right)<br />
    {<br />
        p-&gt;right-&gt;nextRight = getNextRight(p);<br />
        connectRecur(p-&gt;right);<br />
    }<br />
    else<br />
       connectRecur(getNextRight(p));<br />
}</p>
<p>I think in the above function provided,<br />
&#8221; Else part (   else<br />
                       connectRecur(getNextRight(p));<br />
                    )&#8221; is not required, as that subtree is already have nodes of level are connected.</p>
<p>Let me know if I am   correct.  I think that for first solution the complexity for the worst case will be O(n^2).</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-20916">
        <div id="dsq-comment-header-20916" class="dsq-comment-header">
            <cite id="dsq-cite-20916">
                <span id="dsq-author-user-20916">CodeC0mmit</span>
            </cite>
        </div>
        <div id="dsq-comment-body-20916" class="dsq-comment-body">
            <div id="dsq-comment-message-20916" class="dsq-comment-message"><p>Could someone comment on the time complexity in recursive approach?</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-21404">
        <div id="dsq-comment-header-21404" class="dsq-comment-header">
            <cite id="dsq-cite-21404">
                <span id="dsq-author-user-21404">Vibhu Tiwari</span>
            </cite>
        </div>
        <div id="dsq-comment-body-21404" class="dsq-comment-body">
            <div id="dsq-comment-message-21404" class="dsq-comment-message"><p>In the worst case the time complexity would be when you have to traverse all the nodes within the tree and also as it is doing the traversal in preorder traversal for which the time complexity is O(n) so overall the time complexity for this recursive approach is also O(n).</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-20899">
        <div id="dsq-comment-header-20899" class="dsq-comment-header">
            <cite id="dsq-cite-20899">
                <span id="dsq-author-user-20899">vignesh m</span>
            </cite>
        </div>
        <div id="dsq-comment-body-20899" class="dsq-comment-body">
            <div id="dsq-comment-message-20899" class="dsq-comment-message"><p>public Node toSiblingTree(){<br />
		this.root.next = null;<br />
		return toSiblingTree(root);<br />
	}</p>
<p>	public Node toSiblingTree(Node root){<br />
		if(root == null) return null;<br />
		Node left = root.left;<br />
		Node right = root.right;<br />
		if(right != null){<br />
			if(left!=null)<br />
			left.next = right;<br />
			if(root.next == null){<br />
				right.next = null;<br />
			}<br />
			else{<br />
				right.next = root.next.left != null ? root.next.left : root.next.right ;<br />
			}<br />
		}<br />
		else if (left!=null){<br />
			if(root.next == null)<br />
					left.next = null;<br />
			else{<br />
				left.next = root.next.left != null ? root.next.left : root.next.right ;<br />
			}<br />
		}</p>
<p>		root.left = toSiblingTree(left);<br />
		root.right = toSiblingTree(right);<br />
		return root;<br />
	}</p>
<p>	public void printLevelOrder(Node root){<br />
		if(root == null) return;<br />
		Node temp =root;<br />
		while(temp!=null){<br />
			System.out.print(temp.num+&quot; &quot;);<br />
			temp = temp.next;<br />
		}<br />
		System.out.println(&quot;&quot;);<br />
		temp = root;<br />
		Node left = temp.left != null ? temp.left : temp.right;<br />
		while(left == null){<br />
			if(temp == null || temp.next == null) break;<br />
			temp = temp.next;<br />
			left = temp.left != null ? temp.left : temp.right;<br />
		}<br />
		printLevelOrder(left);<br />
		return;<br />
	}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-20007">
        <div id="dsq-comment-header-20007" class="dsq-comment-header">
            <cite id="dsq-cite-20007">
                <span id="dsq-author-user-20007">hunter</span>
            </cite>
        </div>
        <div id="dsq-comment-body-20007" class="dsq-comment-body">
            <div id="dsq-comment-message-20007" class="dsq-comment-message"><p>//my solution is using queue<br />
void connectnodes(*root)<br />
{<br />
t=root;<br />
enqueue(t);<br />
enqueue(NULL);<br />
while(!isempty())<br />
{<br />
  t=dequeue();<br />
  if(t==NULL)<br />
  {<br />
if(isempty())<br />
break;<br />
else<br />
enqueue(NULL);<br />
}<br />
else<br />
{<br />
t-&gt;sibling=queuefront();<br />
if(t-&gt;left)<br />
enqueue(t-&gt;left);<br />
if(t-&gt;right)<br />
enqueue(t-&gt;right);<br />
}<br />
}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-19736">
        <div id="dsq-comment-header-19736" class="dsq-comment-header">
            <cite id="dsq-cite-19736">
                <span id="dsq-author-user-19736">logic_bomber</span>
            </cite>
        </div>
        <div id="dsq-comment-body-19736" class="dsq-comment-body">
            <div id="dsq-comment-message-19736" class="dsq-comment-message"><p>In worst case each node is traversed twice,so complexity of this algorithm is O(2*n) i.e O(n).Am i right?</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-19684">
        <div id="dsq-comment-header-19684" class="dsq-comment-header">
            <cite id="dsq-cite-19684">
                <span id="dsq-author-user-19684">pranshu</span>
            </cite>
        </div>
        <div id="dsq-comment-body-19684" class="dsq-comment-body">
            <div id="dsq-comment-message-19684" class="dsq-comment-message"><p>Is condition given in else part (connectRecur(getNextRight(p));).<br />
in recursive solution necessary?</p>
</div>
        </div>

    </li><!-- #comment-## -->
</li><!-- #comment-## -->
    <li class="comment byuser comment-author-abhishek08aug even thread-odd thread-alt depth-1" id="dsq-comment-18374">
        <div id="dsq-comment-header-18374" class="dsq-comment-header">
            <cite id="dsq-cite-18374">
                <span id="dsq-author-user-18374">abhishek08aug</span>
            </cite>
        </div>
        <div id="dsq-comment-body-18374" class="dsq-comment-body">
            <div id="dsq-comment-message-18374" class="dsq-comment-message"><p>Intelligent <img src="http://d2o58evtke57tz.cloudfront.net/wp-includes/images/smilies/icon_biggrin.gif" alt=":D" class="wp-smiley" /></p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-19288">
        <div id="dsq-comment-header-19288" class="dsq-comment-header">
            <cite id="dsq-cite-19288">
                <span id="dsq-author-user-19288">kartik</span>
            </cite>
        </div>
        <div id="dsq-comment-body-19288" class="dsq-comment-body">
            <div id="dsq-comment-message-19288" class="dsq-comment-message"><p>why do you comment same thing on every single post ?</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-14719">
        <div id="dsq-comment-header-14719" class="dsq-comment-header">
            <cite id="dsq-cite-14719">
                <span id="dsq-author-user-14719">Neo</span>
            </cite>
        </div>
        <div id="dsq-comment-body-14719" class="dsq-comment-body">
            <div id="dsq-comment-message-14719" class="dsq-comment-message"><p>Java implementation</p>
<pre> <code language="C">
public static void fixNextLink(Node root) {
			if(root == null) return;
			// The right most child for root
			Node rightmostChild = (root.rightChild != null) ? root.rightChild : root.leftChild;
			// Return, if there are no childs
			if(rightmostChild == null) return;
			// Continue to identify the sibling for root.rightmost (The right most child for root)
			Node temp = root.nextRight;
			Node leftmostSibling=null;
			while(temp != null &amp;&amp; leftmostSibling == null){
				// Left most sibling to the right in the current level from the right most node of the current node
				 leftmostSibling = (temp.leftChild != null) ? temp.leftChild : temp.rightChild;
				if(leftmostSibling != null) {
					rightmostChild.nextRight = leftmostSibling;
				}
				temp = temp.nextRight;
			}
			// Finally if the left and right child exists, connect left to right
			if (rightmostChild != root.leftChild&amp;&amp;root.leftChild!=null) {
				root.leftChild.nextRight = root.rightChild;
			}
			// Go down the tree to fix other links
			fixNextLink(root.leftChild);
			fixNextLink(root.rightChild);
		}
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-13247">
        <div id="dsq-comment-header-13247" class="dsq-comment-header">
            <cite id="dsq-cite-13247">
                <span id="dsq-author-user-13247">Paparao Veeragandham</span>
            </cite>
        </div>
        <div id="dsq-comment-body-13247" class="dsq-comment-body">
            <div id="dsq-comment-message-13247" class="dsq-comment-message"><p>void connectRecur(struct node* p)<br />
{<br />
    // Base case<br />
    if (!p)<br />
       return;</p>
<p>    /* Before setting nextRight of left and right children, set nextRight<br />
    of other nodes at same level */<br />
    if (p-&gt;nextRight != NULL)<br />
       connectRecur(p-&gt;nextRight);</p>
<p>    /* Set the nextRight pointer for p&#8217;s left child */<br />
    if (p-&gt;left)<br />
    {<br />
       if (p-&gt;right)<br />
       {<br />
           p-&gt;left-&gt;nextRight = p-&gt;right;<br />
           p-&gt;right-&gt;nextRight = getNextRight(p);<br />
       }<br />
       else<br />
           p-&gt;left-&gt;nextRight = getNextRight(p);</p>
<p>       /* Recursively call for next level nodes.  Note that we call only<br />
       for left child. The call for left child will call for right child */<br />
       connectRecur(p-&gt;left);<br />
    }</p>
<p>    /* If left child is NULL then first node on next level will be either<br />
      right child or getNextRight(p) */<br />
    else if (p-&gt;right)<br />
       connectRecur(p-&gt;right);<br />
    else<br />
       connectRecur(getNextRight(p));<br />
}</p>
<p>From the above code :<br />
   else<br />
       connectRecur(getNextRight(p));</p>
<p>Is not required. Because this scenirio already covered in below code </p>
<p>if (p-&gt;nextRight != NULL)<br />
       connectRecur(p-&gt;nextRight);</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-13246">
        <div id="dsq-comment-header-13246" class="dsq-comment-header">
            <cite id="dsq-cite-13246">
                <span id="dsq-author-user-13246">Paparao Veeragandham</span>
            </cite>
        </div>
        <div id="dsq-comment-body-13246" class="dsq-comment-body">
            <div id="dsq-comment-message-13246" class="dsq-comment-message"><pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */



if (p-&gt;nextRight != NULL)
       connectRecur(p-&gt;nextRight);
 
    /* Set the nextRight pointer for p's left child */
    if (p-&gt;left)
    {
       if (p-&gt;right)
       {
           p-&gt;left-&gt;nextRight = p-&gt;right;
           p-&gt;right-&gt;nextRight = getNextRight(p);
       }
       else
           p-&gt;left-&gt;nextRight = getNextRight(p);
 
       /* Recursively call for next level nodes.  Note that we call only
       for left child. The call for left child will call for right child */
       connectRecur(p-&gt;left);
    }
 
    /* If left child is NULL then first node on next level will be either
      right child or getNextRight(p) */
    else if (p-&gt;right)
       connectRecur(p-&gt;right);
    else
       connectRecur(getNextRight(p));



From the above code :

  else
       connectRecur(getNextRight(p));

Above statement is not required. Because it is already covered by below statement:

if (p-&gt;nextRight != NULL)
       connectRecur(p-&gt;nextRight);


Correct me If i was wrong. 





</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-13823">
        <div id="dsq-comment-header-13823" class="dsq-comment-header">
            <cite id="dsq-cite-13823">
                <span id="dsq-author-user-13823">rahul sundar</span>
            </cite>
        </div>
        <div id="dsq-comment-body-13823" class="dsq-comment-body">
            <div id="dsq-comment-message-13823" class="dsq-comment-message"><p>You are correct!</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-9763">
        <div id="dsq-comment-header-9763" class="dsq-comment-header">
            <cite id="dsq-cite-9763">
                <span id="dsq-author-user-9763">priso</span>
            </cite>
        </div>
        <div id="dsq-comment-body-9763" class="dsq-comment-body">
            <div id="dsq-comment-message-9763" class="dsq-comment-message"><p>Why cant it be much simplified? by traversing the right sub-tree first and then traversing the left sub-tree?</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
// Sets the nextRight of root and calls connectRecur() for other nodes
void connect (struct node *p)
{
    // Set the nextRight for root
    p-&gt;nextRight = NULL;
 
    // Set the next right for rest of the nodes (other than root)
    connectRecur(p);
}
 
/* Set next right of all descendents of p. */
void connectRecur(struct node* p)
{
  // Base case
  if (!p)
    return;
 
  // Set the nextRight pointer for p's left child
  if (p-&gt;left)
    p-&gt;left-&gt;nextRight = (p-&gt;right)? p-&gt;right : getNextRight(p);
 
  // Set the nextRight pointer for p's right child
  // p-&gt;nextRight will be NULL if p is the right most child at its level
  if (p-&gt;right)
    p-&gt;right-&gt;nextRight = getNextRight(p);
 
  // First populate the right tree and then come to left sub-tree
  
  connectRecur(p-&gt;right);
  connectRecur(p-&gt;left);
}

struct node *getNextRight(struct node *p)
{
    struct node *temp = p-&gt;nextRight;
 
    /* Traverse nodes at p's level and find and return
       the first node's first child */
    while(temp != NULL)
    {
        if(temp-&gt;left != NULL)
            return temp-&gt;left;
        if(temp-&gt;right != NULL)
            return temp-&gt;right;
        temp = temp-&gt;nextRight;
    }
 
    // If all the nodes at p's level are leaf nodes then return NULL
    return NULL;
}
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-12133">
        <div id="dsq-comment-header-12133" class="dsq-comment-header">
            <cite id="dsq-cite-12133">
                <span id="dsq-author-user-12133">Palash</span>
            </cite>
        </div>
        <div id="dsq-comment-body-12133" class="dsq-comment-body">
            <div id="dsq-comment-message-12133" class="dsq-comment-message"><p>Yeah, it&#8217;ll work.</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-8971">
        <div id="dsq-comment-header-8971" class="dsq-comment-header">
            <cite id="dsq-cite-8971">
                <span id="dsq-author-user-8971">N.Balasubramanian</span>
            </cite>
        </div>
        <div id="dsq-comment-body-8971" class="dsq-comment-body">
            <div id="dsq-comment-message-8971" class="dsq-comment-message"><p>I have one doubt in the recursive version of the solution:<br />
Supposing, we have the following tree</p>
<pre> <code language="C">
        A
       / \
      B   C
         / \
        D   E
</code> </pre>
<p>Now, after completing the operations in the sub-tree rooted at C, we check if B has a left or right child. Since it doesn&#8217;t have any, we call the function on the getNextRight(B) which will again call the function with p as D, for which we have already finished everything.<br />
So, my question is: Is the last call necessary?<br />
Please tell me if I have missed something here.<br />
Thanks,<br />
Balasubramanian.N</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-12132">
        <div id="dsq-comment-header-12132" class="dsq-comment-header">
            <cite id="dsq-cite-12132">
                <span id="dsq-author-user-12132">Palash</span>
            </cite>
        </div>
        <div id="dsq-comment-body-12132" class="dsq-comment-body">
            <div id="dsq-comment-message-12132" class="dsq-comment-message"><p>Yeah, it&#8217;ll work.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-3" id="dsq-comment-12134">
        <div id="dsq-comment-header-12134" class="dsq-comment-header">
            <cite id="dsq-cite-12134">
                <span id="dsq-author-user-12134">Palash</span>
            </cite>
        </div>
        <div id="dsq-comment-body-12134" class="dsq-comment-body">
            <div id="dsq-comment-message-12134" class="dsq-comment-message"><p>Sorry, the above reply is for the comment above.<br />
Your website seems to have a very messed up commenting system. Maybe, you guys should do something about it.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-8350">
        <div id="dsq-comment-header-8350" class="dsq-comment-header">
            <cite id="dsq-cite-8350">
                <span id="dsq-author-user-8350">avikodak</span>
            </cite>
        </div>
        <div id="dsq-comment-body-8350" class="dsq-comment-body">
            <div id="dsq-comment-message-8350" class="dsq-comment-message"><p>int max_index_array,max_index_power_2,index=0;<br />
void initializeArrayInDFSOrder(int,int,int);<br />
int checkLastNodesAreNULL(int);<br />
int sumOfPowersOfTwo(int number);<br />
void joinNodesInLevelWithLinkedList();<br />
void initializeArrayInDFSOrder(int index,int traversalIndex,int level)<br />
{<br />
	if(arrayOfNodesInDFSOrder[traversalIndex] != NULL)<br />
	{<br />
		if (arrayOfNodesInDFSOrder[traversalIndex]-&gt;left != NULL) {<br />
			arrayOfNodesInDFSOrder[index] = arrayOfNodesInDFSOrder[traversalIndex]-&gt;left;<br />
		} else {<br />
			arrayOfNodesInDFSOrder[index] = NULL;<br />
		}<br />
		index++;<br />
		if (arrayOfNodesInDFSOrder[traversalIndex]-&gt;right != NULL) {<br />
			arrayOfNodesInDFSOrder[index] = arrayOfNodesInDFSOrder[traversalIndex]-&gt;right;<br />
		} else {<br />
			arrayOfNodesInDFSOrder[index] = NULL;<br />
		}<br />
		index++;<br />
	}<br />
	else{<br />
		arrayOfNodesInDFSOrder[index] = NULL;index++;<br />
		arrayOfNodesInDFSOrder[index] = NULL;index++;<br />
	}<br />
	if((traversalIndex==sumOfPowersOfTwo(level)-1))<br />
	{<br />
		//power of 2<br />
		if(!checkLastNodesAreNULL(level))<br />
		{<br />
			arrayOfNodesInDFSOrder[0]-&gt;next = NULL;<br />
			joinNodesInLevelWithLinkedList();<br />
			int j=0;<br />
			int i=pow(2,j)-1;<br />
			while(j&lt;max_index_power_2-1)<br />
			{<br />
				printf(&quot;\nLEVEL %d&quot;,j);<br />
				printf(&quot;\n========&quot;);<br />
				display(arrayOfNodesInDFSOrder[i]);<br />
				j++;<br />
				i=pow(2,j)-1;<br />
			}<br />
			return;<br />
		}else{<br />
			level=level+1;<br />
		}<br />
	}<br />
	++traversalIndex;<br />
	initializeArrayInDFSOrder(index,traversalIndex,level);<br />
}</p>
<p>int checkLastNodesAreNULL(int level)<br />
{<br />
	int index = pow(2,level-1)-1;<br />
	int max_index=pow(2, level)-1;<br />
	int i,count=0;<br />
	for (i = index; i &lt; max_index; i++) {<br />
		if (arrayOfNodesInDFSOrder[i] == NULL) {<br />
			count++;<br />
		}<br />
	}<br />
	if(count!=0)<br />
	{<br />
		count = count&amp;(count-1);<br />
		if(!(count)){<br />
			max_index_array = i-1;<br />
			max_index_power_2=level;<br />
			return 0;<br />
		}<br />
	}<br />
	return 1;<br />
}</p>
<p>int sumOfPowersOfTwo(int number)<br />
{<br />
	int sumPower=0,i;<br />
	for(i=0;i&lt;number;i++)<br />
	{<br />
		sumPower = sumPower + pow(2,i);<br />
	}<br />
	return sumPower;<br />
}</p>
<p>int getIndexWhichIsNotNull(int index)<br />
{<br />
	int i;<br />
	for(i=index;i&lt;=max_index_array;i++)<br />
	{<br />
		if(arrayOfNodesInDFSOrder[i]!=NULL)<br />
		{<br />
			return  i;<br />
		}<br />
	}<br />
}</p>
<p>void joinNodesInLevelWithLinkedList()<br />
{<br />
	int level=2,i,nextPtrIndex;<br />
	node *getNextPtr;<br />
	for(i=1;inext = arrayOfNodesInDFSOrder[i+1];<br />
				}<br />
				else<br />
				{<br />
					nextPtrIndex = getIndexWhichIsNotNull(i+1);<br />
					getNextPtr = arrayOfNodesInDFSOrder[nextPtrIndex];<br />
					if(getNextPtr!=NULL)<br />
					{<br />
						arrayOfNodesInDFSOrder[i]-&gt;next =getNextPtr;<br />
						i = nextPtrIndex;<br />
					}<br />
					else<br />
					{<br />
						arrayOfNodesInDFSOrder[i]-&gt;next =NULL;<br />
					}<br />
				}<br />
			}<br />
		}<br />
		else<br />
		{<br />
			arrayOfNodesInDFSOrder[i]-&gt;next = NULL;<br />
			level++;<br />
		}<br />
	}<br />
}</p>
<p>void display(node *root)<br />
{<br />
	printf(&#8220;\n&#8221;);<br />
	while(root-&gt;next != NULL)<br />
	{<br />
		printf(&#8220;%d-&gt;&#8221;,root-&gt;num);<br />
		root=root-&gt;next;<br />
	}<br />
	printf(&#8220;%d-&gt;NULL\n&#8221;,root-&gt;num);<br />
	return;<br />
}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-8171">
        <div id="dsq-comment-header-8171" class="dsq-comment-header">
            <cite id="dsq-cite-8171">
                <span id="dsq-author-user-8171">Sharat</span>
            </cite>
        </div>
        <div id="dsq-comment-body-8171" class="dsq-comment-body">
            <div id="dsq-comment-message-8171" class="dsq-comment-message"><pre> <code language="C">
breadth_recursion(tree* root){
tree *left, *right;

push (root-&gt;right);  // push right child to stack
push (root-&gt;left);   //push left child to stack
left = pop();        //pop left child from stack
right = pop();       //pop right child from stack
left-&gt;next = right;
breadth_recursion(left);
breadth_recursion(right);
}

</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-sparco odd alt thread-odd thread-alt depth-1" id="dsq-comment-7748">
        <div id="dsq-comment-header-7748" class="dsq-comment-header">
            <cite id="dsq-cite-7748">
                <span id="dsq-author-user-7748">sparco</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7748" class="dsq-comment-body">
            <div id="dsq-comment-message-7748" class="dsq-comment-message"><p>Calling connect((p->left)->nextRight) and connect((p->nextRight)->left) twice which are one and the same can be optimised.<br />
We can omit calling connect((p->nextRight)->left) by using a flag</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-sparco even depth-2" id="dsq-comment-7749">
        <div id="dsq-comment-header-7749" class="dsq-comment-header">
            <cite id="dsq-cite-7749">
                <span id="dsq-author-user-7749">sparco</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7749" class="dsq-comment-body">
            <div id="dsq-comment-message-7749" class="dsq-comment-message"><p>My apologies for my repeated comments&#8230; Network down<br />
Please omit my other queries</p>
<p>Below is even an optimised version of the solution.</p>
<pre> <code language="C">

void connectRecur(struct node* p,int nextflag)
{

    // Base case
    if (!p)
       return;
    /* Before setting nextRight of left and right children, set nextRight
    of children of other nodes at same level (because we can access
    children of other nodes using p's nextRight only) */
    if (p-&gt;nextRight != NULL) {
       connectRecur(p-&gt;nextRight,1);
    } 
    /* Set the nextRight pointer for p's left child */
    if (p-&gt;left )
    {
       if (p-&gt;right)
       {
           p-&gt;left-&gt;nextRight = p-&gt;right;
           p-&gt;right-&gt;nextRight = getNextRight(p);
       }
       else
           p-&gt;left-&gt;nextRight = getNextRight(p);
 
       /* Recursively call for next level nodes.  Note that we call only
       for left child. The call for left child will call for right child */

		if (! nextflag ) {  
			if ( isLeaf(p-&gt;left) ) {
				connectRecur(getNextRight(p),0); 
			} else {
				connectRecur(p-&gt;left,0); 
			}
		}
    }
    /* If left child is NULL then first node of next level will either be
      p-&gt;right or getNextRight(p) */
    else if (p-&gt;right)
    {
        p-&gt;right-&gt;nextRight = getNextRight(p);
 		if (! nextflag ) { 
			if ( isLeaf(p-&gt;left) ) {
			connectRecur(getNextRight(p),0); 
			} else {
			connectRecur(p-&gt;right,0); 
			}
		}
    }
    else {
    if (! nextflag ) {    
        connectRecur(getNextRight(p),0); 
    }
    }

}

// Routine to print next

void printnext (struct node *p) {
   struct node* temp=p;
   while ( temp-&gt;nextRight != NULL ) {
       printf(&quot;%d -&gt; %d \n&quot;,temp-&gt;data,temp-&gt;nextRight-&gt;data);
       temp=temp-&gt;nextRight;
   }
   printf(&quot;%d -&gt; 0 \n&quot;,temp-&gt;data);
   if (p-&gt;left) { printnext(p-&gt;left); }
}

</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-7746">
        <div id="dsq-comment-header-7746" class="dsq-comment-header">
            <cite id="dsq-cite-7746">
                <span id="dsq-author-user-7746">sparco</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7746" class="dsq-comment-body">
            <div id="dsq-comment-message-7746" class="dsq-comment-message"><p>Giving print statement inside the Recursive function ,<br />
Calling connect((p-&gt;left)-&gt;nextRight) and connect((p-&gt;nextRight)-&gt;left) twice which are one and the same can be optimised.<br />
We can omit calling connect((p-&gt;nextRight)-&gt;left) by using a flag</p>
<p>connect(1)<br />
&#8212; connect decideright(1)<br />
connect p-&gt;left<br />
connect(2)<br />
connect p-&gt;nextRight<br />
connect(3)<br />
&#8212; connect decideright(3)<br />
connect p-&gt;left<br />
connect(6)<br />
connect p-&gt;nextRight<br />
connect(7)<br />
&#8212; connect decideright(7)<br />
connect getnextright<br />
&#8212; connect decideright(6)<br />
connect getnextright<br />
&#8212; connect decideright(2)<br />
connect p-&gt;left<br />
connect(4)<br />
connect p-&gt;nextRight<br />
connect(5)<br />
connect p-&gt;nextRight<br />
connect(6)<br />
connect p-&gt;nextRight<br />
connect(7)<br />
&#8212; connect decideright(7)<br />
connect getnextright<br />
&#8212; connect decideright(6)<br />
connect getnextright<br />
&#8212; connect decideright(5)<br />
connect getnextright<br />
&#8212; connect decideright(4)<br />
connect getnextright</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-7745">
        <div id="dsq-comment-header-7745" class="dsq-comment-header">
            <cite id="dsq-cite-7745">
                <span id="dsq-author-user-7745">sparco</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7745" class="dsq-comment-body">
            <div id="dsq-comment-message-7745" class="dsq-comment-message"><p>Giving print statement inside the Recursive function ,<br />
Calling connect((p-&gt;left)-&gt;nextRight) and connect((p-&gt;nextRight)-&gt;left) twice which are one and the same can be optimised.<br />
We can omit calling connect((p-&gt;left)-&gt;nextRight) by using a flag</p>
<p>connect(1)<br />
&#8212; connect decideright(1)<br />
connect p-&gt;left<br />
connect(2)<br />
connect p-&gt;nextRight<br />
connect(3)<br />
&#8212; connect decideright(3)<br />
connect p-&gt;left<br />
connect(6)<br />
connect p-&gt;nextRight<br />
connect(7)<br />
&#8212; connect decideright(7)<br />
connect getnextright<br />
&#8212; connect decideright(6)<br />
connect getnextright<br />
&#8212; connect decideright(2)<br />
connect p-&gt;left<br />
connect(4)<br />
connect p-&gt;nextRight<br />
connect(5)<br />
connect p-&gt;nextRight<br />
connect(6)<br />
connect p-&gt;nextRight<br />
connect(7)<br />
&#8212; connect decideright(7)<br />
connect getnextright<br />
&#8212; connect decideright(6)<br />
connect getnextright<br />
&#8212; connect decideright(5)<br />
connect getnextright<br />
&#8212; connect decideright(4)<br />
connect getnextright</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-7560">
        <div id="dsq-comment-header-7560" class="dsq-comment-header">
            <cite id="dsq-cite-7560">
                <span id="dsq-author-user-7560">ashish</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7560" class="dsq-comment-body">
            <div id="dsq-comment-message-7560" class="dsq-comment-message"><p>I don&#8217;t think that the last else part is required as it is already taken care by </p>
<pre> <code language="C">
connectRecur(p-&gt;nextRight);
</code> </pre>
<p>so exlude last</p>
<pre> <code language="C">
else
       connectRecur(getNextRight(p));
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-7315">
        <div id="dsq-comment-header-7315" class="dsq-comment-header">
            <cite id="dsq-cite-7315">
                <span id="dsq-author-user-7315">atul</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7315" class="dsq-comment-body">
            <div id="dsq-comment-message-7315" class="dsq-comment-message"><p>this can be done by level order traversal&#8230;</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-camster odd alt depth-2" id="dsq-comment-7318">
        <div id="dsq-comment-header-7318" class="dsq-comment-header">
            <cite id="dsq-cite-7318">
                <span id="dsq-author-user-7318">camster</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7318" class="dsq-comment-body">
            <div id="dsq-comment-message-7318" class="dsq-comment-message"><p>@Atul, Yes , it can be done by level order traversal but is it more complicated than just level order traversal because you have to do it constant extra space. Please test my proposed solution. Thank you, Camster,</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-3" id="dsq-comment-7325">
        <div id="dsq-comment-header-7325" class="dsq-comment-header">
            <cite id="dsq-cite-7325">
                <span id="dsq-author-user-7325">atul</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7325" class="dsq-comment-body">
            <div id="dsq-comment-message-7325" class="dsq-comment-message"><p>if i am not wrong you are doing level order traversal using queue&#8230;and completing the given job.. if that so&#8230;then actually that was in mind before posting this post&#8230;and level order traversal should be done using queue as its complexity would be O(n)..using recursion it would cost O(n^2) at worst case. </p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt depth-3" id="dsq-comment-7330">
        <div id="dsq-comment-header-7330" class="dsq-comment-header">
            <cite id="dsq-cite-7330">
                <span id="dsq-author-user-7330">atul</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7330" class="dsq-comment-body">
            <div id="dsq-comment-message-7330" class="dsq-comment-message"><p>@cramster : here is how we can do it using queue&#8230;its not a code..just algo with more details to make it more clear&#8230;.</p>
<p>setLevelOrderNext(BinaryTree *root) {<br />
node *temp;<br />
enqueue(root);<br />
nod=0;<br />
idx=0;<br />
i=0;<br />
BinaryTree  *nextPtr;<br />
while((temp=dequeue()) != NULL)<br />
{</p>
<p>   if(nod==idx)<br />
    {<br />
            idx=0;<br />
            i++;<br />
            if(i!=1)<br />
           {<br />
             enqueue(DelimeterNode);<br />
             nod=pow(2,i);<br />
         }<br />
   }<br />
if(i!=1)<br />
      nextPtr=dequeue();<br />
      if(nextPtr!=DelimeterNode)<br />
      {<br />
              temp-&gt;next=nextPrt;<br />
              enqueue(nextPrt);<br />
     }<br />
}           </p>
<p>    if (temp-&gt;left)<br />
    {<br />
       enqueue(temp-&gt;left);<br />
    }</p>
<p>    if ( temp-&gt;right)<br />
    {<br />
       enqueue(temp-&gt;right);</p>
<p>    }</p>
<p>    idx=idx+2;</p>
<p>}</p>
<p>}</p>
<p>i just setting some delimiter node after end of each level..i.e when all nodes of x level are in queue..hope you get the idea..<br />
comments are welcome<br />
thanks</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment byuser comment-author-camster even thread-even depth-1" id="dsq-comment-7253">
        <div id="dsq-comment-header-7253" class="dsq-comment-header">
            <cite id="dsq-cite-7253">
                <span id="dsq-author-user-7253">camster</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7253" class="dsq-comment-body">
            <div id="dsq-comment-message-7253" class="dsq-comment-message"><p>Here is a program that connects binary tree nodes at the same level using constant extra space. Thank, Camster.</p>
<pre> <code language="C">
struct Tree{
   int value;
   Tree* left;
   Tree* right;
   Tree* next;
};
void ConnectNodesAtSameLevel(Tree*&amp; root){
	if (root == NULL){
		return;
	}
	Tree* prev = NULL;
	std::queue&lt;Tree*&gt; nodesQueue;
	int nodesInCurrentLevel = 1;
	int nodesinNextLevel = 0;

	nodesQueue.push(root);

	while (!nodesQueue.empty()){
		Tree* currNode = nodesQueue.front();
		if (currNode == NULL){
			break;
		}
		nodesQueue.pop();
		nodesInCurrentLevel -= 1;
		if (currNode){
		  if (prev){
			  prev-&gt;next = currNode;
		  }	
		  prev = currNode;
		  nodesQueue.push(currNode-&gt;left);
          nodesQueue.push(currNode-&gt;right);
		  nodesinNextLevel += 2;

		}
		if (nodesInCurrentLevel == 0){
			if (currNode){
				currNode-&gt;next = NULL;
			}
			prev = NULL;
			nodesInCurrentLevel = nodesinNextLevel;
			nodesinNextLevel = 0;
		}
	}
}
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-7147">
        <div id="dsq-comment-header-7147" class="dsq-comment-header">
            <cite id="dsq-cite-7147">
                <span id="dsq-author-user-7147">Karthick</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7147" class="dsq-comment-body">
            <div id="dsq-comment-message-7147" class="dsq-comment-message"><p>I seem to find a small glitch in the recursive solution. But, I am not sure about it. So, if I am wrong, I am sorry.<br />
Suppose, we have the following tree</p>
<pre>
10
  \
   2
  / \
 3   9
</pre>
<p>First, we start at 10. Here, we have not set the nextRight value of 2 to be NULL. Since 10 has no left child, we move over to its right child, which is 2.<br />
Here, we check if the nextRight of 2 is NULL. Now, it is possible that the nextRight of 2 might contain garbage values, since we have not set its nextRight pointer to NULL.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-geeksforgeeks bypostauthor even depth-2" id="dsq-comment-7151">
        <div id="dsq-comment-header-7151" class="dsq-comment-header">
            <cite id="dsq-cite-7151">
                <span id="dsq-author-user-7151">GeeksforGeeks</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7151" class="dsq-comment-body">
            <div id="dsq-comment-message-7151" class="dsq-comment-message"><p>@Karthick: Thanks for pointing this case.  We have made changes to handle this case.  We added &#8221; p->right->nextRight = getNextRight(p);&#8221; in following else if block. This problem didn&#8217;t occur in testing because newNode() function sets nextRight as NULL. Keep it up!</p>
<pre> <code language="C">
    else if (p-&gt;right)
    {
        p-&gt;right-&gt;nextRight = getNextRight(p);
        connectRecur(p-&gt;right);
    }
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-7134">
        <div id="dsq-comment-header-7134" class="dsq-comment-header">
            <cite id="dsq-cite-7134">
                <span id="dsq-author-user-7134">Rahul</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7134" class="dsq-comment-body">
            <div id="dsq-comment-message-7134" class="dsq-comment-message"><p>What is the time Complexity here..I guess O(2n)</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-flyinghearts even thread-odd thread-alt depth-1" id="dsq-comment-7100">
        <div id="dsq-comment-header-7100" class="dsq-comment-header">
            <cite id="dsq-cite-7100">
http://www.cppblog.com/flyinghearts                <span id="dsq-author-user-7100">flyinghearts</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7100" class="dsq-comment-body">
            <div id="dsq-comment-message-7100" class="dsq-comment-message"><pre> <code language="CPP">

//recursive version:
static void set_nextRight(node* root, node* nextRight)
{
  root-&gt;nextRight   = nextRight;
  node* const left  = root-&gt;left;
  node* const right = root-&gt;right;
  if (left == NULL &amp;&amp; right == NULL) return;
  
  while (nextRight) {
    if (nextRight-&gt;left)  { nextRight = nextRight-&gt;left;  break;}
    if (nextRight-&gt;right) { nextRight = nextRight-&gt;right; break;}
    nextRight = nextRight-&gt;nextRight;
  }
  
  if (right) { 
    set_nextRight(right, nextRight);  
    nextRight = right;
  }    
  
  if (left) set_nextRight(left, nextRight);
}

void connect(struct node *root)
{
  if (root) set_nextRight(root, NULL);
}


//nonrecursive version
void connect(node* root)
{
  if (root == NULL) return;
  root-&gt;nextRight = NULL;
  
  node* level_start = NULL;
  while (root) {   
    node* const left  = root-&gt;left;
    node* const right = root-&gt;right;

    if (level_start == NULL) level_start = left ? left : right;
    node* nextRight = NULL;
    while (true) {
      root = root-&gt;nextRight;
      if (root == NULL) { root = level_start; level_start = NULL; break; }
      if (root-&gt;left)   { nextRight = root-&gt;left;  break; }
      if (root-&gt;right)  { nextRight = root-&gt;right; break; }
    }
    if (right) { right-&gt;nextRight = nextRight;  nextRight = right; }
    if (left)  { left-&gt;nextRight  = nextRight;}
  }
}

</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-7090">
        <div id="dsq-comment-header-7090" class="dsq-comment-header">
            <cite id="dsq-cite-7090">
                <span id="dsq-author-user-7090">Bugaboo</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7090" class="dsq-comment-body">
            <div id="dsq-comment-message-7090" class="dsq-comment-message"><p>I don&#8217;t think your iterative version takes care of the root not having a left child but just a right child.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-kartik even depth-2" id="dsq-comment-7107">
        <div id="dsq-comment-header-7107" class="dsq-comment-header">
            <cite id="dsq-cite-7107">
                <span id="dsq-author-user-7107">kartik</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7107" class="dsq-comment-body">
            <div id="dsq-comment-message-7107" class="dsq-comment-message"><p>The iterative version also takes care of root not having left child.  Take a closer look at the following piece of code in iterative version.</p>
<pre> <code language="C">
        // start from the first node of next level
        if (p-&gt;left)
           p = p-&gt;left;
        else if (p-&gt;right)
           p = p-&gt;right;
        else
           p = getNextRight(p);
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-7083">
        <div id="dsq-comment-header-7083" class="dsq-comment-header">
            <cite id="dsq-cite-7083">
                <span id="dsq-author-user-7083">stat</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7083" class="dsq-comment-body">
            <div id="dsq-comment-message-7083" class="dsq-comment-message"><p>i don&#8217;t think the recursive solution is working for a tree with the root not having a left child.<br />
what is the use of *temp variable in void connectRecur(struct node* p) ???</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-geeksforgeeks bypostauthor even depth-2" id="dsq-comment-7086">
        <div id="dsq-comment-header-7086" class="dsq-comment-header">
            <cite id="dsq-cite-7086">
                <span id="dsq-author-user-7086">GeeksforGeeks</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7086" class="dsq-comment-body">
            <div id="dsq-comment-message-7086" class="dsq-comment-message"><p>Thanks for pointing out this case.  We have updated the code so that it handles this case as well.  Keep it up!!  </p>
<p>Following is an example run of recursive method.</p>
<pre> <code language="CPP">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct node
{
    int data;
    struct node *left;
    struct node *right;
    struct node *nextRight;
};

void connectRecur(struct node* p);
struct node *getNextRight(struct node *p);

// Sets the nextRight of root and calls connectRecur() for other nodes
void connect (struct node *p)
{
    // Set the nextRight for root
    p-&gt;nextRight = NULL;

    // Set the next right for rest of the nodes (other than root)
    connectRecur(p);
}

/* Set next right of all descendents of p. This function makes sure that
nextRight of nodes ar level i is set before level i+1 nodes. */
void connectRecur(struct node* p)
{
    // Base case
    if (!p)
       return;

    /* Before setting nextRight of left and right children, set nextRight
    of other nodes at same level */
    if (p-&gt;nextRight != NULL)
       connectRecur(p-&gt;nextRight);

    /* Set the nextRight pointer for p's left child */
    if (p-&gt;left)
    {
       if (p-&gt;right)
       {
           p-&gt;left-&gt;nextRight = p-&gt;right;
           p-&gt;right-&gt;nextRight = getNextRight(p);
       }
       else
           p-&gt;left-&gt;nextRight = getNextRight(p);

       /* Recursively call for next level nodes.  Note that we call only
       for left child. The call for left child will call for right child */
       connectRecur(p-&gt;left);
    }

    /* If left child is NULL then first node on next level will be either
      right child or getNextRight(p) */
    else if (p-&gt;right)
       connectRecur(p-&gt;right);
    else
       connectRecur(getNextRight(p));
}

/* This function returns the leftmost child of nodes at the same level as p.
   This function is used to getNExt right of p's right child
   If right child of is NULL then this can also be sued for the left child */
struct node *getNextRight(struct node *p)
{
    struct node *temp = p-&gt;nextRight;

    /* Traverse nodes at p's level and find and return
       the first node's first child */
    while(temp != NULL)
    {
        if(temp-&gt;left != NULL)
            return temp-&gt;left;
        if(temp-&gt;right != NULL)
            return temp-&gt;right;
        temp = temp-&gt;nextRight;
    }

    // If all the nodes at p's level are leaf nodes then return NULL
    return NULL;
}

/* UTILITY FUNCTIONS */
/* Helper function that allocates a new node with the
   given data and NULL left and right pointers. */
struct node* newnode(int data)
{
    struct node* node = (struct node*)
                        malloc(sizeof(struct node));
    node-&gt;data = data;
    node-&gt;left = NULL;
    node-&gt;right = NULL;
    node-&gt;nextRight = NULL;

    return(node);
}

/* Driver program to test above functions*/
int main()
{

    /* Constructed binary tree is
              10
                \
                 2
               /   \
              3     90
    */
    struct node *root = newnode(10);
    root-&gt;right       = newnode(2);
    root-&gt;right-&gt;left  = newnode(3);
    root-&gt;right-&gt;right = newnode(90);

    // Populates nextRight pointer in all nodes
    connect(root);

    // Let us check the values of nextRight pointers
    printf(&quot;Following are populated nextRight pointers in the tree &quot;
           &quot;(-1 is printed if there is no nextRight) \n&quot;);
    printf(&quot;nextRight of %d is %d \n&quot;, root-&gt;data,
           root-&gt;nextRight? root-&gt;nextRight-&gt;data: -1);
    printf(&quot;nextRight of %d is %d \n&quot;, root-&gt;right-&gt;data,
           root-&gt;right-&gt;nextRight? root-&gt;right-&gt;nextRight-&gt;data: -1);
    printf(&quot;nextRight of %d is %d \n&quot;, root-&gt;right-&gt;left-&gt;data,
           root-&gt;right-&gt;left-&gt;nextRight? root-&gt;right-&gt;left-&gt;nextRight-&gt;data: -1);
    printf(&quot;nextRight of %d is %d \n&quot;, root-&gt;right-&gt;right-&gt;data,
           root-&gt;right-&gt;right-&gt;nextRight? root-&gt;right-&gt;right-&gt;nextRight-&gt;data: -1);

    getchar();
    return 0;
}
</code> </pre>
<p>Output:</p>
<pre>
Following are populated nextRight pointers in the tree 
(-1 is printed if there is no nextRight)
nextRight of 10 is -1
nextRight of 2 is -1
nextRight of 3 is 90
nextRight of 90 is -1
</pre>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-3" id="dsq-comment-13248">
        <div id="dsq-comment-header-13248" class="dsq-comment-header">
            <cite id="dsq-cite-13248">
                <span id="dsq-author-user-13248">Paparao Veeragandham</span>
            </cite>
        </div>
        <div id="dsq-comment-body-13248" class="dsq-comment-body">
            <div id="dsq-comment-message-13248" class="dsq-comment-message"><p>if (p-&gt;nextRight != NULL)<br />
       connectRecur(p-&gt;nextRight);</p>
<p>Above code is  already covering this case:</p>
<p>else<br />
       connectRecur(getNextRight(p));</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
            </ul>


        </div>

    </div>

<script type="text/javascript">
var disqus_url = 'http://www.geeksforgeeks.org/connect-nodes-at-same-level-with-o1-extra-space/';
var disqus_identifier = '16952 http://www.geeksforgeeks.org/?p=16952';
var disqus_container_id = 'disqus_thread';
var disqus_shortname = 'geeksforgeeks';
var disqus_title = "Connect nodes at same level using constant extra space";
var disqus_config_custom = window.disqus_config;
var disqus_config = function () {
    /*
    All currently supported events:
    onReady: fires when everything is ready,
    onNewComment: fires when a new comment is posted,
    onIdentify: fires when user is authenticated
    */
    
    
    this.language = '';
    
    if (disqus_config_custom) {
        disqus_config_custom.call(this);
    }
};

(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>

			</div>
	
					
			
			

		</div> <!-- end post -->	

<br></br>
	
</div> <!-- end content -->

<ul id="sidebar">
	<li id="text-19" class="widget widget_text">			<div class="textwidget"><script>
  (function() {
    var cx = '009682134359037907028:tj6eafkv_be';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//www.google.com/cse/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>

<style type="text/css">
  .gsc-control-cse {
    font-family: "Trebuchet MS", sans-serif;
    border-color: #E1F3DA;
    background-color: #E1F3DA;
  }
  input.gsc-input {
    border-color: #94CC7A;
  }
  input.gsc-search-button {
    border-color: #94CC7A;
    background-color: #AADA92;
  }
  .gsc-tabHeader.gsc-tabhInactive {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gsc-tabHeader.gsc-tabhActive {
    border-color: #A9DA92;
    background-color: #A9DA92;
  }
  .gsc-tabsArea {
    border-color: #A9DA92;
  }
  .gsc-webResult.gsc-result {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gsc-webResult.gsc-result:hover {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gs-webResult.gs-result a.gs-title:link,
  .gs-webResult.gs-result a.gs-title:link b {
    color: #009900;
  }
  .gs-webResult.gs-result a.gs-title:visited,
  .gs-webResult.gs-result a.gs-title:visited b {
    color: #009900;
  }
  .gs-webResult.gs-result a.gs-title:hover,
  .gs-webResult.gs-result a.gs-title:hover b {
    color: #003300;
  }
  .gs-webResult.gs-result a.gs-title:active,
  .gs-webResult.gs-result a.gs-title:active b {
    color: #009900;
  }
  .gsc-cursor-page {
    color: #009900;
  }
  a.gsc-trailing-more-results:link {
    color: #009900;
  }
  .gs-webResult.gs-result .gs-snippet {
    color: #454545;
  }
  .gs-webResult.gs-result .gs-visibleUrl {
    color: #33cc00;
  }
  .gs-webResult.gs-result .gs-visibleUrl-short {
    color: #33cc00;
  }
  .gs-webResult.gs-result .gs-visibleUrl-short {
    display: none;
  }
  .gs-webResult.gs-result .gs-visibleUrl-long {
    display: block;
  }
  .gsc-cursor-box {
    border-color: #A9DA92;
  }
  .gsc-results .gsc-cursor-page {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gsc-results .gsc-cursor-page.gsc-cursor-current-page {
    border-color: #A9DA92;
    background-color: #A9DA92;
  }
  .gs-promotion.gs-result {
    border-color: #94CC7A;
    background-color: #CBE8B4;
  }
  .gs-promotion.gs-result a.gs-title:link {
    color: #0066CC;
  }
  .gs-promotion.gs-result a.gs-title:visited {
    color: #0066CC;
  }
  .gs-promotion.gs-result a.gs-title:hover {
    color: #0066CC;
  }
  .gs-promotion.gs-result a.gs-title:active {
    color: #0066CC;
  }
  .gs-promotion.gs-result .gs-snippet {
    color: #454545;
  }
  .gs-promotion.gs-result .gs-visibleUrl,
  .gs-promotion.gs-result .gs-visibleUrl-short {
    color: #815FA7;
  }
</style>    </div>
		</li>
<li id="text-9" class="widget widget_text">			<div class="textwidget"><div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=138031159685820";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>

<div class="fb-like-box" data-href="https://www.facebook.com/pages/GeeksforGeeks/316764689022" data-width="250" data-height="170" data-colorscheme="light" data-show-faces="true" data-header="false" data-stream="false" data-show-border="false"></div></div>
		</li>
<li id="text-18" class="widget widget_text">			<div class="textwidget"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LargeRectangleSide -->
<ins class="adsbygoogle"
     style="display:inline-block;width:336px;height:280px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="1884636833"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
		</li>
<li id="text-13" class="widget widget_text">			<div class="textwidget"><ul><li><a href="http://www.geeksforgeeks.org/category/interview-experiences/">Interview Experiences</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/advance-data-structures">Advanced Data Structures</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/dynamic-programming">Dynamic Programming</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/Greedy-Algorithm/">Greedy Algorithms</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/backtracking">Backtracking</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/pattern-searching">Pattern Searching</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/divide-and-conquer">Divide & Conquer</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/MathematicalAlgo">Mathematical Algorithms</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/recursion">Recursion</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/geometric-algorithms/">Geometric Algorithms</a></li>
</ul></div>
		</li>
<li id="text-17" class="widget widget_text">			<div class="textwidget"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big 300x600 Sidebar -->
<ins class="adsbygoogle"
     style="display:inline-block;width:300px;height:600px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="4402736037"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
		</li>
<li id="text-14" class="widget widget_text"><h2 class="widgettitle">Popular Posts</h2>
			<div class="textwidget"><ul>
<li><a href="http://www.geeksforgeeks.org/write-a-c-program-to-print-all-permutations-of-a-given-string/">  All permutations of a given string </a></li>
<li><a href="http://www.geeksforgeeks.org/memory-layout-of-c-program/"> Memory Layout of C Programs</a> </li>
<li><a href="http://www.geeksforgeeks.org/understanding-extern-keyword-in-c/"> Understanding extern keyword in C</a> </li>
<li><a href="http://www.geeksforgeeks.org/median-of-two-sorted-arrays/">Median of two sorted arrays</a> </li>
<li><a href="http://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/"> Tree traversal without recursion and without stack! </a></li>
<li><a href="http://www.geeksforgeeks.org/structure-member-alignment-padding-and-data-packing/"> Structure Member Alignment, Padding and Data Packing</a> </li>
<li><a href="http://www.geeksforgeeks.org/write-a-function-to-get-the-intersection-point-of-two-linked-lists/"> Intersection point of two Linked Lists</a> </li>
<li><a href="http://www.geeksforgeeks.org/lowest-common-ancestor-in-a-binary-search-tree/"> Lowest Common Ancestor in a BST.</span></a> </li>
<li><a href="http://www.geeksforgeeks.org/a-program-to-check-if-a-binary-tree-is-bst-or-not/"> Check if a binary tree is BST or not</a> </li>
<li><a href="http://www.geeksforgeeks.org/sorted-linked-list-to-balanced-bst/"> Sorted Linked List to Balanced BST</a></li>
</ul></div>
		</li>
<li id="text-3" class="widget widget_text">			<div class="textwidget"><a href="https://twitter.com/GeeksforGeeks" class="twitter-follow-button" data-show-count="false">Follow @GeeksforGeeks</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>         


<!-- GOOGLE FEEDBURNER BUTTON-->
<a href="http://feeds.feedburner.com/Geeksforgeeks" title="Subscribe to my feed" rel="alternate" type="application/rss+xml"><img src="http://www.feedburner.com/fb/images/pub/feed-icon32x32.png" alt="" style="border:0"/></a><a href="http://feeds.feedburner.com/Geeksforgeeks" title="Subscribe to my feed" rel="alternate" type="application/rss+xml">Subscribe</a>

</div>
		</li>
<li id="text-21" class="widget widget_text"><h2 class="widgettitle">Recent Comments</h2>
			<div class="textwidget"><script type="text/javascript" src="http://geeksforgeeks.disqus.com//recent_comments_widget.js?num_items=6&hide_avatars=1&excerpt_length=50&hide_mods=0"></script></div>
		</li>
<li id="text-22" class="widget widget_text">			<div class="textwidget"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LinkAd -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:90px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="2606115235"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LinkAd -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:90px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="2606115235"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LinkAd -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:90px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="2606115235"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
		</li>

</ul>					  
		<div class="clear"></div>

		<div id="footer">
		
		    <div class="xhtml">
                        @geeksforgeeks, <a href="http://creativecommons.org/licenses/by-nc-nd/2.5/in/deed.en_US" title="Valid XHTML Strict 1.0">Some rights reserved</a>  <a href="http://www.geeksforgeeks.org/about/contact-us/"> &nbsp; &nbsp; &nbsp; &nbsp;Contact Us!</a>

		    </div>
		    
		    <div class="credits">
			  Powered by <a href="http://wordpress.org">WordPress </a> &amp; <a href="http://mootools.net/" title="Mootools JavaScript Framework">MooTools</a>, customized by geeksforgeeks team </div>
			  
		   <div class="clear"></div>						                            
		   
		</div> <!--end footer-->  
        
		        <script type="text/javascript">
        // <![CDATA[
        var disqus_shortname = 'geeksforgeeks';
        (function () {
            var nodes = document.getElementsByTagName('span');
            for (var i = 0, url; i < nodes.length; i++) {
                if (nodes[i].className.indexOf('dsq-postid') != -1) {
                    nodes[i].parentNode.setAttribute('data-disqus-identifier', nodes[i].getAttribute('rel'));
                    url = nodes[i].parentNode.href.split('#', 1);
                    if (url.length == 1) { url = url[0]; }
                    else { url = url[1]; }
                    nodes[i].parentNode.href = url + '#disqus_thread';
                }
            }
            var s = document.createElement('script'); 
            s.async = true;
            s.type = 'text/javascript';
            s.src = '//' + disqus_shortname + '.disqus.com/count.js';
            (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
        }());
        // ]]>
        </script>
        <script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/scripts/shCore.js?ver=3.0.9'></script>
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/scripts/shBrushCpp.js?ver=3.0.9'></script>
<script type='text/javascript'>
	(function(){
		var corecss = document.createElement('link');
		var themecss = document.createElement('link');
		var corecssurl = "http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/styles/shCore.css?ver=3.0.9";
		if ( corecss.setAttribute ) {
				corecss.setAttribute( "rel", "stylesheet" );
				corecss.setAttribute( "type", "text/css" );
				corecss.setAttribute( "href", corecssurl );
		} else {
				corecss.rel = "stylesheet";
				corecss.href = corecssurl;
		}
		document.getElementsByTagName("head")[0].insertBefore( corecss, document.getElementById("syntaxhighlighteranchor") );
		var themecssurl = "http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/styles/shThemeDefault.css?ver=3.0.9";
		if ( themecss.setAttribute ) {
				themecss.setAttribute( "rel", "stylesheet" );
				themecss.setAttribute( "type", "text/css" );
				themecss.setAttribute( "href", themecssurl );
		} else {
				themecss.rel = "stylesheet";
				themecss.href = themecssurl;
		}
		//document.getElementById("syntaxhighlighteranchor").appendChild(themecss);
		document.getElementsByTagName("head")[0].insertBefore( themecss, document.getElementById("syntaxhighlighteranchor") );
	})();
	SyntaxHighlighter.config.strings.expandSource = '+ expand source';
	SyntaxHighlighter.config.strings.help = '?';
	SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
	SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
	SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
	SyntaxHighlighter.defaults['gutter'] = false;
	SyntaxHighlighter.defaults['pad-line-numbers'] = true;
	SyntaxHighlighter.defaults['toolbar'] = false;
	SyntaxHighlighter.all();
</script>
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/bbpress/templates/default/js/editor.js?ver=2.5.4-5380'></script>
				  
		</div> <!--end wrapper-->
        <div id="ajaxSpinner"></div> <!--For AJAX spinner holder-->
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-12148232-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
	</body>

</html>
<!-- Dynamic page generated in 0.272 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2014-11-27 23:29:57 -->

<!-- Compression = gzip -->
<!-- super cache -->