<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
       <title>Diameter of a Binary Tree - GeeksforGeeks</title>
       <style type="text/css" media="screen">
          @import url('http://d2o58evtke57tz.cloudfront.net/wp-content/themes/minimoo/style.css');
    </style>
      <link href="http://d2o58evtke57tz.cloudfront.net/wp-content/themes/minimoo/favicon.ico" rel="shortcut icon" />    
    
<!-- This site is optimized with the Yoast WordPress SEO plugin v1.7.1 - https://yoast.com/wordpress/plugins/seo/ -->
<link rel="canonical" href="http://www.geeksforgeeks.org/diameter-of-a-binary-tree/" />
<meta property="og:locale" content="en_US" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Diameter of a Binary Tree - GeeksforGeeks" />
<meta property="og:description" content="The diameter of a tree (sometimes called the width) is the number of nodes on the longest path between two leaves in the tree. The diagram below shows two trees each with diameter nine, the leaves that form the ends of a longest path are shaded (note that there is more than one path in &hellip;" />
<meta property="og:url" content="http://www.geeksforgeeks.org/diameter-of-a-binary-tree/" />
<meta property="og:site_name" content="GeeksforGeeks" />
<meta property="article:section" content="Trees" />
<meta property="article:published_time" content="2010-03-15T19:15:58+00:00" />
<meta property="article:modified_time" content="2011-12-14T11:10:21+00:00" />
<meta property="og:updated_time" content="2011-12-14T11:10:21+00:00" />
<meta property="og:image" content="http://geeksforgeeks.org/wp-content/uploads/tree_diameter.GIF" />
<!-- / Yoast WordPress SEO plugin. -->

<link rel='stylesheet' id='wp-quicklatex-format-css'  href='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/wp-quicklatex/css/quicklatex-format.css?ver=4.0.1' type='text/css' media='all' />
<link rel='stylesheet' id='bbp-default-css'  href='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/bbpress/templates/default/css/bbpress.css?ver=2.5.4-5380' type='text/css' media='screen' />
<link rel='stylesheet' id='wp-pagenavi-css'  href='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/wp-pagenavi/pagenavi-css.css?ver=2.70' type='text/css' media='all' />
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-includes/js/jquery/jquery.js?ver=1.11.1'></script>
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-includes/js/jquery/jquery-migrate.min.js?ver=1.2.1'></script>
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/wp-quicklatex/js/wp-quicklatex-frontend.js?ver=1.0'></script>

<!-- Bad Behavior 2.2.16 run time: 1.472 ms -->
<script type="text/javascript">
<!--
function bb2_addLoadEvent(func) {
	var oldonload = window.onload;
	if (typeof window.onload != 'function') {
		window.onload = func;
	} else {
		window.onload = function() {
			oldonload();
			func();
		}
	}
}

bb2_addLoadEvent(function() {
	for ( i=0; i < document.forms.length; i++ ) {
		if (document.forms[i].method == 'post') {
			var myElement = document.createElement('input');
			myElement.setAttribute('type', 'hidden');
			myElement.name = 'bb2_screener_';
			myElement.value = '1417111007 203.110.243.22';
			document.forms[i].appendChild(myElement);
		}
	}
});
// --></script>
		<style type="text/css" id="syntaxhighlighteranchor"></style>
   <meta name="google-site-verification" content="rHK2v8_zzuAZQY8JHAzbllDN8u-aQxcn2Kqnp67Old0" />
</head>

<body>
<!-- o4dI0sCXUgoSONabbd8mbZ4SA3E -->    
    <div id="wrapper">
        <div class="blog-info">
                <h1 class="blog-title">
                <a href="http://www.geeksforgeeks.org" title="GeeksforGeeks">GeeksforGeeks</a>
            </h1>
       
            <div class="blog-description">
                A computer science portal for geeks            </div>
        </div>
        <b><p>  <h2 align="right"> <a href="http://geeksquiz.com/">GeeksQuiz</a></h2> 
   <a href="http://www.geeksforgeeks.org/wp-login.php">Login</a> 
         </p></b>  
         
         <div class="clear"></div>         
              
                     
            <div id="menu">   
                 <ul>
 <li><a href="http://www.geeksforgeeks.org">Home</a></li>
  <li><a href="http://www.geeksforgeeks.org/fundamentals-of-algorithms/">Algorithms</a></li>
 <li><a href="http://www.geeksforgeeks.org/data-structures/">DS</a></li>
  <li><a href="http://www.geeksforgeeks.org/gate-corner/">GATE</a></li>
  <li><a href="http://www.geeksforgeeks.org/about/interview-corner/">Interview Corner</a></li>
  <li><a href="http://www.geeksforgeeks.org/forums/">Q&A</a></li>
  <li><a href="http://www.geeksforgeeks.org/c/">C</a></li>
  <li><a href="http://www.geeksforgeeks.org/c-plus-plus/">C++</a></li>
  <li><a href="http://www.geeksforgeeks.org/java/">Java</a></li>
  <li><a href="http://www.geeksforgeeks.org/books/">Books</a></li>
  <li><a href="http://www.geeksforgeeks.org/contribute/">Contribute</a></li>
  <li><a href="http://www.geeksforgeeks.org/contribute/ask-a-question/">Ask a Q</a></li>
  <li><a href="http://www.geeksforgeeks.org/about/">About</a></li>
            </ul>

               
            <div class="clear"></div>     
        </div>
             <div id="navmenu">
				<ul id="menu" style="padding:0; margin:0;">
						<li class="cat-item cat-item-3"><a href="http://www.geeksforgeeks.org/category/c-arrays/" title="Questions regarding Arrays">Array</a>
</li>	

	<li class="cat-item cat-item-17"><a href="http://www.geeksforgeeks.org/category/bit-magic/" title="View all posts filed under Bit Magic">Bit Magic</a>
</li>
	<li class="cat-item cat-item-14"><a href="http://www.geeksforgeeks.org/category/c-puzzles/" title="View all posts filed under C/C++ Puzzles">C/C++</a>
</li>

<li class="cat-item cat-item-18"><a href="http://www.geeksforgeeks.org/category/articles/" title="View all posts filed under Articles">Articles</a>
</li>

	<li class="cat-item cat-item-67"><a href="http://www.geeksforgeeks.org/category/gfact/" title="View all posts filed under GFacts">GFacts</a>
</li>
	<li class="cat-item cat-item-8"><a href="http://www.geeksforgeeks.org/category/linked-list/" title="Linked List problems">Linked List</a>
</li>
	<li class="cat-item cat-item-66"><a href="http://www.geeksforgeeks.org/category/multiple-choice-question/" title="View all posts filed under MCQ">MCQ</a>

</li>
	<li class="cat-item cat-item-4"><a href="http://www.geeksforgeeks.org/category/c-programs/" title="Miscellaneous">Misc</a>
</li>
	<li class="cat-item cat-item-5"><a href="http://www.geeksforgeeks.org/category/program-output/" title="View all posts filed under Output">Output</a>
</li>
	<li class="cat-item cat-item-7"><a href="http://www.geeksforgeeks.org/category/c-strings/" title="Questions related to strings">String</a>
</li>
	<li class="cat-item cat-item-19"><a href="http://www.geeksforgeeks.org/category/tree/" title="View all posts filed under Trees">Tree</a>
</li>
	<li class="cat-item cat-item-19"><a href="http://www.geeksforgeeks.org/category/graph/" title="View all posts filed under Graph">Graph</a>
</li>
</ul>
        </div>
             <div id="content">	   	
	<div class="post" id="post">
							<div class="post-info">			
					<div class="post-title-info">
						<h2 class="post-title">Diameter of a Binary Tree</h2>
					</div>			
					<div class="clear"></div>				  
				<div class="post-content" id="post-content">
					<p>The diameter of a tree (sometimes called the width) is the number of nodes on the longest path between two leaves in the tree.  <span id="more-5687"></span>The diagram below shows two trees each with diameter nine, the leaves that form the ends of a longest path are shaded (note that there is more than one path in each tree of length nine, but no path longer than nine nodes). </p>
<p><a href="http://geeksforgeeks.org/wp-content/uploads/tree_diameter.GIF"><img src="http://geeksforgeeks.org/wp-content/uploads/tree_diameter.GIF" alt="" title="tree_diameter" width="633" height="236" class="aligncenter size-full wp-image-5737" /></a></p>
<p>The diameter of a tree T is the largest of the following quantities:</p>
<p>* the diameter of T&#8217;s left subtree<br />
* the diameter of T&#8217;s right subtree<br />
* the longest path between leaves that goes through the root of T (this can be computed from the heights of the subtrees of T) </p>
<p>Implementation:</p>
<pre class="brush: cpp; title: ; notranslate" title="">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

/* A binary tree node has data, pointer to left child
   and a pointer to right child */
struct node
{
    int data;
    struct node* left;
    struct node* right;
};

/* function to create a new node of tree and returns pointer */
struct node* newNode(int data);

/* returns max of two integers */
int max(int a, int b);

/* function to Compute height of a tree. */
int height(struct node* node);

/* Function to get diameter of a binary tree */
int diameter(struct node * tree)
{
   /* base case where tree is empty */
   if (tree == 0)
     return 0;

  /* get the height of left and right sub-trees */
  int lheight = height(tree-&gt;left);
  int rheight = height(tree-&gt;right);

  /* get the diameter of left and right sub-trees */
  int ldiameter = diameter(tree-&gt;left);
  int rdiameter = diameter(tree-&gt;right);

  /* Return max of following three
   1) Diameter of left subtree
   2) Diameter of right subtree
   3) Height of left subtree + height of right subtree + 1 */
  return max(lheight + rheight + 1, max(ldiameter, rdiameter));
} 

/* UTILITY FUNCTIONS TO TEST diameter() FUNCTION */

/*  The function Compute the &quot;height&quot; of a tree. Height is the 
    number f nodes along the longest path from the root node 
    down to the farthest leaf node.*/
int height(struct node* node)
{
   /* base case tree is empty */ 
   if(node == NULL)
       return 0;

   /* If tree is not empty then height = 1 + max of left 
      height and right heights */    
   return 1 + max(height(node-&gt;left), height(node-&gt;right));
} 

/* Helper function that allocates a new node with the
   given data and NULL left and right pointers. */
struct node* newNode(int data)
{
  struct node* node = (struct node*)
                       malloc(sizeof(struct node));
  node-&gt;data = data;
  node-&gt;left = NULL;
  node-&gt;right = NULL;

  return(node);
}

/* returns maximum of two integers */
int max(int a, int b)
{
  return (a &gt;= b)? a: b;
}    

/* Driver program to test above functions*/
int main()
{

  /* Constructed binary tree is 
            1
          /   \
        2      3
      /  \
    4     5
  */
  struct node *root = newNode(1);
  root-&gt;left        = newNode(2);
  root-&gt;right       = newNode(3);
  root-&gt;left-&gt;left  = newNode(4);
  root-&gt;left-&gt;right = newNode(5);

  printf(&quot;Diameter of the given binary tree is %d\n&quot;, diameter(root));

  getchar();
  return 0;
}
</pre>
<p>Time Complexity: O(n^2)</p>
<p></br><br />
<strong>Optimized implementation:</strong> The above implementation can be optimized by calculating the height in the same recursion rather than calling a height() separately. Thanks to Amar  for suggesting this optimized version. This optimization reduces time complexity to O(n).</p>
<pre class="brush: cpp; title: ; notranslate" title="">
/*The second parameter is to store the height of tree.
   Initially, we need to pass a pointer to a location with value
   as 0. So, function should be used as follows:

   int height = 0;
   struct node *root = SomeFunctionToMakeTree();
   int diameter = diameterOpt(root, &amp;height); */
int diameterOpt(struct node *root, int* height)
{
  /* lh --&gt; Height of left subtree
      rh --&gt; Height of right subtree */
  int lh = 0, rh = 0;
 
  /* ldiameter  --&gt; diameter of left subtree
      rdiameter  --&gt; Diameter of right subtree */
  int ldiameter = 0, rdiameter = 0;
 
  if(root == NULL)
  {
    *height = 0;
     return 0; /* diameter is also 0 */
  }
 
  /* Get the heights of left and right subtrees in lh and rh
    And store the returned values in ldiameter and ldiameter */
  ldiameter = diameterOpt(root-&gt;left, &amp;lh);
  rdiameter = diameterOpt(root-&gt;right, &amp;rh);
 
  /* Height of current node is max of heights of left and
     right subtrees plus 1*/
  *height = max(lh, rh) + 1;
 
  return max(lh + rh + 1, max(ldiameter, rdiameter));
}
</pre>
<p>Time Complexity: O(n)</p>
<p>References:<br />
<a href="http://www.cs.duke.edu/courses/spring00/cps100/assign/trees/diameter.html">http://www.cs.duke.edu/courses/spring00/cps100/assign/trees/diameter.html</a></p>
<p>Please write comments if you find any of the above codes/algorithms incorrect, or find other ways to solve the same problem.</p>
		
&nbsp;
&nbsp;
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle"
     style="display:inline-block;width:336px;height:280px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="4061219431"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>



&nbsp;
&nbsp;
&nbsp;
<h3>Related Topics:</h3><ul><li><a href="http://www.geeksforgeeks.org/perfect-binary-tree-specific-level-order-traversal/" title="Perfect Binary Tree Specific Level Order Traversal">Perfect Binary Tree Specific Level Order Traversal</a></li><li><a href="http://www.geeksforgeeks.org/print-nodes-top-view-binary-tree/" title="Print Nodes in Top View of Binary Tree">Print Nodes in Top View of Binary Tree</a></li><li><a href="http://www.geeksforgeeks.org/k-dimensional-tree/" title="K Dimensional Tree">K Dimensional Tree</a></li><li><a href="http://www.geeksforgeeks.org/convert-binary-tree-threaded-binary-tree/" title="Convert a Binary Tree to Threaded binary tree">Convert a Binary Tree to Threaded binary tree</a></li><li><a href="http://www.geeksforgeeks.org/serialize-deserialize-n-ary-tree/" title="Serialize and Deserialize an N-ary Tree">Serialize and Deserialize an N-ary Tree</a></li><li><a href="http://www.geeksforgeeks.org/serialize-deserialize-binary-tree/" title="Serialize and Deserialize a Binary Tree">Serialize and Deserialize a Binary Tree</a></li><li><a href="http://www.geeksforgeeks.org/given-binary-tree-print-nodes-two-given-level-numbers/" title="Print nodes between two given level numbers of a binary tree">Print nodes between two given level numbers of a binary tree</a></li><li><a href="http://www.geeksforgeeks.org/find-height-binary-tree-represented-parent-array/" title="Find Height of Binary Tree represented by Parent array">Find Height of Binary Tree represented by Parent array</a></li></ul>
<p></p> 
<div>
<iframe src="http://www.facebook.com/plugins/like.php?href=http%3A%2F%2Fwww.geeksforgeeks.org%2Fdiameter-of-a-binary-tree%2F&layout=button_count&show_faces=false&width=90&action=like&colorscheme=light" scrolling="no" frameborder="0" allowTransparency="true" style="border:none; overflow:hidden; width:90px; height:20px"></iframe>
<a href="http://twitter.com/share" class="twitter-share-button" data-url="http://www.geeksforgeeks.org/diameter-of-a-binary-tree/" data-text="Diameter of a Binary Tree" data-count="horizontal" data-via="jakerutter">Tweet</a><script type="text/javascript" src="http://platform.twitter.com/widgets.js"></script>
<g:plusone size="medium" href="http://www.geeksforgeeks.org/diameter-of-a-binary-tree/"></g:plusone>
<!-- Place this render call where appropriate -->
<script type="text/javascript">
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script></div>





				</div>		  
			</div> <!-- end post main -->					
			<div class="post-meta">
				<div class="left"></div>				
				<div class="clear"></div>
			</div>			
        
			<div class="comments-main">		
 <b>Writing code in comment?</b> Please use <b><a href="http://ideone.com/">ideone.com</a></b> and share the link here.
				
<div id="disqus_thread">
            <div id="dsq-content">


            <ul id="dsq-comments">
                    <li class="comment even thread-even depth-1" id="dsq-comment-32992">
        <div id="dsq-comment-header-32992" class="dsq-comment-header">
            <cite id="dsq-cite-32992">
                <span id="dsq-author-user-32992">achiever01</span>
            </cite>
        </div>
        <div id="dsq-comment-body-32992" class="dsq-comment-body">
            <div id="dsq-comment-message-32992" class="dsq-comment-message"><p>Thank you, excellent explanation</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-32549">
        <div id="dsq-comment-header-32549" class="dsq-comment-header">
            <cite id="dsq-cite-32549">
                <span id="dsq-author-user-32549">sakimahesh</span>
            </cite>
        </div>
        <div id="dsq-comment-body-32549" class="dsq-comment-body">
            <div id="dsq-comment-message-32549" class="dsq-comment-message"><p>how would the complexity differ if the tree is a BST in both the solutions mentioned above?<br />
would it be O(nlogn) for first solution?</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-31610">
        <div id="dsq-comment-header-31610" class="dsq-comment-header">
            <cite id="dsq-cite-31610">
                <span id="dsq-author-user-31610">Nitin</span>
            </cite>
        </div>
        <div id="dsq-comment-body-31610" class="dsq-comment-body">
            <div id="dsq-comment-message-31610" class="dsq-comment-message"><p>is this correct??</p>
<p>int d=0;<br />
int dia(node *root)<br />
{<br />
    if(!root)<br />
    return 0;<br />
    int h1=dia(root-&gt;left);<br />
    int h2=dia(root-&gt;right);<br />
    d=max(d,h1+h2+1);<br />
    return d;<br />
}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-29738">
        <div id="dsq-comment-header-29738" class="dsq-comment-header">
            <cite id="dsq-cite-29738">
http://www.TechProceed.com                <span id="dsq-author-user-29738">Snehal Masne</span>
            </cite>
        </div>
        <div id="dsq-comment-body-29738" class="dsq-comment-body">
            <div id="dsq-comment-message-29738" class="dsq-comment-message"><p>The most easy algo for this is:<br />
Do a BFS from root.. then find out the node with the largest distance assigned(assuming each edge to be of length = 1) then Do a BFS from that node, the largest assigned node in this case is the Diameter of tree&#8230;.<br />
Let me know if m incorrect!!</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-2" id="dsq-comment-30317">
        <div id="dsq-comment-header-30317" class="dsq-comment-header">
            <cite id="dsq-cite-30317">
                <span id="dsq-author-user-30317">babar</span>
            </cite>
        </div>
        <div id="dsq-comment-body-30317" class="dsq-comment-body">
            <div id="dsq-comment-message-30317" class="dsq-comment-message"><p>u are correct.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt depth-2" id="dsq-comment-30534">
        <div id="dsq-comment-header-30534" class="dsq-comment-header">
            <cite id="dsq-cite-30534">
                <span id="dsq-author-user-30534">sachin</span>
            </cite>
        </div>
        <div id="dsq-comment-body-30534" class="dsq-comment-body">
            <div id="dsq-comment-message-30534" class="dsq-comment-message"><p>Can you explain a little more? I didn&#8217;t get your solution. Thanks in advance.<br />
Thanks</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even depth-2" id="dsq-comment-30568">
        <div id="dsq-comment-header-30568" class="dsq-comment-header">
            <cite id="dsq-cite-30568">
                <span id="dsq-author-user-30568">Gaurav Ramesh</span>
            </cite>
        </div>
        <div id="dsq-comment-body-30568" class="dsq-comment-body">
            <div id="dsq-comment-message-30568" class="dsq-comment-message"><p>what about the direction of the links ? how will you reach any other node from a leaf ?.. the idea is good though</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-3" id="dsq-comment-30607">
        <div id="dsq-comment-header-30607" class="dsq-comment-header">
            <cite id="dsq-cite-30607">
                <span id="dsq-author-user-30607">its_dark</span>
            </cite>
        </div>
        <div id="dsq-comment-body-30607" class="dsq-comment-body">
            <div id="dsq-comment-message-30607" class="dsq-comment-message"><p>the algo can be used for calculating diameter for an undirected  graph, rather than tree</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-28975">
        <div id="dsq-comment-header-28975" class="dsq-comment-header">
            <cite id="dsq-cite-28975">
                <span id="dsq-author-user-28975">DarkProtocol</span>
            </cite>
        </div>
        <div id="dsq-comment-body-28975" class="dsq-comment-body">
            <div id="dsq-comment-message-28975" class="dsq-comment-message"><p>Can any one explain how come the solution provided is O(N^2) &#8230; and optimition is O(n),, ,i dnt see much diff</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-29011">
        <div id="dsq-comment-header-29011" class="dsq-comment-header">
            <cite id="dsq-cite-29011">
                <span id="dsq-author-user-29011">vishal11</span>
            </cite>
        </div>
        <div id="dsq-comment-body-29011" class="dsq-comment-body">
            <div id="dsq-comment-message-29011" class="dsq-comment-message"><p>for a skewed tree the height function has to be called each time for every node and it is doing this for every node that why the first method is o(n^2) and for the second method height of a node is calculated in the function itself and that why the second method is o(n)</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-28817">
        <div id="dsq-comment-header-28817" class="dsq-comment-header">
            <cite id="dsq-cite-28817">
                <span id="dsq-author-user-28817">Ashok</span>
            </cite>
        </div>
        <div id="dsq-comment-body-28817" class="dsq-comment-body">
            <div id="dsq-comment-message-28817" class="dsq-comment-message"><p>why can&#8217;t we interpret as levelOf(leftSubTree)+levelOf(RightSubTree)+1.</p>
<p>+1 for root. Essentially, we need to traverse the tree in level order. So complexity will be O(n).</p>
<p>Any thoughts ?</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-28820">
        <div id="dsq-comment-header-28820" class="dsq-comment-header">
            <cite id="dsq-cite-28820">
                <span id="dsq-author-user-28820">Ashok</span>
            </cite>
        </div>
        <div id="dsq-comment-body-28820" class="dsq-comment-body">
            <div id="dsq-comment-message-28820" class="dsq-comment-message"><p>never mind, this may not be true always, as the longest path need not to go thru root always..</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-28479">
        <div id="dsq-comment-header-28479" class="dsq-comment-header">
            <cite id="dsq-cite-28479">
                <span id="dsq-author-user-28479">Vivek</span>
            </cite>
        </div>
        <div id="dsq-comment-body-28479" class="dsq-comment-body">
            <div id="dsq-comment-message-28479" class="dsq-comment-message"><p>#include<br />
#include<br />
struct node<br />
{<br />
    int data;<br />
    struct node* left;<br />
    struct node* right;<br />
};</p>
<p>/* function to create a new node of tree and returns pointer */<br />
struct node* newNode(int data);</p>
<p>/* returns max of two integers */<br />
int max(int a, int b);</p>
<p>/* function to Compute height of a tree. */<br />
int height(struct node* node);<br />
int max(int a, int b)<br />
{<br />
	return b&gt;a?b:a;<br />
}</p>
<p>int get_height(struct node *root)<br />
{<br />
	if(root)<br />
	{<br />
		return 1+max(get_height(root-&gt;left),get_height(root-&gt;right));<br />
	}<br />
	else<br />
	return 0;<br />
}</p>
<p>int get_diameter(struct node *root)<br />
{<br />
	if(root)</p>
<p>	return (max((1 + get_height(root-&gt;left) + get_height(root-&gt;right)),max(get_diameter(root-&gt;left),get_diameter(root-&gt;right))));<br />
	else<br />
	return 0;<br />
}</p>
<p>struct node* newNode(int data)<br />
{<br />
  struct node* node = (struct node*)<br />
                       malloc(sizeof(struct node));<br />
  node-&gt;data = data;<br />
  node-&gt;left = NULL;<br />
  node-&gt;right = NULL;</p>
<p>  return(node);<br />
}</p>
<p>int main()<br />
{</p>
<p>  /* Constructed binary tree is<br />
            1<br />
          /<br />
        2      3<br />
      /<br />
    4     5<br />
  */<br />
  struct node *root = newNode(1);<br />
  root-&gt;left        = newNode(2);<br />
  root-&gt;right       = newNode(3);<br />
  root-&gt;left-&gt;left  = newNode(4);<br />
  root-&gt;left-&gt;right = newNode(5);</p>
<p>  printf(&#8220;Diameter of the given binary tree is %dn&#8221;, get_diameter(root));</p>
<p>  getchar();<br />
  return 0;<br />
}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-28158">
        <div id="dsq-comment-header-28158" class="dsq-comment-header">
            <cite id="dsq-cite-28158">
                <span id="dsq-author-user-28158">Neha Garg</span>
            </cite>
        </div>
        <div id="dsq-comment-body-28158" class="dsq-comment-body">
            <div id="dsq-comment-message-28158" class="dsq-comment-message"><p>i have one doubt &#8230; please somebody clear it<br />
in optimized soluton where we are updating the values of lh and rh ????</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-2" id="dsq-comment-29539">
        <div id="dsq-comment-header-29539" class="dsq-comment-header">
            <cite id="dsq-cite-29539">
                <span id="dsq-author-user-29539">Anon</span>
            </cite>
        </div>
        <div id="dsq-comment-body-29539" class="dsq-comment-body">
            <div id="dsq-comment-message-29539" class="dsq-comment-message"><p>I think they&#8217;re passed by ref, so they&#8217;re being updating already.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-24963">
        <div id="dsq-comment-header-24963" class="dsq-comment-header">
            <cite id="dsq-cite-24963">
                <span id="dsq-author-user-24963">sumit dey</span>
            </cite>
        </div>
        <div id="dsq-comment-body-24963" class="dsq-comment-body">
            <div id="dsq-comment-message-24963" class="dsq-comment-message"><p>The above solution will not work because for skewed tree the diameter should be zero and tree for example should have diameter 3.</p>
<p>1<br />
  \<br />
   2<br />
    \<br />
     4<br />
    / \<br />
   3   5</p>
<pre> <code language="C">
public class FindDiameter{

	class Tree{
	
		Object data;
		Tree lftChild;
		Tree rhtChild;
	}
    class MaxLengthSoFar{
	
		Tree node; // to store the root node that give rise to the diameter
		int maxLength;// to store the diameter 
		
		public int getMaxLength(){
			return maxLength;
		}
	
		public void setMaxLength(int maxLen){
			maxLength=maxLen;
		}
		public void setNode(Tree pNode){
			node=pNaode;
		}
	}


	public int getDiameter(Tree root){

		int heightOfTree=getDiameter(root,this.new MaxLengthSoFar());
		return maxLengthSofar.getMaxLength();
	}	

	private int getDiameter(Tree root,MaxLengthSoFar dataTracker){
	
		if(root==null)
			return 0;
		
		int hieghtLch=getDiameter(root.lftChild,dataTracker);
		int heightRch=getDiameter(root.rhtChild,dataTracker);
	//these two conditions for left-height and right-height foe non zero is added because the solution for skewed tree should be zero
		if(hieghtLch!=0 &amp;&amp; heightRch!=0 &amp;&amp; (hieghtLch+heightRch+1)&gt;dataTracker.getMaxLength()){
			dataTracker.setMaxLength(hieghtLch+heightRch+1);
			dataTracker.setNode(root);
		}
		
		return (hieghtLch&gt;heightRch?heightLch:heightRch)+1;
	}


}
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-sumit5113 even thread-odd thread-alt depth-1" id="dsq-comment-24962">
        <div id="dsq-comment-header-24962" class="dsq-comment-header">
            <cite id="dsq-cite-24962">
                <span id="dsq-author-user-24962">sumit5113</span>
            </cite>
        </div>
        <div id="dsq-comment-body-24962" class="dsq-comment-body">
            <div id="dsq-comment-message-24962" class="dsq-comment-message"><p>The following solution is elegant and simple. It calculates both height and diameter of the tree.</p>
<pre> <code language="C">
public class FindDiameter{

	class Tree{
	
		Object data;
		Tree lftChild;
		Tree rhtChild;
	}
    class MaxLengthSoFar{
	
		Tree node; // to store the root node that give rise to the diameter
		int maxLength;// to store the diameter 
		
		public int getMaxLength(){
			return maxLength;
		}
	
		public void setMaxLength(int maxLen){
			maxLength=maxLen;
		}
		public void setNode(Tree pNode){
			node=pNaode;
		}
	}


	public int getDiameter(Tree root){

		int heightOfTree=getDiameter(root,this.new MaxLengthSoFar());
		return maxLengthSofar.getMaxLength();
	}	

	private int getDiameter(Tree root,MaxLengthSoFar dataTracker){
	
		if(root==null)
			return 0;
		
		int hieghtLch=getDiameter(root.lftChild,dataTracker);
		int heightRch=getDiameter(root.rhtChild,dataTracker);

		if((hieghtLch+heightRch+1)&gt;dataTracker.getMaxLength()){
			dataTracker.setMaxLength(hieghtLch+heightRch+1);
			dataTracker.setNode(root);
		}
		
		return (hieghtLch&gt;heightRch?heightLch:heightRch)+1;
	}


}
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-sumit5113 odd alt thread-even depth-1" id="dsq-comment-24958">
        <div id="dsq-comment-header-24958" class="dsq-comment-header">
            <cite id="dsq-cite-24958">
                <span id="dsq-author-user-24958">sumit5113</span>
            </cite>
        </div>
        <div id="dsq-comment-body-24958" class="dsq-comment-body">
            <div id="dsq-comment-message-24958" class="dsq-comment-message"><p>Here is the code that is simple and elegant, it calculate both height and diameter of the tree.</p>
<p>It&#8217;s my request to you guys if you find any test case that invalidate the logic. Please suggest me that case.</p>
<pre> <code language="C">
public class FindDiameter{

	class Tree{
	
		Object data;
		Tree lftChild;
		Tree rhtChild;
	}
    class MaxLengthSoFar{
	
		Tree node;
		int maxLength;
		
		public int getMaxLength(){
			return maxLength;
		}
	
		public void setMaxLength(int maxLen){
			maxLength=maxLen;
		}
		public void setNode(Tree pNode){
			node=pNaode;
		}
	}


	public int getDiameter(Tree root){

		int heightOfTree=getDiameter(root,this.new MaxLengthSoFar());
		return maxLengthSofar.getMaxLength();
	}	

	private int getDiameter(Tree root,MaxLengthSoFar dataTracker){
	
		if(root==null)
			return 0;
		
		int hieghtLch=getDiameter(root.lftChild,dataTracker);
		int heightRch=getDiameter(root.rhtChild,dataTracker);

		if((hieghtLch+heightRch+1)&gt;dataTracker.getMaxLength()){
			dataTracker.setMaxLength(hieghtLch+heightRch+1);
			dataTracker.setNode(root);
		}
		
		return (hieghtLch&gt;heightRch?heightLch:heightRch)+1;
	}


}
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-2" id="dsq-comment-30688">
        <div id="dsq-comment-header-30688" class="dsq-comment-header">
            <cite id="dsq-cite-30688">
                <span id="dsq-author-user-30688">Code_Addict</span>
            </cite>
        </div>
        <div id="dsq-comment-body-30688" class="dsq-comment-body">
            <div id="dsq-comment-message-30688" class="dsq-comment-message"><p>awesome man!!</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt depth-2" id="dsq-comment-31548">
        <div id="dsq-comment-header-31548" class="dsq-comment-header">
            <cite id="dsq-cite-31548">
                <span id="dsq-author-user-31548">srinu</span>
            </cite>
        </div>
        <div id="dsq-comment-body-31548" class="dsq-comment-body">
            <div id="dsq-comment-message-31548" class="dsq-comment-message"><p>i did n&#8217;t understand this line &#8211;&gt; maxLengthSofar.getMaxLength()</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment byuser comment-author-harshbalyan even thread-odd thread-alt depth-1" id="dsq-comment-24805">
        <div id="dsq-comment-header-24805" class="dsq-comment-header">
            <cite id="dsq-cite-24805">
                <span id="dsq-author-user-24805">HarshBalyan</span>
            </cite>
        </div>
        <div id="dsq-comment-body-24805" class="dsq-comment-body">
            <div id="dsq-comment-message-24805" class="dsq-comment-message"><pre> <code language="Java">
int maxNum=0;
static int diameter(TreeNode root).
{
if(root==null) return 0;.
int left=diameter(root.left);
int right=diameter(root.right);
if(left+right+1&gt;maxNum)
{
maxNum=left+right+1;
}
return Math.max(maxNum,1+Math.max(left, right));
}
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-28032">
        <div id="dsq-comment-header-28032" class="dsq-comment-header">
            <cite id="dsq-cite-28032">
                <span id="dsq-author-user-28032">sunil</span>
            </cite>
        </div>
        <div id="dsq-comment-body-28032" class="dsq-comment-body">
            <div id="dsq-comment-message-28032" class="dsq-comment-message"><p>last line 1+Math.max(left, right));<br />
&#8220;1+&#8221; should not be there right?</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-22193">
        <div id="dsq-comment-header-22193" class="dsq-comment-header">
            <cite id="dsq-cite-22193">
                <span id="dsq-author-user-22193">saurabh</span>
            </cite>
        </div>
        <div id="dsq-comment-body-22193" class="dsq-comment-body">
            <div id="dsq-comment-message-22193" class="dsq-comment-message"><p>We can also calculate diameter by making small<br />
modification in max_depth code .</p>
<p>concept: Maximize diameter at every node when calculating max_depth</p>
<pre> <code language="C">
int diameter=0;
int max_depth(struct node* root){
    if(root==NULL)return 0;
    
    int h1= max_depth(root-&gt;left);
    int h2= max_depth(root-&gt;right);
    
    diameter = max(diameter,h1+h2+1);
    
    return max(h1,h2)+1;
    }
</code> </pre>
<p>comment if you find this incorrect.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-22251">
        <div id="dsq-comment-header-22251" class="dsq-comment-header">
            <cite id="dsq-cite-22251">
                <span id="dsq-author-user-22251">ankitesh</span>
            </cite>
        </div>
        <div id="dsq-comment-body-22251" class="dsq-comment-body">
            <div id="dsq-comment-message-22251" class="dsq-comment-message"><p>it&#8217;s correct &#8230; </p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even depth-2" id="dsq-comment-22252">
        <div id="dsq-comment-header-22252" class="dsq-comment-header">
            <cite id="dsq-cite-22252">
                <span id="dsq-author-user-22252">ankitesh</span>
            </cite>
        </div>
        <div id="dsq-comment-body-22252" class="dsq-comment-body">
            <div id="dsq-comment-message-22252" class="dsq-comment-message"><p>i also thought d same &#8230;. It&#8217;s correct </p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt depth-2" id="dsq-comment-31608">
        <div id="dsq-comment-header-31608" class="dsq-comment-header">
            <cite id="dsq-cite-31608">
                <span id="dsq-author-user-31608">Nitin</span>
            </cite>
        </div>
        <div id="dsq-comment-body-31608" class="dsq-comment-body">
            <div id="dsq-comment-message-31608" class="dsq-comment-message"><p>can u plz explain this?</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even depth-2" id="dsq-comment-31609">
        <div id="dsq-comment-header-31609" class="dsq-comment-header">
            <cite id="dsq-cite-31609">
                <span id="dsq-author-user-31609">Nitin</span>
            </cite>
        </div>
        <div id="dsq-comment-body-31609" class="dsq-comment-body">
            <div id="dsq-comment-message-31609" class="dsq-comment-message"><p>why r u returning max(h1,h2)+1</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment byuser comment-author-pranjalgupta odd alt thread-odd thread-alt depth-1" id="dsq-comment-22044">
        <div id="dsq-comment-header-22044" class="dsq-comment-header">
            <cite id="dsq-cite-22044">
                <span id="dsq-author-user-22044">pranjalgupta</span>
            </cite>
        </div>
        <div id="dsq-comment-body-22044" class="dsq-comment-body">
            <div id="dsq-comment-message-22044" class="dsq-comment-message"><p>To simplify the implementation of this question, we can return a structure consisting of diameter and height of a node.Following is the function to accomplish this:<br />
Firstly we create a node that we will return by our function<br />
typedef struct di<br />
{<br />
    int h;<br />
    int d;<br />
}<br />
diam;</p>
<p>diam diameter(tree* root)<br />
{<br />
    if(root==NULL)<br />
    {<br />
        diam temp;<br />
        temp.h=0;<br />
        temp.d=0;<br />
        return temp;<br />
    }</p>
<p>    int lh=diameter(root->left).h;<br />
    int rh=diameter(root->right).h;<br />
    int ld=diameter(root->left).d;<br />
    int rd=diameter(root->right).d;</p>
<p>    int height=max(lh,rh)+1;<br />
    diam temp;<br />
    temp.h=height;<br />
    temp.d=max3(lh+rh+1,ld,rd);<br />
    return temp;</p>
<p>}<br />
We can access the final answer using diameter(root).d.<br />
This technique simplifies most of the questions in trees, with only identification of the type of traversal to be identified.</p>
</div>
        </div>

    </li><!-- #comment-## -->
<ul class="children">
    <li class="comment even depth-2" id="dsq-comment-31607">
        <div id="dsq-comment-header-31607" class="dsq-comment-header">
            <cite id="dsq-cite-31607">
                <span id="dsq-author-user-31607">Nitn</span>
            </cite>
        </div>
        <div id="dsq-comment-body-31607" class="dsq-comment-body">
            <div id="dsq-comment-message-31607" class="dsq-comment-message"><p>its 5 only(1-2-5-7-8)</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment byuser comment-author-abhishek08aug odd alt thread-even depth-1" id="dsq-comment-18082">
        <div id="dsq-comment-header-18082" class="dsq-comment-header">
            <cite id="dsq-cite-18082">
                <span id="dsq-author-user-18082">abhishek08aug</span>
            </cite>
        </div>
        <div id="dsq-comment-body-18082" class="dsq-comment-body">
            <div id="dsq-comment-message-18082" class="dsq-comment-message"><p>C++ code:</p>
<pre> <code language="C">
#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;
using namespace std;
 
class tree_node {
  private:
    int data;
    tree_node * left;
    tree_node * right;
  public:
    tree_node() {
      left=NULL;
      right=NULL;
    }
    void set_data(int data) {
      this-&gt;data=data;
    }
    int get_data() {
      return this-&gt;data;
    }
    void set_left(tree_node * left) {
      this-&gt;left=left;
    }
    tree_node * get_left() {
      return this-&gt;left;
    }
    void set_right(tree_node * right) {
      this-&gt;right=right;
    }
    tree_node * get_right() {
      return this-&gt;right;
    }
    tree_node ** get_left_ref() {
      return &amp;(this-&gt;left);
    }
    tree_node ** get_right_ref() {
      return &amp;(this-&gt;right);
    }
};
 
class tree {
  private:
    tree_node * root;
    int size;
    void _recursive_insert(tree_node ** root_ref, int value);
    void _print_preorder(tree_node * root);
    void _print_inorder(tree_node * root);
    void _print_postorder(tree_node * root);
    int _find_size(tree_node * root);
    int _are_identical(tree_node * tn1, tree_node * tn2);
    int _find_height(tree_node * root);
    void _delete_tree(tree_node ** root);
    void _mirror(tree_node * root);
    void _print_paths(tree_node * root, int * path_nodes, int next_vacant_position);
    void _print_array(int * array, int len);
    tree_node * _lowest_common_ancestor(tree_node * parent, tree_node * root, int a, int b);
    tree_node * _find_node(tree_node * root, int value);
    tree_node * _min_node(tree_node * root);
    void _print_level_order(tree_node * root);
    int _count_leaf_nodes(tree_node * root);
    int _is_bst(tree_node * root);
    int _children_sum(tree_node * root);
    void _ensure_children_sum(tree_node * root);
    int _diameter(tree_node * root);
  public:
    tree() {
      root=NULL;
      size=0;
    }
    void insert(int value);
    void recursive_insert(int value);
    void print_preorder();
    void print_inorder();
    void print_postorder();
    int find_size();
    int get_size() {
      return this-&gt;size;
    }
    int are_identical(tree t);
    int find_height();
    void delete_tree();
    void mirror();
    void print_paths();
    tree_node * lowest_common_ancestor(int a, int b);
    tree_node * find_node(int value);
    tree_node * min_node();
    void print_level_order();
    int count_leaf_nodes();
    int is_bst();
    int children_sum();
    void ensure_children_sum();
    int diameter();
};
 
void tree::insert(int value) {
  if(root==NULL) {
    root=new tree_node;
    root-&gt;set_data(value);
  } else {
    tree_node * parent=NULL;
    tree_node * current=root;
    tree_node * new_node=new tree_node;
    new_node-&gt;set_data(value);
    while(current!=NULL) {
      if(value&lt;=current-&gt;get_data()) {
        parent=current;
        current=current-&gt;get_left();
      } else {
        parent=current;
        current=current-&gt;get_right();
      }
    }
    if(value&lt;=parent-&gt;get_data() &amp;&amp; parent-&gt;get_left()==NULL) {
      parent-&gt;set_left(new_node);
    } else if(value&gt;parent-&gt;get_data() &amp;&amp; parent-&gt;get_right()==NULL) {
      parent-&gt;set_right(new_node);
    }
  }
  size++;
}
 
void tree::recursive_insert(int value) {
  _recursive_insert(&amp;root, value);
  size++;
}
 
void tree::_recursive_insert(tree_node ** root_ref, int value) {
  if(*root_ref==NULL) {
    tree_node * new_node=new tree_node;
    new_node-&gt;set_data(value);
    *root_ref=new_node;   
  } else {
    if(value&lt;=(*root_ref)-&gt;get_data()) {
      _recursive_insert((*root_ref)-&gt;get_left_ref(), value);
    } else {
      _recursive_insert((*root_ref)-&gt;get_right_ref(), value);
    }
  }
}
 
void tree::print_preorder() {
  if(root==NULL) {
    return;
  }
  _print_preorder(root);
  cout&lt;&lt;endl;
}
 
void tree::_print_preorder(tree_node * root) {
  if(root==NULL) {
    return;
  }
  cout&lt;&lt;root-&gt;get_data()&lt;&lt;&quot; &quot;;
  if(root-&gt;get_left()!=NULL)
    _print_preorder(root-&gt;get_left());
  if(root-&gt;get_right()!=NULL)
    _print_preorder(root-&gt;get_right());
}
 
void tree::print_inorder() {
  if(root==NULL) {
    return;
  }
  _print_inorder(root);
  cout&lt;&lt;endl;
}
 
void tree::_print_inorder(tree_node * root) {
  if(root==NULL) {
    return;
  }
  if(root-&gt;get_left()!=NULL)
    _print_inorder(root-&gt;get_left());
  cout&lt;&lt;root-&gt;get_data()&lt;&lt;&quot; &quot;;
  if(root-&gt;get_right()!=NULL)
    _print_inorder(root-&gt;get_right());
}
 
void tree::print_postorder() {
  if(root==NULL) {
    return;
  }
  _print_postorder(root);
  cout&lt;&lt;endl;
}
 
void tree::_print_postorder(tree_node * root) {
  if(root==NULL) {
    return;
  }
  if(root-&gt;get_left()!=NULL)
    _print_postorder(root-&gt;get_left());
  if(root-&gt;get_right()!=NULL)
    _print_postorder(root-&gt;get_right());
  cout&lt;&lt;root-&gt;get_data()&lt;&lt;&quot; &quot;;
}

int tree::find_size() {
  return _find_size(root);
}

int tree::_find_size(tree_node * root) {
  if(root==NULL) {
    return 0;
  } else {
    return 1+_find_size(root-&gt;get_left())+_find_size(root-&gt;get_right());
  }
}

int tree::are_identical(tree t) {
  return _are_identical(this-&gt;root, t.root);
}

int tree::_are_identical(tree_node * tn1, tree_node * tn2) {
  if(tn1==NULL &amp;&amp; tn2==NULL) {
    return 1;
  } else if((tn1==NULL &amp;&amp; tn2!=NULL) || (tn1!=NULL &amp;&amp; tn2==NULL) || (tn1-&gt;get_data()!=tn2-&gt;get_data())) {
    return 0;
  } else {
    return _are_identical(tn1-&gt;get_left(), tn2-&gt;get_left()) &amp;&amp; _are_identical(tn1-&gt;get_right(), tn2-&gt;get_right());
  }
}

int tree::find_height() {
  return _find_height(root);
}

int tree::_find_height(tree_node * root) {
  if(root==NULL) {
    return 0;
  }
  else {
    return 1+max(_find_height(root-&gt;get_left()), _find_height(root-&gt;get_right()));
  }
}

void tree::delete_tree() {
  _delete_tree(&amp;root);
  size=0;
}

void tree::_delete_tree(tree_node ** root) {
  if(*root==NULL) {
    return;
  } else {
    if((*root)-&gt;get_left()!=NULL) {
      _delete_tree((*root)-&gt;get_left_ref());
    }
    if((*root)-&gt;get_right()!=NULL) {
      _delete_tree((*root)-&gt;get_right_ref());
    }
    delete(*root);
    *root=NULL;
  }
}

/* alternate _delete_tree */
/*
void tree::_delete_tree(tree_node ** root) {
  if(*root==NULL) {
    return;
  } else {
    if((*root)-&gt;get_left()!=NULL) {
      tree_node * left_ref=(*root)-&gt;get_left();
      _delete_tree(&amp;left_ref);
    }
    if((*root)-&gt;get_right()!=NULL) {
      tree_node * right_ref=(*root)-&gt;get_right();
      _delete_tree(&amp;right_ref);
    }
    delete(*root);
    *root=NULL;
  }
}
*/

void tree::mirror() {
  _mirror(root);
}

void tree::_mirror(tree_node * root) {
  if(root==NULL) {
    return;
  }

  tree_node * temp=root-&gt;get_left();
  root-&gt;set_left(root-&gt;get_right());
  root-&gt;set_right(temp);
  _mirror(root-&gt;get_left());
  _mirror(root-&gt;get_right());
}

void tree::print_paths(){
   int max_path_length=find_height();
   int * path_nodes=(int *)calloc(sizeof(int), max_path_length);
  _print_paths(root, path_nodes, 0);
}

void tree::_print_paths(tree_node * root, int * path_nodes, int next_vacant_position){
  if(root==NULL) {
    return;
  } else if(root-&gt;get_left()==NULL &amp;&amp; root-&gt;get_right()==NULL) {
    *(path_nodes+next_vacant_position)=root-&gt;get_data();
    _print_array(path_nodes, next_vacant_position);
  } else {
    *(path_nodes+next_vacant_position)=root-&gt;get_data();
    _print_paths(root-&gt;get_left(), path_nodes, next_vacant_position+1);
    _print_paths(root-&gt;get_right(), path_nodes, next_vacant_position+1);
  }
}

void tree::_print_array(int * array, int len) {
  int i;
  for(i=0; i&lt;=len; i++) {
    cout&lt;&lt;*(array+i)&lt;&lt;&quot; &quot;;
  }
  cout&lt;&lt;endl;
}

tree_node * tree::find_node(int value) {
  return _find_node(root, value);
}

tree_node * tree::_find_node(tree_node * root, int value) {
  if(root==NULL || root-&gt;get_data()==value) {
    return root;
  } else if(value&lt;=root-&gt;get_data()) {
    return _find_node(root-&gt;get_left(), value);
  } else {
    return _find_node(root-&gt;get_right(), value);
  }
}

tree_node * tree::lowest_common_ancestor(int a, int b) {
  return _lowest_common_ancestor(NULL, root, a, b);
}

tree_node * tree::_lowest_common_ancestor(tree_node * parent, tree_node * root, int a, int b) {
  if(root==NULL) {
    return root;
  } else if((root-&gt;get_data()==a &amp;&amp; (root-&gt;get_left()-&gt;get_data()==b || root-&gt;get_right()-&gt;get_data()==b))
             || (root-&gt;get_data()==b &amp;&amp; (root-&gt;get_left()-&gt;get_data()==a || root-&gt;get_right()-&gt;get_data()==a))) {
    return parent;
  } else if((_find_node(root-&gt;get_left(), a)!=NULL &amp;&amp; _find_node(root-&gt;get_right(), b)!=NULL)
        || (_find_node(root-&gt;get_left(), b)!=NULL &amp;&amp; _find_node(root-&gt;get_right(), a)!=NULL)) {
    return root; 
  } else if(_find_node(root-&gt;get_left(), a)!=NULL &amp;&amp; _find_node(root-&gt;get_left(), b)!=NULL) {
    return _lowest_common_ancestor(root, root-&gt;get_left(), a, b);
  } else if(_find_node(root-&gt;get_right(), a)!=NULL &amp;&amp; _find_node(root-&gt;get_right(), b)!=NULL) {
    return _lowest_common_ancestor(root, root-&gt;get_right(), a, b);
  } else {
    return NULL;
  }
}

tree_node * tree::min_node() {
  return _min_node(root);
}

tree_node * tree::_min_node(tree_node * root) {
  if(root==NULL || root-&gt;get_left()==NULL) {
    return root;
  } else {
    return _min_node(root-&gt;get_left());
  }
}

int tree::count_leaf_nodes() {
  return _count_leaf_nodes(root);
}

int tree::_count_leaf_nodes(tree_node * root) {
  if(root==NULL) {
    return 0;
  } else if(root-&gt;get_left()==NULL &amp;&amp; root-&gt;get_right()==NULL) {
    return 1;
  } else {
    return _count_leaf_nodes(root-&gt;get_left())+_count_leaf_nodes(root-&gt;get_right());
  }
}


int tree::is_bst() {
  return _is_bst(root);
}

int tree::_is_bst(tree_node * root) {
  static tree_node * previous=NULL;
  if(root==NULL) {
    return 1;
  } else {
    if(!_is_bst(root-&gt;get_left())) {
      return 0;
    }
    if(previous!=NULL &amp;&amp; (previous-&gt;get_data())&gt;(root-&gt;get_data())) {
      return 0;
    }
    previous=root;
    if(!_is_bst(root-&gt;get_right())) {
      return 0;
    }    
  }
}

int tree::children_sum() {
  return _children_sum(root);
}

int tree::_children_sum(tree_node * root) {
  if(root==NULL) {
    return 1;
  }
  if(root-&gt;get_left()==NULL &amp;&amp; root-&gt;get_right()==NULL) {
    return 1;
  }
  else if(_children_sum(root-&gt;get_left()) &amp;&amp; _children_sum(root-&gt;get_right())){
    int left_data;
    int right_data;
    if(root-&gt;get_left()!=NULL) {
      left_data=root-&gt;get_left()-&gt;get_data();
    } else {
      left_data=0;
    }
    if(root-&gt;get_right()!=NULL) {
      right_data=root-&gt;get_right()-&gt;get_data();
    } else {
      right_data=0;
    }

    if(left_data+right_data==root-&gt;get_data()) {
      return 1;
    } else {
      return 0;
    }
  } else {
    return 0;
  }
}

void tree::ensure_children_sum() {
  _ensure_children_sum(root);
}

void tree::_ensure_children_sum(tree_node * root) {
  if(root==NULL || (root-&gt;get_left()==NULL &amp;&amp; root-&gt;get_right()==NULL)) {
    return;
  } else {
    _ensure_children_sum(root-&gt;get_left());
    _ensure_children_sum(root-&gt;get_right());
    int left_data;
    int right_data;
    if(root-&gt;get_left()!=NULL) {
      left_data=root-&gt;get_left()-&gt;get_data();
    } else {
      left_data=0;
    }
    if(root-&gt;get_right()!=NULL) {
      right_data=root-&gt;get_right()-&gt;get_data();
    } else {
      right_data=0;
    }
    root-&gt;set_data(left_data+right_data);
  }
}

int tree::diameter() {
  return _diameter(root);
}

int tree::_diameter(tree_node * root) {
  if(root==NULL) {
    return 0;
  } else {
    return max(_find_height(root-&gt;get_left())+_find_height(root-&gt;get_right())+1, max(_diameter(root-&gt;get_left()), _diameter(root-&gt;get_left())));
  }
}

int main() {
  tree t1;

  t1.recursive_insert(5);
  t1.recursive_insert(3);
  t1.insert(10);
  t1.insert(7);
  t1.recursive_insert(50);
  t1.recursive_insert(6);
  t1.recursive_insert(1);
  t1.recursive_insert(45);
  t1.recursive_insert(55);
  t1.recursive_insert(4);
  t1.recursive_insert(70);

  t1.print_inorder();

  cout&lt;&lt;&quot;Diameter of the tree is: &quot;&lt;&lt;t1.diameter()&lt;&lt;endl;

  return 0;
}
</code> </pre>
<p>1 3 4 5 6 7 10 45 50 55 70<br />
Diameter of the tree is: 7</p>
</div>
        </div>

    </li><!-- #comment-## -->
</li><!-- #comment-## -->
    <li class="comment byuser comment-author-bhengra-amit even thread-odd thread-alt depth-1" id="dsq-comment-17004">
        <div id="dsq-comment-header-17004" class="dsq-comment-header">
            <cite id="dsq-cite-17004">
                <span id="dsq-author-user-17004">bhengra.amit</span>
            </cite>
        </div>
        <div id="dsq-comment-body-17004" class="dsq-comment-body">
            <div id="dsq-comment-message-17004" class="dsq-comment-message"><p>Why isn&#8217;t diameter of a node = lh + rh +2 ?</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-shailraj odd alt thread-even depth-1" id="dsq-comment-16693">
        <div id="dsq-comment-header-16693" class="dsq-comment-header">
            <cite id="dsq-cite-16693">
                <span id="dsq-author-user-16693">shailraj</span>
            </cite>
        </div>
        <div id="dsq-comment-body-16693" class="dsq-comment-body">
            <div id="dsq-comment-message-16693" class="dsq-comment-message"><p>will it work ?<br />
int path(struct binary *tree,int &#038;len){<br />
    if(tree==NULL)<br />
        return 0;<br />
    int p1,p2;<br />
    p1=p2=0;<br />
    if(tree-> left){<br />
        p1=path(tree->left);<br />
    }<br />
    if(tree-> right){<br />
        p2=path(tree->right);<br />
    }<br />
    if(len < p1+p2+1)<br />
        len=p1+p2+1;<br />
    return max(p1,p2)+1;<br />
 }</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-16437">
        <div id="dsq-comment-header-16437" class="dsq-comment-header">
            <cite id="dsq-cite-16437">
                <span id="dsq-author-user-16437">rohit</span>
            </cite>
        </div>
        <div id="dsq-comment-body-16437" class="dsq-comment-body">
            <div id="dsq-comment-message-16437" class="dsq-comment-message"><p>/*have a look at this O(n) solution*/<br />
#include<br />
#include<br />
#include<br />
#define max(a,b) (a&gt;b?a:b)<br />
struct node<br />
{<br />
int data;<br />
struct node *left;<br />
struct node *right;<br />
};<br />
struct node *newnode(int val)<br />
{<br />
struct node *l=(struct node *)malloc(sizeof(struct node));<br />
l-&gt;data=val;<br />
l-&gt;left=NULL;<br />
l-&gt;right=NULL;<br />
return(l);<br />
}<br />
int maxi=0;<br />
int height(struct node *root)<br />
{<br />
int h1=0,h2=0;<br />
if(root==NULL)<br />
return(0);<br />
h1=height(root-&gt;left);<br />
h2=height(root-&gt;right);<br />
root-&gt;data=max(h1,h2);<br />
return(root-&gt;data+1);<br />
}<br />
void dia(struct node *root)<br />
{<br />
int h1=0,h2=0;<br />
if((root==NULL)||((root-&gt;left==NULL)&amp;&amp;(root-&gt;right==NULL)))<br />
return;<br />
if(root-&gt;left!=NULL)<br />
h1=root-&gt;left-&gt;data+1;<br />
if(root-&gt;right!=NULL)<br />
h2=root-&gt;right-&gt;data+1;<br />
if(h1+h2+1&gt;maxi)<br />
maxi=h1+h2+1;<br />
dia(root-&gt;left);<br />
dia(root-&gt;right);<br />
}<br />
int main()<br />
{<br />
int k;<br />
struct node *root=newnode(1);<br />
root-&gt;left=newnode(2);<br />
root-&gt;right=newnode(3);<br />
root-&gt;left-&gt;left=newnode(4);<br />
root-&gt;left-&gt;right=newnode(5);<br />
root-&gt;left-&gt;right-&gt;right=newnode(8);<br />
k=height(root);<br />
dia(root);<br />
printf(&#8220;%d\n&#8221;,maxi);<br />
return(0);<br />
}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-16334">
        <div id="dsq-comment-header-16334" class="dsq-comment-header">
            <cite id="dsq-cite-16334">
                <span id="dsq-author-user-16334">Navneet</span>
            </cite>
        </div>
        <div id="dsq-comment-body-16334" class="dsq-comment-body">
            <div id="dsq-comment-message-16334" class="dsq-comment-message"><p>I m not very good with recursion and all . Please some body explain me how the lh and rh values increase in the optimized value . Please explain in detail. You can also email me at <a href="mailto:nnavneet.sinha10@gmail.com">nnavneet.sinha10@gmail.com</a><br />
Thanks.</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-15026">
        <div id="dsq-comment-header-15026" class="dsq-comment-header">
            <cite id="dsq-cite-15026">
                <span id="dsq-author-user-15026">akshat215</span>
            </cite>
        </div>
        <div id="dsq-comment-body-15026" class="dsq-comment-body">
            <div id="dsq-comment-message-15026" class="dsq-comment-message"><p>@geeks4geeks:<br />
can you help me figure out,in what aspects Optimised algo O(n) is different from Naive approach O(n^2)</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-kartik odd alt depth-2" id="dsq-comment-15592">
        <div id="dsq-comment-header-15592" class="dsq-comment-header">
            <cite id="dsq-cite-15592">
                <span id="dsq-author-user-15592">kartik</span>
            </cite>
        </div>
        <div id="dsq-comment-body-15592" class="dsq-comment-body">
            <div id="dsq-comment-message-15592" class="dsq-comment-message"><p>Take a closer look at both implementations.  </p>
<p>The code for optimized implementation is just tree traversal type where every node is visited once and O(1) work is done for every node being visited.</p>
<p>In naive implementation, for every node being visited, O(k) work is node where k is number of nodes under it.  This O(k) work is done to find heights of left and right subtrees. Consider skewed tree like following for worst case analysis.  The total time for following tree would be O(n) + O(n-1) + &#8230;&#8230; O(1) which is O(n^2)</p>
<p>If we consider the optimized implementation for following tree, we get the time complexity as O(1) + O(1) + &#8230;.. + O(1) which is O(n).</p>
<pre>
             1
            /
           2
          /
         3
        /
 
     n       
</pre>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-3" id="dsq-comment-23022">
        <div id="dsq-comment-header-23022" class="dsq-comment-header">
            <cite id="dsq-cite-23022">
                <span id="dsq-author-user-23022">Vikrant</span>
            </cite>
        </div>
        <div id="dsq-comment-body-23022" class="dsq-comment-body">
            <div id="dsq-comment-message-23022" class="dsq-comment-message"><p>thanks kartik <img src="http://d2o58evtke57tz.cloudfront.net/wp-includes/images/smilies/icon_smile.gif" alt=":)" class="wp-smiley" /></p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-14894">
        <div id="dsq-comment-header-14894" class="dsq-comment-header">
            <cite id="dsq-cite-14894">
                <span id="dsq-author-user-14894">mrn</span>
            </cite>
        </div>
        <div id="dsq-comment-body-14894" class="dsq-comment-body">
            <div id="dsq-comment-message-14894" class="dsq-comment-message"><pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
int d_so_far=0;

int dmtr(Node *nd,int *d)
{
	if(nd==NULL)
		{*d=0;return 0;}
		
	int dl=0,dr=0;
	int hl=dmtr(nd-&gt;l,&amp;dl);
	int hr=dmtr(nd-&gt;r,&amp;dr);
	if(hl!=0 &amp;&amp; hr!=0)
	{
		*d=maxx(hl+hr+1 , maxx(dl , dr));
		d_so_far=d_so_far &lt; *d ? *d : d_so_far;
	}
	return maxx(hl+1, hr+1);
}

in main() - 
cout&lt;&lt;d_so_far&lt;&lt;endl;
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-2" id="dsq-comment-15581">
        <div id="dsq-comment-header-15581" class="dsq-comment-header">
            <cite id="dsq-cite-15581">
                <span id="dsq-author-user-15581">mrn</span>
            </cite>
        </div>
        <div id="dsq-comment-body-15581" class="dsq-comment-body">
            <div id="dsq-comment-message-15581" class="dsq-comment-message"><pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
int diameter(Node n,int *d)
{
	if(n==NULL) {return 0;}
	int dl=0,dr=0;
	int lh=diameter(n-&gt;l,&amp;dl);
	int lr=diameter(n-&gt;r,&amp;dr);
	int newl=lh+lr+1;
	int newd=dl&gt;dr?(dl&gt;newl?dl:newl):(dr&gt;newl?dr:newl);
	if(newd &gt; *d) *d=newd;
	return lh&gt;lr?lh+1:lr+1;
}
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-14591">
        <div id="dsq-comment-header-14591" class="dsq-comment-header">
            <cite id="dsq-cite-14591">
                <span id="dsq-author-user-14591">kkkmaurya</span>
            </cite>
        </div>
        <div id="dsq-comment-body-14591" class="dsq-comment-body">
            <div id="dsq-comment-message-14591" class="dsq-comment-message"><pre> <code language="C">
int diameter(struct tree *node, *dia)
{
	if(node == NULL)return 0;
	lh= diameter(node-&gt;left,dia);
	rh=diameter(node-&gt;right,dia);
	total=lh+rh+1;
	if(total &gt;*dia)
	*dia=total;
	return max(lh,rh)+1;
}
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-14474">
        <div id="dsq-comment-header-14474" class="dsq-comment-header">
            <cite id="dsq-cite-14474">
                <span id="dsq-author-user-14474">AT</span>
            </cite>
        </div>
        <div id="dsq-comment-body-14474" class="dsq-comment-body">
            <div id="dsq-comment-message-14474" class="dsq-comment-message"><p>While I agree with your solution, I am having hard find figuring out why my solution might be incorrect. Please share your comments.</p>
<p>As I see, we can maintain a max_sum variable and count the height of the left subtree (lh), height of right subtree (rh) and update the max_sum if lh + rh + 1 is its greater. We calculate this sum at each of the nodes in the tree.</p>
<p>From your solution, ultimately the diameters will be calculated based on heights of the left and right subtrees at some point of time in the code.</p>
<p>I am only removing the calculation of Max of diameters of left and right subtrees. I think my solution might take a hit in terms of time complexity.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-13426">
        <div id="dsq-comment-header-13426" class="dsq-comment-header">
            <cite id="dsq-cite-13426">
                <span id="dsq-author-user-13426">Vivek</span>
            </cite>
        </div>
        <div id="dsq-comment-body-13426" class="dsq-comment-body">
            <div id="dsq-comment-message-13426" class="dsq-comment-message"><p>This method is passing both cases through root and not through root.<br />
In this temp is having the result of maximum diameter so far and it gets updated.<br />
Height is also recursively found. Then pointer *dia contains the max dia and not the value returned by function.</p>
<p>Please check if its failing in some scenario.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-13425">
        <div id="dsq-comment-header-13425" class="dsq-comment-header">
            <cite id="dsq-cite-13425">
                <span id="dsq-author-user-13425">Vivek</span>
            </cite>
        </div>
        <div id="dsq-comment-body-13425" class="dsq-comment-body">
            <div id="dsq-comment-message-13425" class="dsq-comment-message"><pre> <code language="C">
//to get the diameter of given tree 
int diameter(node *nodeptr, int *dia) 
{ 
 int left_h,right_h,temp; 
 if(!nodeptr) 
 	return 0;	 
 left_h = diameter(nodeptr-&gt;left,dia); 
 right_h = diameter(nodeptr-&gt;right,dia); 
 temp = left_h + right_h + 1; 
 if(temp &gt; *dia) 
 	*dia = temp; 
 return (max(left_h,right_h) + 1); 
} 
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-13427">
        <div id="dsq-comment-header-13427" class="dsq-comment-header">
            <cite id="dsq-cite-13427">
                <span id="dsq-author-user-13427">Vivek</span>
            </cite>
        </div>
        <div id="dsq-comment-body-13427" class="dsq-comment-body">
            <div id="dsq-comment-message-13427" class="dsq-comment-message"><p>Here temp contains the diameter till current level and *dia contains the max diameter. Its fulfilling above two cases with root and without root.<br />
Its calculating left subtree height and right subtree height through recursion.<br />
The function doesn&#8217;t return the max diameter , it returns max height.<br />
Please check if something is wrong.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-3" id="dsq-comment-19954">
        <div id="dsq-comment-header-19954" class="dsq-comment-header">
            <cite id="dsq-cite-19954">
                <span id="dsq-author-user-19954">Saurabh Vats</span>
            </cite>
        </div>
        <div id="dsq-comment-body-19954" class="dsq-comment-body">
            <div id="dsq-comment-message-19954" class="dsq-comment-message"><pre> <code language="C">
int diameter(node *nodeptr, int *dia) 
{ 
 int left_h,right_h,temp; 
 if(!nodeptr) 
    return 0;    
 left_h = diameter(nodeptr-&gt;left,dia); 
 right_h = diameter(nodeptr-&gt;right,dia); 
 temp = left_h + right_h;  // here was the problem
 if(temp &gt; *dia) 
    *dia = temp; 
 return (max(left_h,right_h) + 1); 
} 
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-12109">
        <div id="dsq-comment-header-12109" class="dsq-comment-header">
            <cite id="dsq-cite-12109">
                <span id="dsq-author-user-12109">rsingh</span>
            </cite>
        </div>
        <div id="dsq-comment-body-12109" class="dsq-comment-body">
            <div id="dsq-comment-message-12109" class="dsq-comment-message"><p>Is anything wrong this way ?</p>
<pre> <code language="C">
void converttree(node * root){
    if(root==NULL||root-&gt;left==NULL&amp;&amp;root-&gt;right==NULL)
        return;
    int leftdata = 0,rightdata = 0;
    if(root-&gt;left!=NULL)
        leftdata = root-&gt;left-&gt;key;
    if(root-&gt;right!=NULL)
        rightdata = root-&gt;right-&gt;key;

    int diff,sum;
    sum = leftdata+rightdata;

    if(root-&gt;key &gt; sum){
        diff = root-&gt;key - sum;
        root-&gt;left-&gt;key += diff;
    }
    converttree(root-&gt;left);
    converttree(root-&gt;right);
    root-&gt;key = root-&gt;left-&gt;key + root-&gt;right-&gt;key;
}
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-2" id="dsq-comment-12110">
        <div id="dsq-comment-header-12110" class="dsq-comment-header">
            <cite id="dsq-cite-12110">
                <span id="dsq-author-user-12110">rsingh</span>
            </cite>
        </div>
        <div id="dsq-comment-body-12110" class="dsq-comment-body">
            <div id="dsq-comment-message-12110" class="dsq-comment-message"><p>replace last line with the following lines</p>
<p>    if(root-&gt;left!=NULL)<br />
        root-&gt;key += root-&gt;left-&gt;key;<br />
    if(root-&gt;right!=NULL)<br />
        root-&gt;key += root-&gt;right-&gt;key;</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-12108">
        <div id="dsq-comment-header-12108" class="dsq-comment-header">
            <cite id="dsq-cite-12108">
                <span id="dsq-author-user-12108">rsingh</span>
            </cite>
        </div>
        <div id="dsq-comment-body-12108" class="dsq-comment-body">
            <div id="dsq-comment-message-12108" class="dsq-comment-message"><p>Is anything is wrong with following code ?</p>
<pre> <code language="C">
void converttree(node * root){
    if(root==NULL||root-&gt;left==NULL&amp;&amp;root-&gt;right==NULL)
        return;
    int leftdata = 0,rightdata = 0;
    if(root-&gt;left!=NULL)
        leftdata = root-&gt;left-&gt;key;
    if(root-&gt;right!=NULL)
        rightdata = root-&gt;right-&gt;key;

    int diff,sum;
    sum = leftdata+rightdata;

    if(root-&gt;key &gt; sum){
        diff = root-&gt;key - sum;
        root-&gt;left-&gt;key += diff;
    }
    converttree(root-&gt;left);
    converttree(root-&gt;right);
    root-&gt;key = root-&gt;left-&gt;key + root-&gt;right-&gt;key;
}
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-10420">
        <div id="dsq-comment-header-10420" class="dsq-comment-header">
            <cite id="dsq-cite-10420">
                <span id="dsq-author-user-10420">leet</span>
            </cite>
        </div>
        <div id="dsq-comment-body-10420" class="dsq-comment-body">
            <div id="dsq-comment-message-10420" class="dsq-comment-message"><p>What if the tree is skewed ? then longest path between two leaves ?<br />
As there is only one leaf.<br />
According to your algo it will return height of the tree.<br />
or the definition should change to longest path in the tree</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-10304">
        <div id="dsq-comment-header-10304" class="dsq-comment-header">
            <cite id="dsq-cite-10304">
                <span id="dsq-author-user-10304">piyush</span>
            </cite>
        </div>
        <div id="dsq-comment-body-10304" class="dsq-comment-body">
            <div id="dsq-comment-message-10304" class="dsq-comment-message"><pre> <code language="C">
int max_dia=0;
diameter(struct node *T)
{
 if(T)
 {
  l=diameter(T-&gt;lptr);
  r=diameter(T-&gt;rptr);
  max_dia=maxValue(l+r+1,max);
  return maxValue(l,r)+1; 
 }
 else
 {
 return 0;
 }
}

//tell me if something wrong in this logic....
//maxValue is the function which will return max value

</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-2" id="dsq-comment-14466">
        <div id="dsq-comment-header-14466" class="dsq-comment-header">
            <cite id="dsq-cite-14466">
                <span id="dsq-author-user-14466">Piyush Kunal</span>
            </cite>
        </div>
        <div id="dsq-comment-body-14466" class="dsq-comment-body">
            <div id="dsq-comment-message-14466" class="dsq-comment-message"><p>Your logic is incorrect as you are always assuming that diameter will go through the root itself. The diameter may be maximum in the sub-tree itself. </p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-10303">
        <div id="dsq-comment-header-10303" class="dsq-comment-header">
            <cite id="dsq-cite-10303">
                <span id="dsq-author-user-10303">piyush</span>
            </cite>
        </div>
        <div id="dsq-comment-body-10303" class="dsq-comment-body">
            <div id="dsq-comment-message-10303" class="dsq-comment-message"><p>int max_dia=0;<br />
diameter(struct node *T)<br />
{<br />
 if(T)<br />
 {<br />
  l=diameter(T-&gt;lptr);<br />
  r=diameter(T-&gt;rptr);<br />
  max_dia=maxValue(l+r+1,max);<br />
  return maxValue(l,r)+1;<br />
 }<br />
 else<br />
 {<br />
 return 0;<br />
 }<br />
}</p>
<p>//tell me if something wrong in this logic&#8230;.<br />
//maxValue is the function which will return max value</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-10302">
        <div id="dsq-comment-header-10302" class="dsq-comment-header">
            <cite id="dsq-cite-10302">
                <span id="dsq-author-user-10302">piyush</span>
            </cite>
        </div>
        <div id="dsq-comment-body-10302" class="dsq-comment-body">
            <div id="dsq-comment-message-10302" class="dsq-comment-message"><p>int max_dia=0;<br />
diameter(struct node *T)<br />
{<br />
 if(T)<br />
 {<br />
  l=diameter(T-&gt;lptr);<br />
  r=diameter(T-&gt;rptr);<br />
  max_dia=maxValue(l+r+1,max);<br />
  return maxValue(l,r)+1;<br />
 }<br />
 else<br />
 {<br />
 return 0;<br />
 }<br />
}</p>
<p>//tell me if something wrong in this logic&#8230;.<br />
//maxValue is the function which will return max value</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-10144">
        <div id="dsq-comment-header-10144" class="dsq-comment-header">
            <cite id="dsq-cite-10144">
                <span id="dsq-author-user-10144">seabird</span>
            </cite>
        </div>
        <div id="dsq-comment-body-10144" class="dsq-comment-body">
            <div id="dsq-comment-message-10144" class="dsq-comment-message"><pre> <code language="C">
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

typedef struct node{
    int data;
    struct node *left;
    struct node *right;
} node;

void print(node *root)
{
    if(root!=NULL) {
        print(root-&gt;left);
        printf(&quot;%d &quot;,root-&gt;data);
        print(root-&gt;right);
    }
}

int diameter(node *root,int *max)
{
    if(root==NULL)return 0;
    else {
        int l=diameter(root-&gt;left,max);
        int r=diameter(root-&gt;right,max);
        if(*max &lt; l+r+1)*max=l+r+1;
        if(l&gt;r) {
            return l+1;
        } else {
            return r+1;
        }
    }
}

node *make_tree(node *root,int num)
{
    if(root==NULL) {
        node *newnode=malloc(sizeof(node));
        newnode-&gt;data=num;
        newnode-&gt;left=NULL;
        newnode-&gt;right=NULL;
        root=newnode;
    } else {
        if((root-&gt;data) &lt;= num ) {
            root-&gt;right=make_tree(root-&gt;right,num);
        } else {
            root-&gt;left=make_tree(root-&gt;left,num);
        }
    }
    return root;
}

int main()
{
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    int i;
    node *root=NULL;
    int num;
    for(i=0;i&lt;n;i++) {
        scanf(&quot;%d&quot;,&amp;num);
        root=make_tree(root,num);
    }
    int max=0;
    diameter(root,&amp;max);
    printf(&quot;%d\n&quot;,max);
    return 0;
}

</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-9742">
        <div id="dsq-comment-header-9742" class="dsq-comment-header">
            <cite id="dsq-cite-9742">
                <span id="dsq-author-user-9742">Aj</span>
            </cite>
        </div>
        <div id="dsq-comment-body-9742" class="dsq-comment-body">
            <div id="dsq-comment-message-9742" class="dsq-comment-message"><p>Quick question,<br />
  why do we even calculate diameter of left and right subtrees? Wouldn&#8217;t the height of the left and right subtrees suffice? I ran the algorithm on the second example and in every step, the diameter of left/right st never won the max predicate.</p>
<p>Any helpful insight(s) most welcome!</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-9228">
        <div id="dsq-comment-header-9228" class="dsq-comment-header">
            <cite id="dsq-cite-9228">
                <span id="dsq-author-user-9228">harsh jain</span>
            </cite>
        </div>
        <div id="dsq-comment-body-9228" class="dsq-comment-body">
            <div id="dsq-comment-message-9228" class="dsq-comment-message"><pre> <code language="C">

problem can be easily solved if we take a global variable and 
use a same function to calculate the height with little modification here is code

#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;



struct node {
       int data;
       node *left;
       node *right;
};

int m;
int max( int  a , int b )
{
    if( a &gt; b )
        return a;
    else
        return b;
}
void insert( struct node **x , int n ) {
     if ( *x == NULL ) {
          *x = ( struct node*)malloc( sizeof( struct node ) );
          (*x)-&gt;data = n;
          (*x)-&gt;left = NULL;
          (*x)-&gt;right = NULL;
     } else {
            if( (*x)-&gt;data &gt; n ) {
                insert( &amp;(*x)-&gt;left , n );
            } else {
                insert( &amp;(*x)-&gt;right , n );
            }
     }
}

int hight( struct node *x ) 
{
    
     int p;
     if( x == NULL )
        return 0;
    
     int l , r;
     l = hight( x-&gt;left );
     r = hight( x-&gt;right );
     p = l + r + 1;
    if( p &gt; m )
        m = p;
    
    
    return ( max( l , r ) + 1 );
    
}

void print( struct node *x )
{
     if( x == NULL )
         return;
         
     print( x-&gt;left );
     
     printf(&quot;%d\n&quot; , x-&gt;data );
     
     print( x-&gt;right );
}
int main()
{
    struct node *root;
    
    root = NULL;
    
    
    m = 0;
    int t , k , i;
    scanf(&quot;%d&quot; , &amp;t );
    for (  i = 0; i &lt; t; i++  ) {
        scanf(&quot;%d&quot; , &amp;k );
        insert( &amp;root , k );
    }
    
    hight( root );
    printf(&quot;%d&quot; , m );
    
    return 0;
}



</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-9203">
        <div id="dsq-comment-header-9203" class="dsq-comment-header">
            <cite id="dsq-cite-9203">
                <span id="dsq-author-user-9203">MV</span>
            </cite>
        </div>
        <div id="dsq-comment-body-9203" class="dsq-comment-body">
            <div id="dsq-comment-message-9203" class="dsq-comment-message"><pre> <code language="C">
int mx=0;
struct node *res=NULL;

int diameter(struct node *nd)
{
	if(nd==NULL) 	return 0;
	int ld=diameter(nd-&gt;l);
	int rd=diameter(nd-&gt;r);
	if(mx &lt; ld+rd+1)
	{
		res=nd;
		mx=ld+rd+1;
	}
return ld&gt;rd?ld+1:rd+1;
}
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-9023">
        <div id="dsq-comment-header-9023" class="dsq-comment-header">
            <cite id="dsq-cite-9023">
                <span id="dsq-author-user-9023">Sam</span>
            </cite>
        </div>
        <div id="dsq-comment-body-9023" class="dsq-comment-body">
            <div id="dsq-comment-message-9023" class="dsq-comment-message"><p>in the optimized version shouldn&#8217;t the return statement be </p>
<p> return max(height, max(ldiameter, rdiameter)); </p>
<p>instead of  return max(lh + rh + 1, max(ldiameter, rdiameter));</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-2" id="dsq-comment-9026">
        <div id="dsq-comment-header-9026" class="dsq-comment-header">
            <cite id="dsq-cite-9026">
                <span id="dsq-author-user-9026">Sam</span>
            </cite>
        </div>
        <div id="dsq-comment-body-9026" class="dsq-comment-body">
            <div id="dsq-comment-message-9026" class="dsq-comment-message"><p>not height&#8230;but I am not really sure why height is computed in this function&#8230;</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt depth-2" id="dsq-comment-9027">
        <div id="dsq-comment-header-9027" class="dsq-comment-header">
            <cite id="dsq-cite-9027">
                <span id="dsq-author-user-9027">sam</span>
            </cite>
        </div>
        <div id="dsq-comment-body-9027" class="dsq-comment-body">
            <div id="dsq-comment-message-9027" class="dsq-comment-message"><p>it should not be replaced with height&#8230;but i am not sure why height is used&#8230;.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-8745">
        <div id="dsq-comment-header-8745" class="dsq-comment-header">
            <cite id="dsq-cite-8745">
                <span id="dsq-author-user-8745">sachin</span>
            </cite>
        </div>
        <div id="dsq-comment-body-8745" class="dsq-comment-body">
            <div id="dsq-comment-message-8745" class="dsq-comment-message"><p>Can somebody tell me how to find the nodes which are farthest?</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-atul007 odd alt thread-odd thread-alt depth-1" id="dsq-comment-7906">
        <div id="dsq-comment-header-7906" class="dsq-comment-header">
            <cite id="dsq-cite-7906">
                <span id="dsq-author-user-7906">atul007</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7906" class="dsq-comment-body">
            <div id="dsq-comment-message-7906" class="dsq-comment-message"><p>in optimized version , i didnt get what is the use of last return<br />
comparison i.e max(ldiameter, rdiameter)</p>
<p>replacing return max(lh + rh + 1, max(ldiameter, rdiameter));<br />
with below will give correct ouput<br />
return lh + rh + 1;</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-atul007 even depth-2" id="dsq-comment-7907">
        <div id="dsq-comment-header-7907" class="dsq-comment-header">
            <cite id="dsq-cite-7907">
                <span id="dsq-author-user-7907">atul007</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7907" class="dsq-comment-body">
            <div id="dsq-comment-message-7907" class="dsq-comment-message"><p>ok it wont work!!</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment byuser comment-author-cracker odd alt thread-even depth-1" id="dsq-comment-7768">
        <div id="dsq-comment-header-7768" class="dsq-comment-header">
            <cite id="dsq-cite-7768">
http://algods-cracker.blogspot.com/                <span id="dsq-author-user-7768">Cracker</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7768" class="dsq-comment-body">
            <div id="dsq-comment-message-7768" class="dsq-comment-message"><p><a href="http://algods-cracker.blogspot.in/2012/03/microsoft-question-find-diameter-of.html" rel="nofollow">http://algods-cracker.blogspot.in/2012/03/microsoft-question-find-diameter-of.html</a></p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-pphanireddy even thread-odd thread-alt depth-1" id="dsq-comment-6652">
        <div id="dsq-comment-header-6652" class="dsq-comment-header">
            <cite id="dsq-cite-6652">
                <span id="dsq-author-user-6652">pphanireddy</span>
            </cite>
        </div>
        <div id="dsq-comment-body-6652" class="dsq-comment-body">
            <div id="dsq-comment-message-6652" class="dsq-comment-message"><p>    /****************************************************************************<br />
     * Calculate the diameter of the Binary tree<br />
     ****************************************************************************/<br />
    public int getDiameter() {<br />
	int[] diameter = new int[1];<br />
	getDiameter(root, diameter);<br />
	return diameter[0];<br />
    }</p>
<p>    private int getDiameter(Node currNode, int[] diameter) {<br />
	if(currNode.left == null &amp;&amp; currNode.right == null) {<br />
	    return 0;<br />
	}</p>
<p>	int myHeight = 0;<br />
	int myDiameter = 0;<br />
	int maxHeight;<br />
	int leftHeight = -1, rightHeight = -1;</p>
<p>	if(currNode.left != null) {<br />
	    leftHeight = getDiameter(currNode.left, diameter);<br />
	    myDiameter = leftHeight + 1;<br />
	}<br />
	if(currNode.right != null) {<br />
	    rightHeight = getDiameter(currNode.right, diameter);<br />
	    myDiameter = rightHeight + 1;<br />
	} </p>
<p>	maxHeight = Math.max(leftHeight, rightHeight);<br />
	if (maxHeight != -1) {<br />
	    myHeight =  maxHeight + 1;<br />
	}</p>
<p>	if(diameter[0] &lt; myDiameter) {<br />
	    diameter[0] = myDiameter;<br />
	}</p>
<p>	return myHeight;<br />
    }</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-6646">
        <div id="dsq-comment-header-6646" class="dsq-comment-header">
            <cite id="dsq-cite-6646">
                <span id="dsq-author-user-6646">Hi</span>
            </cite>
        </div>
        <div id="dsq-comment-body-6646" class="dsq-comment-body">
            <div id="dsq-comment-message-6646" class="dsq-comment-message"><p>The most easy algo for this is:<br />
Do a BFS from root.. then find out the node with the largest distance assigned(assuming each edge to be of length = 1) then Do a BFS from that node, the largest assigned node in this case is the Diameter of tree&#8230;.<br />
Let me know if m incorrect!!</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-6365">
        <div id="dsq-comment-header-6365" class="dsq-comment-header">
            <cite id="dsq-cite-6365">
                <span id="dsq-author-user-6365">mohit</span>
            </cite>
        </div>
        <div id="dsq-comment-body-6365" class="dsq-comment-body">
            <div id="dsq-comment-message-6365" class="dsq-comment-message"><pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
int diameter_tree(Node n)
{
	if(n==NULL) return 0;
	
	int l=0,r=0;
	
	l=diameter_tree(n-&gt;l);
	r=diameter_tree(n-&gt;r);
	if(l+r &gt; new_diameter) new_diameter=l+r+1;
	return max(l,r)+1;
}
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-6366">
        <div id="dsq-comment-header-6366" class="dsq-comment-header">
            <cite id="dsq-cite-6366">
                <span id="dsq-author-user-6366">mohit</span>
            </cite>
        </div>
        <div id="dsq-comment-body-6366" class="dsq-comment-body">
            <div id="dsq-comment-message-6366" class="dsq-comment-message"><p>if condition should be :<br />
 if(l+r+1 &gt; new_diameter) new_diameter=l+r+1;</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even depth-2" id="dsq-comment-7082">
        <div id="dsq-comment-header-7082" class="dsq-comment-header">
            <cite id="dsq-cite-7082">
                <span id="dsq-author-user-7082">geek</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7082" class="dsq-comment-body">
            <div id="dsq-comment-message-7082" class="dsq-comment-message"><p>It wont work for the second tree diagram given on the top. It only works for tree diameter via root.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-4973">
        <div id="dsq-comment-header-4973" class="dsq-comment-header">
            <cite id="dsq-cite-4973">
                <span id="dsq-author-user-4973">Karthick</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4973" class="dsq-comment-body">
            <div id="dsq-comment-message-4973" class="dsq-comment-message"><p>Well, is the following algorithm correct for the given problem?</p>
<p>//cur_max is a variable declared above the function</p>
<pre> <code language="C">diameter(Node cur)
{
     if(cur==null)
     {
        return 0;
      }
      l=diameter(cur.left);
      r=diameter(cur.right);
      if(l+r+1&gt;cur_max&amp;&amp;l!=0&amp;r!=0)
      {
          cur_max=l+r+1;
      }
      return Math.max(l+r)+1;
   }
}</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-hackme even depth-2" id="dsq-comment-5763">
        <div id="dsq-comment-header-5763" class="dsq-comment-header">
            <cite id="dsq-cite-5763">
                <span id="dsq-author-user-5763">Hackme</span>
            </cite>
        </div>
        <div id="dsq-comment-body-5763" class="dsq-comment-body">
            <div id="dsq-comment-message-5763" class="dsq-comment-message"><p>wrong!!<br />
heights of left and right trees are added to get diameter.<br />
Not diameters.<br />
check it again.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt depth-2" id="dsq-comment-10173">
        <div id="dsq-comment-header-10173" class="dsq-comment-header">
            <cite id="dsq-cite-10173">
                <span id="dsq-author-user-10173">atul</span>
            </cite>
        </div>
        <div id="dsq-comment-body-10173" class="dsq-comment-body">
            <div id="dsq-comment-message-10173" class="dsq-comment-message"><p>diameter(Node cur)<br />
{<br />
     if(cur==null)<br />
     {<br />
        return 0;<br />
      }<br />
      l=diameter(cur.left);<br />
      r=diameter(cur.right);<br />
      if(l+r+1&gt;cur_max)<br />
      {<br />
          cur_max=l+r+1;<br />
      }<br />
      return Math.max(l,r)+1;<br />
   }<br />
}<br />
this should work</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-4718">
        <div id="dsq-comment-header-4718" class="dsq-comment-header">
            <cite id="dsq-cite-4718">
                <span id="dsq-author-user-4718">k</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4718" class="dsq-comment-body">
            <div id="dsq-comment-message-4718" class="dsq-comment-message"><pre> <code language="C">

struct node
{
    int value;
    struct node * left;
    struct node * right;
};

int func( struct node* root,int *diameter);


int main()
{
   int depth_returned;
   int dia=0;

   struct node * A= (struct node*)malloc(sizeof(struct node ));
   struct node * B= (struct node*)malloc(sizeof(struct node ));
   struct node * C= (struct node*)malloc(sizeof(struct node ));
   struct node * D= (struct node*)malloc(sizeof(struct node ));
   struct node * E= (struct node*)malloc(sizeof(struct node ));
   struct node * F= (struct node*)malloc(sizeof(struct node ));
   struct node * G= (struct node*)malloc(sizeof(struct node ));
   struct node * H= (struct node*)malloc(sizeof(struct node ));
   struct node * I= (struct node*)malloc(sizeof(struct node ));


   
   I-&gt;value=9;
   I-&gt;left=NULL;
   I-&gt;right=NULL;
   
   H-&gt;value=8;
   H-&gt;left=NULL;
   H-&gt;right=NULL;
   
   G-&gt;value=7;
   G-&gt;left=NULL;
   G-&gt;right=H;

   F-&gt;value=6;
   F-&gt;left=NULL;
   F-&gt;right=G;

   E-&gt;value=5;
   E-&gt;left=NULL;
   E-&gt;right=NULL;
   
   D-&gt;value=4;
   D-&gt;left=E;
   D-&gt;right=NULL;
   
   C-&gt;value=3;
   C-&gt;left=D;
   C-&gt;right=NULL;

   B-&gt;value=2;
   B-&gt;left=C;
   B-&gt;right=F;

   A-&gt;value=1;
   A-&gt;left=B;
   A-&gt;right=I;

   depth_returned=func(A,&amp;dia);

   printf(&quot;The maximum  diameter observed is %d&quot;,dia);
   
   return 0;
}

int func( struct node* root,int *diameter)
{ 
    int l=0;
    int r=0;
    int depth;
    if(root-&gt;left==NULL &amp;&amp; root-&gt;right==NULL)
        return 1;
    if(root-&gt;left)
        l=func(root-&gt;left,diameter);
    *diameter=l;
    if(root-&gt;right)
        r=func(root-&gt;right,diameter);
    
    if(l&gt;r)
        depth=l+1;
    else 
        depth=r+1;
    
    if((*diameter)&lt;l+r)
      *diameter=l+r;
    return depth;
}
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-4675">
        <div id="dsq-comment-header-4675" class="dsq-comment-header">
            <cite id="dsq-cite-4675">
                <span id="dsq-author-user-4675">SymbolofSilence</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4675" class="dsq-comment-body">
            <div id="dsq-comment-message-4675" class="dsq-comment-message"><p>There is one more way to do this <img src="http://d2o58evtke57tz.cloudfront.net/wp-includes/images/smilies/icon_smile.gif" alt=":)" class="wp-smiley" /> You can do DFS twice! <img src="http://d2o58evtke57tz.cloudfront.net/wp-includes/images/smilies/icon_smile.gif" alt=":)" class="wp-smiley" /> First, take an arbirary node in the tree and travel to the farthest point, and then from that farthest point, do a DFS again to find the longest path in the tree! <img src="http://d2o58evtke57tz.cloudfront.net/wp-includes/images/smilies/icon_biggrin.gif" alt=":D" class="wp-smiley" /></p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-2" id="dsq-comment-12718">
        <div id="dsq-comment-header-12718" class="dsq-comment-header">
            <cite id="dsq-cite-12718">
                <span id="dsq-author-user-12718">sumit</span>
            </cite>
        </div>
        <div id="dsq-comment-body-12718" class="dsq-comment-body">
            <div id="dsq-comment-message-12718" class="dsq-comment-message"><p>can u please elaborate on your logic</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt depth-2" id="dsq-comment-16436">
        <div id="dsq-comment-header-16436" class="dsq-comment-header">
            <cite id="dsq-cite-16436">
                <span id="dsq-author-user-16436">rohit</span>
            </cite>
        </div>
        <div id="dsq-comment-body-16436" class="dsq-comment-body">
            <div id="dsq-comment-message-16436" class="dsq-comment-message"><p>it is not necessary that the arbitary node is included in final answer&#8230;.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-3911">
        <div id="dsq-comment-header-3911" class="dsq-comment-header">
            <cite id="dsq-cite-3911">
                <span id="dsq-author-user-3911">Raja</span>
            </cite>
        </div>
        <div id="dsq-comment-body-3911" class="dsq-comment-body">
            <div id="dsq-comment-message-3911" class="dsq-comment-message"><p>I dont see any where in the code &#8220;height&#8221; variable is used except the below initialization.</p>
<p>*height = 0;</p>
<p>Please correct me if i&#8217;m wrong.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-3912">
        <div id="dsq-comment-header-3912" class="dsq-comment-header">
            <cite id="dsq-cite-3912">
                <span id="dsq-author-user-3912">Raja</span>
            </cite>
        </div>
        <div id="dsq-comment-body-3912" class="dsq-comment-body">
            <div id="dsq-comment-message-3912" class="dsq-comment-message"><p>I mean, height is not used in any calculations.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-vineel567 even depth-2" id="dsq-comment-4243">
        <div id="dsq-comment-header-4243" class="dsq-comment-header">
            <cite id="dsq-cite-4243">
http://vineelkumarreddy.blogspot.com                <span id="dsq-author-user-4243">Vineel Kumar Reddy</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4243" class="dsq-comment-body">
            <div id="dsq-comment-message-4243" class="dsq-comment-message"><p>height is not a local variable of function diameterOpt. its a reference to a variable in the caller function. so when ever u modify *height =  u are passing the height info to its caller variables lh or rh &#8230;..<br />
hope u got it&#8230;</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-3691">
        <div id="dsq-comment-header-3691" class="dsq-comment-header">
            <cite id="dsq-cite-3691">
                <span id="dsq-author-user-3691">reader1</span>
            </cite>
        </div>
        <div id="dsq-comment-body-3691" class="dsq-comment-body">
            <div id="dsq-comment-message-3691" class="dsq-comment-message"><p>This solution doesn&#8217;t work. </p>
<p>Imagine if you have a BST in preorder {1,2,4,3,5}</p>
<pre>
 1
  \
   2
    \
     4
    / \
   3   5
</pre>
<p>The algorithm gives 4 but the correct answer would be 3.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-vineel567 even depth-2" id="dsq-comment-4242">
        <div id="dsq-comment-header-4242" class="dsq-comment-header">
            <cite id="dsq-cite-4242">
http://vineelkumarreddy.blogspot.com                <span id="dsq-author-user-4242">Vineel Kumar Reddy</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4242" class="dsq-comment-body">
            <div id="dsq-comment-message-4242" class="dsq-comment-message"><p>boss the algo counts number of nodes in the path, not the path length itself&#8230;</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-3" id="dsq-comment-4253">
        <div id="dsq-comment-header-4253" class="dsq-comment-header">
            <cite id="dsq-cite-4253">
                <span id="dsq-author-user-4253">reader1</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4253" class="dsq-comment-body">
            <div id="dsq-comment-message-4253" class="dsq-comment-message"><p>According to the top of the webpage,</p>
<p>Defn: The diameter of a tree (sometimes called the width) is the number of nodes on the longest path between two leaves in the tree. </p>
<p>Between leaf &#8216;3&#8217; and leaf &#8216;5&#8217;, how many nodes are there on the longest path?</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-4" id="dsq-comment-4368">
        <div id="dsq-comment-header-4368" class="dsq-comment-header">
            <cite id="dsq-cite-4368">
                <span id="dsq-author-user-4368">tyro</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4368" class="dsq-comment-body">
            <div id="dsq-comment-message-4368" class="dsq-comment-message"><p>@reader1..Good one.<br />
We need to check at every stage that none of lh and rh should be zero. Only then it&#8217;ll be used in calculating<br />
max(lh+rh+1,max(rdiam,ldiam)).</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt depth-4" id="dsq-comment-12719">
        <div id="dsq-comment-header-12719" class="dsq-comment-header">
            <cite id="dsq-cite-12719">
                <span id="dsq-author-user-12719">sumit</span>
            </cite>
        </div>
        <div id="dsq-comment-body-12719" class="dsq-comment-body">
            <div id="dsq-comment-message-12719" class="dsq-comment-message"><p>nyc catch</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-898">
        <div id="dsq-comment-header-898" class="dsq-comment-header">
            <cite id="dsq-cite-898">
                <span id="dsq-author-user-898">Himanshu Aggarwal</span>
            </cite>
        </div>
        <div id="dsq-comment-body-898" class="dsq-comment-body">
            <div id="dsq-comment-message-898" class="dsq-comment-message"><p>Hi,</p>
<p>Is there any way be which I can use the above algorithm to find the diameter of an n-ary tree.</p>
<p>Thanks and Regards,<br />
Himanshu</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-nesamani1822 odd alt thread-even depth-1" id="dsq-comment-753">
        <div id="dsq-comment-header-753" class="dsq-comment-header">
            <cite id="dsq-cite-753">
                <span id="dsq-author-user-753">nesamani1822</span>
            </cite>
        </div>
        <div id="dsq-comment-body-753" class="dsq-comment-body">
            <div id="dsq-comment-message-753" class="dsq-comment-message"><p>we can find the diameter of tree using the problem &#8220;print root to leaf..&#8221;</p>
<p>Find the two highest length from the path and add those lengths and subtract with 1 to get diameter of tree with including the root node. if we subtract with 2 then we will get the diameter of tree without including the root node.</p>
<pre>
printPathsRecur(tree, path[], pathlen)
   1) If node is not NULL then
         a) push data to path array:
                path[pathlen] = node-&gt;data.
         b) increment pathlen
                pathlen++
   2) If node is a leaf node then <strong>find the two highest lengths</strong>
   3) Else
        a) Call printPathsRecur for left subtree
                 printPathsRecur(node-&gt;left, path, pathLen)
        b) Call printPathsRecur for right subtree.
                printPathsRecur(node-&gt;right, path, pathLen)
</pre>
<pre> <code language="C">
int first=0;
int second=0;
void printPathsRecur(struct node* node, int path[], int pathLen)
{
  if (node==NULL) return;
 
  /* append this node to the path array */
  path[pathLen] = node-&gt;data;
  pathLen++;
 
  /* it's a leaf, so print the path that led to here */
  if (node-&gt;left==NULL &amp;&amp; node-&gt;right==NULL)
  {
    printArray(pathLen);
  }
  else
  {
  /* otherwise try both subtrees */
    printPathsRecur(node-&gt;left, path, pathLen);
    printPathsRecur(node-&gt;right, path, pathLen);
  }
}
 

void printArray(int len)
{
  if(len&gt;first)
   {
      second=first;
      first=len
   }
  else if(len&gt;secon)
   {
      second=len;
   }
} 
//diameter of tree
diameter=first+second-1;
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-2" id="dsq-comment-798">
        <div id="dsq-comment-header-798" class="dsq-comment-header">
            <cite id="dsq-cite-798">
                <span id="dsq-author-user-798">Nithish</span>
            </cite>
        </div>
        <div id="dsq-comment-body-798" class="dsq-comment-body">
            <div id="dsq-comment-message-798" class="dsq-comment-message"><p>@nesamani: That is a cool efficient way to solve the problem.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-sandeep odd alt depth-3" id="dsq-comment-813">
        <div id="dsq-comment-header-813" class="dsq-comment-header">
            <cite id="dsq-cite-813">
                <span id="dsq-author-user-813">Sandeep</span>
            </cite>
        </div>
        <div id="dsq-comment-body-813" class="dsq-comment-body">
            <div id="dsq-comment-message-813" class="dsq-comment-message"><p>@nesamani1822: The code doesn&#8217;t work for the cases where root is not in path of diameter, like second tree in the diagram given in post. Let me know if I am wrong.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-4" id="dsq-comment-2079">
        <div id="dsq-comment-header-2079" class="dsq-comment-header">
            <cite id="dsq-cite-2079">
                <span id="dsq-author-user-2079">Abhijith K</span>
            </cite>
        </div>
        <div id="dsq-comment-body-2079" class="dsq-comment-body">
            <div id="dsq-comment-message-2079" class="dsq-comment-message"><p>@Sandeep You are right. The code doesn’t work for the cases where root is not in path.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-5" id="dsq-comment-2200">
        <div id="dsq-comment-header-2200" class="dsq-comment-header">
            <cite id="dsq-cite-2200">
                <span id="dsq-author-user-2200">gk_manutd</span>
            </cite>
        </div>
        <div id="dsq-comment-body-2200" class="dsq-comment-body">
            <div id="dsq-comment-message-2200" class="dsq-comment-message"><p>In the &#8220;optimized implementation&#8221; above:</p>
<p>if you initialize left &amp; right as 0 everytime… then max always returns 1, right?</p>
<p>Shouldn’t left &amp; right be initialized outside the function altogether?</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even depth-4" id="dsq-comment-4251">
        <div id="dsq-comment-header-4251" class="dsq-comment-header">
            <cite id="dsq-cite-4251">
                <span id="dsq-author-user-4251">satya</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4251" class="dsq-comment-body">
            <div id="dsq-comment-message-4251" class="dsq-comment-message"><p>@sandeep&#8230;can you guide how we can find the diameter of tree without recursion..?? i mean in O(N) without using recursion</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
            </ul>


        </div>

    </div>

<script type="text/javascript">
var disqus_url = 'http://www.geeksforgeeks.org/diameter-of-a-binary-tree/';
var disqus_identifier = '5687 http://geeksforgeeks.org/?p=5687';
var disqus_container_id = 'disqus_thread';
var disqus_shortname = 'geeksforgeeks';
var disqus_title = "Diameter of a Binary Tree";
var disqus_config_custom = window.disqus_config;
var disqus_config = function () {
    /*
    All currently supported events:
    onReady: fires when everything is ready,
    onNewComment: fires when a new comment is posted,
    onIdentify: fires when user is authenticated
    */
    
    
    this.language = '';
    
    if (disqus_config_custom) {
        disqus_config_custom.call(this);
    }
};

(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>

			</div>
	
					
			
			

		</div> <!-- end post -->	

<br></br>
	
</div> <!-- end content -->

<ul id="sidebar">
	<li id="text-19" class="widget widget_text">			<div class="textwidget"><script>
  (function() {
    var cx = '009682134359037907028:tj6eafkv_be';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//www.google.com/cse/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>

<style type="text/css">
  .gsc-control-cse {
    font-family: "Trebuchet MS", sans-serif;
    border-color: #E1F3DA;
    background-color: #E1F3DA;
  }
  input.gsc-input {
    border-color: #94CC7A;
  }
  input.gsc-search-button {
    border-color: #94CC7A;
    background-color: #AADA92;
  }
  .gsc-tabHeader.gsc-tabhInactive {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gsc-tabHeader.gsc-tabhActive {
    border-color: #A9DA92;
    background-color: #A9DA92;
  }
  .gsc-tabsArea {
    border-color: #A9DA92;
  }
  .gsc-webResult.gsc-result {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gsc-webResult.gsc-result:hover {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gs-webResult.gs-result a.gs-title:link,
  .gs-webResult.gs-result a.gs-title:link b {
    color: #009900;
  }
  .gs-webResult.gs-result a.gs-title:visited,
  .gs-webResult.gs-result a.gs-title:visited b {
    color: #009900;
  }
  .gs-webResult.gs-result a.gs-title:hover,
  .gs-webResult.gs-result a.gs-title:hover b {
    color: #003300;
  }
  .gs-webResult.gs-result a.gs-title:active,
  .gs-webResult.gs-result a.gs-title:active b {
    color: #009900;
  }
  .gsc-cursor-page {
    color: #009900;
  }
  a.gsc-trailing-more-results:link {
    color: #009900;
  }
  .gs-webResult.gs-result .gs-snippet {
    color: #454545;
  }
  .gs-webResult.gs-result .gs-visibleUrl {
    color: #33cc00;
  }
  .gs-webResult.gs-result .gs-visibleUrl-short {
    color: #33cc00;
  }
  .gs-webResult.gs-result .gs-visibleUrl-short {
    display: none;
  }
  .gs-webResult.gs-result .gs-visibleUrl-long {
    display: block;
  }
  .gsc-cursor-box {
    border-color: #A9DA92;
  }
  .gsc-results .gsc-cursor-page {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gsc-results .gsc-cursor-page.gsc-cursor-current-page {
    border-color: #A9DA92;
    background-color: #A9DA92;
  }
  .gs-promotion.gs-result {
    border-color: #94CC7A;
    background-color: #CBE8B4;
  }
  .gs-promotion.gs-result a.gs-title:link {
    color: #0066CC;
  }
  .gs-promotion.gs-result a.gs-title:visited {
    color: #0066CC;
  }
  .gs-promotion.gs-result a.gs-title:hover {
    color: #0066CC;
  }
  .gs-promotion.gs-result a.gs-title:active {
    color: #0066CC;
  }
  .gs-promotion.gs-result .gs-snippet {
    color: #454545;
  }
  .gs-promotion.gs-result .gs-visibleUrl,
  .gs-promotion.gs-result .gs-visibleUrl-short {
    color: #815FA7;
  }
</style>    </div>
		</li>
<li id="text-9" class="widget widget_text">			<div class="textwidget"><div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=138031159685820";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>

<div class="fb-like-box" data-href="https://www.facebook.com/pages/GeeksforGeeks/316764689022" data-width="250" data-height="170" data-colorscheme="light" data-show-faces="true" data-header="false" data-stream="false" data-show-border="false"></div></div>
		</li>
<li id="text-18" class="widget widget_text">			<div class="textwidget"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LargeRectangleSide -->
<ins class="adsbygoogle"
     style="display:inline-block;width:336px;height:280px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="1884636833"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
		</li>
<li id="text-13" class="widget widget_text">			<div class="textwidget"><ul><li><a href="http://www.geeksforgeeks.org/category/interview-experiences/">Interview Experiences</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/advance-data-structures">Advanced Data Structures</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/dynamic-programming">Dynamic Programming</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/Greedy-Algorithm/">Greedy Algorithms</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/backtracking">Backtracking</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/pattern-searching">Pattern Searching</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/divide-and-conquer">Divide & Conquer</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/MathematicalAlgo">Mathematical Algorithms</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/recursion">Recursion</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/geometric-algorithms/">Geometric Algorithms</a></li>
</ul></div>
		</li>
<li id="text-17" class="widget widget_text">			<div class="textwidget"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big 300x600 Sidebar -->
<ins class="adsbygoogle"
     style="display:inline-block;width:300px;height:600px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="4402736037"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
		</li>
<li id="text-14" class="widget widget_text"><h2 class="widgettitle">Popular Posts</h2>
			<div class="textwidget"><ul>
<li><a href="http://www.geeksforgeeks.org/write-a-c-program-to-print-all-permutations-of-a-given-string/">  All permutations of a given string </a></li>
<li><a href="http://www.geeksforgeeks.org/memory-layout-of-c-program/"> Memory Layout of C Programs</a> </li>
<li><a href="http://www.geeksforgeeks.org/understanding-extern-keyword-in-c/"> Understanding “extern” keyword in C</a> </li>
<li><a href="http://www.geeksforgeeks.org/median-of-two-sorted-arrays/">Median of two sorted arrays</a> </li>
<li><a href="http://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/"> Tree traversal without recursion and without stack! </a></li>
<li><a href="http://www.geeksforgeeks.org/structure-member-alignment-padding-and-data-packing/"> Structure Member Alignment, Padding and Data Packing</a> </li>
<li><a href="http://www.geeksforgeeks.org/write-a-function-to-get-the-intersection-point-of-two-linked-lists/"> Intersection point of two Linked Lists</a> </li>
<li><a href="http://www.geeksforgeeks.org/lowest-common-ancestor-in-a-binary-search-tree/"> Lowest Common Ancestor in a BST.</span></a> </li>
<li><a href="http://www.geeksforgeeks.org/a-program-to-check-if-a-binary-tree-is-bst-or-not/"> Check if a binary tree is BST or not</a> </li>
<li><a href="http://www.geeksforgeeks.org/sorted-linked-list-to-balanced-bst/"> Sorted Linked List to Balanced BST</a></li>
</ul></div>
		</li>
<li id="text-3" class="widget widget_text">			<div class="textwidget"><a href="https://twitter.com/GeeksforGeeks" class="twitter-follow-button" data-show-count="false">Follow @GeeksforGeeks</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>         


<!-- GOOGLE FEEDBURNER BUTTON-->
<a href="http://feeds.feedburner.com/Geeksforgeeks" title="Subscribe to my feed" rel="alternate" type="application/rss+xml"><img src="http://www.feedburner.com/fb/images/pub/feed-icon32x32.png" alt="" style="border:0"/></a><a href="http://feeds.feedburner.com/Geeksforgeeks" title="Subscribe to my feed" rel="alternate" type="application/rss+xml">Subscribe</a>

</div>
		</li>
<li id="text-21" class="widget widget_text"><h2 class="widgettitle">Recent Comments</h2>
			<div class="textwidget"><script type="text/javascript" src="http://geeksforgeeks.disqus.com//recent_comments_widget.js?num_items=6&hide_avatars=1&excerpt_length=50&hide_mods=0"></script></div>
		</li>
<li id="text-22" class="widget widget_text">			<div class="textwidget"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LinkAd -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:90px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="2606115235"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LinkAd -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:90px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="2606115235"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LinkAd -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:90px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="2606115235"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
		</li>

</ul>					  
		<div class="clear"></div>

		<div id="footer">
		
		    <div class="xhtml">
                        @geeksforgeeks, <a href="http://creativecommons.org/licenses/by-nc-nd/2.5/in/deed.en_US" title="Valid XHTML Strict 1.0">Some rights reserved</a>  <a href="http://www.geeksforgeeks.org/about/contact-us/"> &nbsp; &nbsp; &nbsp; &nbsp;Contact Us!</a>

		    </div>
		    
		    <div class="credits">
			  Powered by <a href="http://wordpress.org">WordPress </a> &amp; <a href="http://mootools.net/" title="Mootools JavaScript Framework">MooTools</a>, customized by geeksforgeeks team </div>
			  
		   <div class="clear"></div>						                            
		   
		</div> <!--end footer-->  
        
		        <script type="text/javascript">
        // <![CDATA[
        var disqus_shortname = 'geeksforgeeks';
        (function () {
            var nodes = document.getElementsByTagName('span');
            for (var i = 0, url; i < nodes.length; i++) {
                if (nodes[i].className.indexOf('dsq-postid') != -1) {
                    nodes[i].parentNode.setAttribute('data-disqus-identifier', nodes[i].getAttribute('rel'));
                    url = nodes[i].parentNode.href.split('#', 1);
                    if (url.length == 1) { url = url[0]; }
                    else { url = url[1]; }
                    nodes[i].parentNode.href = url + '#disqus_thread';
                }
            }
            var s = document.createElement('script'); 
            s.async = true;
            s.type = 'text/javascript';
            s.src = '//' + disqus_shortname + '.disqus.com/count.js';
            (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
        }());
        // ]]>
        </script>
        <script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/scripts/shCore.js?ver=3.0.9'></script>
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/scripts/shBrushCpp.js?ver=3.0.9'></script>
<script type='text/javascript'>
	(function(){
		var corecss = document.createElement('link');
		var themecss = document.createElement('link');
		var corecssurl = "http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/styles/shCore.css?ver=3.0.9";
		if ( corecss.setAttribute ) {
				corecss.setAttribute( "rel", "stylesheet" );
				corecss.setAttribute( "type", "text/css" );
				corecss.setAttribute( "href", corecssurl );
		} else {
				corecss.rel = "stylesheet";
				corecss.href = corecssurl;
		}
		document.getElementsByTagName("head")[0].insertBefore( corecss, document.getElementById("syntaxhighlighteranchor") );
		var themecssurl = "http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/styles/shThemeDefault.css?ver=3.0.9";
		if ( themecss.setAttribute ) {
				themecss.setAttribute( "rel", "stylesheet" );
				themecss.setAttribute( "type", "text/css" );
				themecss.setAttribute( "href", themecssurl );
		} else {
				themecss.rel = "stylesheet";
				themecss.href = themecssurl;
		}
		//document.getElementById("syntaxhighlighteranchor").appendChild(themecss);
		document.getElementsByTagName("head")[0].insertBefore( themecss, document.getElementById("syntaxhighlighteranchor") );
	})();
	SyntaxHighlighter.config.strings.expandSource = '+ expand source';
	SyntaxHighlighter.config.strings.help = '?';
	SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
	SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
	SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
	SyntaxHighlighter.defaults['gutter'] = false;
	SyntaxHighlighter.defaults['pad-line-numbers'] = true;
	SyntaxHighlighter.defaults['toolbar'] = false;
	SyntaxHighlighter.all();
</script>
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/bbpress/templates/default/js/editor.js?ver=2.5.4-5380'></script>
				  
		</div> <!--end wrapper-->
        <div id="ajaxSpinner"></div> <!--For AJAX spinner holder-->
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-12148232-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
	</body>

</html>
<!-- Dynamic page generated in 0.245 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2014-11-27 23:26:47 -->

<!-- Compression = gzip -->
<!-- super cache -->