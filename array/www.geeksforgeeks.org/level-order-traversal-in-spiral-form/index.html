<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
       <title>Level order traversal in spiral form - GeeksforGeeks</title>
       <style type="text/css" media="screen">
          @import url('http://d2o58evtke57tz.cloudfront.net/wp-content/themes/minimoo/style.css');
    </style>
      <link href="http://d2o58evtke57tz.cloudfront.net/wp-content/themes/minimoo/favicon.ico" rel="shortcut icon" />    
    
<!-- This site is optimized with the Yoast WordPress SEO plugin v1.7.1 - https://yoast.com/wordpress/plugins/seo/ -->
<link rel="canonical" href="http://www.geeksforgeeks.org/level-order-traversal-in-spiral-form/" />
<meta property="og:locale" content="en_US" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Level order traversal in spiral form - GeeksforGeeks" />
<meta property="og:description" content="Write a function to print spiral order traversal of a tree. For below tree, function should print 1, 2, 3, 4, 5, 6, 7. Method 1 (Recursive) This problem can bee seen as an extension of the level order traversal post. To print the nodes in spiral order, nodes at different levels should be printed &hellip;" />
<meta property="og:url" content="http://www.geeksforgeeks.org/level-order-traversal-in-spiral-form/" />
<meta property="og:site_name" content="GeeksforGeeks" />
<meta property="article:section" content="Trees" />
<meta property="article:published_time" content="2009-12-20T21:13:20+00:00" />
<meta property="article:modified_time" content="2014-11-08T22:18:01+00:00" />
<meta property="og:updated_time" content="2014-11-08T22:18:01+00:00" />
<meta property="og:image" content="http://geeksforgeeks.org/wp-content/uploads/2009/12/spiral_order.gif" />
<!-- / Yoast WordPress SEO plugin. -->

<link rel='stylesheet' id='wp-quicklatex-format-css'  href='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/wp-quicklatex/css/quicklatex-format.css?ver=4.0.1' type='text/css' media='all' />
<link rel='stylesheet' id='bbp-default-css'  href='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/bbpress/templates/default/css/bbpress.css?ver=2.5.4-5380' type='text/css' media='screen' />
<link rel='stylesheet' id='wp-pagenavi-css'  href='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/wp-pagenavi/pagenavi-css.css?ver=2.70' type='text/css' media='all' />
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-includes/js/jquery/jquery.js?ver=1.11.1'></script>
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-includes/js/jquery/jquery-migrate.min.js?ver=1.2.1'></script>
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/wp-quicklatex/js/wp-quicklatex-frontend.js?ver=1.0'></script>

<!-- Bad Behavior 2.2.16 run time: 1.491 ms -->
<script type="text/javascript">
<!--
function bb2_addLoadEvent(func) {
	var oldonload = window.onload;
	if (typeof window.onload != 'function') {
		window.onload = func;
	} else {
		window.onload = function() {
			oldonload();
			func();
		}
	}
}

bb2_addLoadEvent(function() {
	for ( i=0; i < document.forms.length; i++ ) {
		if (document.forms[i].method == 'post') {
			var myElement = document.createElement('input');
			myElement.setAttribute('type', 'hidden');
			myElement.name = 'bb2_screener_';
			myElement.value = '1417111038 182.69.6.143';
			document.forms[i].appendChild(myElement);
		}
	}
});
// --></script>
		<style type="text/css" id="syntaxhighlighteranchor"></style>
   <meta name="google-site-verification" content="rHK2v8_zzuAZQY8JHAzbllDN8u-aQxcn2Kqnp67Old0" />
</head>

<body>
<!-- o4dI0sCXUgoSONabbd8mbZ4SA3E -->    
    <div id="wrapper">
        <div class="blog-info">
                <h1 class="blog-title">
                <a href="http://www.geeksforgeeks.org" title="GeeksforGeeks">GeeksforGeeks</a>
            </h1>
       
            <div class="blog-description">
                A computer science portal for geeks            </div>
        </div>
        <b><p>  <h2 align="right"> <a href="http://geeksquiz.com/">GeeksQuiz</a></h2> 
   <a href="http://www.geeksforgeeks.org/wp-login.php">Login</a> 
         </p></b>  
         
         <div class="clear"></div>         
              
                     
            <div id="menu">   
                 <ul>
 <li><a href="http://www.geeksforgeeks.org">Home</a></li>
  <li><a href="http://www.geeksforgeeks.org/fundamentals-of-algorithms/">Algorithms</a></li>
 <li><a href="http://www.geeksforgeeks.org/data-structures/">DS</a></li>
  <li><a href="http://www.geeksforgeeks.org/gate-corner/">GATE</a></li>
  <li><a href="http://www.geeksforgeeks.org/about/interview-corner/">Interview Corner</a></li>
  <li><a href="http://www.geeksforgeeks.org/forums/">Q&A</a></li>
  <li><a href="http://www.geeksforgeeks.org/c/">C</a></li>
  <li><a href="http://www.geeksforgeeks.org/c-plus-plus/">C++</a></li>
  <li><a href="http://www.geeksforgeeks.org/java/">Java</a></li>
  <li><a href="http://www.geeksforgeeks.org/books/">Books</a></li>
  <li><a href="http://www.geeksforgeeks.org/contribute/">Contribute</a></li>
  <li><a href="http://www.geeksforgeeks.org/contribute/ask-a-question/">Ask a Q</a></li>
  <li><a href="http://www.geeksforgeeks.org/about/">About</a></li>
            </ul>

               
            <div class="clear"></div>     
        </div>
             <div id="navmenu">
				<ul id="menu" style="padding:0; margin:0;">
						<li class="cat-item cat-item-3"><a href="http://www.geeksforgeeks.org/category/c-arrays/" title="Questions regarding Arrays">Array</a>
</li>	

	<li class="cat-item cat-item-17"><a href="http://www.geeksforgeeks.org/category/bit-magic/" title="View all posts filed under Bit Magic">Bit Magic</a>
</li>
	<li class="cat-item cat-item-14"><a href="http://www.geeksforgeeks.org/category/c-puzzles/" title="View all posts filed under C/C++ Puzzles">C/C++</a>
</li>

<li class="cat-item cat-item-18"><a href="http://www.geeksforgeeks.org/category/articles/" title="View all posts filed under Articles">Articles</a>
</li>

	<li class="cat-item cat-item-67"><a href="http://www.geeksforgeeks.org/category/gfact/" title="View all posts filed under GFacts">GFacts</a>
</li>
	<li class="cat-item cat-item-8"><a href="http://www.geeksforgeeks.org/category/linked-list/" title="Linked List problems">Linked List</a>
</li>
	<li class="cat-item cat-item-66"><a href="http://www.geeksforgeeks.org/category/multiple-choice-question/" title="View all posts filed under MCQ">MCQ</a>

</li>
	<li class="cat-item cat-item-4"><a href="http://www.geeksforgeeks.org/category/c-programs/" title="Miscellaneous">Misc</a>
</li>
	<li class="cat-item cat-item-5"><a href="http://www.geeksforgeeks.org/category/program-output/" title="View all posts filed under Output">Output</a>
</li>
	<li class="cat-item cat-item-7"><a href="http://www.geeksforgeeks.org/category/c-strings/" title="Questions related to strings">String</a>
</li>
	<li class="cat-item cat-item-19"><a href="http://www.geeksforgeeks.org/category/tree/" title="View all posts filed under Trees">Tree</a>
</li>
	<li class="cat-item cat-item-19"><a href="http://www.geeksforgeeks.org/category/graph/" title="View all posts filed under Graph">Graph</a>
</li>
</ul>
        </div>
             <div id="content">	   	
	<div class="post" id="post">
							<div class="post-info">			
					<div class="post-title-info">
						<h2 class="post-title">Level order traversal in spiral form</h2>
					</div>			
					<div class="clear"></div>				  
				<div class="post-content" id="post-content">
					<p>Write a function to print spiral order traversal of a tree. For below tree, function should print 1, 2, 3, 4, 5, 6, 7. <span id="more-3758"></span></p>
<p><img src="http://geeksforgeeks.org/wp-content/uploads/2009/12/spiral_order.gif" alt="spiral_order" title="spiral_order" width="250" height="150" class="aligncenter size-full wp-image-3766" /></p>
<p><strong>Method 1 (Recursive)</strong><br />
This problem can bee seen as an extension of the <a href="http://geeksforgeeks.org/?p=2686">level order traversal</a> post.<br />
To print the nodes in spiral order, nodes at different levels should be printed in alternating order. An additional Boolean variable <em>ltr </em>is used to change printing order of levels.   If <em>ltr </em>is 1 then printGivenLevel() prints nodes from left to right else from right to left. Value of <em>ltr </em>is flipped in each iteration to change the order.</p>
<p>Function to print level order traversal of tree</p>
<pre><strong>
printSpiral(tree)</strong>
  bool ltr = 0;
  for d = 1 to height(tree)
     printGivenLevel(tree, d, ltr);
     ltr ~= ltr /*flip ltr*/
</pre>
<p>Function to print all nodes at a given level</p>
<pre>
<strong>printGivenLevel(tree, level, ltr)</strong>
if tree is NULL then return;
if level is 1, then
    print(tree->data);
else if level greater than 1, then
    if(ltr)
        printGivenLevel(tree->left, level-1, ltr);
        printGivenLevel(tree->right, level-1, ltr);
    else
        printGivenLevel(tree->right, level-1, ltr);
        printGivenLevel(tree->left, level-1, ltr);
</pre>
<p>Following is C implementation of above algorithm.</p>
<pre class="brush: cpp; highlight: [19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57]; title: ; notranslate" title="">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;

/* A binary tree node has data, pointer to left child
   and a pointer to right child */
struct node
{
    int data;
    struct node* left;
    struct node* right;
};

/* Function protoypes */
void printGivenLevel(struct node* root, int level, int ltr);
int height(struct node* node);
struct node* newNode(int data);

/* Function to print spiral traversal of a tree*/
void printSpiral(struct node* root)
{
    int h = height(root);
    int i;

    /*ltr -&gt; Left to Right. If this variable is set,
      then the given level is traverseed from left to right. */
    bool ltr = false;
    for(i=1; i&lt;=h; i++)
    {
        printGivenLevel(root, i, ltr);

        /*Revert ltr to traverse next level in oppposite order*/
        ltr = !ltr;
    }
}

/* Print nodes at a given level */
void printGivenLevel(struct node* root, int level, int ltr)
{
    if(root == NULL)
        return;
    if(level == 1)
        printf(&quot;%d &quot;, root-&gt;data);
    else if (level &gt; 1)
    {
        if(ltr)
        {
            printGivenLevel(root-&gt;left, level-1, ltr);
            printGivenLevel(root-&gt;right, level-1, ltr);
        }
        else
        {
            printGivenLevel(root-&gt;right, level-1, ltr);
            printGivenLevel(root-&gt;left, level-1, ltr);
        }
    }
}

/* Compute the &quot;height&quot; of a tree -- the number of
    nodes along the longest path from the root node
    down to the farthest leaf node.*/
int height(struct node* node)
{
    if (node==NULL)
        return 0;
    else
    {
        /* compute the height of each subtree */
        int lheight = height(node-&gt;left);
        int rheight = height(node-&gt;right);

        /* use the larger one */
        if (lheight &gt; rheight)
            return(lheight+1);
        else return(rheight+1);
    }
}

/* Helper function that allocates a new node with the
   given data and NULL left and right pointers. */
struct node* newNode(int data)
{
    struct node* node = (struct node*)
                        malloc(sizeof(struct node));
    node-&gt;data = data;
    node-&gt;left = NULL;
    node-&gt;right = NULL;

    return(node);
}

/* Driver program to test above functions*/
int main()
{
    struct node *root = newNode(1);
    root-&gt;left        = newNode(2);
    root-&gt;right       = newNode(3);
    root-&gt;left-&gt;left  = newNode(7);
    root-&gt;left-&gt;right = newNode(6);
    root-&gt;right-&gt;left  = newNode(5);
    root-&gt;right-&gt;right = newNode(4);
    printf(&quot;Spiral Order traversal of binary tree is \n&quot;);
    printSpiral(root);

    return 0;
}
</pre>
<p>Output:
<pre>Spiral Order traversal of binary tree is
1 2 3 4 5 6 7</pre>
<p><strong>Time Complexity:</strong> Worst case time complexity of the above method is <strong>O(n^2)</strong>. Worst case occurs in case of skewed trees.</p>
<p></br><br />
<strong>Method 2 (Iterative)</strong><br />
We can print spiral order traversal in<strong> O(n) time </strong>and O(n) extra space. The idea is to use two stacks. We can use one stack for printing from left to right and other stack for printing from right to left. In every iteration, we have nodes of one level in one of the stacks.  We print the nodes, and push nodes of next level in other stack.</p>
<pre class="brush: cpp; highlight: [13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57]; title: ; notranslate" title="">
// C++ implementation of a O(n) time method for spiral order traversal
#include &lt;iostream&gt;
#include &lt;stack&gt;
using namespace std;

// Binary Tree node
struct node
{
    int data;
    struct node *left, *right;
};

void printSpiral(struct node *root)
{
    if (root == NULL)  return;   // NULL check

    // Create two stacks to store alternate levels
    stack&lt;struct node*&gt; s1;  // For levels to be printed from right to left
    stack&lt;struct node*&gt; s2;  // For levels to be printed from left to right

    // Push first level to first stack 's1'
    s1.push(root);

    // Keep ptinting while any of the stacks has some nodes
    while (!s1.empty() || !s2.empty())
    {
        // Print nodes of current level from s1 and push nodes of
        // next level to s2
        while (!s1.empty())
        {
            struct node *temp = s1.top();
            s1.pop();
            cout &lt;&lt; temp-&gt;data &lt;&lt; &quot; &quot;;

            // Note that is right is pushed before left
            if (temp-&gt;right)
                s2.push(temp-&gt;right);
            if (temp-&gt;left)
                s2.push(temp-&gt;left);
        }

        // Print nodes of current level from s2 and push nodes of
        // next level to s1
        while (!s2.empty())
        {
            struct node *temp = s2.top();
            s2.pop();
            cout &lt;&lt; temp-&gt;data &lt;&lt; &quot; &quot;;

            // Note that is left is pushed before right
            if (temp-&gt;left)
                s1.push(temp-&gt;left);
            if (temp-&gt;right)
                s1.push(temp-&gt;right);
        }
    }
}

// A utility functiont to create a new node
struct node* newNode(int data)
{
    struct node* node = new struct node;
    node-&gt;data = data;
    node-&gt;left = NULL;
    node-&gt;right = NULL;

    return(node);
}

int main()
{
    struct node *root = newNode(1);
    root-&gt;left        = newNode(2);
    root-&gt;right       = newNode(3);
    root-&gt;left-&gt;left  = newNode(7);
    root-&gt;left-&gt;right = newNode(6);
    root-&gt;right-&gt;left  = newNode(5);
    root-&gt;right-&gt;right = newNode(4);
    cout &lt;&lt; &quot;Spiral Order traversal of binary tree is \n&quot;;
    printSpiral(root);

    return 0;
}
</pre>
<p>Output:
<pre>Spiral Order traversal of binary tree is
1 2 3 4 5 6 7</pre>
<p></br><br />
Please write comments if you find any bug in the above program/algorithm; or if you want to share more information about spiral traversal.</p>
		
&nbsp;
&nbsp;
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle"
     style="display:inline-block;width:336px;height:280px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="4061219431"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>



&nbsp;
&nbsp;
&nbsp;
<h3>Related Topics:</h3><ul><li><a href="http://www.geeksforgeeks.org/perfect-binary-tree-specific-level-order-traversal/" title="Perfect Binary Tree Specific Level Order Traversal">Perfect Binary Tree Specific Level Order Traversal</a></li><li><a href="http://www.geeksforgeeks.org/print-nodes-top-view-binary-tree/" title="Print Nodes in Top View of Binary Tree">Print Nodes in Top View of Binary Tree</a></li><li><a href="http://www.geeksforgeeks.org/k-dimensional-tree/" title="K Dimensional Tree">K Dimensional Tree</a></li><li><a href="http://www.geeksforgeeks.org/convert-binary-tree-threaded-binary-tree/" title="Convert a Binary Tree to Threaded binary tree">Convert a Binary Tree to Threaded binary tree</a></li><li><a href="http://www.geeksforgeeks.org/serialize-deserialize-n-ary-tree/" title="Serialize and Deserialize an N-ary Tree">Serialize and Deserialize an N-ary Tree</a></li><li><a href="http://www.geeksforgeeks.org/serialize-deserialize-binary-tree/" title="Serialize and Deserialize a Binary Tree">Serialize and Deserialize a Binary Tree</a></li><li><a href="http://www.geeksforgeeks.org/given-binary-tree-print-nodes-two-given-level-numbers/" title="Print nodes between two given level numbers of a binary tree">Print nodes between two given level numbers of a binary tree</a></li><li><a href="http://www.geeksforgeeks.org/find-height-binary-tree-represented-parent-array/" title="Find Height of Binary Tree represented by Parent array">Find Height of Binary Tree represented by Parent array</a></li></ul>
<p></p> 
<div>
<iframe src="http://www.facebook.com/plugins/like.php?href=http%3A%2F%2Fwww.geeksforgeeks.org%2Flevel-order-traversal-in-spiral-form%2F&layout=button_count&show_faces=false&width=90&action=like&colorscheme=light" scrolling="no" frameborder="0" allowTransparency="true" style="border:none; overflow:hidden; width:90px; height:20px"></iframe>
<a href="http://twitter.com/share" class="twitter-share-button" data-url="http://www.geeksforgeeks.org/level-order-traversal-in-spiral-form/" data-text="Level order traversal in spiral form" data-count="horizontal" data-via="jakerutter">Tweet</a><script type="text/javascript" src="http://platform.twitter.com/widgets.js"></script>
<g:plusone size="medium" href="http://www.geeksforgeeks.org/level-order-traversal-in-spiral-form/"></g:plusone>
<!-- Place this render call where appropriate -->
<script type="text/javascript">
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script></div>





				</div>		  
			</div> <!-- end post main -->					
			<div class="post-meta">
				<div class="left"></div>				
				<div class="clear"></div>
			</div>			
        
			<div class="comments-main">		
 <b>Writing code in comment?</b> Please use <b><a href="http://ideone.com/">ideone.com</a></b> and share the link here.
				
<div id="disqus_thread">
            <div id="dsq-content">


            <ul id="dsq-comments">
                    <li class="comment even thread-even depth-1" id="dsq-comment-34638">
        <div id="dsq-comment-header-34638" class="dsq-comment-header">
            <cite id="dsq-cite-34638">
                <span id="dsq-author-user-34638">Klove</span>
            </cite>
        </div>
        <div id="dsq-comment-body-34638" class="dsq-comment-body">
            <div id="dsq-comment-message-34638" class="dsq-comment-message"><p>Thanks for the code! Quick question , isnt the time complexity of method #2 O(n square) ?</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-32392">
        <div id="dsq-comment-header-32392" class="dsq-comment-header">
            <cite id="dsq-cite-32392">
                <span id="dsq-author-user-32392">Vishal Hemnani</span>
            </cite>
        </div>
        <div id="dsq-comment-body-32392" class="dsq-comment-body">
            <div id="dsq-comment-message-32392" class="dsq-comment-message"><p>Solution using Stack and Queue:</p>
<p><a href="http://ideone.com/LxzZS1" rel="nofollow">http://ideone.com/LxzZS1</a></p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-32075">
        <div id="dsq-comment-header-32075" class="dsq-comment-header">
            <cite id="dsq-cite-32075">
                <span id="dsq-author-user-32075">TheTrisha</span>
            </cite>
        </div>
        <div id="dsq-comment-body-32075" class="dsq-comment-body">
            <div id="dsq-comment-message-32075" class="dsq-comment-message"><p>I do not think the second method gives the correct result.<br />
A SUGGESTION : use a stack and a queue. The stack will help to print a level from right to left and queue will help to print a level from left to right. Here is a C function required to serve our goal. I am using arrays, you can used linked lists.</p>
<p>void spiral_level_order(struct node * root)</p>
<p>{</p>
<p>    int front=0,rear=0,top=0;</p>
<p>    struct node * q[100];</p>
<p>    struct node * s[100];</p>
<p>struct node * temp=NULL;</p>
<p>s[top]=root;</p>
<p>top=top+1;</p>
<p>while(front0)</p>
<p>{</p>
<p>while(top&gt;0)</p>
<p>{</p>
<p>top=top-1;</p>
<p>temp=s[top];</p>
<p>printf(&#8221; %d &#8220;,temp-&gt;data);</p>
<p>if(temp-&gt;left)</p>
<p>{</p>
<p>q[rear]=temp-&gt;left;</p>
<p>rear=rear+1;</p>
<p>}</p>
<p>if(temp-&gt;right)</p>
<p>{</p>
<p>q[rear]=temp-&gt;right;</p>
<p>rear=rear+1;</p>
<p>}</p>
<p>}</p>
<p>while(frontdata);</p>
<p>if(temp-&gt;left)</p>
<p>{</p>
<p>s[top]=temp-&gt;left;</p>
<p>top=top+1;</p>
<p>}</p>
<p>if(temp-&gt;right)</p>
<p>{</p>
<p>s[top]=temp-&gt;right;</p>
<p>top=top+1;</p>
<p>}</p>
<p>}</p>
<p>}</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-32076">
        <div id="dsq-comment-header-32076" class="dsq-comment-header">
            <cite id="dsq-cite-32076">
                <span id="dsq-author-user-32076">TheTrisha</span>
            </cite>
        </div>
        <div id="dsq-comment-body-32076" class="dsq-comment-body">
            <div id="dsq-comment-message-32076" class="dsq-comment-message"><p>SORRY FOR THE WEIRD MIX-UPS IN THE TEXT. REWRITTEN COMMENT.</p>
<p>I do not think the second method gives the correct result.<br />
A SUGGESTION : use a stack and a queue. The stack will help to print a level from right to left and queue will help to print a level from left to right. Here is a C function required to serve our goal. I am using arrays, you can used linked lists.</p>
<p>void spiral_level_order(struct node * root)</p>
<p>{</p>
<p>int front=0,rear=0,top=0;</p>
<p>struct node * q[100];</p>
<p>struct node * s[100];</p>
<p>struct node * temp=NULL;</p>
<p>s[top]=root;</p>
<p>top=top+1;</p>
<p>while(front0)</p>
<p>{</p>
<p>while(top&gt;0)</p>
<p>{</p>
<p>top=top-1;</p>
<p>temp=s[top];</p>
<p>printf(&#8221; %d &#8220;,temp-&gt;data);</p>
<p>if(temp-&gt;left)</p>
<p>{</p>
<p>q[rear]=temp-&gt;left;</p>
<p>rear=rear+1;</p>
<p>}</p>
<p>if(temp-&gt;right)</p>
<p>{</p>
<p>q[rear]=temp-&gt;right;</p>
<p>rear=rear+1;</p>
<p>}</p>
<p>}</p>
<p>while(frontdata);</p>
<p>if(temp-&gt;left)</p>
<p>{</p>
<p>s[top]=temp-&gt;left;</p>
<p>top=top+1;</p>
<p>}</p>
<p>if(temp-&gt;right)</p>
<p>{</p>
<p>s[top]=temp-&gt;right;</p>
<p>top=top+1;</p>
<p>}</p>
<p>}</p>
<p>}</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-3" id="dsq-comment-32077">
        <div id="dsq-comment-header-32077" class="dsq-comment-header">
            <cite id="dsq-cite-32077">
                <span id="dsq-author-user-32077">TheTrisha</span>
            </cite>
        </div>
        <div id="dsq-comment-body-32077" class="dsq-comment-body">
            <div id="dsq-comment-message-32077" class="dsq-comment-message"><p>Do not know what is the matter. trying to write the 2nd loop again.</p>
<p>while(frontdata);</p>
<p>if(temp-&gt;left)</p>
<p>{</p>
<p>s[top]=temp-&gt;left;</p>
<p>top=top+1;</p>
<p>}</p>
<p>if(temp-&gt;right)</p>
<p>{</p>
<p>s[top]=temp-&gt;right;</p>
<p>top=top+1;</p>
<p>}</p>
<p>}</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-31478">
        <div id="dsq-comment-header-31478" class="dsq-comment-header">
            <cite id="dsq-cite-31478">
                <span id="dsq-author-user-31478">Harsh</span>
            </cite>
        </div>
        <div id="dsq-comment-body-31478" class="dsq-comment-body">
            <div id="dsq-comment-message-31478" class="dsq-comment-message"><p>why is time complexity O(n^2)??</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-28671">
        <div id="dsq-comment-header-28671" class="dsq-comment-header">
            <cite id="dsq-cite-28671">
                <span id="dsq-author-user-28671">DarkProtocol</span>
            </cite>
        </div>
        <div id="dsq-comment-body-28671" class="dsq-comment-body">
            <div id="dsq-comment-message-28671" class="dsq-comment-message"><p>Can any one explain y T(n) for level order is O(n^2) while its taking O(n) in other  traversals&#8230;?</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-34802">
        <div id="dsq-comment-header-34802" class="dsq-comment-header">
            <cite id="dsq-cite-34802">
                <span id="dsq-author-user-34802">vaibhav</span>
            </cite>
        </div>
        <div id="dsq-comment-body-34802" class="dsq-comment-body">
            <div id="dsq-comment-message-34802" class="dsq-comment-message"><p>in right/left skewed its o(n^2) as for each node,, we have to visit all the previous nodes  in the tree</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-28481">
        <div id="dsq-comment-header-28481" class="dsq-comment-header">
            <cite id="dsq-cite-28481">
                <span id="dsq-author-user-28481">guest</span>
            </cite>
        </div>
        <div id="dsq-comment-body-28481" class="dsq-comment-body">
            <div id="dsq-comment-message-28481" class="dsq-comment-message"><p>can anyone plz tell me that in 1st method how the time complexity in O(n^2) ?? </p>
<p>thanks</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-28423">
        <div id="dsq-comment-header-28423" class="dsq-comment-header">
            <cite id="dsq-cite-28423">
                <span id="dsq-author-user-28423">sbellam</span>
            </cite>
        </div>
        <div id="dsq-comment-body-28423" class="dsq-comment-body">
            <div id="dsq-comment-message-28423" class="dsq-comment-message"><p>Method 2: Iterative solution has a bug. </p>
<p>In the first while loop the left node has to be pushed first , then right node.</p>
<p>As this is a stack last in first out. similarly look in the second loop as well.</p>
<p>Here is the corrected code</p>
<p>void printSprial(Node root)<br />
{<br />
       if(root == null)<br />
         return;<br />
         Stack s1 = new Stack();<br />
         Stack s2 = new Stack();<br />
         s1.push(root);<br />
         while(!s1.empty() || !s2.empty())<br />
          {<br />
              while(!s1.empty())<br />
             {<br />
                Node temp = s1.top();<br />
                  s1.pop();<br />
                  Console.WriteLine(temp.data);<br />
                  if(temp.left!=null)<br />
                       s2.push(temp.left);<br />
                  if(temp.right!=null)<br />
                        s2.push(temp.right);<br />
            }<br />
           while(!s2.empty())<br />
           {<br />
               Node temp = s2.top();<br />
               s2.pop();<br />
               Console.WriteLine(temp.data);<br />
                if(temp.right!=null)<br />
                    s1.push(temp.right);<br />
                if(temp.left!=null)<br />
                     s1.push(temp.left);<br />
         }<br />
   }<br />
}</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-2" id="dsq-comment-34068">
        <div id="dsq-comment-header-34068" class="dsq-comment-header">
            <cite id="dsq-cite-34068">
                <span id="dsq-author-user-34068">twinkles</span>
            </cite>
        </div>
        <div id="dsq-comment-body-34068" class="dsq-comment-body">
            <div id="dsq-comment-message-34068" class="dsq-comment-message"><p>Yes&#8230; please correct the code</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-3" id="dsq-comment-34072">
        <div id="dsq-comment-header-34072" class="dsq-comment-header">
            <cite id="dsq-cite-34072">
                <span id="dsq-author-user-34072">GeeksforGeeks</span>
            </cite>
        </div>
        <div id="dsq-comment-body-34072" class="dsq-comment-body">
            <div id="dsq-comment-message-34072" class="dsq-comment-message"><p>Could u please provide an example tree for which the method 2 doesn&#8217;t work?</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-27422">
        <div id="dsq-comment-header-27422" class="dsq-comment-header">
            <cite id="dsq-cite-27422">
                <span id="dsq-author-user-27422">Guest</span>
            </cite>
        </div>
        <div id="dsq-comment-body-27422" class="dsq-comment-body">
            <div id="dsq-comment-message-27422" class="dsq-comment-message"><p>This can also be implemented using One Stack and One Queue and using a flag to switch between stack and queues.</p>
<p>Here is the code snippet&#8230;</p>
<p>void LevelOrderTraversalInSpiral(Tree *root)<br />
{<br />
 if(root == NULL)<br />
 	return;<br />
 else<br />
 {<br />
 	Queue Q;<br />
 	Stack S;<br />
 	bool flag=true;<br />
 	S.Push(root);<br />
 	while(!S.IsStackEmpty() || !Q.IsQueueEmpty())<br />
 	{<br />
  	if(flag)<br />
  	{<br />
   	while(!S.IsStackEmpty())<br />
   	{<br />
    	root=S.Pop();<br />
    	cout&lt;data&lt;left)<br />
     	Q.EnQueue(root-&gt;left);<br />
    	if(root-&gt;right)<br />
     	Q.EnQueue(root-&gt;right);<br />
   	}<br />
  	}<br />
  	else<br />
  	{<br />
   	while(!Q.IsQueueEmpty())<br />
   	{<br />
    	root=Q.DeQueue();<br />
    	cout&lt;data&lt;left)<br />
     	S.Push(root-&gt;left);<br />
    	if(root-&gt;right)<br />
     	S.Push(root-&gt;right);<br />
   	}<br />
  	}<br />
  	flag^=true;<br />
 }<br />
 }</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-31196">
        <div id="dsq-comment-header-31196" class="dsq-comment-header">
            <cite id="dsq-cite-31196">
                <span id="dsq-author-user-31196">bakwasscoder</span>
            </cite>
        </div>
        <div id="dsq-comment-body-31196" class="dsq-comment-body">
            <div id="dsq-comment-message-31196" class="dsq-comment-message"><p>this doesn&#8217;t work: <a href="http://ideone.com/d7V9te" rel="nofollow">http://ideone.com/d7V9te</a><br />
I don&#8217;t think we can do it with a stack and a queue.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-3" id="dsq-comment-32391">
        <div id="dsq-comment-header-32391" class="dsq-comment-header">
            <cite id="dsq-cite-32391">
                <span id="dsq-author-user-32391">Vishal Hemnani</span>
            </cite>
        </div>
        <div id="dsq-comment-body-32391" class="dsq-comment-body">
            <div id="dsq-comment-message-32391" class="dsq-comment-message"><p>Using Stack and Queue:</p>
<p><a href="http://ideone.com/LxzZS1" rel="nofollow">http://ideone.com/LxzZS1</a></p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-27240">
        <div id="dsq-comment-header-27240" class="dsq-comment-header">
            <cite id="dsq-cite-27240">
                <span id="dsq-author-user-27240">Sumit Monga</span>
            </cite>
        </div>
        <div id="dsq-comment-body-27240" class="dsq-comment-body">
            <div id="dsq-comment-message-27240" class="dsq-comment-message"><p>the pop_back() and push_front() can be exchanged in odd and even levels keeping one operation at front and other at the back.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-27239">
        <div id="dsq-comment-header-27239" class="dsq-comment-header">
            <cite id="dsq-cite-27239">
                <span id="dsq-author-user-27239">Sumit Monga</span>
            </cite>
        </div>
        <div id="dsq-comment-body-27239" class="dsq-comment-body">
            <div id="dsq-comment-message-27239" class="dsq-comment-message"><p>here is the code for solution using deque.</p>
<p>#include </p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>using namespace std;</p>
<p>typedef struct node</p>
<p>{</p>
<p>int data;</p>
<p>struct node * left,*right;</p>
<p>}Node;</p>
<p>Node * newNode(int data)</p>
<p>{</p>
<p>Node * temp = new(Node);</p>
<p>temp-&gt;data = data;</p>
<p>temp-&gt;left = NULL;</p>
<p>temp-&gt;right = NULL;</p>
<p>return temp;</p>
<p>}</p>
<p>void LOT_spiral(Node * root)</p>
<p>{</p>
<p>if(root == NULL)</p>
<p>return;</p>
<p>dequeq;</p>
<p>q.push_back(root);</p>
<p>Node * temp = NULL;</p>
<p>int nodecount = 0;</p>
<p>int level = 1;</p>
<p>while(1)</p>
<p>{</p>
<p>nodecount = q.size();</p>
<p>if(nodecount == 0)</p>
<p>return;</p>
<p>while(nodecount &gt; 0)</p>
<p>{</p>
<p>if(level % 2)</p>
<p>{</p>
<p>temp = q.front();</p>
<p>q.pop_front();</p>
<p>printf(&#8221; %d &#8220;,temp-&gt;data);</p>
<p>if(temp-&gt;right)</p>
<p>q.push_back(temp-&gt;right);</p>
<p>if(temp-&gt;left)</p>
<p>q.push_back(temp-&gt;left);</p>
<p>}</p>
<p>else</p>
<p>{</p>
<p>temp = q.back();</p>
<p>q.pop_back();</p>
<p>printf(&#8221; %d &#8220;,temp-&gt;data);</p>
<p>if(temp-&gt;left)</p>
<p>q.push_front(temp-&gt;left);</p>
<p>if(temp-&gt;right)</p>
<p>q.push_front(temp-&gt;right);</p>
<p>}</p>
<p>nodecount&#8211;;</p>
<p>}</p>
<p>level++;</p>
<p>}</p>
<p>}</p>
<p>int main()</p>
<p>{</p>
<p>Node * root = NULL;</p>
<p>root = newNode(10);</p>
<p>root-&gt;left =  newNode(8);</p>
<p>root-&gt;left-&gt;right =  newNode(5);</p>
<p>root-&gt;left-&gt;left =  newNode(3);</p>
<p>root-&gt;right =  newNode(2);</p>
<p>root-&gt;right-&gt;left = newNode(2);</p>
<p>LOT_spiral(root);</p>
<p>}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-27237">
        <div id="dsq-comment-header-27237" class="dsq-comment-header">
            <cite id="dsq-cite-27237">
                <span id="dsq-author-user-27237">Sumit Monga</span>
            </cite>
        </div>
        <div id="dsq-comment-body-27237" class="dsq-comment-body">
            <div id="dsq-comment-message-27237" class="dsq-comment-message"><p>Can also be done using the &#8220;deque&#8221; container.<br />
For every odd level, use pop_back() and push_front() with right child pushed first then the left child.<br />
For every even level,use pop_front() and push_back() with left child pushed first then the right child</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-2" id="dsq-comment-27566">
        <div id="dsq-comment-header-27566" class="dsq-comment-header">
            <cite id="dsq-cite-27566">
                <span id="dsq-author-user-27566">prakash</span>
            </cite>
        </div>
        <div id="dsq-comment-body-27566" class="dsq-comment-body">
            <div id="dsq-comment-message-27566" class="dsq-comment-message"><p>plz tell me how you will track the level</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-3" id="dsq-comment-33481">
        <div id="dsq-comment-header-33481" class="dsq-comment-header">
            <cite id="dsq-cite-33481">
                <span id="dsq-author-user-33481">guets</span>
            </cite>
        </div>
        <div id="dsq-comment-body-33481" class="dsq-comment-body">
            <div id="dsq-comment-message-33481" class="dsq-comment-message"><p>we can keep a field in the queue data structure which will keep a count of the level.. before pushing elements of the next level we will check the level and act accordingly</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment byuser comment-author-geeksforgeeks bypostauthor even thread-odd thread-alt depth-1" id="dsq-comment-21338">
        <div id="dsq-comment-header-21338" class="dsq-comment-header">
            <cite id="dsq-cite-21338">
                <span id="dsq-author-user-21338">GeeksforGeeks</span>
            </cite>
        </div>
        <div id="dsq-comment-body-21338" class="dsq-comment-body">
            <div id="dsq-comment-message-21338" class="dsq-comment-message"><p>@Prakhar Jain and all,</p>
<p>Thanks for your comments.  We have added 2 Stack based method to the original post.  Keep it up!</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-21994">
        <div id="dsq-comment-header-21994" class="dsq-comment-header">
            <cite id="dsq-cite-21994">
http://mahajanneha.blogspot.com/                <span id="dsq-author-user-21994">neham</span>
            </cite>
        </div>
        <div id="dsq-comment-body-21994" class="dsq-comment-body">
            <div id="dsq-comment-message-21994" class="dsq-comment-message"><p>we must check for base condition in stack method like root should not be null. </p>
<p>if(root!- NULL) {<br />
s1.push(root)<br />
&#8230;<br />
.. // rest same<br />
}</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-geeksforgeeks bypostauthor even depth-3" id="dsq-comment-22011">
        <div id="dsq-comment-header-22011" class="dsq-comment-header">
            <cite id="dsq-cite-22011">
                <span id="dsq-author-user-22011">GeeksforGeeks</span>
            </cite>
        </div>
        <div id="dsq-comment-body-22011" class="dsq-comment-body">
            <div id="dsq-comment-message-22011" class="dsq-comment-message"><p>@neham: Thanks for pointing this out.  We have added a condition for null check. Keep it up!</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</li><!-- #comment-## -->
</li><!-- #comment-## -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-21278">
        <div id="dsq-comment-header-21278" class="dsq-comment-header">
            <cite id="dsq-cite-21278">
                <span id="dsq-author-user-21278">Prakhar Jain</span>
            </cite>
        </div>
        <div id="dsq-comment-body-21278" class="dsq-comment-body">
            <div id="dsq-comment-message-21278" class="dsq-comment-message"><p>Here is a solution using two stacks.</p>
<pre> <code language="C">
#include &lt;iostream&gt;
#include &lt;stack&gt;

using namespace std;

struct node {
	int data;
	struct node *left, *right;
};

void printspiral(struct node *root) {
	stack&lt;struct node*&gt; s1;
	stack&lt;struct node*&gt; s2;
	bool flag = true;
	s1.push(root);
	while (!s1.empty() || !s2.empty()) {
		if (flag) {
			flag = false;
			while (!s1.empty()) {
				struct node *temp = s1.top();
				s1.pop();
				printf(&quot;%d &quot;, temp-&gt;data);
				if (temp-&gt;right)
					s2.push(temp-&gt;right);
				if (temp-&gt;left)
					s2.push(temp-&gt;left);
			}
		}
		else {
			flag = true;
			while (!s2.empty()) {
				struct node *temp = s2.top();
				s2.pop();
				printf(&quot;%d &quot;, temp-&gt;data);
				if (temp-&gt;left)
					s1.push(temp-&gt;left);
				if (temp-&gt;right)
					s1.push(temp-&gt;right);
			}
		}
	}
}

struct node* newNode(int data)
{
  struct node* node = (struct node*)
                       malloc(sizeof(struct node));
  node-&gt;data = data;
  node-&gt;left = NULL;
  node-&gt;right = NULL;
 
  return(node);
}

int main() {
	struct node *root = newNode(1);
 	root-&gt;left        = newNode(2);
 	root-&gt;right       = newNode(3);
	root-&gt;left-&gt;left  = newNode(7);
	root-&gt;left-&gt;right = newNode(6);
	root-&gt;right-&gt;left  = newNode(5);
	root-&gt;right-&gt;right = newNode(4);
	printspiral(root);
}
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-manishsinha even thread-odd thread-alt depth-1" id="dsq-comment-20029">
        <div id="dsq-comment-header-20029" class="dsq-comment-header">
            <cite id="dsq-cite-20029">
                <span id="dsq-author-user-20029">manishsinha</span>
            </cite>
        </div>
        <div id="dsq-comment-body-20029" class="dsq-comment-body">
            <div id="dsq-comment-message-20029" class="dsq-comment-message"><pre> <code language="Java"></code> </pre>
<p>/* Paste your code here (You may delete these lines if not writing code) */</p>
<p>public void printZigZag(Node root){<br />
		if(root==null)<br />
			return ;<br />
		Stack<node> current = new Stack</node><node>();<br />
		current.push(root);<br />
		boolean lr=false;<br />
		zigzag(current,lr);<br />
	}<br />
	public void zigzag(Stack</node><node> current,boolean lr){<br />
		if(current.empty()){<br />
			return;<br />
		}<br />
		System.out.println();<br />
		Stack</node><node> next = new Stack</node><node>();<br />
		if(lr){<br />
			//System.out.println(current.size());<br />
			while(!current.empty()){<br />
				Node tmp = (Node)current.pop();<br />
				System.out.print(tmp.val + &#8221; &#8220;);<br />
				if(tmp.right!=null){<br />
					//System.out.println(&#8220;here&#8221;+tmp.right.val);<br />
					next.push(tmp.right);<br />
					}<br />
				if(tmp.left!=null){<br />
					//System.out.println(&#8220;here&#8221;+tmp.left.val);<br />
					next.push(tmp.left);<br />
				}</p>
<p>			}</p>
<p>		}else{<br />
			while(!current.empty()){<br />
			Node tmp = current.pop();<br />
			System.out.print(tmp.val+&#8221; &#8220;);<br />
			if(tmp.left!=null){<br />
				next.push(tmp.left);<br />
			}<br />
			if(tmp.right!=null){<br />
				next.push(tmp.right);<br />
				}</p>
<p>		}<br />
		}<br />
		lr = !lr;<br />
		zigzag(next,lr);<br />
		return;<br />
	}</node></p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-aman1234 odd alt thread-even depth-1" id="dsq-comment-19696">
        <div id="dsq-comment-header-19696" class="dsq-comment-header">
            <cite id="dsq-cite-19696">
                <span id="dsq-author-user-19696">aman1234</span>
            </cite>
        </div>
        <div id="dsq-comment-body-19696" class="dsq-comment-body">
            <div id="dsq-comment-message-19696" class="dsq-comment-message"><p>We can do it using a single array of nodes pointers.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-19618">
        <div id="dsq-comment-header-19618" class="dsq-comment-header">
            <cite id="dsq-cite-19618">
                <span id="dsq-author-user-19618">Akhil</span>
            </cite>
        </div>
        <div id="dsq-comment-body-19618" class="dsq-comment-body">
            <div id="dsq-comment-message-19618" class="dsq-comment-message"><p>Solutionusing two stacks.</p>
<p>void printLevelOrderZigZag(BinaryTree *root) {<br />
  stack&lt;BinaryTree*&gt; currentLevel, nextLevel;<br />
  bool leftToRight = true;<br />
  currentLevel.push(root);<br />
  while (!currentLevel.empty()) {<br />
    BinaryTree *currNode = currentLevel.top();<br />
    currentLevel.pop();<br />
    if (currNode) {<br />
      cout &lt;&lt; currNode-&gt;data &lt;&lt; &quot; &quot;;<br />
      if (leftToRight) {<br />
        nextLevel.push(currNode-&gt;left);<br />
        nextLevel.push(currNode-&gt;right);<br />
      } else {<br />
        nextLevel.push(currNode-&gt;right);<br />
        nextLevel.push(currNode-&gt;left);<br />
      }<br />
    }<br />
    if (currentLevel.empty()) {<br />
      cout &lt;&lt; endl;<br />
      leftToRight = !leftToRight;<br />
      swap(currentLevel, nextLevel);<br />
    }<br />
  }<br />
}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-17531">
        <div id="dsq-comment-header-17531" class="dsq-comment-header">
            <cite id="dsq-cite-17531">
                <span id="dsq-author-user-17531">BackBencher</span>
            </cite>
        </div>
        <div id="dsq-comment-body-17531" class="dsq-comment-body">
            <div id="dsq-comment-message-17531" class="dsq-comment-message"><p>@all : I think the complexity of solution is O(n^2).<br />
       Please let me know i am right or not?</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-alveko even depth-2" id="dsq-comment-19320">
        <div id="dsq-comment-header-19320" class="dsq-comment-header">
            <cite id="dsq-cite-19320">
                <span id="dsq-author-user-19320">alveko</span>
            </cite>
        </div>
        <div id="dsq-comment-body-19320" class="dsq-comment-body">
            <div id="dsq-comment-message-19320" class="dsq-comment-message"><p>Yes, it&#8217;s quadratic. The 2 stacks solution below is linear.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-16373">
        <div id="dsq-comment-header-16373" class="dsq-comment-header">
            <cite id="dsq-cite-16373">
                <span id="dsq-author-user-16373">Baahu</span>
            </cite>
        </div>
        <div id="dsq-comment-body-16373" class="dsq-comment-body">
            <div id="dsq-comment-message-16373" class="dsq-comment-message"><p>Zigzag implementation using 2 Stacks.</p>
<pre> <code language="CPP">
/* Paste your code here (You may delete these lines if not writing code) */

void ZigZag(struct node *root)
{
        stack&lt;node *&gt; s1;
        stack&lt;node *&gt; s2;
        struct node *temp;
        /*Put the first node into stack*/
        s1.push(root);
        while(1)
        {
                while(s1.size() &gt; 0)
                {
                        temp = s1.top();
                        s1.pop();
                        cout&lt;&lt;&quot; &quot;&lt;&lt;temp-&gt;data;
                        /*Put the data in left right fashion*/
                        if(temp-&gt;left)
                                s2.push(temp-&gt;left);
                        if(temp-&gt;right)
                                s2.push(temp-&gt;right);
                }
                while(s2.size() &gt; 0)
                {
                        temp = s2.top();
                        s2.pop();
                        cout&lt;&lt;&quot; &quot;&lt;&lt;temp-&gt;data;
                        /*REVERSE!!!Put the data in right left fashion*/
                        if(temp-&gt;left)
                                s1.push(temp-&gt;right);
                        if(temp-&gt;right)
                                s1.push(temp-&gt;left);
                }
                if(s2.size() == 0 &amp;&amp; s1.size() == 0)
                        break;
        }


}

</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-2" id="dsq-comment-18214">
        <div id="dsq-comment-header-18214" class="dsq-comment-header">
            <cite id="dsq-cite-18214">
                <span id="dsq-author-user-18214">rkl</span>
            </cite>
        </div>
        <div id="dsq-comment-body-18214" class="dsq-comment-body">
            <div id="dsq-comment-message-18214" class="dsq-comment-message"><p>This code is majorly good and efficient.<br />
But in the second inner loop&#8217;s if condition null-check for proper child. You are checking left child while pushing right child and vice versa.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-alveko odd alt depth-3" id="dsq-comment-19321">
        <div id="dsq-comment-header-19321" class="dsq-comment-header">
            <cite id="dsq-cite-19321">
                <span id="dsq-author-user-19321">alveko</span>
            </cite>
        </div>
        <div id="dsq-comment-body-19321" class="dsq-comment-body">
            <div id="dsq-comment-message-19321" class="dsq-comment-message"><p>+1. Also the if-break condition can be moved to the while line for a cleaner look</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-15726">
        <div id="dsq-comment-header-15726" class="dsq-comment-header">
            <cite id="dsq-cite-15726">
                <span id="dsq-author-user-15726">Rajneesh</span>
            </cite>
        </div>
        <div id="dsq-comment-body-15726" class="dsq-comment-body">
            <div id="dsq-comment-message-15726" class="dsq-comment-message"><pre> <code language="C">
//using single queue
void printLevelOrder(BinaryTree *root) {
  if (!root) return;
  queue&lt;BinaryTree*&gt; nodesQueue;

  nodesQueue.push(root);
  int nodesInCurrentLevel = 1;
  int nodesInNextLevel = 0;
  int ltr=0;
  
  while (!nodesQueue.empty()) {
    BinaryTree *currNode = nodesQueue.front();
    nodesQueue.pop();
    nodesInCurrentLevel--;
    if (currNode) {
      cout &lt;&lt; currNode-&gt;data &lt;&lt; &quot; &quot;;
	  if(ltr==0){
		nodesQueue.push(currNode-&gt;left);
		nodesQueue.push(currNode-&gt;right);
	  }
	  else{
		nodesQueue.push(currNode-&gt;right);
		nodesQueue.push(currNode-&gt;left);
	  }
	  
      nodesInNextLevel += 2;
    }
    if (nodesInCurrentLevel == 0) {
      cout &lt;&lt; endl;
	  ltr=(ltr==0)?1:0;
      nodesInCurrentLevel = nodesInNextLevel;
      nodesInNextLevel = 0;
    }
  }
}
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-15871">
        <div id="dsq-comment-header-15871" class="dsq-comment-header">
            <cite id="dsq-cite-15871">
                <span id="dsq-author-user-15871">Ark</span>
            </cite>
        </div>
        <div id="dsq-comment-body-15871" class="dsq-comment-body">
            <div id="dsq-comment-message-15871" class="dsq-comment-message"><p>I think this code is not correct . It is wrong .</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-3" id="dsq-comment-15874">
        <div id="dsq-comment-header-15874" class="dsq-comment-header">
            <cite id="dsq-cite-15874">
                <span id="dsq-author-user-15874">Ark</span>
            </cite>
        </div>
        <div id="dsq-comment-body-15874" class="dsq-comment-body">
            <div id="dsq-comment-message-15874" class="dsq-comment-message"><p>U should use the concept of deque (Double Ended queue) data structure if u want to implement using a single queue .  Ur code will give wrong output.<br />
See abishek&#8217;s post below dec 20, 2011 to do that . That code will work fine .</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-4" id="dsq-comment-15877">
        <div id="dsq-comment-header-15877" class="dsq-comment-header">
            <cite id="dsq-cite-15877">
                <span id="dsq-author-user-15877">Rajneesh</span>
            </cite>
        </div>
        <div id="dsq-comment-body-15877" class="dsq-comment-body">
            <div id="dsq-comment-message-15877" class="dsq-comment-message"><p>Yes..you are right. It will not work.<br />
It can be solved by either use of single doubly ended queue or using two queues. Thanks for pointing out mistake <img src="http://d2o58evtke57tz.cloudfront.net/wp-includes/images/smilies/icon_smile.gif" alt=":)" class="wp-smiley" /></p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-15433">
        <div id="dsq-comment-header-15433" class="dsq-comment-header">
            <cite id="dsq-cite-15433">
                <span id="dsq-author-user-15433">joker</span>
            </cite>
        </div>
        <div id="dsq-comment-body-15433" class="dsq-comment-body">
            <div id="dsq-comment-message-15433" class="dsq-comment-message"><p>#include &lt;iostream&gt;</p>
<p>using namespace std;</p>
<p>int turn = 0;</p>
<p>struct node<br />
{<br />
   int data;<br />
   node *left;<br />
   node *right;<br />
}*root;</p>
<p>struct list<br />
{<br />
   struct node* val;<br />
   list *next;<br />
}*front1,*front2;</p>
<p>void traverse()<br />
{<br />
	list *temp,*temp2,*newlt;<br />
	node * print;<br />
	front2 = NULL;<br />
	front1 = NULL;<br />
	if(root != NULL)<br />
	{<br />
	   cout&lt;&lt;root-&gt;data&lt;&lt;&quot;\t&quot;;</p>
<p>	   if(root-&gt;left!=NULL)<br />
	   {<br />
		front1 = new list;<br />
		front1-&gt;val = root-&gt;left;<br />
		//cout&lt;&lt;front1-&gt;val-&gt;data;<br />
	    front1-&gt;next = NULL;<br />
	   }<br />
	   if(root-&gt;right!=NULL)<br />
	   {<br />
		   temp = new list;<br />
		   temp-&gt;val = root-&gt;right;<br />
		   temp-&gt;next = NULL;<br />
		   if(front1 != NULL)<br />
			front1-&gt;next = temp;<br />
		   else<br />
		    front1 = temp;<br />
	   }</p>
<p>	}<br />
	while(front1 != NULL || front2 != NULL){<br />
	if(turn %2 == 0)<br />
	{<br />
		turn++;<br />
		temp = front1;<br />
		while(temp!= NULL)<br />
		{<br />
			print = temp-&gt;val;<br />
			cout&lt;&lt;print-&gt;data&lt;&lt;&quot;\t&quot;;<br />
			if(print-&gt;left != NULL){<br />
				newlt = new list;<br />
				newlt-&gt;val = print-&gt;left;<br />
				newlt-&gt;next = front2;<br />
				front2 = newlt;<br />
			}<br />
			if(print-&gt;right != NULL){<br />
				newlt = new list;<br />
				newlt-&gt;val = print-&gt;right;<br />
				newlt-&gt;next = front2;<br />
				front2 = newlt;<br />
			}<br />
			temp2 = temp;<br />
			temp = temp-&gt;next;<br />
			delete(temp2);<br />
		}<br />
		front1 = temp;<br />
	}</p>
<p>	else<br />
	{<br />
		turn++;<br />
		temp = front2;<br />
		while(temp!=NULL)<br />
		{<br />
			print = temp-&gt;val;<br />
			cout&lt;&lt;print-&gt;data&lt;&lt;&quot;\t&quot;;<br />
			if(print-&gt;right != NULL){<br />
				newlt =  new list;<br />
				newlt-&gt;val = print-&gt;right;<br />
				newlt-&gt;next = front1;<br />
				front1 = newlt;<br />
			}<br />
			if(print-&gt;left != NULL)<br />
			{<br />
				newlt =  new list;<br />
				newlt-&gt;val = print-&gt;left;<br />
				newlt-&gt;next = front1;<br />
				front1 = newlt;<br />
			}<br />
			temp2 = temp;<br />
			temp = temp-&gt;next;<br />
			delete(temp2);<br />
		}<br />
	    front2 = NULL;<br />
	}</p>
<p>}<br />
}<br />
node* insert(int data,node *temp)<br />
{<br />
	if(temp == NULL)<br />
	 {<br />
	     temp = new node;<br />
	     temp-&gt;data = data;<br />
	     temp-&gt;right = NULL;<br />
	     temp-&gt;left = NULL;<br />
	 }<br />
	else if(data &lt;= temp-&gt;data)<br />
	 {<br />
	    temp-&gt;left = insert(data,temp-&gt;left);<br />
	 }<br />
	else<br />
	{<br />
		temp-&gt;right = insert(data,temp-&gt;right);<br />
	}<br />
	return temp;<br />
} </p>
<p>int main()<br />
{<br />
   int data;<br />
   cin&gt;&gt;data;<br />
    while(data &gt; 0)<br />
    {<br />
	   root = insert(data,root);<br />
	   cin&gt;&gt;data;<br />
	}</p>
<p>   //cout&lt;&lt;root-&gt;data&lt;&lt;&quot;******&quot;&lt;&lt;endl;<br />
   traverse();<br />
   return 0;<br />
}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-15002">
        <div id="dsq-comment-header-15002" class="dsq-comment-header">
            <cite id="dsq-cite-15002">
                <span id="dsq-author-user-15002">mrn</span>
            </cite>
        </div>
        <div id="dsq-comment-body-15002" class="dsq-comment-body">
            <div id="dsq-comment-message-15002" class="dsq-comment-message"><pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
void spiral(Node *n)
{
	Node dummy;
	queue&lt;Node *&gt;q;
	q.push(n);
	q.push(&amp;dummy);
	int cnt=1;
	vector&lt;int&gt; v;
	while(!q.empty())
	{
		Node *tmp=q.front();q.pop();
		
		if(tmp==&amp;dummy)
		{
		if(!q.empty()) q.push(&amp;dummy);
		cout&lt;&lt;endl;
		if(cnt%2==0)
			for(vector&lt;int&gt;::reverse_iterator it=v.rbegin();it!=v.rend();it++)
				cout&lt;&lt;*it&lt;&lt;&quot; &quot;;
			
		else
			for(vector&lt;int&gt;::iterator it=v.begin();it!=v.end();it++)
				cout&lt;&lt;*it&lt;&lt;&quot; &quot;;
			
		cnt++;
		v.clear();
		continue;
		}
		
		v.push_back(tmp-&gt;v);
		if(tmp-&gt;l)q.push(tmp-&gt;l);
		if(tmp-&gt;r)q.push(tmp-&gt;r);
				
	}
}
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-orgzero even thread-odd thread-alt depth-1" id="dsq-comment-14904">
        <div id="dsq-comment-header-14904" class="dsq-comment-header">
            <cite id="dsq-cite-14904">
                <span id="dsq-author-user-14904">orgzero</span>
            </cite>
        </div>
        <div id="dsq-comment-body-14904" class="dsq-comment-body">
            <div id="dsq-comment-message-14904" class="dsq-comment-message"><p>I didn&#8217;t find a simpler solution I had in mind. I&#8217;ve provided that below, let me know if I&#8217;m missing something.</p>
<pre> <code language="Java">

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

public class LevelOrderSpiralTreeTraversal {
	private static class TreeNode {
		int		   data;
		TreeNode	left;
		TreeNode	right;
		
		public TreeNode(int aData) {
			data = aData;
		}
	}
	
	private static void traverseSpiral(TreeNode root) {
		traverseInternal(new TreeNode[] {
			root
		}, false);
	}
	
	private static void traverseInternal(TreeNode[] treeNodes, boolean l2r) {
		if (null == treeNodes || treeNodes.length &lt; 1) {
			return;
		}
		List&lt;TreeNode&gt; nextLevel = new ArrayList&lt;&gt;();
		if (l2r) {
			for (int i = 0; i &lt; treeNodes.length; i++) {
				nextLevel.addAll(process(treeNodes[i]));
			}
		} else {
			for (int i = treeNodes.length - 1; i &gt;= 0; i--) {
				nextLevel.addAll(process(treeNodes[i]));
			}
		}
		traverseInternal(nextLevel.toArray(new TreeNode[nextLevel.size()]), !l2r);
	}
	
	private static Collection&lt;? extends TreeNode&gt; process(TreeNode treeNode) {
		System.out.println(treeNode.data);
		Collection&lt;TreeNode&gt; l = new ArrayList&lt;&gt;();
		if (null != treeNode.left) {
			l.add(treeNode.left);
		}
		if (null != treeNode.right) {
			l.add(treeNode.right);
		}
		return l;
	}
	
	public static void main(String[] args) {
		TreeNode root = new TreeNode(1);
		root.left = new TreeNode(2);
		root.right = new TreeNode(3);
		root.left.left = new TreeNode(7);
		root.left.right = new TreeNode(6);
		root.right.right = new TreeNode(4);
		root.right.left = new TreeNode(5);
		traverseSpiral(root);
	}
}

</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-13928">
        <div id="dsq-comment-header-13928" class="dsq-comment-header">
            <cite id="dsq-cite-13928">
                <span id="dsq-author-user-13928">syang</span>
            </cite>
        </div>
        <div id="dsq-comment-body-13928" class="dsq-comment-body">
            <div id="dsq-comment-message-13928" class="dsq-comment-message"><p>use a queue and a stack to keep track of nodes at different level alternatively. Pseudo Java code as following:</p>
<pre> <code language="Java">
void spiral(Node root) {

    if (root == null) return;
    LinkedList&lt;Node&gt; queue = new LinkedList&lt;Node&gt;();
    LinkedList&lt;Node&gt; stack = new LinkedList&lt;Node&gt;();

    stack.addFirst(root);
    boolean useStack = true;

    while ((useStack &amp;&amp; stack.size() &gt; 0) || 
           (!useStack &amp;&amp; queue.size() &gt; 0) 
    {
        Node node = (useStack ? stack.removeFirst() : 
                                queue.poll());
        
        System.out.println(node.value);

        if (useStack) {
            if (node.left != null) 
                queue.offer(node.left);
            if (node.right != null)
                queue.offer(node.right);
        } else {
            if (node.left != null) 
                stack.addFirst(node.left);
            if (node.right != null)
                stack.addFirst(node.right);
        }

        if (useStack &amp;&amp; stack.size() == 0) {
            useStack = false;
            continue;
        }

        if (!useStack &amp;&amp; queue.size() == 0) {
            useStack = true;
            continue;
        }
    } /* while */
}

</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-12919">
        <div id="dsq-comment-header-12919" class="dsq-comment-header">
            <cite id="dsq-cite-12919">
                <span id="dsq-author-user-12919">Nikhil</span>
            </cite>
        </div>
        <div id="dsq-comment-body-12919" class="dsq-comment-body">
            <div id="dsq-comment-message-12919" class="dsq-comment-message"><p>This can also be solved using queue right???</p>
<p>Using queue method of level order traversal,we just need maintain a boolean for left to right or vice versa traversal.</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-13931">
        <div id="dsq-comment-header-13931" class="dsq-comment-header">
            <cite id="dsq-cite-13931">
                <span id="dsq-author-user-13931">syang</span>
            </cite>
        </div>
        <div id="dsq-comment-body-13931" class="dsq-comment-body">
            <div id="dsq-comment-message-13931" class="dsq-comment-message"><p>I think it&#8217;d better to use a queue as well as a stack.</p>
<pre> <code language="Java">
void spiral(Node root) {

    if (root == null) return;

    LinkedList&lt;Node&gt; stack = new LinkedList&lt;Node&gt;();
    LinkedList&lt;NOde&gt; queue = new LinkedList&lt;Node&gt;();

    boolean use_stack = true;
    stack.addFirst(root);

    while ((use_stack &amp;&amp; stack.size() &gt; 0) ||
           (!use_stack &amp;&amp; queue.size() &gt; 0)) 
    {
        Node node = use_stack ? stack.removeFirst() : queue.poll();

        System.out.println(node.value);

        if (node.left != null) {
            if (use_stack) 
                queue.offer(node.left);
            else
                stack.addFirst(node.left);
        }


        if (node.right != null) {
            if (use_stack) 
                queue.offer(node.right);
            else
                stack.addFirst(node.right);
        }

        if (use_stack &amp;&amp; stack.size() == 0) {
            use_stack = false;
        } else if (!use_stack &amp;&amp; queue.size() == 0) {
            use_stack = true;
        }
    }
}
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-3" id="dsq-comment-15118">
        <div id="dsq-comment-header-15118" class="dsq-comment-header">
            <cite id="dsq-cite-15118">
                <span id="dsq-author-user-15118">Rahim</span>
            </cite>
        </div>
        <div id="dsq-comment-body-15118" class="dsq-comment-body">
            <div id="dsq-comment-message-15118" class="dsq-comment-message"><p>Looks good!</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-8762">
        <div id="dsq-comment-header-8762" class="dsq-comment-header">
            <cite id="dsq-cite-8762">
                <span id="dsq-author-user-8762">Guddu sharma</span>
            </cite>
        </div>
        <div id="dsq-comment-body-8762" class="dsq-comment-body">
            <div id="dsq-comment-message-8762" class="dsq-comment-message"><p>Here is the iterative version using two stacks.</p>
<pre> <code language="C">
void zigZagTraversal(struct node *root)
{
	struct node *Stack1[20],*Stack2[20],*temp;
	int top1=-1,top2=-1,LeftToRight=1;
	
	Stack1[++top1]=root;
	
	while(top1&gt;=0 || top2&gt;=0)
	{
		if(LeftToRight)
		{
			while(top1&gt;=0)
			{
				temp=Stack1[top1--];
				printf(&quot;%d &quot;,temp-&gt;data);
				
				if(temp-&gt;left)
					Stack2[++top2]=temp-&gt;left;
					
				if(temp-&gt;right)
					Stack2[++top2]=temp-&gt;right;
			}
			printf(&quot;|&quot;);
		}
		else
		{
			while(top2&gt;=0)
			{
				temp=Stack2[top2--];
				printf(&quot;%d &quot;,temp-&gt;data);
				
				if(temp-&gt;right)
					Stack1[++top1]=temp-&gt;right;
					
				if(temp-&gt;left)
					Stack1[++top1]=temp-&gt;left;
			}
			printf(&quot;|&quot;);
		}
		LeftToRight=1-LeftToRight;
	}
}
</code> </pre>
<p>Please let me know if anything is wrong.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-2" id="dsq-comment-9095">
        <div id="dsq-comment-header-9095" class="dsq-comment-header">
            <cite id="dsq-cite-9095">
                <span id="dsq-author-user-9095">krishna</span>
            </cite>
        </div>
        <div id="dsq-comment-body-9095" class="dsq-comment-body">
            <div id="dsq-comment-message-9095" class="dsq-comment-message"><p>Using two stacks is a better approach.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt depth-2" id="dsq-comment-10821">
        <div id="dsq-comment-header-10821" class="dsq-comment-header">
            <cite id="dsq-cite-10821">
http://roomforcreativity.wordpress.com                <span id="dsq-author-user-10821">cyclotrojan</span>
            </cite>
        </div>
        <div id="dsq-comment-body-10821" class="dsq-comment-body">
            <div id="dsq-comment-message-10821" class="dsq-comment-message"><p>Perfect</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even depth-2" id="dsq-comment-14245">
        <div id="dsq-comment-header-14245" class="dsq-comment-header">
            <cite id="dsq-cite-14245">
                <span id="dsq-author-user-14245">rahul</span>
            </cite>
        </div>
        <div id="dsq-comment-body-14245" class="dsq-comment-body">
            <div id="dsq-comment-message-14245" class="dsq-comment-message"><p>perfect</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt depth-2" id="dsq-comment-15006">
        <div id="dsq-comment-header-15006" class="dsq-comment-header">
            <cite id="dsq-cite-15006">
                <span id="dsq-author-user-15006">vikash</span>
            </cite>
        </div>
        <div id="dsq-comment-body-15006" class="dsq-comment-body">
            <div id="dsq-comment-message-15006" class="dsq-comment-message"><p>time complexity is O(n). plz correct me if i m worng &#8230;.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even depth-2" id="dsq-comment-17543">
        <div id="dsq-comment-header-17543" class="dsq-comment-header">
            <cite id="dsq-cite-17543">
                <span id="dsq-author-user-17543">BackBencher</span>
            </cite>
        </div>
        <div id="dsq-comment-body-17543" class="dsq-comment-body">
            <div id="dsq-comment-message-17543" class="dsq-comment-message"><p>Hi, </p>
<p> Nice Solution..!</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-8740">
        <div id="dsq-comment-header-8740" class="dsq-comment-header">
            <cite id="dsq-cite-8740">
http://anshulsalvo.blogspot.in/                <span id="dsq-author-user-8740">Anshul</span>
            </cite>
        </div>
        <div id="dsq-comment-body-8740" class="dsq-comment-body">
            <div id="dsq-comment-message-8740" class="dsq-comment-message"><pre> <code language="Java">
public static void zigZag(TreeNode node) {
		int direction = 1;
		ArrayList&lt;TreeNode&gt; alist = new ArrayList&lt;TreeNode&gt;();
		alist.add(node);
		int count1 = 1;
		int count2 = 0;
		while (alist.size() &gt; 0) {
			if (direction == 1) {
				for (int i = 0; i &lt; count1; i++) {
					TreeNode n = alist.get(i);
					if (n.left != null) {
						count2++;
						alist.add(n.left);
					}
					if (n.right != null) {
						count2++;
						alist.add(n.right);
					}
					
				}
				for (int i = 0; i &lt; count1; i++) {
					System.out.print(alist.get(0).data + &quot; &quot;);
					alist.remove(0);
				}
				count1 = 0;
			} else {
				int pos2 = alist.size() - 1;
				int pos1 = alist.size() - count2;
				for (int i = pos1; i &lt;= pos2; i++) {
					TreeNode n = alist.get(i);
					if (n.left != null) {
						count1++;
						alist.add(n.left);
					}
					if (n.right != null) {
						count1++;
						alist.add(n.right);
					}
				}

				for (int i = pos2; i &gt;= pos1; i--) {
					System.out.print(alist.get(i).data + &quot; &quot;);
					alist.remove(i);
				}
				count2 = 0;
			}
			direction = direction ^ 1;
		}
	}
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-2" id="dsq-comment-8751">
        <div id="dsq-comment-header-8751" class="dsq-comment-header">
            <cite id="dsq-cite-8751">
http://anshulsalvo.blogspot.in/                <span id="dsq-author-user-8751">Anshul</span>
            </cite>
        </div>
        <div id="dsq-comment-body-8751" class="dsq-comment-body">
            <div id="dsq-comment-message-8751" class="dsq-comment-message"><p>* The above uses only a single arraylist and performs a BFS type traversal<br />
* We actually dont use 2 stacks or 2 queues.<br />
* The algorithm is linear</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-8449">
        <div id="dsq-comment-header-8449" class="dsq-comment-header">
            <cite id="dsq-cite-8449">
                <span id="dsq-author-user-8449">Pranshu</span>
            </cite>
        </div>
        <div id="dsq-comment-body-8449" class="dsq-comment-body">
            <div id="dsq-comment-message-8449" class="dsq-comment-message"><p>	public void spiralOrder(Tree root, boolean isEven) {<br />
		if (root != null) {<br />
			System.out.println(root.getValue());</p>
<p>			if (!isEven) {<br />
				if (root.getLeftChild() != null)<br />
					queue.add(root.getLeftChild());<br />
				if (root.getRightChild() != null)<br />
					queue.add(root.getRightChild());<br />
				if (!stack.isEmpty())<br />
					spiralOrder(stack.pollFirst(), isEven);<br />
				else if (!queue.isEmpty())<br />
					spiralOrder(queue.poll(), !isEven);<br />
			} else {<br />
				if (root.getLeftChild() != null)<br />
					stack.addFirst(root.getLeftChild());<br />
				if (root.getRightChild() != null)<br />
					stack.addFirst(root.getRightChild());<br />
				if (!queue.isEmpty())<br />
					spiralOrder(queue.poll(), isEven);<br />
				else if (!stack.isEmpty())<br />
					spiralOrder(stack.pollFirst(), !isEven);<br />
			}<br />
		}<br />
	}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-8399">
        <div id="dsq-comment-header-8399" class="dsq-comment-header">
            <cite id="dsq-cite-8399">
                <span id="dsq-author-user-8399">Ashot Madatyan</span>
            </cite>
        </div>
        <div id="dsq-comment-body-8399" class="dsq-comment-body">
            <div id="dsq-comment-message-8399" class="dsq-comment-message"><p>Hey guys. There is a very good DS out there in STL called std::deque, and this problem can be easily solved by using that DS. The following code uses a single<br />
std::deque and a boolean to indicate the printing order, so I am sharing a complete s/c to one of my favourite programming sites:</p>
<pre> <code language="C">
#include &lt;iostream&gt;
#include &lt;queue&gt;

struct Node {
    Node *left;
    Node *right;
    int data;
    Node(Node* l, Node* r, int dat):left(l), right(r), data(dat){};
};

typedef int (*bst_visit)(Node*);

int print_node(Node *pNode)
{
    if (NULL == pNode){
        cout &lt;&lt; &quot;NULL pointer&quot; &lt;&lt; endl;
        return 1;
    }
    
    cout &lt;&lt; pNode-&gt;data &lt;&lt; endl;
    return 0;
}

void bst_LNR(Node *pNode, bst_visit visit)
{
    if (NULL == pNode)
        return;

    /* Process the left subtree */
    if (pNode-&gt;left)
        bst_LNR(pNode-&gt;left, visit);
    
    visit(pNode);

    /* Process the right subtree */
    if (pNode-&gt;right)
        bst_LNR(pNode-&gt;right, visit);    
}

void bst_RNL(Node *pNode, bst_visit visit)
{
    if (NULL == pNode)
        return;

    /* Process the right subtree */
    if (pNode-&gt;right)
        bst_LNR(pNode-&gt;right, visit);
        
    /* Process the node itself */
    visit(pNode);
    
    /* Process the left subtree */
    if (pNode-&gt;left)
        bst_LNR(pNode-&gt;left, visit);    
}

void bst_BFS(Node *pNode, bst_visit visit)
{
    using namespace std;
    int sz, i, level = 0;
    queue&lt;Node*&gt; Q;
    
    if (NULL == pNode)
        return;
        
    Q.push(pNode);
    
    while (! Q.empty()){
        cout &lt;&lt; &quot;L: &quot; &lt;&lt; level &lt;&lt; endl;
        
        sz = Q.size();
        for (i = 0; i &lt; sz; i++){
            Node *pTmpNode = Q.front();
            Q.pop();
            
            visit(pTmpNode);
            
            /* Add the children of this node to the queue */
            if (pTmpNode-&gt;left)
                Q.push(pTmpNode-&gt;left);
            if (pTmpNode-&gt;right)
                Q.push(pTmpNode-&gt;right);
        }
        cout &lt;&lt; endl;
        ++level;
    }
    
    return;
}

void bst_BFS_spiral(Node *pNode, bst_visit visit)
{
    using namespace std;
    int sz, i, level = 0;
    deque&lt;Node*&gt; DQ;
    bool bFillFromLeft = false;
    
    if (NULL == pNode)
        return;
        
    DQ.push_back(pNode);
    
    while (! DQ.empty()){
        cout &lt;&lt; &quot;L: &quot; &lt;&lt; level &lt;&lt; endl;
        
        sz = DQ.size();
        for (i = 0; i &lt; sz; i++){
            Node *pTmpNode;
            if (bFillFromLeft) {
                pTmpNode = DQ.front();
                DQ.pop_front();
            }
            else {
                pTmpNode = DQ.back();
                DQ.pop_back();
            }
            
            visit(pTmpNode);
            
            /* Add the children of this node to the queue */
            if (bFillFromLeft) {
                if (pTmpNode-&gt;left)
                    DQ.push_back(pTmpNode-&gt;left);
                if (pTmpNode-&gt;right)
                    DQ.push_back(pTmpNode-&gt;right);        
            }
            else {
                if (pTmpNode-&gt;right)
                    DQ.push_front(pTmpNode-&gt;right);        
                if (pTmpNode-&gt;left)
                    DQ.push_front(pTmpNode-&gt;left);
            }
        }
        cout &lt;&lt; endl;
        ++level;
        bFillFromLeft = !bFillFromLeft;
    }
    
    return;
}


void bst_add_node(Node *pRoot, Node *pNewNode)
{
    if (NULL == pNewNode)
        return;

    if (pNewNode-&gt;data &lt; pRoot-&gt;data) {
        if (NULL == pRoot-&gt;left)
            pRoot-&gt;left = pNewNode;
        else
            bst_add_node(pRoot-&gt;left, pNewNode);
    }
    else {
        if (NULL == pRoot-&gt;right)
            pRoot-&gt;right = pNewNode;
        else
            bst_add_node(pRoot-&gt;right, pNewNode);
    }    
    return;
}

Node* bst_node_create(int value)
{
    Node *pNewNode = new Node(NULL, NULL, value);
    return pNewNode;
}

Node* bst_CTOR(int arr[], int cnt)
{
    Node *pRoot = bst_node_create(arr[0]);
    Node *pNewNode = NULL;
    int i;
    
    for (i = 1; i &lt; cnt; i++){
        pNewNode = bst_node_create(arr[i]);
        bst_add_node(pRoot, pNewNode);
    }
    return pRoot;
}

void bst_DTOR(Node *pRoot, int dir)
{
    Node *pLeft, *pRight;
    int val;
    
    if (NULL == pRoot)
        return;
        
    pLeft = pRoot-&gt;left;
    pRight = pRoot-&gt;right;

    if (pLeft)
        bst_DTOR(pLeft, -1);
    if (pRight)
        bst_DTOR(pRight, 1);
        
    val = pRoot-&gt;data;
    cout &lt;&lt; pRoot-&gt;data &lt;&lt; &quot;(&quot; &lt;&lt; dir &lt;&lt; &quot;)&quot; &lt;&lt; endl;
    delete pRoot;
    cout &lt;&lt; &quot;Deleted &quot; &lt;&lt; val &lt;&lt; endl;
}

int main(int argc, char *argv[])
{
    Node *pRoot = NULL;
    int arr[] = {25, 55, 37, 8, 14, 9, 40, 1, 60};
    int cnt = sizeof(arr)/sizeof(arr[0]);
    
    cout &lt;&lt; &quot;Bari luis&quot; &lt;&lt; endl;
    pRoot = bst_CTOR(arr, cnt);
    
    bst_LNR(pRoot, print_node);
    
    cout &lt;&lt; &quot;\n--- BFS ---\n&quot;;
    bst_BFS(pRoot, print_node);
    cout &lt;&lt; endl;

    cout &lt;&lt; &quot;\n--- BFS-SPIRAL ---\n&quot;;
    bst_BFS_spiral(pRoot, print_node);
    cout &lt;&lt; endl;
    
    bst_DTOR(pRoot, 0);
}
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-8398">
        <div id="dsq-comment-header-8398" class="dsq-comment-header">
            <cite id="dsq-cite-8398">
                <span id="dsq-author-user-8398">Ashot Madatyan</span>
            </cite>
        </div>
        <div id="dsq-comment-body-8398" class="dsq-comment-body">
            <div id="dsq-comment-message-8398" class="dsq-comment-message"><p>Hey guys. There is a very good DS out there in STL called std::deque, and this problem can be easily solved by using that DS. The following code uses a single<br />
std::deque and a boolean to indicate the printing order, so I am sharing a complete s/c to one of my favourite programming sites:</p>
<pre> <code language="CPP">
#include &lt;iostream&gt;
#include &lt;queue&gt;

struct Node {
    Node *left;
    Node *right;
    int data;
    Node(Node* l, Node* r, int dat):left(l), right(r), data(dat){};
};

typedef int (*bst_visit)(Node*);

int print_node(Node *pNode)
{
    if (NULL == pNode){
        cout &lt;&lt; &quot;NULL pointer&quot; &lt;&lt; endl;
        return 1;
    }
    
    cout &lt;&lt; pNode-&gt;data &lt;&lt; endl;
    return 0;
}

void bst_LNR(Node *pNode, bst_visit visit)
{
    if (NULL == pNode)
        return;

    /* Process the left subtree */
    if (pNode-&gt;left)
        bst_LNR(pNode-&gt;left, visit);
    
    visit(pNode);

    /* Process the right subtree */
    if (pNode-&gt;right)
        bst_LNR(pNode-&gt;right, visit);    
}

void bst_RNL(Node *pNode, bst_visit visit)
{
    if (NULL == pNode)
        return;

    /* Process the right subtree */
    if (pNode-&gt;right)
        bst_LNR(pNode-&gt;right, visit);
        
    /* Process the node itself */
    visit(pNode);
    
    /* Process the left subtree */
    if (pNode-&gt;left)
        bst_LNR(pNode-&gt;left, visit);    
}

void bst_BFS(Node *pNode, bst_visit visit)
{
    using namespace std;
    int sz, i, level = 0;
    queue&lt;Node*&gt; Q;
    
    if (NULL == pNode)
        return;
        
    Q.push(pNode);
    
    while (! Q.empty()){
        cout &lt;&lt; &quot;L: &quot; &lt;&lt; level &lt;&lt; endl;
        
        sz = Q.size();
        for (i = 0; i &lt; sz; i++){
            Node *pTmpNode = Q.front();
            Q.pop();
            
            visit(pTmpNode);
            
            /* Add the children of this node to the queue */
            if (pTmpNode-&gt;left)
                Q.push(pTmpNode-&gt;left);
            if (pTmpNode-&gt;right)
                Q.push(pTmpNode-&gt;right);
        }
        cout &lt;&lt; endl;
        ++level;
    }
    
    return;
}

void bst_BFS_spiral(Node *pNode, bst_visit visit)
{
    using namespace std;
    int sz, i, level = 0;
    deque&lt;Node*&gt; DQ;
    bool bFillFromLeft = false;
    
    if (NULL == pNode)
        return;
        
    DQ.push_back(pNode);
    
    while (! DQ.empty()){
        cout &lt;&lt; &quot;L: &quot; &lt;&lt; level &lt;&lt; endl;
        
        sz = DQ.size();
        for (i = 0; i &lt; sz; i++){
            Node *pTmpNode;
            if (bFillFromLeft) {
                pTmpNode = DQ.front();
                DQ.pop_front();
            }
            else {
                pTmpNode = DQ.back();
                DQ.pop_back();
            }
            
            visit(pTmpNode);
            
            /* Add the children of this node to the queue */
            if (bFillFromLeft) {
                if (pTmpNode-&gt;left)
                    DQ.push_back(pTmpNode-&gt;left);
                if (pTmpNode-&gt;right)
                    DQ.push_back(pTmpNode-&gt;right);        
            }
            else {
                if (pTmpNode-&gt;right)
                    DQ.push_front(pTmpNode-&gt;right);        
                if (pTmpNode-&gt;left)
                    DQ.push_front(pTmpNode-&gt;left);
            }
        }
        cout &lt;&lt; endl;
        ++level;
        bFillFromLeft = !bFillFromLeft;
    }
    
    return;
}


void bst_add_node(Node *pRoot, Node *pNewNode)
{
    if (NULL == pNewNode)
        return;

    if (pNewNode-&gt;data &lt; pRoot-&gt;data) {
        if (NULL == pRoot-&gt;left)
            pRoot-&gt;left = pNewNode;
        else
            bst_add_node(pRoot-&gt;left, pNewNode);
    }
    else {
        if (NULL == pRoot-&gt;right)
            pRoot-&gt;right = pNewNode;
        else
            bst_add_node(pRoot-&gt;right, pNewNode);
    }    
    return;
}

Node* bst_node_create(int value)
{
    Node *pNewNode = new Node(NULL, NULL, value);
    return pNewNode;
}

Node* bst_CTOR(int arr[], int cnt)
{
    Node *pRoot = bst_node_create(arr[0]);
    Node *pNewNode = NULL;
    int i;
    
    for (i = 1; i &lt; cnt; i++){
        pNewNode = bst_node_create(arr[i]);
        bst_add_node(pRoot, pNewNode);
    }
    return pRoot;
}

void bst_DTOR(Node *pRoot, int dir)
{
    Node *pLeft, *pRight;
    int val;
    
    if (NULL == pRoot)
        return;
        
    pLeft = pRoot-&gt;left;
    pRight = pRoot-&gt;right;

    if (pLeft)
        bst_DTOR(pLeft, -1);
    if (pRight)
        bst_DTOR(pRight, 1);
        
    val = pRoot-&gt;data;
    cout &lt;&lt; pRoot-&gt;data &lt;&lt; &quot;(&quot; &lt;&lt; dir &lt;&lt; &quot;)&quot; &lt;&lt; endl;
    delete pRoot;
    cout &lt;&lt; &quot;Deleted &quot; &lt;&lt; val &lt;&lt; endl;
}

int main(int argc, char *argv[])
{
    Node *pRoot = NULL;
    int arr[] = {25, 55, 37, 8, 14, 9, 40, 1, 60};
    int cnt = sizeof(arr)/sizeof(arr[0]);
    
    cout &lt;&lt; &quot;Bari luis&quot; &lt;&lt; endl;
    pRoot = bst_CTOR(arr, cnt);
    
    bst_LNR(pRoot, print_node);
    
    cout &lt;&lt; &quot;\n--- BFS ---\n&quot;;
    bst_BFS(pRoot, print_node);
    cout &lt;&lt; endl;

    cout &lt;&lt; &quot;\n--- BFS-SPIRAL ---\n&quot;;
    bst_BFS_spiral(pRoot, print_node);
    cout &lt;&lt; endl;
    
    bst_DTOR(pRoot, 0);
}
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-8397">
        <div id="dsq-comment-header-8397" class="dsq-comment-header">
            <cite id="dsq-cite-8397">
                <span id="dsq-author-user-8397">Ashot Madatyan</span>
            </cite>
        </div>
        <div id="dsq-comment-body-8397" class="dsq-comment-body">
            <div id="dsq-comment-message-8397" class="dsq-comment-message"><p>Hey guys. There is a very good DS out there in STL called std::deque, and this<br />
problem can be easily solved by using that DS. The following code uses a single<br />
std::deque and a boolean to indicate the printing order, so I am sharing a<br />
complete s/c to one of my favourite programming sites:</p>
<p>/* Paste your code here (You may delete these lines if not writing code) */<br />
#include &lt;iostream&gt;<br />
#include &lt;queue&gt;</p>
<p>struct Node {<br />
    Node *left;<br />
    Node *right;<br />
    int data;<br />
    Node(Node* l, Node* r, int dat):left(l), right(r), data(dat){};<br />
};</p>
<p>typedef int (*bst_visit)(Node*);</p>
<p>int print_node(Node *pNode)<br />
{<br />
    if (NULL == pNode){<br />
        cout &lt;&lt; &quot;NULL pointer&quot; &lt;&lt; endl;<br />
        return 1;<br />
    }</p>
<p>    cout &lt;&lt; pNode-&gt;data &lt;&lt; endl;<br />
    return 0;<br />
}</p>
<p>void bst_LNR(Node *pNode, bst_visit visit)<br />
{<br />
    if (NULL == pNode)<br />
        return;</p>
<p>    /* Process the left subtree */<br />
    if (pNode-&gt;left)<br />
        bst_LNR(pNode-&gt;left, visit);</p>
<p>    visit(pNode);</p>
<p>    /* Process the right subtree */<br />
    if (pNode-&gt;right)<br />
        bst_LNR(pNode-&gt;right, visit);<br />
}</p>
<p>void bst_RNL(Node *pNode, bst_visit visit)<br />
{<br />
    if (NULL == pNode)<br />
        return;</p>
<p>    /* Process the right subtree */<br />
    if (pNode-&gt;right)<br />
        bst_LNR(pNode-&gt;right, visit);</p>
<p>    /* Process the node itself */<br />
    visit(pNode);</p>
<p>    /* Process the left subtree */<br />
    if (pNode-&gt;left)<br />
        bst_LNR(pNode-&gt;left, visit);<br />
}</p>
<p>void bst_BFS(Node *pNode, bst_visit visit)<br />
{<br />
    using namespace std;<br />
    int sz, i, level = 0;<br />
    queue&lt;Node*&gt; Q;</p>
<p>    if (NULL == pNode)<br />
        return;</p>
<p>    Q.push(pNode);</p>
<p>    while (! Q.empty()){<br />
        cout &lt;&lt; &quot;L: &quot; &lt;&lt; level &lt;&lt; endl;</p>
<p>        sz = Q.size();<br />
        for (i = 0; i &lt; sz; i++){<br />
            Node *pTmpNode = Q.front();<br />
            Q.pop();</p>
<p>            visit(pTmpNode);</p>
<p>            /* Add the children of this node to the queue */<br />
            if (pTmpNode-&gt;left)<br />
                Q.push(pTmpNode-&gt;left);<br />
            if (pTmpNode-&gt;right)<br />
                Q.push(pTmpNode-&gt;right);<br />
        }<br />
        cout &lt;&lt; endl;<br />
        ++level;<br />
    }</p>
<p>    return;<br />
}</p>
<p>void bst_BFS_spiral(Node *pNode, bst_visit visit)<br />
{<br />
    using namespace std;<br />
    int sz, i, level = 0;<br />
    deque&lt;Node*&gt; DQ;<br />
    bool bFillFromLeft = false;</p>
<p>    if (NULL == pNode)<br />
        return;</p>
<p>    DQ.push_back(pNode);</p>
<p>    while (! DQ.empty()){<br />
        cout &lt;&lt; &quot;L: &quot; &lt;&lt; level &lt;&lt; endl;</p>
<p>        sz = DQ.size();<br />
        for (i = 0; i &lt; sz; i++){<br />
            Node *pTmpNode;<br />
            if (bFillFromLeft) {<br />
                pTmpNode = DQ.front();<br />
                DQ.pop_front();<br />
            }<br />
            else {<br />
                pTmpNode = DQ.back();<br />
                DQ.pop_back();<br />
            }</p>
<p>            visit(pTmpNode);</p>
<p>            /* Add the children of this node to the queue */<br />
            if (bFillFromLeft) {<br />
                if (pTmpNode-&gt;left)<br />
                    DQ.push_back(pTmpNode-&gt;left);<br />
                if (pTmpNode-&gt;right)<br />
                    DQ.push_back(pTmpNode-&gt;right);<br />
            }<br />
            else {<br />
                if (pTmpNode-&gt;right)<br />
                    DQ.push_front(pTmpNode-&gt;right);<br />
                if (pTmpNode-&gt;left)<br />
                    DQ.push_front(pTmpNode-&gt;left);<br />
            }<br />
        }<br />
        cout &lt;&lt; endl;<br />
        ++level;<br />
        bFillFromLeft = !bFillFromLeft;<br />
    }</p>
<p>    return;<br />
}</p>
<p>void bst_add_node(Node *pRoot, Node *pNewNode)<br />
{<br />
    if (NULL == pNewNode)<br />
        return;</p>
<p>    if (pNewNode-&gt;data &lt; pRoot-&gt;data) {<br />
        if (NULL == pRoot-&gt;left)<br />
            pRoot-&gt;left = pNewNode;<br />
        else<br />
            bst_add_node(pRoot-&gt;left, pNewNode);<br />
    }<br />
    else {<br />
        if (NULL == pRoot-&gt;right)<br />
            pRoot-&gt;right = pNewNode;<br />
        else<br />
            bst_add_node(pRoot-&gt;right, pNewNode);<br />
    }<br />
    return;<br />
}</p>
<p>Node* bst_node_create(int value)<br />
{<br />
    Node *pNewNode = new Node(NULL, NULL, value);<br />
    return pNewNode;<br />
}</p>
<p>Node* bst_CTOR(int arr[], int cnt)<br />
{<br />
    Node *pRoot = bst_node_create(arr[0]);<br />
    Node *pNewNode = NULL;<br />
    int i;</p>
<p>    for (i = 1; i &lt; cnt; i++){<br />
        pNewNode = bst_node_create(arr[i]);<br />
        bst_add_node(pRoot, pNewNode);<br />
    }<br />
    return pRoot;<br />
}</p>
<p>void bst_DTOR(Node *pRoot, int dir)<br />
{<br />
    Node *pLeft, *pRight;<br />
    int val;</p>
<p>    if (NULL == pRoot)<br />
        return;</p>
<p>    pLeft = pRoot-&gt;left;<br />
    pRight = pRoot-&gt;right;</p>
<p>    if (pLeft)<br />
        bst_DTOR(pLeft, -1);<br />
    if (pRight)<br />
        bst_DTOR(pRight, 1);</p>
<p>    val = pRoot-&gt;data;<br />
    cout &lt;&lt; pRoot-&gt;data &lt;&lt; &quot;(&quot; &lt;&lt; dir &lt;&lt; &quot;)&quot; &lt;&lt; endl;<br />
    delete pRoot;<br />
    cout &lt;&lt; &quot;Deleted &quot; &lt;&lt; val &lt;&lt; endl;<br />
}</p>
<p>int main(int argc, char *argv[])<br />
{<br />
    Node *pRoot = NULL;<br />
    int arr[] = {25, 55, 37, 8, 14, 9, 40, 1, 60};<br />
    int cnt = sizeof(arr)/sizeof(arr[0]);</p>
<p>    cout &lt;&lt; &quot;Bari luis&quot; &lt;&lt; endl;<br />
    pRoot = bst_CTOR(arr, cnt);</p>
<p>    bst_LNR(pRoot, print_node);</p>
<p>    cout &lt;&lt; &quot;\n&#8212; BFS &#8212;\n&quot;;<br />
    bst_BFS(pRoot, print_node);<br />
    cout &lt;&lt; endl;</p>
<p>    cout &lt;&lt; &quot;\n&#8212; BFS-SPIRAL &#8212;\n&quot;;<br />
    bst_BFS_spiral(pRoot, print_node);<br />
    cout &lt;&lt; endl;</p>
<p>    bst_DTOR(pRoot, 0);<br />
}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-8396">
        <div id="dsq-comment-header-8396" class="dsq-comment-header">
            <cite id="dsq-cite-8396">
                <span id="dsq-author-user-8396">Ashot Madatyan</span>
            </cite>
        </div>
        <div id="dsq-comment-body-8396" class="dsq-comment-body">
            <div id="dsq-comment-message-8396" class="dsq-comment-message"><p>Hey guys. There is a very good DS out there in STL called std::deque, and this problem can be easily solved by using that DS. The following code uses a single std::deque and a boolean to indicate the printing order, so I am sharing a complete s/c to one of my favourite programming sites:</p>
<p>#include &lt;iostream&gt;<br />
#include &lt;queue&gt;</p>
<p>struct Node {<br />
    Node *left;<br />
    Node *right;<br />
    int data;<br />
    Node(Node* l, Node* r, int dat):left(l), right(r), data(dat){};<br />
};</p>
<p>typedef int (*bst_visit)(Node*);</p>
<p>int print_node(Node *pNode)<br />
{<br />
    if (NULL == pNode){<br />
        cout &lt;&lt; &quot;NULL pointer&quot; &lt;&lt; endl;<br />
        return 1;<br />
    }</p>
<p>    cout &lt;&lt; pNode-&gt;data &lt;&lt; endl;<br />
    return 0;<br />
}</p>
<p>void bst_LNR(Node *pNode, bst_visit visit)<br />
{<br />
    if (NULL == pNode)<br />
        return;</p>
<p>    /* Process the left subtree */<br />
    if (pNode-&gt;left)<br />
        bst_LNR(pNode-&gt;left, visit);</p>
<p>    visit(pNode);</p>
<p>    /* Process the right subtree */<br />
    if (pNode-&gt;right)<br />
        bst_LNR(pNode-&gt;right, visit);<br />
}</p>
<p>void bst_RNL(Node *pNode, bst_visit visit)<br />
{<br />
    if (NULL == pNode)<br />
        return;</p>
<p>    /* Process the right subtree */<br />
    if (pNode-&gt;right)<br />
        bst_LNR(pNode-&gt;right, visit);</p>
<p>    /* Process the node itself */<br />
    visit(pNode);</p>
<p>    /* Process the left subtree */<br />
    if (pNode-&gt;left)<br />
        bst_LNR(pNode-&gt;left, visit);<br />
}</p>
<p>void bst_BFS(Node *pNode, bst_visit visit)<br />
{<br />
    using namespace std;<br />
    int sz, i, level = 0;<br />
    queue&lt;Node*&gt; Q;</p>
<p>    if (NULL == pNode)<br />
        return;</p>
<p>    Q.push(pNode);</p>
<p>    while (! Q.empty()){<br />
        cout &lt;&lt; &quot;L: &quot; &lt;&lt; level &lt;&lt; endl;</p>
<p>        sz = Q.size();<br />
        for (i = 0; i &lt; sz; i++){<br />
            Node *pTmpNode = Q.front();<br />
            Q.pop();</p>
<p>            visit(pTmpNode);</p>
<p>            /* Add the children of this node to the queue */<br />
            if (pTmpNode-&gt;left)<br />
                Q.push(pTmpNode-&gt;left);<br />
            if (pTmpNode-&gt;right)<br />
                Q.push(pTmpNode-&gt;right);<br />
        }<br />
        cout &lt;&lt; endl;<br />
        ++level;<br />
    }</p>
<p>    return;<br />
}</p>
<p>void bst_BFS_spiral(Node *pNode, bst_visit visit)<br />
{<br />
    using namespace std;<br />
    int sz, i, level = 0;<br />
    deque&lt;Node*&gt; DQ;<br />
    bool bFillFromLeft = false;</p>
<p>    if (NULL == pNode)<br />
        return;</p>
<p>    DQ.push_back(pNode);</p>
<p>    while (! DQ.empty()){<br />
        cout &lt;&lt; &quot;L: &quot; &lt;&lt; level &lt;&lt; endl;</p>
<p>        sz = DQ.size();<br />
        for (i = 0; i &lt; sz; i++){<br />
            Node *pTmpNode;<br />
            if (bFillFromLeft) {<br />
                pTmpNode = DQ.front();<br />
                DQ.pop_front();<br />
            }<br />
            else {<br />
                pTmpNode = DQ.back();<br />
                DQ.pop_back();<br />
            }</p>
<p>            visit(pTmpNode);</p>
<p>            /* Add the children of this node to the queue */<br />
            if (bFillFromLeft) {<br />
                if (pTmpNode-&gt;left)<br />
                    DQ.push_back(pTmpNode-&gt;left);<br />
                if (pTmpNode-&gt;right)<br />
                    DQ.push_back(pTmpNode-&gt;right);<br />
            }<br />
            else {<br />
                if (pTmpNode-&gt;right)<br />
                    DQ.push_front(pTmpNode-&gt;right);<br />
                if (pTmpNode-&gt;left)<br />
                    DQ.push_front(pTmpNode-&gt;left);<br />
            }<br />
        }<br />
        cout &lt;&lt; endl;<br />
        ++level;<br />
        bFillFromLeft = !bFillFromLeft;<br />
    }</p>
<p>    return;<br />
}</p>
<p>void bst_add_node(Node *pRoot, Node *pNewNode)<br />
{<br />
    if (NULL == pNewNode)<br />
        return;</p>
<p>    if (pNewNode-&gt;data &lt; pRoot-&gt;data) {<br />
        if (NULL == pRoot-&gt;left)<br />
            pRoot-&gt;left = pNewNode;<br />
        else<br />
            bst_add_node(pRoot-&gt;left, pNewNode);<br />
    }<br />
    else {<br />
        if (NULL == pRoot-&gt;right)<br />
            pRoot-&gt;right = pNewNode;<br />
        else<br />
            bst_add_node(pRoot-&gt;right, pNewNode);<br />
    }<br />
    return;<br />
}</p>
<p>Node* bst_node_create(int value)<br />
{<br />
    Node *pNewNode = new Node(NULL, NULL, value);<br />
    return pNewNode;<br />
}</p>
<p>Node* bst_CTOR(int arr[], int cnt)<br />
{<br />
    Node *pRoot = bst_node_create(arr[0]);<br />
    Node *pNewNode = NULL;<br />
    int i;</p>
<p>    for (i = 1; i &lt; cnt; i++){<br />
        pNewNode = bst_node_create(arr[i]);<br />
        bst_add_node(pRoot, pNewNode);<br />
    }<br />
    return pRoot;<br />
}</p>
<p>void bst_DTOR(Node *pRoot, int dir)<br />
{<br />
    Node *pLeft, *pRight;<br />
    int val;</p>
<p>    if (NULL == pRoot)<br />
        return;</p>
<p>    pLeft = pRoot-&gt;left;<br />
    pRight = pRoot-&gt;right;</p>
<p>    if (pLeft)<br />
        bst_DTOR(pLeft, -1);<br />
    if (pRight)<br />
        bst_DTOR(pRight, 1);</p>
<p>    val = pRoot-&gt;data;<br />
    cout &lt;&lt; pRoot-&gt;data &lt;&lt; &quot;(&quot; &lt;&lt; dir &lt;&lt; &quot;)&quot; &lt;&lt; endl;<br />
    delete pRoot;<br />
    cout &lt;&lt; &quot;Deleted &quot; &lt;&lt; val &lt;&lt; endl;<br />
}</p>
<p>int main(int argc, char *argv[])<br />
{<br />
    Node *pRoot = NULL;<br />
    int arr[] = {25, 55, 37, 8, 14, 9, 40, 1, 60};<br />
    int cnt = sizeof(arr)/sizeof(arr[0]);</p>
<p>    cout &lt;&lt; &quot;Bari luis&quot; &lt;&lt; endl;<br />
    pRoot = bst_CTOR(arr, cnt);</p>
<p>    bst_LNR(pRoot, print_node);</p>
<p>    cout &lt;&lt; &quot;\n&#8212; BFS &#8212;\n&quot;;<br />
    bst_BFS(pRoot, print_node);<br />
    cout &lt;&lt; endl;</p>
<p>    cout &lt;&lt; &quot;\n&#8212; BFS-SPIRAL &#8212;\n&quot;;<br />
    bst_BFS_spiral(pRoot, print_node);<br />
    cout &lt;&lt; endl;</p>
<p>    bst_DTOR(pRoot, 0);<br />
}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-8067">
        <div id="dsq-comment-header-8067" class="dsq-comment-header">
            <cite id="dsq-cite-8067">
http://extremecodeworld.blogspot.com                <span id="dsq-author-user-8067">Sheikh Abdul Wahid</span>
            </cite>
        </div>
        <div id="dsq-comment-body-8067" class="dsq-comment-body">
            <div id="dsq-comment-message-8067" class="dsq-comment-message"><p>your height calculating function will not probably work. it will always return 0. If i am work please do explain your logic.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-sachdeva odd alt thread-even depth-1" id="dsq-comment-7925">
        <div id="dsq-comment-header-7925" class="dsq-comment-header">
            <cite id="dsq-cite-7925">
                <span id="dsq-author-user-7925">ashu</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7925" class="dsq-comment-body">
            <div id="dsq-comment-message-7925" class="dsq-comment-message"><pre> <code language="C">
/* int level_spiral(struct node *root)
{
    char flag='L';
    stack&lt;struct node *&gt; mystk1;
    stack&lt;struct node *&gt; mystk2;
    
    mystk1.push(root);
    cout&lt;&lt;root-&gt;data&lt;&lt;&quot;\t&quot;;
    
    while(1)
    {
        while(!mystk1.empty())
        {
            struct node *temp=mystk1.top();
            mystk1.pop();
        
            if(flag=='L')
            {
                if(temp-&gt;left!=NULL)
                {
                    mystk2.push(temp-&gt;left);
                    cout&lt;&lt;temp-&gt;left-&gt;data&lt;&lt;&quot;\t&quot;;
                }
                if(temp-&gt;right!=NULL)
                {
                    mystk2.push(temp-&gt;right);
                    cout&lt;&lt;temp-&gt;right-&gt;data&lt;&lt;&quot;\t&quot;;
                }
            }
            else if(flag=='R')
            {
                if(temp-&gt;right!=NULL)
                {
                    mystk2.push(temp-&gt;right);
                    cout&lt;&lt;temp-&gt;right-&gt;data&lt;&lt;&quot;\t&quot;;
                }
                if(temp-&gt;left!=NULL)
                {
                    mystk2.push(temp-&gt;left);
                    cout&lt;&lt;temp-&gt;left-&gt;data&lt;&lt;&quot;\t&quot;;
                }
            }
        }
        if(!mystk2.empty())
        {
            swap(mystk2,mystk1);
            if(flag=='L')
                flag='R';
            else 
                flag='L';
        }
        else
            break;
    }
    return 0;
}*/
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-sachdeva even depth-2" id="dsq-comment-7926">
        <div id="dsq-comment-header-7926" class="dsq-comment-header">
            <cite id="dsq-cite-7926">
                <span id="dsq-author-user-7926">ashu</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7926" class="dsq-comment-body">
            <div id="dsq-comment-message-7926" class="dsq-comment-message"><p>it uses two stacks&#8230; and alternatively switch between left to right and right to left depending upon flag&#8230;</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment byuser comment-author-sachdeva odd alt thread-odd thread-alt depth-1" id="dsq-comment-7912">
        <div id="dsq-comment-header-7912" class="dsq-comment-header">
            <cite id="dsq-cite-7912">
                <span id="dsq-author-user-7912">ashu</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7912" class="dsq-comment-body">
            <div id="dsq-comment-message-7912" class="dsq-comment-message"><p>Solution using two stacks:</p>
<p>int level_spiral(struct node *root)<br />
{<br />
    char flag=&#8217;L';<br />
    stack<struct node *> mystk1;<br />
    stack</struct><struct node *> mystk2;</p>
<p>    mystk1.push(root);<br />
    cout< <root->data< <"\t";</p>
<p>    while(1)<br />
    {<br />
        while(!mystk1.empty())<br />
        {<br />
            struct node *temp=mystk1.top();<br />
            mystk1.pop();</p>
<p>            if(flag=='L')<br />
            {<br />
                if(temp->left!=NULL)<br />
                {<br />
                    mystk2.push(temp->left);<br />
                    cout< <temp->left->data< <"\t";<br />
                }<br />
                if(temp->right!=NULL)<br />
                {<br />
                    mystk2.push(temp->right);<br />
                    cout< <temp->right->data< <"\t";<br />
                }<br />
            }<br />
            else if(flag=='R')<br />
            {<br />
                if(temp->right!=NULL)<br />
                {<br />
                    mystk2.push(temp->right);<br />
                    cout< <temp->right->data< <"\t";<br />
                }<br />
                if(temp->left!=NULL)<br />
                {<br />
                    mystk2.push(temp->left);<br />
                    cout< <temp->left->data<<&#8221;\t&#8221;;<br />
                }<br />
            }<br />
        }<br />
        if(!mystk2.empty())<br />
        {<br />
            swap(mystk2,mystk1);<br />
            if(flag==&#8217;L&#8217;)<br />
                flag=&#8217;R';<br />
            else<br />
                flag=&#8217;L';<br />
        }<br />
        else<br />
            break;<br />
    }<br />
    return 0;<br />
}</struct></p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-7886">
        <div id="dsq-comment-header-7886" class="dsq-comment-header">
            <cite id="dsq-cite-7886">
                <span id="dsq-author-user-7886">Ajinkya</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7886" class="dsq-comment-body">
            <div id="dsq-comment-message-7886" class="dsq-comment-message"><p>RAJNIKANTH&#8217;S CODE:<br />
Rascala pussies&#8230;<br />
shortest and simplest solution&#8230;.<br />
sweet rascala mind it!! <img src="http://d2o58evtke57tz.cloudfront.net/wp-includes/images/smilies/icon_smile.gif" alt=":)" class="wp-smiley" /></p>
<pre> <code language="C">
stack s1,s2;
bool flag=1;
s1.push(root);
cout&lt;&lt;root-&gt;data;

while(!s1.empty())
{
    s2.init();
    while(!s1.empty())
    {
           if(flag)   {
                       node *p=s1.pop();
                       if(p-&gt;left!=NULL) {
                         s2.push(p-&gt;left); cout&lt;&lt;p-&gt;left-&gt;data; }
                       if(p-&gt;right!=NULL) {
                          s2.push(p-&gt;right); cout&lt;&lt;p-&gt;right-&gt;data; }

           else {
                 /*tume change-u 
                  -check right child 1st and push if !=NULL
                  -check left child 2nd and push if !=NULL
                }
     }
     s1=s2;
     flag=~flag;
}

Thats it machchas... NORMAL traversal QUEUE. SPIRAL traversal STACK. Keep it simple silly.

</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-7818">
        <div id="dsq-comment-header-7818" class="dsq-comment-header">
            <cite id="dsq-cite-7818">
                <span id="dsq-author-user-7818">khush</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7818" class="dsq-comment-body">
            <div id="dsq-comment-message-7818" class="dsq-comment-message"><p>there is small typo<br />
declaration of printGivenLevel method is printGivenLevel(tree,level)<br />
two argument but solution is calling printGivenLevel(tree,level,ltr)</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-geeksforgeeks bypostauthor even depth-2" id="dsq-comment-7821">
        <div id="dsq-comment-header-7821" class="dsq-comment-header">
            <cite id="dsq-cite-7821">
                <span id="dsq-author-user-7821">GeeksforGeeks</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7821" class="dsq-comment-body">
            <div id="dsq-comment-message-7821" class="dsq-comment-message"><p>@khush: Thanks for pointing out the typo in the algorithm. We have corrected it now.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment byuser comment-author-codinglearner odd alt thread-even depth-1" id="dsq-comment-7589">
        <div id="dsq-comment-header-7589" class="dsq-comment-header">
            <cite id="dsq-cite-7589">
                <span id="dsq-author-user-7589">codinglearner</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7589" class="dsq-comment-body">
            <div id="dsq-comment-message-7589" class="dsq-comment-message"><p>another soln &#8230;.<br />
correct me if wrong</p>
<pre> <code language="C">
/*LEVEL ORDER TRAVERSAL IN THE SPIRAL ORDER*/
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
struct node{
int data;
struct node *left,*right;
};
struct node* newNode(int d)
{
struct node *f=(struct node*)malloc(sizeof(struct node));
f-&gt;data=d;
f-&gt;left=f-&gt;right=NULL;
return f;
}
int height(struct node* root)
{
if(root==NULL)
return 0;
else
{
int lheight=height(root-&gt;left);
int rheight=height(root-&gt;right);
if(lheight&gt;=rheight)
return (lheight+1);
else
return (rheight+1);
}
}
void printlevel(struct node* node,int level)
{
if(node==NULL)
return;
if(level==1)
printf(&quot;%d\t&quot;,node-&gt;data);
else
{
        if(level%2==0)
        {
        printlevel(node-&gt;right,level-1);
        printlevel(node-&gt;left,level-1);
        }
        else
        {
        printlevel(node-&gt;left,level-1);
        printlevel(node-&gt;right,level-1);
        }
}
}
void printlevelorder(struct node *tree)
{
if(tree==NULL)
return;
for(int i=1;i&lt;=height(tree);i++)
printlevel(tree,i);
}
int main()
{
struct node* root=newNode(4);
root-&gt;left=newNode(2);
root-&gt;right=newNode(5);
root-&gt;left-&gt;left=newNode(1);
root-&gt;right-&gt;left=newNode(3);
printlevelorder(root);
return 0;
}
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-codinglearner even thread-odd thread-alt depth-1" id="dsq-comment-7588">
        <div id="dsq-comment-header-7588" class="dsq-comment-header">
            <cite id="dsq-cite-7588">
                <span id="dsq-author-user-7588">codinglearner</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7588" class="dsq-comment-body">
            <div id="dsq-comment-message-7588" class="dsq-comment-message"><pre> <code language="C">
/*LEVEL ORDER TRAVERSAL IN THE SPIRAL ORDER*/
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
struct node{
int data;
struct node *left,*right;
};
struct node* newNode(int d)
{
struct node *f=(struct node*)malloc(sizeof(struct node));
f-&gt;data=d;
f-&gt;left=f-&gt;right=NULL;
return f;
}
int height(struct node* root)
{
if(root==NULL)
return 0;
else
{
int lheight=height(root-&gt;left);
int rheight=height(root-&gt;right);
if(lheight&gt;=rheight)
return (lheight+1);
else
return (rheight+1);
}
}
void printlevel(struct node* node,int level)
{
if(node==NULL)
return;
if(level==1)
printf(&quot;%d\t&quot;,node-&gt;data);
else
{
        if(level%2==0)
        {
        printlevel(node-&gt;right,level-1);
        printlevel(node-&gt;left,level-1);
        }
        else
        {
        printlevel(node-&gt;left,level-1);
        printlevel(node-&gt;right,level-1);
        }
}
}
void printlevelorder(struct node *tree)
{
if(tree==NULL)
return;
for(int i=1;i&lt;=height(tree);i++)
printlevel(tree,i);
}
int main()
{
struct node* root=newNode(4);
root-&gt;left=newNode(2);
root-&gt;right=newNode(5);
root-&gt;left-&gt;left=newNode(1);
root-&gt;right-&gt;left=newNode(3);
printlevelorder(root);
return 0;
}
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-6869">
        <div id="dsq-comment-header-6869" class="dsq-comment-header">
            <cite id="dsq-cite-6869">
                <span id="dsq-author-user-6869">Abhishek</span>
            </cite>
        </div>
        <div id="dsq-comment-body-6869" class="dsq-comment-body">
            <div id="dsq-comment-message-6869" class="dsq-comment-message"><p>void printLevelOrderSpiral(node* root) {<br />
  if (!root) return;<br />
  deque  nodesQueue;<br />
  int nodesInCurrentLevel = 1;<br />
  int nodesInNextLevel = 0;<br />
  nodesQueue.push_back(root);<br />
  bool dir = true;<br />
  while (!nodesQueue.empty()) {<br />
    node* currNode ;<br />
    if(dir){<br />
       currNode = nodesQueue.front();<br />
       nodesQueue.pop_front();<br />
    }<br />
    else {<br />
       currNode = nodesQueue.back();<br />
       nodesQueue.pop_back();<br />
    }<br />
    nodesInCurrentLevel&#8211;;<br />
    if (currNode) {<br />
      cout &lt;data &lt;left);<br />
         nodesQueue.push_back(currNode-&gt;right);<br />
      }<br />
      else {<br />
         nodesQueue.push_front(currNode-&gt;right);<br />
         nodesQueue.push_front(currNode-&gt;left);<br />
      }<br />
      nodesInNextLevel += 2;<br />
    }<br />
    if (nodesInCurrentLevel == 0) {<br />
      cout &lt;&lt; endl;<br />
      nodesInCurrentLevel = nodesInNextLevel;<br />
      nodesInNextLevel = 0;<br />
      dir = dir ? false: true;</p>
<p>    }<br />
  }<br />
}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-6868">
        <div id="dsq-comment-header-6868" class="dsq-comment-header">
            <cite id="dsq-cite-6868">
                <span id="dsq-author-user-6868">Abhishek</span>
            </cite>
        </div>
        <div id="dsq-comment-body-6868" class="dsq-comment-body">
            <div id="dsq-comment-message-6868" class="dsq-comment-message"><pre> <code language="C">
void printLevelOrderSpiral(node* root) {
  if (!root) return;
  deque &lt;node*&gt; nodesQueue;
  int nodesInCurrentLevel = 1;
  int nodesInNextLevel = 0;
  nodesQueue.push_back(root);
  bool dir = true;
  while (!nodesQueue.empty()) {
    node* currNode ;
    if(dir){
       currNode = nodesQueue.front();
       nodesQueue.pop_front();
    }
    else {
       currNode = nodesQueue.back();
       nodesQueue.pop_back();
    }
    nodesInCurrentLevel--;
    if (currNode) {
      cout &lt;&lt; currNode-&gt;data &lt;&lt; &quot; &quot;;
      if(dir) {
         nodesQueue.push_back(currNode-&gt;left);
         nodesQueue.push_back(currNode-&gt;right);
      }
      else {
         nodesQueue.push_front(currNode-&gt;right);
         nodesQueue.push_front(currNode-&gt;left);
      }
      nodesInNextLevel += 2;
    }
    if (nodesInCurrentLevel == 0) {
      cout &lt;&lt; endl;
      nodesInCurrentLevel = nodesInNextLevel;
      nodesInNextLevel = 0;
      dir = dir ? false: true;

    }
  }
}
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-18530">
        <div id="dsq-comment-header-18530" class="dsq-comment-header">
            <cite id="dsq-cite-18530">
                <span id="dsq-author-user-18530">KK</span>
            </cite>
        </div>
        <div id="dsq-comment-body-18530" class="dsq-comment-body">
            <div id="dsq-comment-message-18530" class="dsq-comment-message"><p>Excellent sollution</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-6857">
        <div id="dsq-comment-header-6857" class="dsq-comment-header">
            <cite id="dsq-cite-6857">
                <span id="dsq-author-user-6857">Mad Coder</span>
            </cite>
        </div>
        <div id="dsq-comment-body-6857" class="dsq-comment-body">
            <div id="dsq-comment-message-6857" class="dsq-comment-message"><p>SOLUTION USING 2 STACKS</p>
<pre> <code language="C">
#include&lt;iostream&gt;
#include&lt;cstdlib&gt;
using namespace std;
struct tree
{
	int data;
	struct tree * left;
	struct tree * right;
}*stack1[10]={NULL},*stack2[10]={NULL};
int top1=0,top2=0;
struct tree * newNode(int data)
{
	struct tree * temp;
	temp=(struct tree *)malloc(sizeof(struct tree));
	temp-&gt;data=data;
	temp-&gt;left=NULL;
	temp-&gt;right=NULL;
	return temp;
}
void spiralorder(struct tree * n1,int level)
{
	if(!n1)
		return;
	if(level%2)
	{
		if(!top1)
			return;
		cout&lt;&lt;stack1[top1]-&gt;data&lt;&lt;&quot; &quot;;
		if(n1-&gt;left)
			stack2[++top2]=n1-&gt;left;
		if(n1-&gt;right)
			stack2[++top2]=n1-&gt;right;
		while(--top1&gt;0)
			spiralorder(stack1[top1],level);
		spiralorder(stack2[top2],level+1);
		return;
	}
		if(!top2)
			return;
		cout&lt;&lt;stack2[top2]-&gt;data&lt;&lt;&quot; &quot;;
		if(n1-&gt;right)
			stack1[++top1]=n1-&gt;right;
		if(n1-&gt;left)
			stack1[++top1]=n1-&gt;left;
		while(--top2&gt;0)
			spiralorder(stack2[top2],level);
		spiralorder(stack1[top1],level+1);
		return;
}
int main()
{
	struct tree * root1=newNode(7);
	struct tree * n1=newNode(2);
	struct tree * n2=newNode(30);
	struct tree * n3=newNode(1);
	struct tree * n4=newNode(5);
	struct tree * n5=newNode(8);
	struct tree * n6=newNode(4);
	struct tree * n7=newNode(10);
	root1-&gt;left=n1;
	root1-&gt;right=n2;
	n1-&gt;right=n3;
	n2-&gt;left=n4;
	n2-&gt;right=n5;
	n3-&gt;left=n6;
	n3-&gt;right=n7;
	stack1[++top1]=root1;
	spiralorder(root1,1);
	return 0;
}
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-pphanireddy odd alt thread-odd thread-alt depth-1" id="dsq-comment-6649">
        <div id="dsq-comment-header-6649" class="dsq-comment-header">
            <cite id="dsq-cite-6649">
                <span id="dsq-author-user-6649">pphanireddy</span>
            </cite>
        </div>
        <div id="dsq-comment-body-6649" class="dsq-comment-body">
            <div id="dsq-comment-message-6649" class="dsq-comment-message"><pre> <code language="C">
/****************************************************************************
     * Print spirally
     ****************************************************************************/
    public void printSpiral() {
	Stack&lt;Node&gt; spiralStack1 = new Stack&lt;Node&gt;();
	Stack&lt;Node&gt; spiralStack2 = new Stack&lt;Node&gt;();
	Node tempNode;
	int stackIdx = 0;
	int depth = 0;
	if(root != null) {
	    spiralStack1.push(root);
	}
	
	while(!spiralStack1.isEmpty() || !spiralStack2.isEmpty()) {
	    System.out.println(&quot;--------------( depth: &quot; + depth + &quot; )--------------&quot;);
	    if (stackIdx == 0) {
    	    	while (!spiralStack1.isEmpty()) {
    	    	    tempNode = spiralStack1.pop();
    	    	    if (tempNode != null) {
	    		System.out.println(&quot;(&quot; + tempNode.key + &quot;, &quot; + tempNode.val + &quot;) &quot;);
	    		spiralStack2.push(tempNode.left);
	    		spiralStack2.push(tempNode.right);
    	    	    }
    	    	    else {
	    		System.out.println(&quot;(NULL, NULL) &quot;);
    	    	    } 
    	    	}
	    }
	    else {
    	    	while (!spiralStack2.isEmpty()) {
    	    	    tempNode = spiralStack2.pop();
    	    	    if (tempNode != null) {
	    		System.out.println(&quot;(&quot; + tempNode.key + &quot;, &quot; + tempNode.val + &quot;) &quot;);
	    		spiralStack1.push(tempNode.right);
	    		spiralStack1.push(tempNode.left);
    	    	    }
    	    	    else {
	    		System.out.println(&quot;(NULL, NULL) &quot;);
    	    	    } 
    	    	}
	    }
	    depth++;
	    stackIdx = depth%2;
	}
	
    }
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-5339">
        <div id="dsq-comment-header-5339" class="dsq-comment-header">
            <cite id="dsq-cite-5339">
                <span id="dsq-author-user-5339">root.node</span>
            </cite>
        </div>
        <div id="dsq-comment-body-5339" class="dsq-comment-body">
            <div id="dsq-comment-message-5339" class="dsq-comment-message"><p><strong>SOLUTION USING TWO STACKS</strong></p>
<pre> <code language="C">
#include&lt;iostream&gt;
#include&lt;stack&gt;
#include&lt;queue&gt;

   using namespace std;

   struct Node {
      Node(){}
   
      Node(int info){
         this-&gt;info=info;	
         left=NULL;
         right=NULL;
      }
   	
      int info;
      Node * left;
      Node * right;
   };



   void printLevelOrder(Node *root) 
   {
      queue&lt;Node *&gt; q;
      Node *temp;
      q.push(root);
      while(!q.empty())
      {	
         temp=q.front();
         cout&lt;&lt;temp-&gt;info&lt;&lt;&quot; &quot;;
         q.pop();
      
         if(temp-&gt;left)
            q.push(temp-&gt;left);
      
         if(temp-&gt;right)
            q.push(temp-&gt;right);
      }
   
   
   
   }

   void printZigZag(Node *root);

   int main()
   {
    
      Node *root=new Node(1);
      root-&gt;left=new Node(2);
      root-&gt;right=new Node(3);
      root-&gt;left-&gt;left=new Node(4);
      root-&gt;left-&gt;right=new Node(5);
      root-&gt;right-&gt;left=new Node(6);
      root-&gt;right-&gt;right=new Node(7);
      printLevelOrder(root);
   
      cout&lt;&lt;endl;
      printZigZag(root);
   
      return 0;
   
   
   }


   void printZigZag(Node *root)
   {
      stack&lt;Node *&gt; s1,s2;
      Node *temp;
      s1.push(root);
   
   
      while(!s1.empty() || !s2.empty())
      {
      
         if(!s1.empty())
         {
            while(!s1.empty())
            {
               temp=s1.top();
               s1.pop();
               cout&lt;&lt;temp-&gt;info&lt;&lt;&quot; &quot;;
            
            
               if(temp-&gt;left)
                  s2.push(temp-&gt;left);
            
            
               if(temp-&gt;right)
                  s2.push(temp-&gt;right);
            
            }
         
         
         }
         else
         {
         
            while(!s2.empty())
            {
               temp=s2.top();
               s2.pop();
               cout&lt;&lt;temp-&gt;info&lt;&lt;&quot; &quot;;
            
               
		if(temp-&gt;right)
                  s1.push(temp-&gt;right);
					
		if(temp-&gt;left)
                  s1.push(temp-&gt;left);
             
            
            
            }			
         
         }
      
      }
   
   }
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-4682">
        <div id="dsq-comment-header-4682" class="dsq-comment-header">
            <cite id="dsq-cite-4682">
                <span id="dsq-author-user-4682">Phen0m</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4682" class="dsq-comment-body">
            <div id="dsq-comment-message-4682" class="dsq-comment-message"><p>A problem which could be easily coded by BFS O(n)-Time and O(n)-Memory.But a dumber iterative deepening algorithm is proposed .</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-4396">
        <div id="dsq-comment-header-4396" class="dsq-comment-header">
            <cite id="dsq-cite-4396">
                <span id="dsq-author-user-4396">rammi</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4396" class="dsq-comment-body">
            <div id="dsq-comment-message-4396" class="dsq-comment-message"><p>we can easily do it by using two stacks</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-venki odd alt depth-2" id="dsq-comment-4406">
        <div id="dsq-comment-header-4406" class="dsq-comment-header">
            <cite id="dsq-cite-4406">
http://www.linkedin.com/in/ramanawithu                <span id="dsq-author-user-4406">Venki</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4406" class="dsq-comment-body">
            <div id="dsq-comment-message-4406" class="dsq-comment-message"><p>Good idea, a &#8216;left to right stack&#8217; and a &#8216;right to left stack&#8217; can hold the items read on each alternative level.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-4214">
        <div id="dsq-comment-header-4214" class="dsq-comment-header">
            <cite id="dsq-cite-4214">
                <span id="dsq-author-user-4214">ska</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4214" class="dsq-comment-body">
            <div id="dsq-comment-message-4214" class="dsq-comment-message"><p>You don&#8217;t need to maintain ltr variable separately. Can do a % operation on level to decide which way to insert.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-2642">
        <div id="dsq-comment-header-2642" class="dsq-comment-header">
            <cite id="dsq-cite-2642">
                <span id="dsq-author-user-2642">Algorithmus</span>
            </cite>
        </div>
        <div id="dsq-comment-body-2642" class="dsq-comment-body">
            <div id="dsq-comment-message-2642" class="dsq-comment-message"><p>Hi all,</p>
<p>Can someone explain the complexity of above code ???</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-jalajb2k7 even depth-2" id="dsq-comment-7813">
        <div id="dsq-comment-header-7813" class="dsq-comment-header">
            <cite id="dsq-cite-7813">
                <span id="dsq-author-user-7813">jalajb2k7</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7813" class="dsq-comment-body">
            <div id="dsq-comment-message-7813" class="dsq-comment-message"><p>n^2 when tree is skewed</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-2532">
        <div id="dsq-comment-header-2532" class="dsq-comment-header">
            <cite id="dsq-cite-2532">
                <span id="dsq-author-user-2532">Arindam Nayak</span>
            </cite>
        </div>
        <div id="dsq-comment-body-2532" class="dsq-comment-body">
            <div id="dsq-comment-message-2532" class="dsq-comment-message"><p>If the question is only for Binary search tree and level has not be indicated by new line then i have one suggestion.</p>
<p>We can store it in an array .<br />
If root is stored at index n<br />
then its left child will be stored at location 2n + 1<br />
and right child will be stored at location 2n + 2</p>
<p>and print the whole array for level order traversal.</p>
<p>Example:</p>
<p>          A<br />
        /   \<br />
       B     C<br />
      / \   / \<br />
     D   E *   F  </p>
<p>lets say C doesn&#8217;t have left child.</p>
<p>Array Structure<br />
Index:   0 1 2 3 4 5 6 7 8 9<br />
Element: A B C D E * F</p>
<p>I am explaining only for single node.</p>
<p>A is root node so its index is 0</p>
<p>B is left child so its index is 2*0 +1 = 1<br />
D is left child of B<br />
so its index will be 2*(Index of B) + 1 = 2*1 +1 = 3</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-2223">
        <div id="dsq-comment-header-2223" class="dsq-comment-header">
            <cite id="dsq-cite-2223">
http://dzmitryhuba.blogspot.com                <span id="dsq-author-user-2223">Dzmitry Huba</span>
            </cite>
        </div>
        <div id="dsq-comment-body-2223" class="dsq-comment-body">
            <div id="dsq-comment-message-2223" class="dsq-comment-message"><p>I described algorithm and implementation in my blog <a href="http://dzmitryhuba.blogspot.com/2010/09/traverse-binary-tree-in-level-order-by.html" rel="nofollow">Traverse binary tree in level order by spiral</a></p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-1371">
        <div id="dsq-comment-header-1371" class="dsq-comment-header">
            <cite id="dsq-cite-1371">
http://dzmitryhuba.blogspot.com                <span id="dsq-author-user-1371">Dzmitry Huba</span>
            </cite>
        </div>
        <div id="dsq-comment-body-1371" class="dsq-comment-body">
            <div id="dsq-comment-message-1371" class="dsq-comment-message"><p>We can traverse level by spiral using two stacks in O(n) time and O(n) space using the following algorithm:<br />
&#8211; Use two stacks (current and next).<br />
&#8211; Swap current and next stacks<br />
&#8211; At each level we maintain order (left to right or right to left) and change it with each level<br />
&#8211; Pop item from current stack, print it (or process in any other way) and push their children into next stack. If it is left to right order we first push right child and then left child; otherwise push left child first and then right child<br />
&#8211; Continue until next stack has items</p>
<p>You can find C# code below:</p>
<p>static IEnumerable&lt;T&gt; LevelOrderBySpiral&lt;T&gt;(TreeNode&lt;T&gt; root)<br />
	where T:IComparable&lt;T&gt;<br />
{<br />
	var curr = new Stack&lt;TreeNode&lt;T&gt;&gt;();<br />
	var next = new Stack&lt;TreeNode&lt;T&gt;&gt;();</p>
<p>	var leftToRight = true;<br />
	next.Push(root);</p>
<p>	do<br />
	{<br />
		ObjectExtensions.Swap(ref curr, ref next);<br />
		while(curr.Count &gt; 0)<br />
		{<br />
			var node = curr.Pop();<br />
			yield return node.Value;</p>
<p>			if (leftToRight)<br />
			{<br />
				Push(next, node.Right);<br />
				Push(next, node.Left);<br />
			}<br />
			else<br />
			{<br />
				Push(next, node.Left);<br />
				Push(next, node.Right);<br />
			}<br />
		}<br />
		leftToRight = !leftToRight;<br />
	} while (next.Count &gt; 0);<br />
}</p>
<p>static void Push&lt;T&gt;(Stack&lt;T&gt; stackWithMin, T value)<br />
	where T: class<br />
{<br />
	if (value != null)<br />
		stackWithMin.Push(value);<br />
}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-1248">
        <div id="dsq-comment-header-1248" class="dsq-comment-header">
            <cite id="dsq-cite-1248">
                <span id="dsq-author-user-1248">nikhils</span>
            </cite>
        </div>
        <div id="dsq-comment-body-1248" class="dsq-comment-body">
            <div id="dsq-comment-message-1248" class="dsq-comment-message"><p>Using a stack and a queue, this can be done in O(n) time and O(n) space complexity. Complexity of current solution is O(n^2)</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-6368">
        <div id="dsq-comment-header-6368" class="dsq-comment-header">
            <cite id="dsq-cite-6368">
                <span id="dsq-author-user-6368">deb</span>
            </cite>
        </div>
        <div id="dsq-comment-body-6368" class="dsq-comment-body">
            <div id="dsq-comment-message-6368" class="dsq-comment-message"><p>Can you provide a bit more explanation on this?</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-678">
        <div id="dsq-comment-header-678" class="dsq-comment-header">
            <cite id="dsq-cite-678">
                <span id="dsq-author-user-678">tls</span>
            </cite>
        </div>
        <div id="dsq-comment-body-678" class="dsq-comment-body">
            <div id="dsq-comment-message-678" class="dsq-comment-message"><p>I think we can add another check in the if condition apart from root == NULL.</p>
<p>if ( root == NULL || level == 0) this will help eliminate to traverse all the left links, right links when level is 0.</p>
<p>Any comments pl. let me know</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-geeksforgeeks bypostauthor odd alt depth-2" id="dsq-comment-679">
        <div id="dsq-comment-header-679" class="dsq-comment-header">
            <cite id="dsq-cite-679">
                <span id="dsq-author-user-679">GeeksforGeeks</span>
            </cite>
        </div>
        <div id="dsq-comment-body-679" class="dsq-comment-body">
            <div id="dsq-comment-message-679" class="dsq-comment-message"><p>@tls: Nice suggestion! We have modified the if condition.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-3" id="dsq-comment-777">
        <div id="dsq-comment-header-777" class="dsq-comment-header">
            <cite id="dsq-cite-777">
                <span id="dsq-author-user-777">coderyogi</span>
            </cite>
        </div>
        <div id="dsq-comment-body-777" class="dsq-comment-body">
            <div id="dsq-comment-message-777" class="dsq-comment-message"><p>I&#8217;m not able to see how level == 0 condition will ever be true.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-geeksforgeeks bypostauthor odd alt depth-4" id="dsq-comment-780">
        <div id="dsq-comment-header-780" class="dsq-comment-header">
            <cite id="dsq-cite-780">
                <span id="dsq-author-user-780">GeeksforGeeks</span>
            </cite>
        </div>
        <div id="dsq-comment-body-780" class="dsq-comment-body">
            <div id="dsq-comment-message-780" class="dsq-comment-message"><p>@coderyogi: Your point is valid. We have removed level == 0 condition.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
            </ul>


        </div>

    </div>

<script type="text/javascript">
var disqus_url = 'http://www.geeksforgeeks.org/level-order-traversal-in-spiral-form/';
var disqus_identifier = '3758 http://geeksforgeeks.org/?p=3758';
var disqus_container_id = 'disqus_thread';
var disqus_shortname = 'geeksforgeeks';
var disqus_title = "Level order traversal in spiral form";
var disqus_config_custom = window.disqus_config;
var disqus_config = function () {
    /*
    All currently supported events:
    onReady: fires when everything is ready,
    onNewComment: fires when a new comment is posted,
    onIdentify: fires when user is authenticated
    */
    
    
    this.language = '';
    
    if (disqus_config_custom) {
        disqus_config_custom.call(this);
    }
};

(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>

			</div>
	
					
			
			

		</div> <!-- end post -->	

<br></br>
	
</div> <!-- end content -->

<ul id="sidebar">
	<li id="text-19" class="widget widget_text">			<div class="textwidget"><script>
  (function() {
    var cx = '009682134359037907028:tj6eafkv_be';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//www.google.com/cse/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>

<style type="text/css">
  .gsc-control-cse {
    font-family: "Trebuchet MS", sans-serif;
    border-color: #E1F3DA;
    background-color: #E1F3DA;
  }
  input.gsc-input {
    border-color: #94CC7A;
  }
  input.gsc-search-button {
    border-color: #94CC7A;
    background-color: #AADA92;
  }
  .gsc-tabHeader.gsc-tabhInactive {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gsc-tabHeader.gsc-tabhActive {
    border-color: #A9DA92;
    background-color: #A9DA92;
  }
  .gsc-tabsArea {
    border-color: #A9DA92;
  }
  .gsc-webResult.gsc-result {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gsc-webResult.gsc-result:hover {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gs-webResult.gs-result a.gs-title:link,
  .gs-webResult.gs-result a.gs-title:link b {
    color: #009900;
  }
  .gs-webResult.gs-result a.gs-title:visited,
  .gs-webResult.gs-result a.gs-title:visited b {
    color: #009900;
  }
  .gs-webResult.gs-result a.gs-title:hover,
  .gs-webResult.gs-result a.gs-title:hover b {
    color: #003300;
  }
  .gs-webResult.gs-result a.gs-title:active,
  .gs-webResult.gs-result a.gs-title:active b {
    color: #009900;
  }
  .gsc-cursor-page {
    color: #009900;
  }
  a.gsc-trailing-more-results:link {
    color: #009900;
  }
  .gs-webResult.gs-result .gs-snippet {
    color: #454545;
  }
  .gs-webResult.gs-result .gs-visibleUrl {
    color: #33cc00;
  }
  .gs-webResult.gs-result .gs-visibleUrl-short {
    color: #33cc00;
  }
  .gs-webResult.gs-result .gs-visibleUrl-short {
    display: none;
  }
  .gs-webResult.gs-result .gs-visibleUrl-long {
    display: block;
  }
  .gsc-cursor-box {
    border-color: #A9DA92;
  }
  .gsc-results .gsc-cursor-page {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gsc-results .gsc-cursor-page.gsc-cursor-current-page {
    border-color: #A9DA92;
    background-color: #A9DA92;
  }
  .gs-promotion.gs-result {
    border-color: #94CC7A;
    background-color: #CBE8B4;
  }
  .gs-promotion.gs-result a.gs-title:link {
    color: #0066CC;
  }
  .gs-promotion.gs-result a.gs-title:visited {
    color: #0066CC;
  }
  .gs-promotion.gs-result a.gs-title:hover {
    color: #0066CC;
  }
  .gs-promotion.gs-result a.gs-title:active {
    color: #0066CC;
  }
  .gs-promotion.gs-result .gs-snippet {
    color: #454545;
  }
  .gs-promotion.gs-result .gs-visibleUrl,
  .gs-promotion.gs-result .gs-visibleUrl-short {
    color: #815FA7;
  }
</style>    </div>
		</li>
<li id="text-9" class="widget widget_text">			<div class="textwidget"><div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=138031159685820";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>

<div class="fb-like-box" data-href="https://www.facebook.com/pages/GeeksforGeeks/316764689022" data-width="250" data-height="170" data-colorscheme="light" data-show-faces="true" data-header="false" data-stream="false" data-show-border="false"></div></div>
		</li>
<li id="text-18" class="widget widget_text">			<div class="textwidget"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LargeRectangleSide -->
<ins class="adsbygoogle"
     style="display:inline-block;width:336px;height:280px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="1884636833"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
		</li>
<li id="text-13" class="widget widget_text">			<div class="textwidget"><ul><li><a href="http://www.geeksforgeeks.org/category/interview-experiences/">Interview Experiences</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/advance-data-structures">Advanced Data Structures</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/dynamic-programming">Dynamic Programming</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/Greedy-Algorithm/">Greedy Algorithms</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/backtracking">Backtracking</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/pattern-searching">Pattern Searching</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/divide-and-conquer">Divide & Conquer</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/MathematicalAlgo">Mathematical Algorithms</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/recursion">Recursion</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/geometric-algorithms/">Geometric Algorithms</a></li>
</ul></div>
		</li>
<li id="text-17" class="widget widget_text">			<div class="textwidget"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big 300x600 Sidebar -->
<ins class="adsbygoogle"
     style="display:inline-block;width:300px;height:600px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="4402736037"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
		</li>
<li id="text-14" class="widget widget_text"><h2 class="widgettitle">Popular Posts</h2>
			<div class="textwidget"><ul>
<li><a href="http://www.geeksforgeeks.org/write-a-c-program-to-print-all-permutations-of-a-given-string/">  All permutations of a given string </a></li>
<li><a href="http://www.geeksforgeeks.org/memory-layout-of-c-program/"> Memory Layout of C Programs</a> </li>
<li><a href="http://www.geeksforgeeks.org/understanding-extern-keyword-in-c/"> Understanding extern keyword in C</a> </li>
<li><a href="http://www.geeksforgeeks.org/median-of-two-sorted-arrays/">Median of two sorted arrays</a> </li>
<li><a href="http://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/"> Tree traversal without recursion and without stack! </a></li>
<li><a href="http://www.geeksforgeeks.org/structure-member-alignment-padding-and-data-packing/"> Structure Member Alignment, Padding and Data Packing</a> </li>
<li><a href="http://www.geeksforgeeks.org/write-a-function-to-get-the-intersection-point-of-two-linked-lists/"> Intersection point of two Linked Lists</a> </li>
<li><a href="http://www.geeksforgeeks.org/lowest-common-ancestor-in-a-binary-search-tree/"> Lowest Common Ancestor in a BST.</span></a> </li>
<li><a href="http://www.geeksforgeeks.org/a-program-to-check-if-a-binary-tree-is-bst-or-not/"> Check if a binary tree is BST or not</a> </li>
<li><a href="http://www.geeksforgeeks.org/sorted-linked-list-to-balanced-bst/"> Sorted Linked List to Balanced BST</a></li>
</ul></div>
		</li>
<li id="text-3" class="widget widget_text">			<div class="textwidget"><a href="https://twitter.com/GeeksforGeeks" class="twitter-follow-button" data-show-count="false">Follow @GeeksforGeeks</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>         


<!-- GOOGLE FEEDBURNER BUTTON-->
<a href="http://feeds.feedburner.com/Geeksforgeeks" title="Subscribe to my feed" rel="alternate" type="application/rss+xml"><img src="http://www.feedburner.com/fb/images/pub/feed-icon32x32.png" alt="" style="border:0"/></a><a href="http://feeds.feedburner.com/Geeksforgeeks" title="Subscribe to my feed" rel="alternate" type="application/rss+xml">Subscribe</a>

</div>
		</li>
<li id="text-21" class="widget widget_text"><h2 class="widgettitle">Recent Comments</h2>
			<div class="textwidget"><script type="text/javascript" src="http://geeksforgeeks.disqus.com//recent_comments_widget.js?num_items=6&hide_avatars=1&excerpt_length=50&hide_mods=0"></script></div>
		</li>
<li id="text-22" class="widget widget_text">			<div class="textwidget"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LinkAd -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:90px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="2606115235"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LinkAd -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:90px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="2606115235"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LinkAd -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:90px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="2606115235"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
		</li>

</ul>					  
		<div class="clear"></div>

		<div id="footer">
		
		    <div class="xhtml">
                        @geeksforgeeks, <a href="http://creativecommons.org/licenses/by-nc-nd/2.5/in/deed.en_US" title="Valid XHTML Strict 1.0">Some rights reserved</a>  <a href="http://www.geeksforgeeks.org/about/contact-us/"> &nbsp; &nbsp; &nbsp; &nbsp;Contact Us!</a>

		    </div>
		    
		    <div class="credits">
			  Powered by <a href="http://wordpress.org">WordPress </a> &amp; <a href="http://mootools.net/" title="Mootools JavaScript Framework">MooTools</a>, customized by geeksforgeeks team </div>
			  
		   <div class="clear"></div>						                            
		   
		</div> <!--end footer-->  
        
		        <script type="text/javascript">
        // <![CDATA[
        var disqus_shortname = 'geeksforgeeks';
        (function () {
            var nodes = document.getElementsByTagName('span');
            for (var i = 0, url; i < nodes.length; i++) {
                if (nodes[i].className.indexOf('dsq-postid') != -1) {
                    nodes[i].parentNode.setAttribute('data-disqus-identifier', nodes[i].getAttribute('rel'));
                    url = nodes[i].parentNode.href.split('#', 1);
                    if (url.length == 1) { url = url[0]; }
                    else { url = url[1]; }
                    nodes[i].parentNode.href = url + '#disqus_thread';
                }
            }
            var s = document.createElement('script'); 
            s.async = true;
            s.type = 'text/javascript';
            s.src = '//' + disqus_shortname + '.disqus.com/count.js';
            (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
        }());
        // ]]>
        </script>
        <script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/scripts/shCore.js?ver=3.0.9'></script>
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/scripts/shBrushCpp.js?ver=3.0.9'></script>
<script type='text/javascript'>
	(function(){
		var corecss = document.createElement('link');
		var themecss = document.createElement('link');
		var corecssurl = "http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/styles/shCore.css?ver=3.0.9";
		if ( corecss.setAttribute ) {
				corecss.setAttribute( "rel", "stylesheet" );
				corecss.setAttribute( "type", "text/css" );
				corecss.setAttribute( "href", corecssurl );
		} else {
				corecss.rel = "stylesheet";
				corecss.href = corecssurl;
		}
		document.getElementsByTagName("head")[0].insertBefore( corecss, document.getElementById("syntaxhighlighteranchor") );
		var themecssurl = "http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/styles/shThemeDefault.css?ver=3.0.9";
		if ( themecss.setAttribute ) {
				themecss.setAttribute( "rel", "stylesheet" );
				themecss.setAttribute( "type", "text/css" );
				themecss.setAttribute( "href", themecssurl );
		} else {
				themecss.rel = "stylesheet";
				themecss.href = themecssurl;
		}
		//document.getElementById("syntaxhighlighteranchor").appendChild(themecss);
		document.getElementsByTagName("head")[0].insertBefore( themecss, document.getElementById("syntaxhighlighteranchor") );
	})();
	SyntaxHighlighter.config.strings.expandSource = '+ expand source';
	SyntaxHighlighter.config.strings.help = '?';
	SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
	SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
	SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
	SyntaxHighlighter.defaults['gutter'] = false;
	SyntaxHighlighter.defaults['pad-line-numbers'] = true;
	SyntaxHighlighter.defaults['toolbar'] = false;
	SyntaxHighlighter.all();
</script>
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/bbpress/templates/default/js/editor.js?ver=2.5.4-5380'></script>
				  
		</div> <!--end wrapper-->
        <div id="ajaxSpinner"></div> <!--For AJAX spinner holder-->
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-12148232-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
	</body>

</html>
<!-- Dynamic page generated in 0.262 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2014-11-27 23:27:19 -->

<!-- Compression = gzip -->
<!-- super cache -->