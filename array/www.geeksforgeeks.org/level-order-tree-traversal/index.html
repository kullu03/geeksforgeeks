<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
       <title>Level Order Tree Traversal - GeeksforGeeks</title>
       <style type="text/css" media="screen">
          @import url('http://d2o58evtke57tz.cloudfront.net/wp-content/themes/minimoo/style.css');
    </style>
      <link href="http://d2o58evtke57tz.cloudfront.net/wp-content/themes/minimoo/favicon.ico" rel="shortcut icon" />    
    
<!-- This site is optimized with the Yoast WordPress SEO plugin v1.7.1 - https://yoast.com/wordpress/plugins/seo/ -->
<link rel="canonical" href="http://www.geeksforgeeks.org/level-order-tree-traversal/" />
<meta property="og:locale" content="en_US" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Level Order Tree Traversal - GeeksforGeeks" />
<meta property="og:description" content="Level order traversal of a tree is breadth first traversal for the tree. Level order traversal of the above tree is 1 2 3 4 5 METHOD 1 (Use function to print a given level) Algorithm: There are basically two functions in this method. One is to print all nodes at a given level (printGivenLevel), &hellip;" />
<meta property="og:url" content="http://www.geeksforgeeks.org/level-order-tree-traversal/" />
<meta property="og:site_name" content="GeeksforGeeks" />
<meta property="article:section" content="Trees" />
<meta property="article:published_time" content="2009-11-07T03:10:39+00:00" />
<meta property="article:modified_time" content="2011-12-04T01:10:39+00:00" />
<meta property="og:updated_time" content="2011-12-04T01:10:39+00:00" />
<meta property="og:image" content="http://geeksforgeeks.org/wp-content/uploads/2009/06/tree122.gif" />
<!-- / Yoast WordPress SEO plugin. -->

<link rel='stylesheet' id='wp-quicklatex-format-css'  href='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/wp-quicklatex/css/quicklatex-format.css?ver=4.0.1' type='text/css' media='all' />
<link rel='stylesheet' id='bbp-default-css'  href='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/bbpress/templates/default/css/bbpress.css?ver=2.5.4-5380' type='text/css' media='screen' />
<link rel='stylesheet' id='wp-pagenavi-css'  href='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/wp-pagenavi/pagenavi-css.css?ver=2.70' type='text/css' media='all' />
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-includes/js/jquery/jquery.js?ver=1.11.1'></script>
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-includes/js/jquery/jquery-migrate.min.js?ver=1.2.1'></script>
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/wp-quicklatex/js/wp-quicklatex-frontend.js?ver=1.0'></script>

<!-- Bad Behavior 2.2.16 run time: 1.581 ms -->
<script type="text/javascript">
<!--
function bb2_addLoadEvent(func) {
	var oldonload = window.onload;
	if (typeof window.onload != 'function') {
		window.onload = func;
	} else {
		window.onload = function() {
			oldonload();
			func();
		}
	}
}

bb2_addLoadEvent(function() {
	for ( i=0; i < document.forms.length; i++ ) {
		if (document.forms[i].method == 'post') {
			var myElement = document.createElement('input');
			myElement.setAttribute('type', 'hidden');
			myElement.name = 'bb2_screener_';
			myElement.value = '1417110986 125.19.211.6';
			document.forms[i].appendChild(myElement);
		}
	}
});
// --></script>
		<style type="text/css" id="syntaxhighlighteranchor"></style>
   <meta name="google-site-verification" content="rHK2v8_zzuAZQY8JHAzbllDN8u-aQxcn2Kqnp67Old0" />
</head>

<body>
<!-- o4dI0sCXUgoSONabbd8mbZ4SA3E -->    
    <div id="wrapper">
        <div class="blog-info">
                <h1 class="blog-title">
                <a href="http://www.geeksforgeeks.org" title="GeeksforGeeks">GeeksforGeeks</a>
            </h1>
       
            <div class="blog-description">
                A computer science portal for geeks            </div>
        </div>
        <b><p>  <h2 align="right"> <a href="http://geeksquiz.com/">GeeksQuiz</a></h2> 
   <a href="http://www.geeksforgeeks.org/wp-login.php">Login</a> 
         </p></b>  
         
         <div class="clear"></div>         
              
                     
            <div id="menu">   
                 <ul>
 <li><a href="http://www.geeksforgeeks.org">Home</a></li>
  <li><a href="http://www.geeksforgeeks.org/fundamentals-of-algorithms/">Algorithms</a></li>
 <li><a href="http://www.geeksforgeeks.org/data-structures/">DS</a></li>
  <li><a href="http://www.geeksforgeeks.org/gate-corner/">GATE</a></li>
  <li><a href="http://www.geeksforgeeks.org/about/interview-corner/">Interview Corner</a></li>
  <li><a href="http://www.geeksforgeeks.org/forums/">Q&A</a></li>
  <li><a href="http://www.geeksforgeeks.org/c/">C</a></li>
  <li><a href="http://www.geeksforgeeks.org/c-plus-plus/">C++</a></li>
  <li><a href="http://www.geeksforgeeks.org/java/">Java</a></li>
  <li><a href="http://www.geeksforgeeks.org/books/">Books</a></li>
  <li><a href="http://www.geeksforgeeks.org/contribute/">Contribute</a></li>
  <li><a href="http://www.geeksforgeeks.org/contribute/ask-a-question/">Ask a Q</a></li>
  <li><a href="http://www.geeksforgeeks.org/about/">About</a></li>
            </ul>

               
            <div class="clear"></div>     
        </div>
             <div id="navmenu">
				<ul id="menu" style="padding:0; margin:0;">
						<li class="cat-item cat-item-3"><a href="http://www.geeksforgeeks.org/category/c-arrays/" title="Questions regarding Arrays">Array</a>
</li>	

	<li class="cat-item cat-item-17"><a href="http://www.geeksforgeeks.org/category/bit-magic/" title="View all posts filed under Bit Magic">Bit Magic</a>
</li>
	<li class="cat-item cat-item-14"><a href="http://www.geeksforgeeks.org/category/c-puzzles/" title="View all posts filed under C/C++ Puzzles">C/C++</a>
</li>

<li class="cat-item cat-item-18"><a href="http://www.geeksforgeeks.org/category/articles/" title="View all posts filed under Articles">Articles</a>
</li>

	<li class="cat-item cat-item-67"><a href="http://www.geeksforgeeks.org/category/gfact/" title="View all posts filed under GFacts">GFacts</a>
</li>
	<li class="cat-item cat-item-8"><a href="http://www.geeksforgeeks.org/category/linked-list/" title="Linked List problems">Linked List</a>
</li>
	<li class="cat-item cat-item-66"><a href="http://www.geeksforgeeks.org/category/multiple-choice-question/" title="View all posts filed under MCQ">MCQ</a>

</li>
	<li class="cat-item cat-item-4"><a href="http://www.geeksforgeeks.org/category/c-programs/" title="Miscellaneous">Misc</a>
</li>
	<li class="cat-item cat-item-5"><a href="http://www.geeksforgeeks.org/category/program-output/" title="View all posts filed under Output">Output</a>
</li>
	<li class="cat-item cat-item-7"><a href="http://www.geeksforgeeks.org/category/c-strings/" title="Questions related to strings">String</a>
</li>
	<li class="cat-item cat-item-19"><a href="http://www.geeksforgeeks.org/category/tree/" title="View all posts filed under Trees">Tree</a>
</li>
	<li class="cat-item cat-item-19"><a href="http://www.geeksforgeeks.org/category/graph/" title="View all posts filed under Graph">Graph</a>
</li>
</ul>
        </div>
             <div id="content">	   	
	<div class="post" id="post">
							<div class="post-info">			
					<div class="post-title-info">
						<h2 class="post-title">Level Order Tree Traversal</h2>
					</div>			
					<div class="clear"></div>				  
				<div class="post-content" id="post-content">
					<p>Level order traversal of a tree is <a href="http://en.wikipedia.org/wiki/Breadth-first_traversal">breadth first traversal f</a>or the tree.<span id="more-2686"></span> </p>
<div id="attachment_650" style="width: 269px" class="wp-caption aligncenter"><img src="http://geeksforgeeks.org/wp-content/uploads/2009/06/tree122.gif" alt="Example Tree" title="tree12" width="259" height="156" class="size-full wp-image-650" /><p class="wp-caption-text">Example Tree</p></div>
<p>Level order traversal of the above tree is 1 2 3 4 5 </p>
<p><strong>METHOD 1 (Use function to print a given level)</strong></p>
<p><strong>Algorithm:</strong><br />
There are basically two functions in this method.  One is to print all nodes at a given level (printGivenLevel), and other is to print level order traversal of the tree (printLevelorder). printLevelorder makes use of printGivenLevel to print nodes at all levels one by one starting from root.</p>
<pre>/*Function to print level order traversal of tree*/
<strong>printLevelorder(tree)</strong>
for d = 1 to height(tree)
   printGivenLevel(tree, d);

/*Function to print all nodes at a given level*/
<strong>printGivenLevel(tree, level)</strong>
if tree is NULL then return;
if level is 1, then
    print(tree->data);
else if level greater than 1, then
    printGivenLevel(tree->left, level-1);
    printGivenLevel(tree->right, level-1);
</pre>
<p><strong>Implementation:</strong></p>
<pre class="brush: cpp; title: ; notranslate" title="">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

/* A binary tree node has data, pointer to left child
   and a pointer to right child */
struct node
{
    int data;
    struct node* left;
    struct node* right;
};

/*Function protoypes*/
void printGivenLevel(struct node* root, int level);
int height(struct node* node);
struct node* newNode(int data);

/* Function to print level order traversal a tree*/
void printLevelOrder(struct node* root)
{
  int h = height(root);
  int i;
  for(i=1; i&lt;=h; i++)
    printGivenLevel(root, i);
}     

/* Print nodes at a given level */
void printGivenLevel(struct node* root, int level)
{
  if(root == NULL)
    return;
  if(level == 1)
    printf(&quot;%d &quot;, root-&gt;data);
  else if (level &gt; 1)
  {
    printGivenLevel(root-&gt;left, level-1);
    printGivenLevel(root-&gt;right, level-1);
  }
}

/* Compute the &quot;height&quot; of a tree -- the number of
    nodes along the longest path from the root node
    down to the farthest leaf node.*/
int height(struct node* node)
{
   if (node==NULL)
       return 0;
   else
   {
     /* compute the height of each subtree */
     int lheight = height(node-&gt;left);
     int rheight = height(node-&gt;right);

     /* use the larger one */
     if (lheight &gt; rheight)
         return(lheight+1);
     else return(rheight+1);
   }
} 

/* Helper function that allocates a new node with the
   given data and NULL left and right pointers. */
struct node* newNode(int data)
{
  struct node* node = (struct node*)
                       malloc(sizeof(struct node));
  node-&gt;data = data;
  node-&gt;left = NULL;
  node-&gt;right = NULL;

  return(node);
}

/* Driver program to test above functions*/
int main()
{
  struct node *root = newNode(1);
  root-&gt;left        = newNode(2);
  root-&gt;right       = newNode(3);
  root-&gt;left-&gt;left  = newNode(4);
  root-&gt;left-&gt;right = newNode(5); 

  printf(&quot;Level Order traversal of binary tree is \n&quot;);
  printLevelOrder(root);

  getchar();
  return 0;
}
</pre>
<p>Time Complexity: O(n^2) in worst case.  For a skewed tree, printGivenLevel() takes O(n) time where n is the number of nodes in the skewed tree. So time complexity of printLevelOrder() is O(n) + O(n-1) + O(n-2) + .. + O(1) which is O(n^2).</p>
<p></br><br />
<br /></br><br />
<strong>METHOD 2 (Use Queue)</strong></p>
<p><strong>Algorithm:</strong><br />
For each node, first the node is visited and then it&#8217;s child nodes are put in a FIFO queue.</p>
<pre>printLevelorder(tree)
1) Create an empty queue q
2) temp_node = root /*start from root*/
3) Loop while temp_node is not NULL
    a) print temp_node->data.
    b) Enqueue temp_node’s children (first left then right children) to q
    c) Dequeue a node from q and assign it’s value to temp_node
</pre>
<p><strong>Implementation:</strong><br />
Here is a simple implementation of the above algorithm. Queue is implemented using an array with maximum size of 500. We can implement queue as linked list also.</p>
<pre class="brush: cpp; title: ; notranslate" title="">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#define MAX_Q_SIZE 500

/* A binary tree node has data, pointer to left child
   and a pointer to right child */
struct node
{
    int data;
    struct node* left;
    struct node* right;
};

/* frunction prototypes */
struct node** createQueue(int *, int *);
void enQueue(struct node **, int *, struct node *);
struct node *deQueue(struct node **, int *);

/* Given a binary tree, print its nodes in level order
   using array for implementing queue */
void printLevelOrder(struct node* root)
{
  int rear, front;
  struct node **queue = createQueue(&amp;front, &amp;rear);  
  struct node *temp_node = root; 

  while(temp_node)
  {
    printf(&quot;%d &quot;, temp_node-&gt;data);

    /*Enqueue left child */
    if(temp_node-&gt;left)
      enQueue(queue, &amp;rear, temp_node-&gt;left);

    /*Enqueue right child */
    if(temp_node-&gt;right)
      enQueue(queue, &amp;rear, temp_node-&gt;right);

    /*Dequeue node and make it temp_node*/
    temp_node = deQueue(queue, &amp;front);
  }
}

/*UTILITY FUNCTIONS*/
struct node** createQueue(int *front, int *rear)
{
  struct node **queue =
   (struct node **)malloc(sizeof(struct node*)*MAX_Q_SIZE);  

  *front = *rear = 0;
  return queue;
} 

void enQueue(struct node **queue, int *rear, struct node *new_node)
{
  queue[*rear] = new_node;
  (*rear)++;
}     

struct node *deQueue(struct node **queue, int *front)
{
  (*front)++;
  return queue[*front - 1];
}     

/* Helper function that allocates a new node with the
   given data and NULL left and right pointers. */
struct node* newNode(int data)
{
  struct node* node = (struct node*)
                       malloc(sizeof(struct node));
  node-&gt;data = data;
  node-&gt;left = NULL;
  node-&gt;right = NULL;

  return(node);
}

/* Driver program to test above functions*/
int main()
{
  struct node *root = newNode(1);
  root-&gt;left        = newNode(2);
  root-&gt;right       = newNode(3);
  root-&gt;left-&gt;left  = newNode(4);
  root-&gt;left-&gt;right = newNode(5); 

  printf(&quot;Level Order traversal of binary tree is \n&quot;);
  printLevelOrder(root);

  getchar();
  return 0;
}
</pre>
<p><strong>Time Complexity:</strong> O(n) where n is number of nodes in the binary tree</p>
<p><strong>References:</strong><br />
<a href="http://en.wikipedia.org/wiki/Breadth-first_traversal">http://en.wikipedia.org/wiki/Breadth-first_traversal</a></p>
<p>Please write comments if you find any bug in the above programs/algorithms or other ways to solve the same problem. </p>
		
&nbsp;
&nbsp;
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle"
     style="display:inline-block;width:336px;height:280px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="4061219431"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>



&nbsp;
&nbsp;
&nbsp;
<h3>Related Topics:</h3><ul><li><a href="http://www.geeksforgeeks.org/perfect-binary-tree-specific-level-order-traversal/" title="Perfect Binary Tree Specific Level Order Traversal">Perfect Binary Tree Specific Level Order Traversal</a></li><li><a href="http://www.geeksforgeeks.org/print-nodes-top-view-binary-tree/" title="Print Nodes in Top View of Binary Tree">Print Nodes in Top View of Binary Tree</a></li><li><a href="http://www.geeksforgeeks.org/k-dimensional-tree/" title="K Dimensional Tree">K Dimensional Tree</a></li><li><a href="http://www.geeksforgeeks.org/convert-binary-tree-threaded-binary-tree/" title="Convert a Binary Tree to Threaded binary tree">Convert a Binary Tree to Threaded binary tree</a></li><li><a href="http://www.geeksforgeeks.org/serialize-deserialize-n-ary-tree/" title="Serialize and Deserialize an N-ary Tree">Serialize and Deserialize an N-ary Tree</a></li><li><a href="http://www.geeksforgeeks.org/serialize-deserialize-binary-tree/" title="Serialize and Deserialize a Binary Tree">Serialize and Deserialize a Binary Tree</a></li><li><a href="http://www.geeksforgeeks.org/given-binary-tree-print-nodes-two-given-level-numbers/" title="Print nodes between two given level numbers of a binary tree">Print nodes between two given level numbers of a binary tree</a></li><li><a href="http://www.geeksforgeeks.org/find-height-binary-tree-represented-parent-array/" title="Find Height of Binary Tree represented by Parent array">Find Height of Binary Tree represented by Parent array</a></li></ul>
<p></p> 
<div>
<iframe src="http://www.facebook.com/plugins/like.php?href=http%3A%2F%2Fwww.geeksforgeeks.org%2Flevel-order-tree-traversal%2F&layout=button_count&show_faces=false&width=90&action=like&colorscheme=light" scrolling="no" frameborder="0" allowTransparency="true" style="border:none; overflow:hidden; width:90px; height:20px"></iframe>
<a href="http://twitter.com/share" class="twitter-share-button" data-url="http://www.geeksforgeeks.org/level-order-tree-traversal/" data-text="Level Order Tree Traversal" data-count="horizontal" data-via="jakerutter">Tweet</a><script type="text/javascript" src="http://platform.twitter.com/widgets.js"></script>
<g:plusone size="medium" href="http://www.geeksforgeeks.org/level-order-tree-traversal/"></g:plusone>
<!-- Place this render call where appropriate -->
<script type="text/javascript">
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script></div>





				</div>		  
			</div> <!-- end post main -->					
			<div class="post-meta">
				<div class="left"></div>				
				<div class="clear"></div>
			</div>			
        
			<div class="comments-main">		
 <b>Writing code in comment?</b> Please use <b><a href="http://ideone.com/">ideone.com</a></b> and share the link here.
				
<div id="disqus_thread">
            <div id="dsq-content">


            <ul id="dsq-comments">
                    <li class="comment even thread-even depth-1" id="dsq-comment-34746">
        <div id="dsq-comment-header-34746" class="dsq-comment-header">
            <cite id="dsq-cite-34746">
                <span id="dsq-author-user-34746">yewD</span>
            </cite>
        </div>
        <div id="dsq-comment-body-34746" class="dsq-comment-body">
            <div id="dsq-comment-message-34746" class="dsq-comment-message"><p>queue.enQueue(root);<br />
queue.enQueue(null);<br />
while(!queue.isEmpty){<br />
temp = queue.deQueue();<br />
if(temp==null)<br />
            queue.deQueue();<br />
            break line;<br />
             queue.enQueue(null);<br />
}else {<br />
      print(temp.data);<br />
       if(temp.left!=null) queue.enQueue(temp.left);<br />
       if(temp.right!=null) queue.enQueue(temp.right);<br />
}</p>
<p>}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-34739">
        <div id="dsq-comment-header-34739" class="dsq-comment-header">
            <cite id="dsq-cite-34739">
                <span id="dsq-author-user-34739">Secord</span>
            </cite>
        </div>
        <div id="dsq-comment-body-34739" class="dsq-comment-body">
            <div id="dsq-comment-message-34739" class="dsq-comment-message"><p>Please I need the implementation of level order traversal into source please help me </p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>using namespace std;</p>
<p>class Node</p>
<p>{</p>
<p>public:</p>
<p>	int value;</p>
<p>	Node* left;</p>
<p>	Node* right;</p>
<p>	Node(int value, Node* left = NULL, Node* right = NULL)</p>
<p>	{</p>
<p>		this-&gt;left = left;</p>
<p>		this-&gt;right = right;</p>
<p>		this-&gt;value = value;</p>
<p>	}</p>
<p>	~Node();</p>
<p>private:</p>
<p>};</p>
<p>class Btree</p>
<p>{</p>
<p>public:</p>
<p>	Btree()</p>
<p>	{</p>
<p>		root = NULL;</p>
<p>	}</p>
<p>	void print_subtree(Node* x)</p>
<p>	{</p>
<p>		if (x != NULL)</p>
<p>		{</p>
<p>			print_subtree(x-&gt;left);</p>
<p>			cout &lt;value &lt;&lt; &quot; &quot; &lt;right);</p>
<p>		}</p>
<p>	}</p>
<p>	void print()</p>
<p>	{</p>
<p>		print_subtree(root);</p>
<p>	}</p>
<p>	void insert(int new_value)</p>
<p>	{</p>
<p>		if (root == NULL)</p>
<p>		{</p>
<p>			root = new Node(new_value);</p>
<p>		}</p>
<p>		else</p>
<p>		{</p>
<p>			insert_node(new_value,root);</p>
<p>		}</p>
<p>	}</p>
<p>	void insert_node(int new_value, Node* c)</p>
<p>	{</p>
<p>		if (c-&gt;value &gt; new_value)</p>
<p>		{</p>
<p>			if (c-&gt;left == NULL)</p>
<p>			{</p>
<p>				c-&gt;left = new Node(new_value);</p>
<p>				return;</p>
<p>			}</p>
<p>			else</p>
<p>			{</p>
<p>				insert_node(new_value, c-&gt;left);</p>
<p>			}</p>
<p>		}</p>
<p>		else</p>
<p>		{</p>
<p>			if (c-&gt;right == NULL)</p>
<p>			{</p>
<p>				c-&gt;right = new Node(new_value);</p>
<p>					return;</p>
<p>			}</p>
<p>			else</p>
<p>			{</p>
<p>				insert_node(new_value, c-&gt;right);</p>
<p>			}</p>
<p>		}</p>
<p>	}</p>
<p>	~Btree();</p>
<p>private:</p>
<p>	Node* root;</p>
<p>};</p>
<p>int main()</p>
<p>{</p>
<p>	Btree* v = new Btree();</p>
<p>	v-&gt;insert(10);</p>
<p>	v-&gt;insert(7);</p>
<p>	v-&gt;insert(15);</p>
<p>	v-&gt;insert(6);</p>
<p>	v-&gt;insert(17);</p>
<p>	v-&gt;insert(8);</p>
<p>	v-&gt;insert(16);</p>
<p>	v-&gt;insert(19);</p>
<p>	v-&gt;print();</p>
<p>	return 0;</p>
<p>}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-34322">
        <div id="dsq-comment-header-34322" class="dsq-comment-header">
            <cite id="dsq-cite-34322">
http://www.phoenixuser.blogspot.com                <span id="dsq-author-user-34322">GOPI GOPINATH</span>
            </cite>
        </div>
        <div id="dsq-comment-body-34322" class="dsq-comment-body">
            <div id="dsq-comment-message-34322" class="dsq-comment-message"><p>here is the implementation of level order traversal using linked list queue</p>
<p>#include<br />
#include<br />
#include<br />
struct Treenode<br />
{<br />
	int data;<br />
	struct Treenode * left;<br />
	struct Treenode *right;<br />
};<br />
struct Treenode* newnode(int data)<br />
{<br />
	struct Treenode* temp=(struct Treenode *)malloc(sizeof(struct Treenode));<br />
	temp-&gt;data=data;<br />
	temp-&gt;left=NULL;<br />
	temp-&gt;right=NULL;<br />
	return temp;<br />
}<br />
struct List<br />
{<br />
	struct Treenode* node;<br />
	struct List *next;<br />
};<br />
struct queue<br />
{<br />
 	struct List * front;<br />
	 struct List *rear;<br />
};<br />
struct queue* createqueue()<br />
{<br />
	struct queue* ptr= (struct queue *)malloc(sizeof(struct queue));<br />
	if(!ptr)return NULL;<br />
	ptr-&gt;front= NULL;<br />
	ptr-&gt;rear=NULL;<br />
	return ptr;<br />
}<br />
void enqueue(struct queue* q,struct Treenode *root )<br />
{<br />
	struct List *newnode=(struct List *)malloc(sizeof(struct List));<br />
	newnode-&gt;node=root;<br />
	newnode-&gt;next=NULL;<br />
	if(q-&gt;rear==NULL)<br />
	{<br />
			q-&gt;rear=newnode;<br />
	}<br />
	else<br />
	{<br />
		q-&gt;rear-&gt;next=newnode;<br />
		q-&gt;rear=newnode;<br />
	}<br />
	if(q-&gt;front==NULL)<br />
		q-&gt;front=q-&gt;rear;<br />
}<br />
int isempty(struct queue* q)<br />
{<br />
	return (q-&gt;front==NULL);<br />
}<br />
struct Treenode* dequeue(struct queue* q)<br />
{<br />
	struct Treenode* dq;<br />
	struct List *temp;<br />
	if(isempty(q))<br />
	{<br />
		printf(&#8220;No elements in queue&#8221;);<br />
		return NULL;<br />
	}<br />
	else<br />
	{<br />
		temp=q-&gt;front;<br />
		dq=q-&gt;front-&gt;node;<br />
		q-&gt;front=q-&gt;front-&gt;next;<br />
		free(temp);<br />
	}<br />
	return dq;<br />
}<br />
void levelordertraversal(struct Treenode *root)<br />
{<br />
	struct Treenode* temp;<br />
	struct queue* q=createqueue();<br />
	enqueue(q,root);<br />
	while(!isempty(q))<br />
	{<br />
		temp=dequeue(q);<br />
		printf(&#8221; %d-&gt;&#8221;,temp-&gt;data);<br />
		if(temp-&gt;left)<br />
		{<br />
			enqueue(q,temp-&gt;left);<br />
		}<br />
		if(temp-&gt;right)<br />
		{<br />
			enqueue(q,temp-&gt;right);<br />
		}<br />
	}<br />
}<br />
int main()<br />
{<br />
	struct Treenode* root=newnode(5);<br />
	root-&gt;left 			 =newnode(1);<br />
	root-&gt;right			 =newnode(7);<br />
	root-&gt;left-&gt;right	 =newnode(4);<br />
	root-&gt;left-&gt;left     =newnode(9);<br />
	root-&gt;right-&gt;left    =newnode(10);<br />
	root-&gt;right-&gt;right   =newnode(3);<br />
	levelordertraversal(root);<br />
	return 0;<br />
}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-33299">
        <div id="dsq-comment-header-33299" class="dsq-comment-header">
            <cite id="dsq-cite-33299">
                <span id="dsq-author-user-33299">Ankit</span>
            </cite>
        </div>
        <div id="dsq-comment-body-33299" class="dsq-comment-body">
            <div id="dsq-comment-message-33299" class="dsq-comment-message"><p>while(front&lt;=rear) should be used instead of  while(temp_node) because we are not putting any NULL values in temp_node variable and it will crash the programme.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-32583">
        <div id="dsq-comment-header-32583" class="dsq-comment-header">
            <cite id="dsq-cite-32583">
                <span id="dsq-author-user-32583">Guest</span>
            </cite>
        </div>
        <div id="dsq-comment-body-32583" class="dsq-comment-body">
            <div id="dsq-comment-message-32583" class="dsq-comment-message"><p>deleted.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-32242">
        <div id="dsq-comment-header-32242" class="dsq-comment-header">
            <cite id="dsq-cite-32242">
                <span id="dsq-author-user-32242">Srikanth K S</span>
            </cite>
        </div>
        <div id="dsq-comment-body-32242" class="dsq-comment-body">
            <div id="dsq-comment-message-32242" class="dsq-comment-message"><p>Let us say I have implemented the queue using a Linked List. Then I don&#8217;t need to de-queue the element every time I want to print it right?. I can simply traverse through the the queue from head to tail. Am I right? Please correct me if I am wrong.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-2" id="dsq-comment-33066">
        <div id="dsq-comment-header-33066" class="dsq-comment-header">
            <cite id="dsq-cite-33066">
                <span id="dsq-author-user-33066">Anish Thomas</span>
            </cite>
        </div>
        <div id="dsq-comment-body-33066" class="dsq-comment-body">
            <div id="dsq-comment-message-33066" class="dsq-comment-message"><p>The queue is being used as a temporary data structure..Once done with printing/processing, we need not store the data in it..This helps to store only the number of elements at a particular level in the queue instead of all the elements.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-31866">
        <div id="dsq-comment-header-31866" class="dsq-comment-header">
            <cite id="dsq-cite-31866">
                <span id="dsq-author-user-31866">Guest</span>
            </cite>
        </div>
        <div id="dsq-comment-body-31866" class="dsq-comment-body">
            <div id="dsq-comment-message-31866" class="dsq-comment-message"><p>Getting segmentation fault in second method, even after adding (*front==*rear) check condition. Is any correction required or it worked for anyone??</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-2" id="dsq-comment-32122">
        <div id="dsq-comment-header-32122" class="dsq-comment-header">
            <cite id="dsq-cite-32122">
                <span id="dsq-author-user-32122">Pushkar</span>
            </cite>
        </div>
        <div id="dsq-comment-body-32122" class="dsq-comment-body">
            <div id="dsq-comment-message-32122" class="dsq-comment-message"><p>if((front)!=(rear))<br />
temp_node = deQueue(queue, &amp;front);<br />
else<br />
break;<br />
use this in printLevelOrder() function.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt depth-2" id="dsq-comment-33300">
        <div id="dsq-comment-header-33300" class="dsq-comment-header">
            <cite id="dsq-cite-33300">
                <span id="dsq-author-user-33300">Ankit</span>
            </cite>
        </div>
        <div id="dsq-comment-body-33300" class="dsq-comment-body">
            <div id="dsq-comment-message-33300" class="dsq-comment-message"><p>while(front&lt;=rear) should be used instead of while(temp_node) in second method</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-30691">
        <div id="dsq-comment-header-30691" class="dsq-comment-header">
            <cite id="dsq-cite-30691">
                <span id="dsq-author-user-30691">Veracity123</span>
            </cite>
        </div>
        <div id="dsq-comment-body-30691" class="dsq-comment-body">
            <div id="dsq-comment-message-30691" class="dsq-comment-message"><p><code><br />
// BinaryTree.cpp : Defines the entry point for the console application.<br />
#include "stdafx.h"<br />
#include<br />
using namespace std;<br />
struct Node<br />
{<br />
	Node *  left;<br />
	int data;<br />
	int HD;<br />
	Node * right;<br />
};<br />
struct QNode<br />
{<br />
	QNode *next;<br />
	Node *qdata;<br />
};<br />
class Queue<br />
{<br />
public:<br />
	QNode *front;<br />
	QNode *rear;<br />
        Queue()<br />
	{<br />
		front = NULL;<br />
		rear = NULL;<br />
	}<br />
	void Enqueue(Node *node)<br />
	{<br />
		if (rear == NULL)<br />
		{<br />
			rear = new QNode;<br />
			rear-&gt;qdata = node;<br />
			rear-&gt;next = NULL;<br />
			front = rear;<br />
		}<br />
		else<br />
	       {<br />
			// set front correctly<br />
			rear-&gt;next = new QNode;<br />
		        rear-&gt;next-&gt;qdata = node;<br />
			rear-&gt;next-&gt;next = NULL;<br />
			rear = rear-&gt;next; // set the new rear;<br />
		}<br />
	}<br />
	Node* Dequeue()<br />
	{<br />
		QNode *temp;<br />
		Node *node;<br />
		if (front)<br />
		{<br />
			temp = front;<br />
			node = temp-&gt;qdata;<br />
			front = front-&gt;next;<br />
			if (front == NULL)<br />
				rear = NULL;<br />
			delete temp;<br />
			return node;<br />
		}<br />
		else<br />
		{<br />
			return NULL;<br />
		}<br />
	}<br />
	bool IsEmpty()<br />
	{<br />
		if (front == NULL)<br />
			return true;<br />
		return false;<br />
	}<br />
};</p>
<p>class Tree<br />
{<br />
public:<br />
	Node *root;<br />
	bool r;<br />
	bool l;<br />
	Tree()<br />
	{<br />
		r = false;<br />
		l = false;<br />
	}<br />
	void Inorder(Node *node)<br />
	{<br />
		if (node)<br />
		{<br />
			Inorder(node-&gt;left);<br />
			cout &lt;&lt; &quot;[&quot; &lt;data &lt;right);<br />
		}<br />
	}<br />
	void LevelOrder()<br />
	{<br />
		Queue q;<br />
		if (root)<br />
		{<br />
			q.Enqueue(root);<br />
		}<br />
		while (1)<br />
		{<br />
			if (!q.IsEmpty())<br />
			{<br />
				// dequeue node and print it, enqueue its children<br />
				Node *  node = q.Dequeue();<br />
			cout &lt;&lt; &quot;[&quot; &lt;data &lt;left)<br />
         				q.Enqueue(node-&gt;left);<br />
	        		if (node-&gt;right)<br />
					q.Enqueue(node-&gt;right);<br />
			}<br />
			else<br />
				return;<br />
		}<br />
	}<br />
	void InsertNode(int data)// pass head node here<br />
	{<br />
		Node * node = root;<br />
		r = false;<br />
		l = false;<br />
		if (!root)<br />
		{<br />
			node = new Node;<br />
			node-&gt;data = data;<br />
			node-&gt;left = NULL;<br />
			node-&gt;right = NULL;<br />
			root = node;<br />
			return;<br />
		}<br />
		else<br />
		{<br />
			Node * parent;<br />
			while (1)<br />
			{<br />
				if (data data) // go left<br />
				{<br />
					parent = node;<br />
					node = node-&gt;left;<br />
					r = false;;<br />
					l = true;<br />
				}<br />
				else<br />
				{<br />
					parent = node;<br />
					node = node-&gt;right;<br />
					r = true;<br />
					l = false;<br />
				}<br />
				if (node == NULL)<br />
				{<br />
					if (r)<br />
					{<br />
						parent-&gt;right = new Node;<br />
						parent-&gt;right-&gt;data = data;<br />
						parent-&gt;right-&gt;left = NULL;<br />
						parent-&gt;right-&gt;right = NULL;<br />
						return;<br />
					}<br />
					if (l)<br />
					{<br />
						parent-&gt;left = new Node;<br />
						parent-&gt;left-&gt;data = data;<br />
						parent-&gt;left-&gt;left = NULL;<br />
						parent-&gt;left-&gt;right = NULL;<br />
						return;<br />
					}<br />
				}<br />
			}<br />
		}<br />
	}<br />
};<br />
int _tmain(int argc, _TCHAR* argv[])<br />
{<br />
	Tree t;<br />
	t.InsertNode(6);<br />
	t.InsertNode(4);<br />
	t.InsertNode(5);<br />
	t.InsertNode(2);<br />
	t.InsertNode(3);<br />
	t.InsertNode(1);<br />
	t.InsertNode(0);<br />
	t.InsertNode(9);<br />
	t.InsertNode(8);<br />
	t.InsertNode(7);<br />
	t.InsertNode(15);<br />
	t.InsertNode(14);<br />
	t.InsertNode(13);<br />
	t.InsertNode(12);<br />
	t.LevelOrder();<br />
	return 0;<br />
}<br />
</code></p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-29060">
        <div id="dsq-comment-header-29060" class="dsq-comment-header">
            <cite id="dsq-cite-29060">
                <span id="dsq-author-user-29060">anonymous</span>
            </cite>
        </div>
        <div id="dsq-comment-body-29060" class="dsq-comment-body">
            <div id="dsq-comment-message-29060" class="dsq-comment-message"><p>temp=root;<br />
while(temp)<br />
{<br />
     printf: temp-&gt;data;<br />
     if(temp-&gt;left)<br />
        enque(temp-&gt;left);<br />
     if(temp-&gt;right)<br />
       enque(temp-&gt;right);<br />
    temp=deque();</p>
<p>}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-28296">
        <div id="dsq-comment-header-28296" class="dsq-comment-header">
            <cite id="dsq-cite-28296">
                <span id="dsq-author-user-28296">gaurav</span>
            </cite>
        </div>
        <div id="dsq-comment-body-28296" class="dsq-comment-body">
            <div id="dsq-comment-message-28296" class="dsq-comment-message"><p>I used queue as linked list for above problem. For linking different nodes in queue,  I had to modify tree node and use an extra field &#8220;link&#8221;. Is there some way to do so without the need to modify tree node?  Thanks. </p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-27745">
        <div id="dsq-comment-header-27745" class="dsq-comment-header">
            <cite id="dsq-cite-27745">
                <span id="dsq-author-user-27745">iamcoded</span>
            </cite>
        </div>
        <div id="dsq-comment-body-27745" class="dsq-comment-body">
            <div id="dsq-comment-message-27745" class="dsq-comment-message"><p>i cant understand how the worst case time complexity is o(n^2)</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-2" id="dsq-comment-34778">
        <div id="dsq-comment-header-34778" class="dsq-comment-header">
            <cite id="dsq-cite-34778">
                <span id="dsq-author-user-34778">vaibhav</span>
            </cite>
        </div>
        <div id="dsq-comment-body-34778" class="dsq-comment-body">
            <div id="dsq-comment-message-34778" class="dsq-comment-message"><p>see in right skewed tree every time a node is seen at new level , all the previous level nodes are visited b4 getting to it&#8230;.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-27601">
        <div id="dsq-comment-header-27601" class="dsq-comment-header">
            <cite id="dsq-cite-27601">
                <span id="dsq-author-user-27601">vaibhav</span>
            </cite>
        </div>
        <div id="dsq-comment-body-27601" class="dsq-comment-body">
            <div id="dsq-comment-message-27601" class="dsq-comment-message"><p>y do we use double pointer for creating a queue??</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-2" id="dsq-comment-31868">
        <div id="dsq-comment-header-31868" class="dsq-comment-header">
            <cite id="dsq-cite-31868">
                <span id="dsq-author-user-31868">Meenal</span>
            </cite>
        </div>
        <div id="dsq-comment-body-31868" class="dsq-comment-body">
            <div id="dsq-comment-message-31868" class="dsq-comment-message"><p>In struct node** queue, first pointer i.e struct node* denotes type of elements of queue, that are tree nodes of type struct node*, second * is just for passing reference to queue.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-26325">
        <div id="dsq-comment-header-26325" class="dsq-comment-header">
            <cite id="dsq-cite-26325">
                <span id="dsq-author-user-26325">Amar</span>
            </cite>
        </div>
        <div id="dsq-comment-body-26325" class="dsq-comment-body">
            <div id="dsq-comment-message-26325" class="dsq-comment-message"><pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
<p>In the solution for traversal using queue the function deQueue  should be as below else a crash may/will happen when trying to dequeue malloc&#8217;d array beyond valid data within queue.(may be garbage/null)</p>
<p>Preferably memory should be calloc&#8217;d for queue and check as below should be given in deQueue </p>
<p>struct node *deQueue(struct node **queue, int *front)<br />
{<br />
	(*front)++;<br />
	if(queue[*front &#8211; 1]==NULL)<br />
		return NULL;<br />
	else<br />
	return queue[*front &#8211; 1];<br />
}</p>
</div>
        </div>

    </li><!-- #comment-## -->
</li><!-- #comment-## -->
    <li class="comment byuser comment-author-vinodhinic even thread-odd thread-alt depth-1" id="dsq-comment-24925">
        <div id="dsq-comment-header-24925" class="dsq-comment-header">
            <cite id="dsq-cite-24925">
                <span id="dsq-author-user-24925">vinodhinic</span>
            </cite>
        </div>
        <div id="dsq-comment-body-24925" class="dsq-comment-body">
            <div id="dsq-comment-message-24925" class="dsq-comment-message"><p>Shouldn&#8217;t the following function() have </p>
<pre> <code language="C">
if(*front==*rear) 
return NULL;
</code> </pre>
<p>condition??</p>
<pre> <code language="C">
struct node *deQueue(struct node **queue, int *front)
{
  (*front)++;
  return queue[*front - 1];
}
</code> </pre>
<p>If it is not necessary please explain.<br />
P.S: As far as I know, malloc doesn&#8217;t initialize the memory allocated only calloc does.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-23068">
        <div id="dsq-comment-header-23068" class="dsq-comment-header">
            <cite id="dsq-cite-23068">
                <span id="dsq-author-user-23068">Anirudh Singh</span>
            </cite>
        </div>
        <div id="dsq-comment-body-23068" class="dsq-comment-body">
            <div id="dsq-comment-message-23068" class="dsq-comment-message"><p>using namespace std;<br />
#include<br />
#include<br />
#include<br />
#include<br />
/* A binary tree node has data, pointer to left child<br />
   and a pointer to right child */<br />
struct Node<br />
{<br />
    int data;<br />
    struct Node* left;<br />
    struct Node* right;<br />
};</p>
<p>void levelorder(struct Node* n)<br />
{    queue q;</p>
<p>     q.push(n);</p>
<p>     while(!q.empty())<br />
     {<br />
             Node *node = q.front();<br />
             cout&lt;data;<br />
             q.pop();<br />
             if(node-&gt;left != NULL)<br />
             q.push(node-&gt;left);<br />
             if (node-&gt;right != NULL)<br />
             q.push(node-&gt;right);</p>
<p>     }</p>
<p>}</p>
<p>struct Node* newNode(int data)<br />
{<br />
  struct Node* n = (struct Node*)<br />
                       malloc(sizeof(struct Node));<br />
  n-&gt;data = data;<br />
  n-&gt;left = NULL;<br />
  n-&gt;right = NULL;</p>
<p>  return(n);<br />
}</p>
<p>int main()<br />
{<br />
  struct Node *n = newNode(1);<br />
  n-&gt;left        = newNode(2);<br />
  n-&gt;right       = newNode(3);<br />
  n-&gt;left-&gt;left  = newNode(4);<br />
  n-&gt;left-&gt;right = newNode(5); </p>
<p> levelorder(n);<br />
 return 0;</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-jaskaran1 even thread-odd thread-alt depth-1" id="dsq-comment-20480">
        <div id="dsq-comment-header-20480" class="dsq-comment-header">
            <cite id="dsq-cite-20480">
                <span id="dsq-author-user-20480">jaskaran1</span>
            </cite>
        </div>
        <div id="dsq-comment-body-20480" class="dsq-comment-body">
            <div id="dsq-comment-message-20480" class="dsq-comment-message"><p>Time complexity will be O(n) in case of complete and O(n^2) in case of skew.</p>
<p>Let us say time complexity of printlevel is T(k).Then,T(k)=2*T(k-1)+c[The case when the tree is complete]<br />
Thus,T(k)=2^(k-1).<br />
Summing this over all levels:<br />
We get T=2^h-1 where h is the height.In case of balanced tree h=logN .<br />
So in the best case it is O(N).</p>
<p>When tree is skew T(k)=T(k-1)+c<br />
T(k)=O(k)<br />
Since there are n levels as n are the nodes.So 1+2+&#8230;n=n(n+1)/2 which is O(n^2)</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-abhishek08aug odd alt thread-even depth-1" id="dsq-comment-18053">
        <div id="dsq-comment-header-18053" class="dsq-comment-header">
            <cite id="dsq-cite-18053">
                <span id="dsq-author-user-18053">abhishek08aug</span>
            </cite>
        </div>
        <div id="dsq-comment-body-18053" class="dsq-comment-body">
            <div id="dsq-comment-message-18053" class="dsq-comment-message"><p>Intelligent <img src="http://d2o58evtke57tz.cloudfront.net/wp-includes/images/smilies/icon_biggrin.gif" alt=":D" class="wp-smiley" /></p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-17109">
        <div id="dsq-comment-header-17109" class="dsq-comment-header">
            <cite id="dsq-cite-17109">
                <span id="dsq-author-user-17109">Navneet Jain</span>
            </cite>
        </div>
        <div id="dsq-comment-body-17109" class="dsq-comment-body">
            <div id="dsq-comment-message-17109" class="dsq-comment-message"><p>#include<br />
#include<br />
#include<br />
using namespace std;<br />
struct node<br />
{<br />
    int data;<br />
    struct node* left;<br />
    struct node* right;<br />
};</p>
<p>void printLevelOrder(struct node* root)<br />
{<br />
  list queue;<br />
  queue.push_back(root);</p>
<p>  while(!queue.empty())<br />
  {<br />
    struct node *temp_node=queue.front();<br />
    queue.pop_front();<br />
    printf(&#8220;%d &#8220;, temp_node-&gt;data);<br />
    if(temp_node-&gt;left)<br />
    queue.push_back (temp_node-&gt;left);<br />
    if(temp_node-&gt;right)<br />
    queue.push_back (temp_node-&gt;right);</p>
<p>  }<br />
}</p>
<p>struct node* newNode(int data)<br />
{<br />
  struct node* node = (struct node*)<br />
                       malloc(sizeof(struct node));<br />
  node-&gt;data = data;<br />
  node-&gt;left = NULL;<br />
  node-&gt;right = NULL;</p>
<p>  return(node);<br />
}</p>
<p>/* Driver program to test above functions*/<br />
int main()<br />
{<br />
  struct node *root = newNode(1);<br />
  root-&gt;left        = newNode(2);<br />
  root-&gt;right       = newNode(3);<br />
  root-&gt;left-&gt;left  = newNode(4);<br />
  root-&gt;left-&gt;right = newNode(5);</p>
<p>  printf(&#8220;Level Order traversal of binary tree is \n&#8221;);<br />
  printLevelOrder(root);</p>
<p>  getchar();<br />
  return 0;<br />
}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-16407">
        <div id="dsq-comment-header-16407" class="dsq-comment-header">
            <cite id="dsq-cite-16407">
                <span id="dsq-author-user-16407">Nikin Kumar Jain</span>
            </cite>
        </div>
        <div id="dsq-comment-body-16407" class="dsq-comment-body">
            <div id="dsq-comment-message-16407" class="dsq-comment-message"><p>Code to Perform Both Inorder and Level-Order Without Recursion, Using a same kind of Datastucture. But with modified Implementation method. </p>
<pre> <code language="C">
struct node
{
	int data;
	node *left, *right;
};

struct stack
{
	stack *next;
	node *data;
};

void pushQueue(node *sr, stack **s1)
{
	stack *point = new stack;
	point-&gt;data = sr;
	point-&gt;next = NULL;

	if(!*s1)
		*s1 = point;
	else
	{
		stack *pointer = *s1;
		while(pointer-&gt;next)
			pointer = pointer-&gt;next;
		pointer-&gt;next = point;
	}
}
void push(node *sr, stack **s1)
{
	stack *point = new stack;
	point-&gt;data = sr;
	point-&gt;next = NULL;

	if(!*s1)
		*s1 = point;
	else
	{
		point-&gt;next = *s1;
		*s1 = point;
	}
}
node* pop(stack **s1)
{
	stack *point = *s1;
	*s1 = (*s1)-&gt;next;
	return point-&gt;data;
}
bool isEmpty(stack *s)
{
	if(s == NULL)
		return true;
	return false;
}

void levelOrderNoRecurs(node *sr)
{
	if(sr == NULL)
		return;

	stack *s = NULL;
	pushQueue(sr, &amp;s);
	bool done1 = true;
	while(done1)
	{
		if(isEmpty(s))
			return;

		node *dt = pop(&amp;s);
		cout&lt;&lt;dt-&gt;data&lt;&lt;&quot; &quot;;

		if(dt-&gt;left)
			pushQueue(dt-&gt;left, &amp;s);
		if(dt-&gt;right)
			pushQueue(dt-&gt;right, &amp;s);
	}
}

void inorderNoRecurs(node *sr)
{
	if(sr == NULL)
		return;

	stack *s = NULL;
	bool done1 = true;
	while(done1)
	{
		if(sr != NULL)
		{
			push(sr, &amp;s);
			sr = sr-&gt;left;
		}
		else
		{
			if(isEmpty(s))
			{
				done1 = false;
				return;
			}
			node *dt = pop(&amp;s);
			cout&lt;&lt;dt-&gt;data&lt;&lt;&quot; &quot;;

			sr = dt-&gt;right;
		}
	}
}
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-13424">
        <div id="dsq-comment-header-13424" class="dsq-comment-header">
            <cite id="dsq-cite-13424">
                <span id="dsq-author-user-13424">Ravi</span>
            </cite>
        </div>
        <div id="dsq-comment-body-13424" class="dsq-comment-body">
            <div id="dsq-comment-message-13424" class="dsq-comment-message"><p>I think the deQueue method should be something like this, for checking if the queue is empty. I tried to use your code, it resulted in coredump. If the code is modified like this, it is working fine. Please check once.</p>
<pre> <code language="C">
struct node *deQueue(struct node **queue, int *front,int *rear)
{
	if(*front == *rear)
		return NULL;

  (*front)++;
  return queue[*front - 1];
}
</code> </pre>
<p>Thanks</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-13406">
        <div id="dsq-comment-header-13406" class="dsq-comment-header">
            <cite id="dsq-cite-13406">
                <span id="dsq-author-user-13406">ethanjyx</span>
            </cite>
        </div>
        <div id="dsq-comment-body-13406" class="dsq-comment-body">
            <div id="dsq-comment-message-13406" class="dsq-comment-message"><p>What&#8217;s the best case time complexity for method 1 then?</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-9849">
        <div id="dsq-comment-header-9849" class="dsq-comment-header">
            <cite id="dsq-cite-9849">
                <span id="dsq-author-user-9849">Bhupendra</span>
            </cite>
        </div>
        <div id="dsq-comment-body-9849" class="dsq-comment-body">
            <div id="dsq-comment-message-9849" class="dsq-comment-message"><p>@geeksforgeeks<br />
Complexity of first method given is wrong<br />
for level l print level will visit all nodes upto level l so complexity is:<br />
2^1+2^2&#8230;..2^h (h = height of tree)</p>
<p>which is basically 2^(nlogn) or n^n</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-9857">
        <div id="dsq-comment-header-9857" class="dsq-comment-header">
            <cite id="dsq-cite-9857">
                <span id="dsq-author-user-9857">kartik</span>
            </cite>
        </div>
        <div id="dsq-comment-body-9857" class="dsq-comment-body">
            <div id="dsq-comment-message-9857" class="dsq-comment-message"><p>I could not understand your explanation. I still believe time complexity is O(n^2).  You can get O(n^2) using following logic.  </p>
<p>Let n be the number of nodes in a Binary Tree<br />
1) printGivenLevel() will take at most O(n) time.  It is similar to tree traversal functions, like inorder.</p>
<p>2) printGivenLevel() is called for every level and there can be at most O(n) levels. We will have O(n) levels in a skewed tree.</p>
<p>So the upper bound on worst case time complexity is O(n)*O(n) which is O(n^2)</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-3" id="dsq-comment-9858">
        <div id="dsq-comment-header-9858" class="dsq-comment-header">
            <cite id="dsq-cite-9858">
                <span id="dsq-author-user-9858">Bhupendra</span>
            </cite>
        </div>
        <div id="dsq-comment-body-9858" class="dsq-comment-body">
            <div id="dsq-comment-message-9858" class="dsq-comment-message"><p>Worst case won&#8217;t be in case of skewed tree.<br />
It&#8217;s actually best case!<br />
Worst case would be in case of complete tree!</p>
<p>number of nodes upto level l is 2^l (l in  case of skewed tree) and printlevel node will visit all nodes at-least once upto level l. So complexity will be some of this  GP</p>
<p>2^1 +2^2&#8230;.2^h<br />
May be I am still wrong! So please correct!</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-4" id="dsq-comment-14509">
        <div id="dsq-comment-header-14509" class="dsq-comment-header">
            <cite id="dsq-cite-14509">
                <span id="dsq-author-user-14509">Mo</span>
            </cite>
        </div>
        <div id="dsq-comment-body-14509" class="dsq-comment-body">
            <div id="dsq-comment-message-14509" class="dsq-comment-message"><p>2^1 +2^2&#8230;.2^h &lt;= n<br />
where h is O(logn),if it is a complete tree.</p>
<p>Anyway, to visit a node, you have visited at most (n-1) nodes down to it.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-9642">
        <div id="dsq-comment-header-9642" class="dsq-comment-header">
            <cite id="dsq-cite-9642">
                <span id="dsq-author-user-9642">Ankush</span>
            </cite>
        </div>
        <div id="dsq-comment-body-9642" class="dsq-comment-body">
            <div id="dsq-comment-message-9642" class="dsq-comment-message"><p>In second method i think, instead of malloc ,calloc should be used to allocate memory for queue.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-9163">
        <div id="dsq-comment-header-9163" class="dsq-comment-header">
            <cite id="dsq-cite-9163">
                <span id="dsq-author-user-9163">anil arya</span>
            </cite>
        </div>
        <div id="dsq-comment-body-9163" class="dsq-comment-body">
            <div id="dsq-comment-message-9163" class="dsq-comment-message"><pre> <code language="C"></code> </pre>
<p>/* Paste your code here (You may delete these lines if not writing code) */<br />
{{{</p>
<p>#include<br />
 #include<br />
/* A tree node structure */<br />
struct node<br />
{<br />
  int data;<br />
  struct node *left;<br />
  struct node *right;<br />
};</p>
<p> int height(struct node *root)<br />
 {<br />
            if(root==NULL)<br />
                    return 0;</p>
<p>            int lh=height(root-&gt;left);<br />
            int rh=height(root-&gt;right);</p>
<p>            return lh&gt;rh?(lh+1):(rh+1);<br />
    }<br />
/* Utility function to create a new Binary Tree node */<br />
struct node* newNode(int data)<br />
{<br />
  struct node *temp = new struct node;<br />
  temp-&gt;data = data;<br />
  temp-&gt;left = NULL;<br />
  temp-&gt;right = NULL;</p>
<p>  return temp;<br />
}<br />
 void inorder(struct node *root,int k,int i)<br />
 {<br />
            if(root==NULL)<br />
                return ;</p>
<p>            else<br />
                {<br />
                        inorder(root-&gt;left,k,i+1);</p>
<p>                        if(i==k)<br />
                        {<br />
                            printf(&#8220;%d &#8220;,root-&gt;data);</p>
<p>                        }</p>
<p>                        inorder(root-&gt;right,k,i+1);<br />
                }<br />
}<br />
/* Driver function to test above functions */<br />
int main()<br />
{<br />
  struct node *root = new struct node;</p>
<p>  /* Constructing tree given in the above figure */<br />
  root = newNode(3);<br />
  root-&gt;left = newNode(2);<br />
  root-&gt;right = newNode(5);<br />
  root-&gt;left-&gt;left = newNode(1);<br />
  root-&gt;left-&gt;right = newNode(4);<br />
  root-&gt;left-&gt;left-&gt;left = newNode(11);<br />
  root-&gt;left-&gt;right-&gt;left = newNode(14);<br />
  root-&gt;left-&gt;left-&gt;right = newNode(12);<br />
  root-&gt;left-&gt;right -&gt;right= newNode(44);<br />
 int i;</p>
<p>  int ht=height(root);<br />
  for(i=1;i&lt;=ht;i++)<br />
  {<br />
    inorder(root,i,1);<br />
    printf(&quot;\n&quot;);}</p>
<p>  x = 6;</p>
<p>  getchar();<br />
  return 0;<br />
}</p>
<p>}}}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-9112">
        <div id="dsq-comment-header-9112" class="dsq-comment-header">
            <cite id="dsq-cite-9112">
                <span id="dsq-author-user-9112">vivek</span>
            </cite>
        </div>
        <div id="dsq-comment-body-9112" class="dsq-comment-body">
            <div id="dsq-comment-message-9112" class="dsq-comment-message"><p>i guess  this one is simple enough plus no adverse effects of pointer</p>
<pre> <code language="C">
#include &lt;stdio.h&gt;

#define N 10

void bfs(int adj[][N],int visited[],int start)
{
	int q[N],rear=-1,front=-1,i;
	q[++rear]=start;
	visited[start]=1;
	while(rear != front)
	{
		start = q[++front];
		if(start==9)
			printf(&quot;10\t&quot;);
		else
			printf(&quot;%c \t&quot;,start+49); //change to 65 in case of alphabets

		for(i=0;i&lt;N;i++)
		{
			if(adj[start][i] &amp;&amp; !visited[i])
			{
				q[++rear]=i;
				visited[i]=1;
			}
		}
	}
}

int main()
{
	int visited[N]={0};
	int adj[N][N]={{0,1,1,0,0,0,0},
	{0,0,0,1,1,0,0},
	{0,0,0,0,0,1,1},
	{0,0,0,0,0,0,0},
	{0,0,0,0,0,0,0},
	{0,0,0,0,0,0,0},
	{0,0,0,0,0,0,0},
	};

	bfs(adj,visited,0);
	return 0;

	
}

</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-7476">
        <div id="dsq-comment-header-7476" class="dsq-comment-header">
            <cite id="dsq-cite-7476">
                <span id="dsq-author-user-7476">Avinash</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7476" class="dsq-comment-body">
            <div id="dsq-comment-message-7476" class="dsq-comment-message"><pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
void printlevelorder(struct node *tree)
{
	struct queue *Q=createQueue();
	If (!tree) return NULL;
	Enqueue(Q,root)
	while(!IsEmptyQueue(Q))
	{
		struct node *temp=DeQueue(Q);
		printf(&quot;%d&quot;,Q-&gt;data);
		If temp-&gt;left EnQueue(Q, temp-&gt;left);
		If temp-&gt;right EnQueue(Q, temp-&gt;right);
	}
	
	DeleteQueue(Q);
}	
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-psychocoder even thread-even depth-1" id="dsq-comment-7408">
        <div id="dsq-comment-header-7408" class="dsq-comment-header">
            <cite id="dsq-cite-7408">
                <span id="dsq-author-user-7408">PsychoCoder</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7408" class="dsq-comment-body">
            <div id="dsq-comment-message-7408" class="dsq-comment-message"><p>Same thins as method 2. But dynamic <img src="http://d2o58evtke57tz.cloudfront.net/wp-includes/images/smilies/icon_smile.gif" alt=":)" class="wp-smiley" /><br />
Same complexity : O(n)</p>
<pre> <code language="C">
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;limits.h&gt;

typedef struct node {
  int data ;
  struct node *left ;
  struct node *right ;
}node;

typedef struct list {
  node *data ;
  struct list *next;
}list;

typedef struct queue {
  int count ;
  struct list *front ;
  struct list *rear;
}queue ;

void createQueue (queue **head) {
  *head = (queue *) malloc (sizeof(queue)) ;
  (*head)-&gt;count = 0 ;
  (*head)-&gt;front = NULL ;
  (*head)-&gt;rear = NULL ;
}

list* newList (node* data) {
  list *head ;
  head = (list *) malloc (sizeof(list)) ;
  head-&gt;next = NULL ;
  head-&gt;data = data ;
  return head ;
}

queue* enqueue (queue *head, node* data) {
  list *temp = newList (data) ;
  if (head-&gt;front == NULL) {
    head-&gt;front = temp ;
    head-&gt;rear = temp ;
    head-&gt;count ++ ;
  }
  else {
    head-&gt;rear-&gt;next = temp ;
    head-&gt;rear = head-&gt;rear-&gt;next ;
    head-&gt;count ++ ;
  }
  return head;
}

list* dequeue (queue **head) {
  list *temp ;
  if ((*head)-&gt;count == 0)
    return NULL ;
  if ((*head)-&gt;front != NULL) {
    temp = (*head)-&gt;front ;
    if ( (*head)-&gt;front == (*head)-&gt;rear ) {
      (*head)-&gt;front = NULL ;
      (*head)-&gt;rear = NULL ;
      (*head)-&gt;count -- ;
    }
    else 
      (*head)-&gt;front = (*head)-&gt;front-&gt;next ;
      (*head)-&gt;count -- ;
  } 
  return temp ;
}

int isEmpty (queue *q) {
  return (q-&gt;count == 0);
}

node* newnode (int data) {
  node *head ;
  head = (node *) malloc (sizeof(node)) ;
  head-&gt;data = data ;
  head-&gt;left = NULL ;
  head-&gt;right = NULL ;
  return head ;
}

void printLevelBFS (node *tree) {
  queue *q ;
  list *temp ;
  /* Initialize the queue */
  createQueue (&amp;q) ;

  enqueue (q,tree) ;
  /* Use INT_MAX as delimiter */
  enqueue (q,newnode(INT_MAX)) ;

  while ( !isEmpty (q) ) {
    temp = dequeue (&amp;q) ;
  
    /* Check whether it is a delimiter or not */
    if ( temp-&gt;data-&gt;data != INT_MAX ) {
      /* If not then extreme right of this level
         is not reached till now. Enqueue its
         child */
      printf ( &quot;%d &quot;, temp-&gt;data-&gt;data ) ;
      if (temp-&gt;data-&gt;left)
        q = enqueue (q, temp-&gt;data-&gt;left) ;

      if (temp-&gt;data-&gt;right)
        q = enqueue (q, temp-&gt;data-&gt;right) ;
    } else {
      printf ( &quot;\n&quot; ) ;
      /* If a delimiter is reached, then set the 
         delimiter of the next level. Because 
         extreme right is reached for this level */
      if ( !isEmpty(q) )
        enqueue (q,newnode(INT_MAX)) ;
    }
  }

  while (!isEmpty (q))
    dequeue (&amp;q) ;
  free (q) ;
}

int main() {

  node *root 	    = newnode(10);
  root-&gt;left        = newnode(8);
  root-&gt;right       = newnode(2);
  root-&gt;left-&gt;left  = newnode(3);
  root-&gt;right-&gt;left = newnode(6) ;
  root-&gt;right-&gt;right = newnode(7) ;

  printLevelBFS (root ) ;
  free (root);
  return 1 ;
}</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-psychocoder odd alt depth-2" id="dsq-comment-7410">
        <div id="dsq-comment-header-7410" class="dsq-comment-header">
            <cite id="dsq-cite-7410">
                <span id="dsq-author-user-7410">PsychoCoder</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7410" class="dsq-comment-body">
            <div id="dsq-comment-message-7410" class="dsq-comment-message"><p>There is a small mistake in this fucntion . I have Updated it. Here it is :</p>
<pre> <code language="C">
list* dequeue (queue **head) {
  list *temp ;
  if ((*head)-&gt;count == 0)
    return NULL ;
  if ((*head)-&gt;front != NULL) {
    temp = (*head)-&gt;front ;
    if ( (*head)-&gt;front == (*head)-&gt;rear ) {
      (*head)-&gt;front = NULL ;
      (*head)-&gt;rear = NULL ;
      (*head)-&gt;count -- ;
    }
    else {
      (*head)-&gt;front = (*head)-&gt;front-&gt;next ;
      (*head)-&gt;count -- ;
    }
  }
  return temp ;
}</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment byuser comment-author-manish_dawar even thread-odd thread-alt depth-1" id="dsq-comment-6325">
        <div id="dsq-comment-header-6325" class="dsq-comment-header">
            <cite id="dsq-cite-6325">
                <span id="dsq-author-user-6325">Manish_Dawar</span>
            </cite>
        </div>
        <div id="dsq-comment-body-6325" class="dsq-comment-body">
            <div id="dsq-comment-message-6325" class="dsq-comment-message"><p>your code wont work if we have a tree have a root only because there is nothing in the queue and we are still dequeueing it..</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-kartik odd alt depth-2" id="dsq-comment-6326">
        <div id="dsq-comment-header-6326" class="dsq-comment-header">
            <cite id="dsq-cite-6326">
                <span id="dsq-author-user-6326">kartik</span>
            </cite>
        </div>
        <div id="dsq-comment-body-6326" class="dsq-comment-body">
            <div id="dsq-comment-message-6326" class="dsq-comment-message"><p>Take a closer look at the program.  It works for this case also. Also see <a href="http://ideone.com/u05bY" rel="nofollow">this</a> run</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-manish_dawar even depth-3" id="dsq-comment-6329">
        <div id="dsq-comment-header-6329" class="dsq-comment-header">
            <cite id="dsq-cite-6329">
                <span id="dsq-author-user-6329">Manish_Dawar</span>
            </cite>
        </div>
        <div id="dsq-comment-body-6329" class="dsq-comment-body">
            <div id="dsq-comment-message-6329" class="dsq-comment-message"><p>i tried it on gcc. Not working.. So, i jst add on a condition jst before dequeue i.e if front and rear are equal break.. Correct me, if i m wrng..</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-kartik odd alt depth-4" id="dsq-comment-6336">
        <div id="dsq-comment-header-6336" class="dsq-comment-header">
            <cite id="dsq-cite-6336">
                <span id="dsq-author-user-6336">kartik</span>
            </cite>
        </div>
        <div id="dsq-comment-body-6336" class="dsq-comment-body">
            <div id="dsq-comment-message-6336" class="dsq-comment-message"><p>@Manish_Dawar:  could you post the error message that you got.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-5400">
        <div id="dsq-comment-header-5400" class="dsq-comment-header">
            <cite id="dsq-cite-5400">
                <span id="dsq-author-user-5400">sachin</span>
            </cite>
        </div>
        <div id="dsq-comment-body-5400" class="dsq-comment-body">
            <div id="dsq-comment-message-5400" class="dsq-comment-message"><p>my solution is..<br />
#include<br />
typedef struct node<br />
 {<br />
      int value;<br />
      struct node *right;<br />
      struct node *left;<br />
      }mynode;<br />
      mynode *root;<br />
      add_node(int value);<br />
      void levelOrderTraversal(mynode *root);<br />
      int main(int argc, char* argv[]) {<br />
           root = NULL;<br />
           add_node(5);<br />
           add_node(1);<br />
           add_node(-20);<br />
           add_node(100);<br />
            add_node(23);<br />
            add_node(67);<br />
           add_node(13);<br />
            printf(&#8220;\n\n\nLEVEL ORDER TRAVERSAL\n\n&#8221;);<br />
            levelOrderTraversal(root);<br />
            system(&#8220;pause&#8221;);<br />
            return 0;<br />
             }<br />
             add_node(int value)<br />
             {<br />
                 mynode *prev, *cur, *temp;<br />
                 temp = (mynode *) malloc(sizeof(mynode));<br />
                 temp-&gt;value = value;<br />
                 temp-&gt;right = NULL;<br />
                 temp-&gt;left = NULL;<br />
                 if(root==NULL) {<br />
                      printf(&#8220;\nCreating the root..\n&#8221;);<br />
                      root = temp;<br />
                      return;<br />
                      }<br />
                      prev=NULL;<br />
                      cur=root;<br />
                      while(cur!=NULL)<br />
                      {<br />
                          prev=cur;<br />
                 cur=(valuevalue)?cur-&gt;left:cur-&gt;right; }<br />
                 if(value value)<br />
                 prev-&gt;left=temp;<br />
                 else<br />
                 prev-&gt;right=temp;<br />
                 }<br />
                 // Level order traversal..<br />
                 void levelOrderTraversal(mynode *root)<br />
                 {<br />
                     mynode *queue[100] = {(mynode *)0};<br />
                     // Important to initialize!<br />
                     int size = 0;<br />
                     int queue_pointer = 0;<br />
                     while(root)<br />
{ printf(&#8220;[%d] &#8220;, root-&gt;value);<br />
if(root-&gt;left) { queue[size++] = root-&gt;left; }<br />
if(root-&gt;right) { queue[size++] = root-&gt;right; }<br />
 root = queue[queue_pointer++];<br />
 }<br />
 }</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-4992">
        <div id="dsq-comment-header-4992" class="dsq-comment-header">
            <cite id="dsq-cite-4992">
                <span id="dsq-author-user-4992">Decompiler</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4992" class="dsq-comment-body">
            <div id="dsq-comment-message-4992" class="dsq-comment-message"><p>What about storing each node data in multimap and printing them at last ?</p>
<pre> <code language="C">
void level_order( struct node* root, int l )
{
	int m;
	if ( root == NULL )
		return;
	m = root -&gt; data;	
	M.insert ( pair&lt;int,int&gt;(l,m) );	
	l++;	
	level_order(root-&gt;left, l);
	level_order(root-&gt;right, l);			
}
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-4168">
        <div id="dsq-comment-header-4168" class="dsq-comment-header">
            <cite id="dsq-cite-4168">
                <span id="dsq-author-user-4168">satya</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4168" class="dsq-comment-body">
            <div id="dsq-comment-message-4168" class="dsq-comment-message"><p>@geeksforgeeks,,,Can you guys please make your post error free ..m getting 100 of error but just cut &amp; paste in ideone..<br />
don&#8217;t belive click here <a href="https://ideone.com/txVW8" rel="nofollow">https://ideone.com/txVW8</a></p>
<p>like prog.cpp:4: error: stray ‘\302’ in program<br />
prog.cpp:4: error: stray ‘\240’ in program<br />
prog.cpp:9: error: stray ‘\302’ in program<br />
prog.cpp:9: error: stray ‘\240’ in program<br />
prog.cpp:9: error: stray ‘\302’ in program<br />
prog.cpp:9: error: stray ‘\240’ in program<br />
prog.cpp:9: error: stray ‘\302’ in program<br />
prog.cpp:9: error: stray ‘\240’ in program<br />
&amp; so on</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-geeksforgeeks bypostauthor odd alt depth-2" id="dsq-comment-4169">
        <div id="dsq-comment-header-4169" class="dsq-comment-header">
            <cite id="dsq-cite-4169">
                <span id="dsq-author-user-4169">GeeksforGeeks</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4169" class="dsq-comment-body">
            <div id="dsq-comment-message-4169" class="dsq-comment-message"><p>@satya: We tried to run both the given programs using ideone.  They both worked fine for us.  See the following links.</p>
<p><a href="https://ideone.com/XEpQw" rel="nofollow">https://ideone.com/XEpQw</a></p>
<p><a href="https://ideone.com/2PkJ9" rel="nofollow">https://ideone.com/2PkJ9</a></p>
<p>To avoid selecting extra characters when copying, double click anywhere on the code segment and copy the code.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-pragya even depth-3" id="dsq-comment-5404">
        <div id="dsq-comment-header-5404" class="dsq-comment-header">
            <cite id="dsq-cite-5404">
                <span id="dsq-author-user-5404">Pragya</span>
            </cite>
        </div>
        <div id="dsq-comment-body-5404" class="dsq-comment-body">
            <div id="dsq-comment-message-5404" class="dsq-comment-message"><p>@Satya- Even me too encountered with same error many times but now i got the reason behind it. Actually, whenever u copy and paste source code in your .c file some characters are not read properly by ur editor. Mostly , u can see this when u will copy and paste any printf() then the color of characters written inside &#8221; &#8221; is pink in linux, but sometimes when u copy and paste the color remains black, it means it is not yet read properly&#8230; So delete double quotes (&#8221; &#8220;) and type by your own keyboard the quotes only and then u will find the color changes to pink &#8230;so now no error will come&#8230; I hope u got it&#8230; If not got then do let me know please&#8230;</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-3782">
        <div id="dsq-comment-header-3782" class="dsq-comment-header">
            <cite id="dsq-cite-3782">
                <span id="dsq-author-user-3782">mike</span>
            </cite>
        </div>
        <div id="dsq-comment-body-3782" class="dsq-comment-body">
            <div id="dsq-comment-message-3782" class="dsq-comment-message"><p>Hey guys!<br />
so what is the time complexity of the first code?<br />
it it (O)n or (O)n^2 ???</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-sandeep even depth-2" id="dsq-comment-3816">
        <div id="dsq-comment-header-3816" class="dsq-comment-header">
            <cite id="dsq-cite-3816">
                <span id="dsq-author-user-3816">Sandeep</span>
            </cite>
        </div>
        <div id="dsq-comment-body-3816" class="dsq-comment-body">
            <div id="dsq-comment-message-3816" class="dsq-comment-message"><p>@mike:<br />
We have updated the post and added explaination for the time complexity of method 1.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-2285">
        <div id="dsq-comment-header-2285" class="dsq-comment-header">
            <cite id="dsq-cite-2285">
                <span id="dsq-author-user-2285">rohith</span>
            </cite>
        </div>
        <div id="dsq-comment-body-2285" class="dsq-comment-body">
            <div id="dsq-comment-message-2285" class="dsq-comment-message"><p>in the first solution in the height function, with out counting how will the height of left an right subtree caculated??</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-kartik even depth-2" id="dsq-comment-2328">
        <div id="dsq-comment-header-2328" class="dsq-comment-header">
            <cite id="dsq-cite-2328">
                <span id="dsq-author-user-2328">kartik</span>
            </cite>
        </div>
        <div id="dsq-comment-body-2328" class="dsq-comment-body">
            <div id="dsq-comment-message-2328" class="dsq-comment-message"><p>@rohith<br />
I am not able to understand your question :(. Please elaborate.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt depth-2" id="dsq-comment-3823">
        <div id="dsq-comment-header-3823" class="dsq-comment-header">
            <cite id="dsq-cite-3823">
                <span id="dsq-author-user-3823">Pragya</span>
            </cite>
        </div>
        <div id="dsq-comment-body-3823" class="dsq-comment-body">
            <div id="dsq-comment-message-3823" class="dsq-comment-message"><p>@Rohith- In height function of the first solution,u can see the inner if-else statement there you can find that height of left subtree(lheight) and height of right subtree (rheight) is increment as per condition, and thus able to count height.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-2258">
        <div id="dsq-comment-header-2258" class="dsq-comment-header">
            <cite id="dsq-cite-2258">
                <span id="dsq-author-user-2258">Lakshmi</span>
            </cite>
        </div>
        <div id="dsq-comment-body-2258" class="dsq-comment-body">
            <div id="dsq-comment-message-2258" class="dsq-comment-message"><p>What is the time complexity of the first method?</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-kartik odd alt depth-2" id="dsq-comment-2329">
        <div id="dsq-comment-header-2329" class="dsq-comment-header">
            <cite id="dsq-cite-2329">
                <span id="dsq-author-user-2329">kartik</span>
            </cite>
        </div>
        <div id="dsq-comment-body-2329" class="dsq-comment-body">
            <div id="dsq-comment-message-2329" class="dsq-comment-message"><p>I think time complexity is O(n^2). We can see this for a skewed tree.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-3" id="dsq-comment-9847">
        <div id="dsq-comment-header-9847" class="dsq-comment-header">
            <cite id="dsq-cite-9847">
                <span id="dsq-author-user-9847">Bhupendra</span>
            </cite>
        </div>
        <div id="dsq-comment-body-9847" class="dsq-comment-body">
            <div id="dsq-comment-message-9847" class="dsq-comment-message"><p>It will be exponential!!</p>
<p>See my comment for explanation</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-4" id="dsq-comment-9848">
        <div id="dsq-comment-header-9848" class="dsq-comment-header">
            <cite id="dsq-cite-9848">
                <span id="dsq-author-user-9848">Bhupendra</span>
            </cite>
        </div>
        <div id="dsq-comment-body-9848" class="dsq-comment-body">
            <div id="dsq-comment-message-9848" class="dsq-comment-message"><p>for level l print level will visit all nodes upto level l so complexity is:<br />
2^1+2^2&#8230;..2^h (h = height of tree)</p>
<p>which is basically 2^(nlogn) or n^n</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-5" id="dsq-comment-9856">
        <div id="dsq-comment-header-9856" class="dsq-comment-header">
            <cite id="dsq-cite-9856">
                <span id="dsq-author-user-9856">kartik</span>
            </cite>
        </div>
        <div id="dsq-comment-body-9856" class="dsq-comment-body">
            <div id="dsq-comment-message-9856" class="dsq-comment-message"><p>I could not understand your explanation. I still believe time complexity is O(n^2).  You can get O(n^2) using following logic.  </p>
<p>Let n be the number of nodes in a Binary Tree<br />
1) printGivenLevel() will take at most O(n) time.  It is similar to tree traversal functions, like inorder.</p>
<p>2) printGivenLevel() is called for every level and there can be at most O(n) levels.</p>
<p>So the upper bound on worst case time complexity is O(n)*O(n) which is O(n^2)</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment byuser comment-author-jaskaran1 odd alt depth-2" id="dsq-comment-20477">
        <div id="dsq-comment-header-20477" class="dsq-comment-header">
            <cite id="dsq-cite-20477">
                <span id="dsq-author-user-20477">jaskaran1</span>
            </cite>
        </div>
        <div id="dsq-comment-body-20477" class="dsq-comment-body">
            <div id="dsq-comment-message-20477" class="dsq-comment-message"><p>@admin<br />
I believe the time complexity for the first method is stated wrong.<br />
Let us say time complexity of printlevel is T(k).Then,T(k)=2*T(k-1)+c<br />
Thus,T(k)=2^(k-1).<br />
Summing this over all levels:<br />
We get T=2^h-1 where h is the height.In case of balanced tree h=logN and in skew case h=N.So in the worst case it is O(2^N).</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-2095">
        <div id="dsq-comment-header-2095" class="dsq-comment-header">
            <cite id="dsq-cite-2095">
http://whois.domaintools.com/jesswilson.com                <span id="dsq-author-user-2095">Anshul</span>
            </cite>
        </div>
        <div id="dsq-comment-body-2095" class="dsq-comment-body">
            <div id="dsq-comment-message-2095" class="dsq-comment-message"><p>will this give this output:</p>
<p><strong>1<br />
2 3<br />
4 5</strong></p>
<p>i.e by printing at each level in seperate line. How this can be done?</p>
<p>also this line: /*Dequeue node and make it temp_node*/<br />
    temp_node = deQueue(queue, &amp;front);</p>
<p>will only print a Node while we are filling left and right again and again?</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-gauravs odd alt thread-odd thread-alt depth-1" id="dsq-comment-1948">
        <div id="dsq-comment-header-1948" class="dsq-comment-header">
            <cite id="dsq-cite-1948">
                <span id="dsq-author-user-1948">gauravs</span>
            </cite>
        </div>
        <div id="dsq-comment-body-1948" class="dsq-comment-body">
            <div id="dsq-comment-message-1948" class="dsq-comment-message"><p>What will be the time complexity of recursive solution of level order traversal ?</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-671">
        <div id="dsq-comment-header-671" class="dsq-comment-header">
            <cite id="dsq-cite-671">
                <span id="dsq-author-user-671">Shrijeet</span>
            </cite>
        </div>
        <div id="dsq-comment-body-671" class="dsq-comment-body">
            <div id="dsq-comment-message-671" class="dsq-comment-message"><p>void printLevelOrder(struct node* root)<br />
{<br />
  int rear, front;<br />
  struct node **queue = createQueue(&amp;front, &amp;rear);<br />
  struct node *temp_node = root; </p>
<p>  while(temp_node)<br />
  {<br />
    printf(&quot;%d &quot;, temp_node-&gt;data);</p>
<p>    /*Enqueue left child */<br />
     if(temp_node-&gt;left)<br />
      enQueue(queue, &amp;rear, temp_node-&gt;left);</p>
<p>    /*Enqueue right child */<br />
     if(temp_node-&gt;right)<br />
      enQueue(queue, &amp;rear, temp_node-&gt;right);</p>
<p>    /*Dequeue node and make it temp_node*/<br />
    temp_node = deQueue(queue, &amp;front);<br />
  }<br />
}</p>
<p>There is an error in code, note the correction needed.<br />
Thanks!</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-geeksforgeeks bypostauthor odd alt depth-2" id="dsq-comment-674">
        <div id="dsq-comment-header-674" class="dsq-comment-header">
            <cite id="dsq-cite-674">
                <span id="dsq-author-user-674">GeeksforGeeks</span>
            </cite>
        </div>
        <div id="dsq-comment-body-674" class="dsq-comment-body">
            <div id="dsq-comment-message-674" class="dsq-comment-message"><p>@Shrijeet: Thanks for pointing this out. We have made the suggested changes.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-225">
        <div id="dsq-comment-header-225" class="dsq-comment-header">
            <cite id="dsq-cite-225">
                <span id="dsq-author-user-225">Rosy</span>
            </cite>
        </div>
        <div id="dsq-comment-body-225" class="dsq-comment-body">
            <div id="dsq-comment-message-225" class="dsq-comment-message"><p>Thanks..Yeah It will work perfectly..After writing the comments only, I realized that but did n&#8217;t know how to delete my comments..:)..But thanks for the explanation..</p>
<p>Its really a great site..:)</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-geeksforgeeks bypostauthor odd alt thread-even depth-1" id="dsq-comment-224">
        <div id="dsq-comment-header-224" class="dsq-comment-header">
            <cite id="dsq-cite-224">
                <span id="dsq-author-user-224">geeksforgeeks</span>
            </cite>
        </div>
        <div id="dsq-comment-body-224" class="dsq-comment-body">
            <div id="dsq-comment-message-224" class="dsq-comment-message"><p>@Rosy: The first solution will work as printGivenLevel() prints the data when <i>level</i>  becomes 1.  For i = 1 (i.e. root) there won&#8217;t be any recursive calls as <i>level</i>  is 1 so root node will be printed.  For other levels, passed <i>level</i>  will be more than 1, traversal will start from root and <i>level</i>  will be decremented as we move down the tree recursively. When we reach the required level, <i>level</i> will become 1 and nodes will be printed. You can try the code with different trees.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-220">
        <div id="dsq-comment-header-220" class="dsq-comment-header">
            <cite id="dsq-cite-220">
                <span id="dsq-author-user-220">Rosy</span>
            </cite>
        </div>
        <div id="dsq-comment-body-220" class="dsq-comment-body">
            <div id="dsq-comment-message-220" class="dsq-comment-message"><p>Hi,</p>
<p>I do n&#8217;t think the first solution is going to work..</p>
<pre>
Inside printLevelOrder(struct node* root)
{
  ....
  printGivenLevel(root, i); //here its starting from i=0
}
</pre>
<p>And Inside </p>
<pre>
printGivenLevel(struct node* root, int level)
{
  ...
  if(level &gt;1)
   //calling recursively by passing the left and right child 
   // as the first argument and (level-1) as the 2nd argument.
   //Here level starts from zero..so how the revursive calls 
   //are going to happen..
}
</pre>
<p>Please comment if my understanding is incorrect..</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-geeksforgeeks bypostauthor odd alt thread-even depth-1" id="dsq-comment-205">
        <div id="dsq-comment-header-205" class="dsq-comment-header">
            <cite id="dsq-cite-205">
                <span id="dsq-author-user-205">geeksforgeeks</span>
            </cite>
        </div>
        <div id="dsq-comment-body-205" class="dsq-comment-body">
            <div id="dsq-comment-message-205" class="dsq-comment-message"><p>@Shikha: Thanks for pointing out this.  There was a typo.  We have corrected it.  Keep it up!!</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-204">
        <div id="dsq-comment-header-204" class="dsq-comment-header">
            <cite id="dsq-cite-204">
                <span id="dsq-author-user-204">Shikha</span>
            </cite>
        </div>
        <div id="dsq-comment-body-204" class="dsq-comment-body">
            <div id="dsq-comment-message-204" class="dsq-comment-message"><p>&#8220;Time Complexity: O(n)<br />
Space Complexity: O(n)<br />
Space complexity will be equal to height of the tree and for a skewed tree height can be O(n).&#8221;</p>
<p>Space complexity will be equal to number of nodes in the tree. &#8216;n&#8217; refers to number of nodes in tree.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-31627">
        <div id="dsq-comment-header-31627" class="dsq-comment-header">
            <cite id="dsq-cite-31627">
                <span id="dsq-author-user-31627">neelabhsingh</span>
            </cite>
        </div>
        <div id="dsq-comment-body-31627" class="dsq-comment-body">
            <div id="dsq-comment-message-31627" class="dsq-comment-message"><p>Hello Shikha,<br />
Time Complexity -O(n) and Space complexity is O(2^(height of Tree)) and as you mentioned that for skewed tree space complexity is will be always O(1) because you always storing only one child at a time.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
            </ul>


        </div>

    </div>

<script type="text/javascript">
var disqus_url = 'http://www.geeksforgeeks.org/level-order-tree-traversal/';
var disqus_identifier = '2686 http://geeksforgeeks.org/?p=2686';
var disqus_container_id = 'disqus_thread';
var disqus_shortname = 'geeksforgeeks';
var disqus_title = "Level Order Tree Traversal";
var disqus_config_custom = window.disqus_config;
var disqus_config = function () {
    /*
    All currently supported events:
    onReady: fires when everything is ready,
    onNewComment: fires when a new comment is posted,
    onIdentify: fires when user is authenticated
    */
    
    
    this.language = '';
    
    if (disqus_config_custom) {
        disqus_config_custom.call(this);
    }
};

(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>

			</div>
	
					
			
			

		</div> <!-- end post -->	

<br></br>
	
</div> <!-- end content -->

<ul id="sidebar">
	<li id="text-19" class="widget widget_text">			<div class="textwidget"><script>
  (function() {
    var cx = '009682134359037907028:tj6eafkv_be';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//www.google.com/cse/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>

<style type="text/css">
  .gsc-control-cse {
    font-family: "Trebuchet MS", sans-serif;
    border-color: #E1F3DA;
    background-color: #E1F3DA;
  }
  input.gsc-input {
    border-color: #94CC7A;
  }
  input.gsc-search-button {
    border-color: #94CC7A;
    background-color: #AADA92;
  }
  .gsc-tabHeader.gsc-tabhInactive {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gsc-tabHeader.gsc-tabhActive {
    border-color: #A9DA92;
    background-color: #A9DA92;
  }
  .gsc-tabsArea {
    border-color: #A9DA92;
  }
  .gsc-webResult.gsc-result {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gsc-webResult.gsc-result:hover {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gs-webResult.gs-result a.gs-title:link,
  .gs-webResult.gs-result a.gs-title:link b {
    color: #009900;
  }
  .gs-webResult.gs-result a.gs-title:visited,
  .gs-webResult.gs-result a.gs-title:visited b {
    color: #009900;
  }
  .gs-webResult.gs-result a.gs-title:hover,
  .gs-webResult.gs-result a.gs-title:hover b {
    color: #003300;
  }
  .gs-webResult.gs-result a.gs-title:active,
  .gs-webResult.gs-result a.gs-title:active b {
    color: #009900;
  }
  .gsc-cursor-page {
    color: #009900;
  }
  a.gsc-trailing-more-results:link {
    color: #009900;
  }
  .gs-webResult.gs-result .gs-snippet {
    color: #454545;
  }
  .gs-webResult.gs-result .gs-visibleUrl {
    color: #33cc00;
  }
  .gs-webResult.gs-result .gs-visibleUrl-short {
    color: #33cc00;
  }
  .gs-webResult.gs-result .gs-visibleUrl-short {
    display: none;
  }
  .gs-webResult.gs-result .gs-visibleUrl-long {
    display: block;
  }
  .gsc-cursor-box {
    border-color: #A9DA92;
  }
  .gsc-results .gsc-cursor-page {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gsc-results .gsc-cursor-page.gsc-cursor-current-page {
    border-color: #A9DA92;
    background-color: #A9DA92;
  }
  .gs-promotion.gs-result {
    border-color: #94CC7A;
    background-color: #CBE8B4;
  }
  .gs-promotion.gs-result a.gs-title:link {
    color: #0066CC;
  }
  .gs-promotion.gs-result a.gs-title:visited {
    color: #0066CC;
  }
  .gs-promotion.gs-result a.gs-title:hover {
    color: #0066CC;
  }
  .gs-promotion.gs-result a.gs-title:active {
    color: #0066CC;
  }
  .gs-promotion.gs-result .gs-snippet {
    color: #454545;
  }
  .gs-promotion.gs-result .gs-visibleUrl,
  .gs-promotion.gs-result .gs-visibleUrl-short {
    color: #815FA7;
  }
</style>    </div>
		</li>
<li id="text-9" class="widget widget_text">			<div class="textwidget"><div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=138031159685820";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>

<div class="fb-like-box" data-href="https://www.facebook.com/pages/GeeksforGeeks/316764689022" data-width="250" data-height="170" data-colorscheme="light" data-show-faces="true" data-header="false" data-stream="false" data-show-border="false"></div></div>
		</li>
<li id="text-18" class="widget widget_text">			<div class="textwidget"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LargeRectangleSide -->
<ins class="adsbygoogle"
     style="display:inline-block;width:336px;height:280px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="1884636833"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
		</li>
<li id="text-13" class="widget widget_text">			<div class="textwidget"><ul><li><a href="http://www.geeksforgeeks.org/category/interview-experiences/">Interview Experiences</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/advance-data-structures">Advanced Data Structures</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/dynamic-programming">Dynamic Programming</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/Greedy-Algorithm/">Greedy Algorithms</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/backtracking">Backtracking</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/pattern-searching">Pattern Searching</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/divide-and-conquer">Divide & Conquer</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/MathematicalAlgo">Mathematical Algorithms</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/recursion">Recursion</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/geometric-algorithms/">Geometric Algorithms</a></li>
</ul></div>
		</li>
<li id="text-17" class="widget widget_text">			<div class="textwidget"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big 300x600 Sidebar -->
<ins class="adsbygoogle"
     style="display:inline-block;width:300px;height:600px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="4402736037"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
		</li>
<li id="text-14" class="widget widget_text"><h2 class="widgettitle">Popular Posts</h2>
			<div class="textwidget"><ul>
<li><a href="http://www.geeksforgeeks.org/write-a-c-program-to-print-all-permutations-of-a-given-string/">  All permutations of a given string </a></li>
<li><a href="http://www.geeksforgeeks.org/memory-layout-of-c-program/"> Memory Layout of C Programs</a> </li>
<li><a href="http://www.geeksforgeeks.org/understanding-extern-keyword-in-c/"> Understanding “extern” keyword in C</a> </li>
<li><a href="http://www.geeksforgeeks.org/median-of-two-sorted-arrays/">Median of two sorted arrays</a> </li>
<li><a href="http://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/"> Tree traversal without recursion and without stack! </a></li>
<li><a href="http://www.geeksforgeeks.org/structure-member-alignment-padding-and-data-packing/"> Structure Member Alignment, Padding and Data Packing</a> </li>
<li><a href="http://www.geeksforgeeks.org/write-a-function-to-get-the-intersection-point-of-two-linked-lists/"> Intersection point of two Linked Lists</a> </li>
<li><a href="http://www.geeksforgeeks.org/lowest-common-ancestor-in-a-binary-search-tree/"> Lowest Common Ancestor in a BST.</span></a> </li>
<li><a href="http://www.geeksforgeeks.org/a-program-to-check-if-a-binary-tree-is-bst-or-not/"> Check if a binary tree is BST or not</a> </li>
<li><a href="http://www.geeksforgeeks.org/sorted-linked-list-to-balanced-bst/"> Sorted Linked List to Balanced BST</a></li>
</ul></div>
		</li>
<li id="text-3" class="widget widget_text">			<div class="textwidget"><a href="https://twitter.com/GeeksforGeeks" class="twitter-follow-button" data-show-count="false">Follow @GeeksforGeeks</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>         


<!-- GOOGLE FEEDBURNER BUTTON-->
<a href="http://feeds.feedburner.com/Geeksforgeeks" title="Subscribe to my feed" rel="alternate" type="application/rss+xml"><img src="http://www.feedburner.com/fb/images/pub/feed-icon32x32.png" alt="" style="border:0"/></a><a href="http://feeds.feedburner.com/Geeksforgeeks" title="Subscribe to my feed" rel="alternate" type="application/rss+xml">Subscribe</a>

</div>
		</li>
<li id="text-21" class="widget widget_text"><h2 class="widgettitle">Recent Comments</h2>
			<div class="textwidget"><script type="text/javascript" src="http://geeksforgeeks.disqus.com//recent_comments_widget.js?num_items=6&hide_avatars=1&excerpt_length=50&hide_mods=0"></script></div>
		</li>
<li id="text-22" class="widget widget_text">			<div class="textwidget"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LinkAd -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:90px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="2606115235"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LinkAd -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:90px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="2606115235"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LinkAd -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:90px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="2606115235"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
		</li>

</ul>					  
		<div class="clear"></div>

		<div id="footer">
		
		    <div class="xhtml">
                        @geeksforgeeks, <a href="http://creativecommons.org/licenses/by-nc-nd/2.5/in/deed.en_US" title="Valid XHTML Strict 1.0">Some rights reserved</a>  <a href="http://www.geeksforgeeks.org/about/contact-us/"> &nbsp; &nbsp; &nbsp; &nbsp;Contact Us!</a>

		    </div>
		    
		    <div class="credits">
			  Powered by <a href="http://wordpress.org">WordPress </a> &amp; <a href="http://mootools.net/" title="Mootools JavaScript Framework">MooTools</a>, customized by geeksforgeeks team </div>
			  
		   <div class="clear"></div>						                            
		   
		</div> <!--end footer-->  
        
		        <script type="text/javascript">
        // <![CDATA[
        var disqus_shortname = 'geeksforgeeks';
        (function () {
            var nodes = document.getElementsByTagName('span');
            for (var i = 0, url; i < nodes.length; i++) {
                if (nodes[i].className.indexOf('dsq-postid') != -1) {
                    nodes[i].parentNode.setAttribute('data-disqus-identifier', nodes[i].getAttribute('rel'));
                    url = nodes[i].parentNode.href.split('#', 1);
                    if (url.length == 1) { url = url[0]; }
                    else { url = url[1]; }
                    nodes[i].parentNode.href = url + '#disqus_thread';
                }
            }
            var s = document.createElement('script'); 
            s.async = true;
            s.type = 'text/javascript';
            s.src = '//' + disqus_shortname + '.disqus.com/count.js';
            (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
        }());
        // ]]>
        </script>
        <script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/scripts/shCore.js?ver=3.0.9'></script>
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/scripts/shBrushCpp.js?ver=3.0.9'></script>
<script type='text/javascript'>
	(function(){
		var corecss = document.createElement('link');
		var themecss = document.createElement('link');
		var corecssurl = "http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/styles/shCore.css?ver=3.0.9";
		if ( corecss.setAttribute ) {
				corecss.setAttribute( "rel", "stylesheet" );
				corecss.setAttribute( "type", "text/css" );
				corecss.setAttribute( "href", corecssurl );
		} else {
				corecss.rel = "stylesheet";
				corecss.href = corecssurl;
		}
		document.getElementsByTagName("head")[0].insertBefore( corecss, document.getElementById("syntaxhighlighteranchor") );
		var themecssurl = "http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/styles/shThemeDefault.css?ver=3.0.9";
		if ( themecss.setAttribute ) {
				themecss.setAttribute( "rel", "stylesheet" );
				themecss.setAttribute( "type", "text/css" );
				themecss.setAttribute( "href", themecssurl );
		} else {
				themecss.rel = "stylesheet";
				themecss.href = themecssurl;
		}
		//document.getElementById("syntaxhighlighteranchor").appendChild(themecss);
		document.getElementsByTagName("head")[0].insertBefore( themecss, document.getElementById("syntaxhighlighteranchor") );
	})();
	SyntaxHighlighter.config.strings.expandSource = '+ expand source';
	SyntaxHighlighter.config.strings.help = '?';
	SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
	SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
	SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
	SyntaxHighlighter.defaults['gutter'] = false;
	SyntaxHighlighter.defaults['pad-line-numbers'] = true;
	SyntaxHighlighter.defaults['toolbar'] = false;
	SyntaxHighlighter.all();
</script>
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/bbpress/templates/default/js/editor.js?ver=2.5.4-5380'></script>
				  
		</div> <!--end wrapper-->
        <div id="ajaxSpinner"></div> <!--For AJAX spinner holder-->
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-12148232-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
	</body>

</html>
<!-- Dynamic page generated in 0.248 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2014-11-27 23:26:27 -->

<!-- Compression = gzip -->
<!-- super cache -->