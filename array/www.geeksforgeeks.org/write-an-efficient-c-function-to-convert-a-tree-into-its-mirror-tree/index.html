<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
       <title>Write an Efficient C Function to Convert a Binary Tree into its Mirror Tree - GeeksforGeeks</title>
       <style type="text/css" media="screen">
          @import url('http://d2o58evtke57tz.cloudfront.net/wp-content/themes/minimoo/style.css');
    </style>
      <link href="http://d2o58evtke57tz.cloudfront.net/wp-content/themes/minimoo/favicon.ico" rel="shortcut icon" />    
    
<!-- This site is optimized with the Yoast WordPress SEO plugin v1.7.1 - https://yoast.com/wordpress/plugins/seo/ -->
<link rel="canonical" href="http://www.geeksforgeeks.org/write-an-efficient-c-function-to-convert-a-tree-into-its-mirror-tree/" />
<meta property="og:locale" content="en_US" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Write an Efficient C Function to Convert a Binary Tree into its Mirror Tree - GeeksforGeeks" />
<meta property="og:description" content="Mirror of a Tree: Mirror of a Binary Tree T is another Binary Tree M(T) with left and right children of all non-leaf nodes interchanged. Trees in the below figure are mirror of each other Algorithm - Mirror(tree): (1) Call Mirror for left-subtree i.e., Mirror(left-subtree) (2) Call Mirror for right-subtree i.e., Mirror(left-subtree) (3) Swap left &hellip;" />
<meta property="og:url" content="http://www.geeksforgeeks.org/write-an-efficient-c-function-to-convert-a-tree-into-its-mirror-tree/" />
<meta property="og:site_name" content="GeeksforGeeks" />
<meta property="article:tag" content="Convert to Mirror" />
<meta property="article:tag" content="Get the Mirror" />
<meta property="article:tag" content="Mirror Tree" />
<meta property="article:tag" content="Tree Traveral" />
<meta property="article:tag" content="Trees" />
<meta property="article:section" content="Trees" />
<meta property="article:published_time" content="2009-06-27T01:58:23+00:00" />
<meta property="article:modified_time" content="2011-04-19T12:35:35+00:00" />
<meta property="og:updated_time" content="2011-04-19T12:35:35+00:00" />
<meta property="og:image" content="http://geeksforgeeks.org/wp-content/uploads/2009/06/MirrorTree1.GIF" />
<!-- / Yoast WordPress SEO plugin. -->

<link rel='stylesheet' id='wp-quicklatex-format-css'  href='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/wp-quicklatex/css/quicklatex-format.css?ver=4.0.1' type='text/css' media='all' />
<link rel='stylesheet' id='bbp-default-css'  href='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/bbpress/templates/default/css/bbpress.css?ver=2.5.4-5380' type='text/css' media='screen' />
<link rel='stylesheet' id='wp-pagenavi-css'  href='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/wp-pagenavi/pagenavi-css.css?ver=2.70' type='text/css' media='all' />
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-includes/js/jquery/jquery.js?ver=1.11.1'></script>
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-includes/js/jquery/jquery-migrate.min.js?ver=1.2.1'></script>
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/wp-quicklatex/js/wp-quicklatex-frontend.js?ver=1.0'></script>

<!-- Bad Behavior 2.2.16 run time: 1.519 ms -->
<script type="text/javascript">
<!--
function bb2_addLoadEvent(func) {
	var oldonload = window.onload;
	if (typeof window.onload != 'function') {
		window.onload = func;
	} else {
		window.onload = function() {
			oldonload();
			func();
		}
	}
}

bb2_addLoadEvent(function() {
	for ( i=0; i < document.forms.length; i++ ) {
		if (document.forms[i].method == 'post') {
			var myElement = document.createElement('input');
			myElement.setAttribute('type', 'hidden');
			myElement.name = 'bb2_screener_';
			myElement.value = '1417111165 210.212.53.139 172.19.11.169';
			document.forms[i].appendChild(myElement);
		}
	}
});
// --></script>
		<style type="text/css" id="syntaxhighlighteranchor"></style>
   <meta name="google-site-verification" content="rHK2v8_zzuAZQY8JHAzbllDN8u-aQxcn2Kqnp67Old0" />
</head>

<body>
<!-- o4dI0sCXUgoSONabbd8mbZ4SA3E -->    
    <div id="wrapper">
        <div class="blog-info">
                <h1 class="blog-title">
                <a href="http://www.geeksforgeeks.org" title="GeeksforGeeks">GeeksforGeeks</a>
            </h1>
       
            <div class="blog-description">
                A computer science portal for geeks            </div>
        </div>
        <b><p>  <h2 align="right"> <a href="http://geeksquiz.com/">GeeksQuiz</a></h2> 
   <a href="http://www.geeksforgeeks.org/wp-login.php">Login</a> 
         </p></b>  
         
         <div class="clear"></div>         
              
                     
            <div id="menu">   
                 <ul>
 <li><a href="http://www.geeksforgeeks.org">Home</a></li>
  <li><a href="http://www.geeksforgeeks.org/fundamentals-of-algorithms/">Algorithms</a></li>
 <li><a href="http://www.geeksforgeeks.org/data-structures/">DS</a></li>
  <li><a href="http://www.geeksforgeeks.org/gate-corner/">GATE</a></li>
  <li><a href="http://www.geeksforgeeks.org/about/interview-corner/">Interview Corner</a></li>
  <li><a href="http://www.geeksforgeeks.org/forums/">Q&A</a></li>
  <li><a href="http://www.geeksforgeeks.org/c/">C</a></li>
  <li><a href="http://www.geeksforgeeks.org/c-plus-plus/">C++</a></li>
  <li><a href="http://www.geeksforgeeks.org/java/">Java</a></li>
  <li><a href="http://www.geeksforgeeks.org/books/">Books</a></li>
  <li><a href="http://www.geeksforgeeks.org/contribute/">Contribute</a></li>
  <li><a href="http://www.geeksforgeeks.org/contribute/ask-a-question/">Ask a Q</a></li>
  <li><a href="http://www.geeksforgeeks.org/about/">About</a></li>
            </ul>

               
            <div class="clear"></div>     
        </div>
             <div id="navmenu">
				<ul id="menu" style="padding:0; margin:0;">
						<li class="cat-item cat-item-3"><a href="http://www.geeksforgeeks.org/category/c-arrays/" title="Questions regarding Arrays">Array</a>
</li>	

	<li class="cat-item cat-item-17"><a href="http://www.geeksforgeeks.org/category/bit-magic/" title="View all posts filed under Bit Magic">Bit Magic</a>
</li>
	<li class="cat-item cat-item-14"><a href="http://www.geeksforgeeks.org/category/c-puzzles/" title="View all posts filed under C/C++ Puzzles">C/C++</a>
</li>

<li class="cat-item cat-item-18"><a href="http://www.geeksforgeeks.org/category/articles/" title="View all posts filed under Articles">Articles</a>
</li>

	<li class="cat-item cat-item-67"><a href="http://www.geeksforgeeks.org/category/gfact/" title="View all posts filed under GFacts">GFacts</a>
</li>
	<li class="cat-item cat-item-8"><a href="http://www.geeksforgeeks.org/category/linked-list/" title="Linked List problems">Linked List</a>
</li>
	<li class="cat-item cat-item-66"><a href="http://www.geeksforgeeks.org/category/multiple-choice-question/" title="View all posts filed under MCQ">MCQ</a>

</li>
	<li class="cat-item cat-item-4"><a href="http://www.geeksforgeeks.org/category/c-programs/" title="Miscellaneous">Misc</a>
</li>
	<li class="cat-item cat-item-5"><a href="http://www.geeksforgeeks.org/category/program-output/" title="View all posts filed under Output">Output</a>
</li>
	<li class="cat-item cat-item-7"><a href="http://www.geeksforgeeks.org/category/c-strings/" title="Questions related to strings">String</a>
</li>
	<li class="cat-item cat-item-19"><a href="http://www.geeksforgeeks.org/category/tree/" title="View all posts filed under Trees">Tree</a>
</li>
	<li class="cat-item cat-item-19"><a href="http://www.geeksforgeeks.org/category/graph/" title="View all posts filed under Graph">Graph</a>
</li>
</ul>
        </div>
             <div id="content">	   	
	<div class="post" id="post">
							<div class="post-info">			
					<div class="post-title-info">
						<h2 class="post-title">Write an Efficient C Function to Convert a Binary Tree into its Mirror Tree</h2>
					</div>			
					<div class="clear"></div>				  
				<div class="post-content" id="post-content">
					<p>Mirror of a Tree: Mirror of a Binary Tree T is another Binary Tree M(T) with left and right children of all non-leaf nodes interchanged.<br />
<span id="more-662"></span><br />
<img src="http://geeksforgeeks.org/wp-content/uploads/2009/06/MirrorTree1.GIF" alt="MirrorTree1" title="MirrorTree1" width="366" height="173" class="aligncenter size-full wp-image-663" /><br />
Trees in the below figure are mirror of each other<br />
<strong><br />
Algorithm </strong>- Mirror(tree):</p>
<pre>
(1)  Call Mirror for left-subtree    i.e., Mirror(left-subtree)
(2)  Call Mirror for right-subtree  i.e., Mirror(left-subtree)
(3)  Swap left and right subtrees.
          temp = left-subtree
          left-subtree = right-subtree
          right-subtree = temp
</pre>
<p><strong>Program:</strong></p>
<pre class="brush: cpp; title: ; notranslate" title="">
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

/* A binary tree node has data, pointer to left child 
   and a pointer to right child */
struct node 
{
    int data;
    struct node* left;
    struct node* right;
};

/* Helper function that allocates a new node with the
   given data and NULL left and right pointers. */
struct node* newNode(int data)

{
  struct node* node = (struct node*)
                       malloc(sizeof(struct node));
  node-&gt;data = data;
  node-&gt;left = NULL;
  node-&gt;right = NULL;
  
  return(node);
}


/* Change a tree so that the roles of the  left and 
    right pointers are swapped at every node.

 So the tree...
       4
      / \
     2   5
    / \
   1   3

 is changed to...
       4
      / \
     5   2
        / \
       3   1
*/
void mirror(struct node* node) 
{
  if (node==NULL) 
    return;  
  else 
  {
    struct node* temp;
    
    /* do the subtrees */
    mirror(node-&gt;left);
    mirror(node-&gt;right);

    /* swap the pointers in this node */
    temp        = node-&gt;left;
    node-&gt;left  = node-&gt;right;
    node-&gt;right = temp;
  }
} 


/* Helper function to test mirror(). Given a binary
   search tree, print out its data elements in 
   increasing sorted order.*/
void inOrder(struct node* node) 
{
  if (node == NULL) 
    return;
  
  inOrder(node-&gt;left);
  printf(&quot;%d &quot;, node-&gt;data);

  inOrder(node-&gt;right);
}  


/* Driver program to test mirror() */
int main()
{
  struct node *root = newNode(1);
  root-&gt;left        = newNode(2);
  root-&gt;right       = newNode(3);
  root-&gt;left-&gt;left  = newNode(4);
  root-&gt;left-&gt;right = newNode(5); 
  
  /* Print inorder traversal of the input tree */
  printf(&quot;\n Inorder traversal of the constructed tree is \n&quot;);
  inOrder(root);
  
  /* Convert tree to its mirror */
  mirror(root); 
  
  /* Print inorder traversal of the mirror tree */
  printf(&quot;\n Inorder traversal of the mirror tree is \n&quot;);  
  inOrder(root);
  
  getchar();
  return 0;  
}
</pre>
<p><strong>Time &#038; Space Complexities:</strong>  This program is similar to traversal of tree space and time complexities will be same as Tree traversal (Please see our <a href="http://geeksforgeeks.org/?p=618">Tree Traversal</a> post for details)</p>
		
&nbsp;
&nbsp;
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle"
     style="display:inline-block;width:336px;height:280px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="4061219431"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>



&nbsp;
&nbsp;
&nbsp;
<h3>Related Topics:</h3><ul><li><a href="http://www.geeksforgeeks.org/perfect-binary-tree-specific-level-order-traversal/" title="Perfect Binary Tree Specific Level Order Traversal">Perfect Binary Tree Specific Level Order Traversal</a></li><li><a href="http://www.geeksforgeeks.org/print-nodes-top-view-binary-tree/" title="Print Nodes in Top View of Binary Tree">Print Nodes in Top View of Binary Tree</a></li><li><a href="http://www.geeksforgeeks.org/k-dimensional-tree/" title="K Dimensional Tree">K Dimensional Tree</a></li><li><a href="http://www.geeksforgeeks.org/convert-binary-tree-threaded-binary-tree/" title="Convert a Binary Tree to Threaded binary tree">Convert a Binary Tree to Threaded binary tree</a></li><li><a href="http://www.geeksforgeeks.org/serialize-deserialize-n-ary-tree/" title="Serialize and Deserialize an N-ary Tree">Serialize and Deserialize an N-ary Tree</a></li><li><a href="http://www.geeksforgeeks.org/serialize-deserialize-binary-tree/" title="Serialize and Deserialize a Binary Tree">Serialize and Deserialize a Binary Tree</a></li><li><a href="http://www.geeksforgeeks.org/given-binary-tree-print-nodes-two-given-level-numbers/" title="Print nodes between two given level numbers of a binary tree">Print nodes between two given level numbers of a binary tree</a></li><li><a href="http://www.geeksforgeeks.org/find-height-binary-tree-represented-parent-array/" title="Find Height of Binary Tree represented by Parent array">Find Height of Binary Tree represented by Parent array</a></li></ul>
<p>Tags: <a href="http://www.geeksforgeeks.org/tag/convert-to-mirror/" rel="tag">Convert to Mirror</a>, <a href="http://www.geeksforgeeks.org/tag/get-the-mirror/" rel="tag">Get the Mirror</a>, <a href="http://www.geeksforgeeks.org/tag/mirror-tree/" rel="tag">Mirror Tree</a>, <a href="http://www.geeksforgeeks.org/tag/tree-traveral/" rel="tag">Tree Traveral</a>, <a href="http://www.geeksforgeeks.org/tag/tree/" rel="tag">Trees</a></p> 
<div>
<iframe src="http://www.facebook.com/plugins/like.php?href=http%3A%2F%2Fwww.geeksforgeeks.org%2Fwrite-an-efficient-c-function-to-convert-a-tree-into-its-mirror-tree%2F&layout=button_count&show_faces=false&width=90&action=like&colorscheme=light" scrolling="no" frameborder="0" allowTransparency="true" style="border:none; overflow:hidden; width:90px; height:20px"></iframe>
<a href="http://twitter.com/share" class="twitter-share-button" data-url="http://www.geeksforgeeks.org/write-an-efficient-c-function-to-convert-a-tree-into-its-mirror-tree/" data-text="Write an Efficient C Function to Convert a Binary Tree into its Mirror Tree" data-count="horizontal" data-via="jakerutter">Tweet</a><script type="text/javascript" src="http://platform.twitter.com/widgets.js"></script>
<g:plusone size="medium" href="http://www.geeksforgeeks.org/write-an-efficient-c-function-to-convert-a-tree-into-its-mirror-tree/"></g:plusone>
<!-- Place this render call where appropriate -->
<script type="text/javascript">
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script></div>





				</div>		  
			</div> <!-- end post main -->					
			<div class="post-meta">
				<div class="left"></div>				
				<div class="clear"></div>
			</div>			
        
			<div class="comments-main">		
 <b>Writing code in comment?</b> Please use <b><a href="http://ideone.com/">ideone.com</a></b> and share the link here.
				
<div id="disqus_thread">
            <div id="dsq-content">


            <ul id="dsq-comments">
                    <li class="comment even thread-even depth-1" id="dsq-comment-34397">
        <div id="dsq-comment-header-34397" class="dsq-comment-header">
            <cite id="dsq-cite-34397">
                <span id="dsq-author-user-34397">alien</span>
            </cite>
        </div>
        <div id="dsq-comment-body-34397" class="dsq-comment-body">
            <div id="dsq-comment-message-34397" class="dsq-comment-message"><p>I think both preorder and post order traversal will work. But inorder traversal won&#8217;t work</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-33714">
        <div id="dsq-comment-header-33714" class="dsq-comment-header">
            <cite id="dsq-cite-33714">
                <span id="dsq-author-user-33714">Krishana</span>
            </cite>
        </div>
        <div id="dsq-comment-body-33714" class="dsq-comment-body">
            <div id="dsq-comment-message-33714" class="dsq-comment-message"><p>This is really confusing why we are not using double pointer instead of single pointer. I think this swap not reflect in main. Please anyone explain this</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-2" id="dsq-comment-33800">
        <div id="dsq-comment-header-33800" class="dsq-comment-header">
            <cite id="dsq-cite-33800">
                <span id="dsq-author-user-33800">Ankur Sao</span>
            </cite>
        </div>
        <div id="dsq-comment-body-33800" class="dsq-comment-body">
            <div id="dsq-comment-message-33800" class="dsq-comment-message"><p>There is no change in the root of the tree. We need double pointers only in case where root is changing.for eg, adding new link in the beginning of a linked list.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-33199">
        <div id="dsq-comment-header-33199" class="dsq-comment-header">
            <cite id="dsq-cite-33199">
                <span id="dsq-author-user-33199">Marsha Donna</span>
            </cite>
        </div>
        <div id="dsq-comment-body-33199" class="dsq-comment-body">
            <div id="dsq-comment-message-33199" class="dsq-comment-message"><p>following is the link to create a new tree which is mirror of existing tree</p>
<p><a href="http://ideone.com/EtQ9TK" rel="nofollow">http://ideone.com/EtQ9TK</a></p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-28809">
        <div id="dsq-comment-header-28809" class="dsq-comment-header">
            <cite id="dsq-cite-28809">
                <span id="dsq-author-user-28809">Rakesh</span>
            </cite>
        </div>
        <div id="dsq-comment-body-28809" class="dsq-comment-body">
            <div id="dsq-comment-message-28809" class="dsq-comment-message"><p>Comments Appreciated !!</p>
<p>struct Tnode *swaptree(struct Tnode *p)<br />
{</p>
<p>       struct Tnode *t1,*t2;</p>
<p>       if(p!=NULL)</p>
<p>       {</p>
<p>                  t1=swaptree(p-&gt;lchild);</p>
<p>                  t2=swaptree(p-&gt;rchild);</p>
<p>                  p-&gt;lchild=t2;</p>
<p>                  p-&gt;rchild=t1;</p>
<p>       }</p>
<p>       return p;                  </p>
<p>}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-28034">
        <div id="dsq-comment-header-28034" class="dsq-comment-header">
            <cite id="dsq-cite-28034">
                <span id="dsq-author-user-28034">samsammy</span>
            </cite>
        </div>
        <div id="dsq-comment-body-28034" class="dsq-comment-body">
            <div id="dsq-comment-message-28034" class="dsq-comment-message"><p>@d4868dd64c637016efc578852ad7cd68:disqus<br />
Algorithm &#8211; Mirror(tree):</p>
<p>(1)  Call Mirror for left-subtree    i.e., Mirror(left-subtree)<br />
(2)  Call Mirror for right-subtree  i.e., Mirror(left-subtree)</p>
<p>(2) should be- Call Mirror for right-subtree  i.e., Mirror(right-subtree)</p>
<p>Correct me If I am missing something..</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-27975">
        <div id="dsq-comment-header-27975" class="dsq-comment-header">
            <cite id="dsq-cite-27975">
                <span id="dsq-author-user-27975">Sumit Monga</span>
            </cite>
        </div>
        <div id="dsq-comment-body-27975" class="dsq-comment-body">
            <div id="dsq-comment-message-27975" class="dsq-comment-message"><p>First the left and right subtrees need to be done. Before it ,temp should not be declared as it will take stack space until it starts popping off the stack. temp should be allocated on the stack only after doing the left and right subtrees as then only one stack frame will be used at any time(idea of tail recursion).</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-27251">
        <div id="dsq-comment-header-27251" class="dsq-comment-header">
            <cite id="dsq-cite-27251">
                <span id="dsq-author-user-27251">Subrahmanyan Sankaran</span>
            </cite>
        </div>
        <div id="dsq-comment-body-27251" class="dsq-comment-body">
            <div id="dsq-comment-message-27251" class="dsq-comment-message"><p><code><br />
// TreeMirror.cpp : Defines the entry point for the console application.<br />
//<br />
#include "stdafx.h"<br />
#include<br />
using namespace std;<br />
struct Node<br />
{<br />
    int data;<br />
    Node *left;<br />
    Node *right;<br />
};<br />
class Tree<br />
{<br />
    static int l;<br />
    static int flip;<br />
    static int leafdepth;<br />
    static Node * prev;<br />
    static int count;<br />
public:<br />
     Node *head;<br />
     int maxdepth;<br />
Tree()<br />
{<br />
     prev = NULL;<br />
     head = NULL;<br />
     maxdepth = 0;<br />
}<br />
void Mirror(Node *node)<br />
{<br />
     Node *tmp;<br />
     if(node)<br />
     {<br />
         tmp = node-&gt;left;<br />
         node-&gt;left = node-&gt;right;<br />
         node-&gt;right = tmp;<br />
         Mirror(node-&gt;left);<br />
         Mirror(node-&gt;right);<br />
      }<br />
}<br />
void Inorder(Node *node)<br />
{<br />
        if(node)<br />
        {<br />
              Inorder(node-&gt;left);<br />
              std::cout&lt;data;<br />
              Inorder(node-&gt;right);<br />
         }<br />
}<br />
void InsertNode(Node *node,int data)<br />
{<br />
            Node * tmp = node;<br />
            if(head == NULL)<br />
           {<br />
             head = new Node;<br />
             head-&gt;data = data;<br />
             head-&gt;left = NULL;<br />
             head-&gt;right = NULL;<br />
             return;<br />
           }<br />
           else if(tmp)<br />
            {<br />
              prev = tmp;<br />
                if(data &gt; tmp-&gt;data)<br />
                {<br />
                      l=0;<br />
                       tmp = tmp -&gt; right;<br />
                       InsertNode(tmp,data);<br />
                }<br />
                else<br />
               {<br />
                     l=1;<br />
                     InsertNode(tmp-&gt;left,data);<br />
               }<br />
             }<br />
                if(l == 1)<br />
               {<br />
                    prev-&gt;left = new Node;<br />
                    prev-&gt;left-&gt;data = data;<br />
                    prev-&gt;left-&gt;left = NULL;<br />
                    prev-&gt;left-&gt;right = NULL;<br />
                    l = -1;<br />
                    return;<br />
                 }<br />
                 else if(l == 0)<br />
                 {<br />
                    prev-&gt;right = new Node;<br />
                    prev-&gt;right-&gt;data = data;<br />
                    prev-&gt;right-&gt;left = NULL;<br />
                    prev-&gt;right-&gt;right = NULL;<br />
                     l = -1;<br />
                     return;<br />
                 }<br />
  }</p>
<p>};<br />
int Tree::l =0;<br />
int Tree::flip =0;<br />
int Tree::leafdepth =-1;<br />
int Tree::count = 0;<br />
Node * Tree::prev = NULL;<br />
int _tmain(int argc, _TCHAR* argv[])<br />
{<br />
Tree t;<br />
t.InsertNode(t.head,2);<br />
t.InsertNode(t.head,1);<br />
t.InsertNode(t.head,4);<br />
t.InsertNode(t.head,3);<br />
t.InsertNode(t.head,5);<br />
t.Inorder(t.head);<br />
t.Mirror(t.head);<br />
t.Inorder(t.head);<br />
return 0;<br />
}</p>
<p></code></p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-hemanthreddy even thread-odd thread-alt depth-1" id="dsq-comment-24183">
        <div id="dsq-comment-header-24183" class="dsq-comment-header">
            <cite id="dsq-cite-24183">
                <span id="dsq-author-user-24183">hemanthreddy</span>
            </cite>
        </div>
        <div id="dsq-comment-body-24183" class="dsq-comment-body">
            <div id="dsq-comment-message-24183" class="dsq-comment-message"><pre> <code language="C">
struct node * mirror_tree(struct node *root)
{
	struct node *temp;
	if(!root || !root-&gt;left &amp;&amp; !root-&gt;right)
		return root;
	temp = root-&gt;left;
	root-&gt;left = mirror_tree(root-&gt;right);
	root-&gt;right = mirror_tree(temp);
	return root;
}
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-19653">
        <div id="dsq-comment-header-19653" class="dsq-comment-header">
            <cite id="dsq-cite-19653">
                <span id="dsq-author-user-19653">Hanish Bansal</span>
            </cite>
        </div>
        <div id="dsq-comment-body-19653" class="dsq-comment-body">
            <div id="dsq-comment-message-19653" class="dsq-comment-message"><p>This can also be done in preorder</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-19135">
        <div id="dsq-comment-header-19135" class="dsq-comment-header">
            <cite id="dsq-cite-19135">
                <span id="dsq-author-user-19135">Ashish</span>
            </cite>
        </div>
        <div id="dsq-comment-body-19135" class="dsq-comment-body">
            <div id="dsq-comment-message-19135" class="dsq-comment-message"><p>Why are we not passing double pointer to root node<br />
as we are trying to modify the root node(like we do in insert() fuction).Don&#8217;t you think that the original root pointer will be unchanged by this mirror function?</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-20693">
        <div id="dsq-comment-header-20693" class="dsq-comment-header">
            <cite id="dsq-cite-20693">
                <span id="dsq-author-user-20693">lizard</span>
            </cite>
        </div>
        <div id="dsq-comment-body-20693" class="dsq-comment-body">
            <div id="dsq-comment-message-20693" class="dsq-comment-message"><p>In the mirror tree root node remains same&#8230;.<br />
so it is not required to modify the root node&#8230;only the left and right pointers of root node are being modified&#8230;</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-19134">
        <div id="dsq-comment-header-19134" class="dsq-comment-header">
            <cite id="dsq-cite-19134">
                <span id="dsq-author-user-19134">Ashish</span>
            </cite>
        </div>
        <div id="dsq-comment-body-19134" class="dsq-comment-body">
            <div id="dsq-comment-message-19134" class="dsq-comment-message"><p>why are we not passing double pointer for root in mirror() as we are trying to modify the root pointer(like we do in insert() function)? I think,passing single pointer will not change the original root pointer.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</li><!-- #comment-## -->
    <li class="comment byuser comment-author-abhishek08aug odd alt thread-odd thread-alt depth-1" id="dsq-comment-18038">
        <div id="dsq-comment-header-18038" class="dsq-comment-header">
            <cite id="dsq-cite-18038">
                <span id="dsq-author-user-18038">abhishek08aug</span>
            </cite>
        </div>
        <div id="dsq-comment-body-18038" class="dsq-comment-body">
            <div id="dsq-comment-message-18038" class="dsq-comment-message"><p>C++ code extended from my post on: <a href="http://www.geeksforgeeks.org/write-a-c-program-to-delete-a-tree/" rel="nofollow">http://www.geeksforgeeks.org/write-a-c-program-to-delete-a-tree/</a></p>
<pre> <code language="C">
#include&lt;iostream&gt;
using namespace std;
 
class tree_node {
  private:
    int data;
    tree_node * left;
    tree_node * right;
  public:
    tree_node() {
      left=NULL;
      right=NULL;
    }
    void set_data(int data) {
      this-&gt;data=data;
    }
    int get_data() {
      return this-&gt;data;
    }
    void set_left(tree_node * left) {
      this-&gt;left=left;
    }
    tree_node * get_left() {
      return this-&gt;left;
    }
    void set_right(tree_node * right) {
      this-&gt;right=right;
    }
    tree_node * get_right() {
      return this-&gt;right;
    }
    tree_node ** get_left_ref() {
      return &amp;(this-&gt;left);
    }
    tree_node ** get_right_ref() {
      return &amp;(this-&gt;right);
    }
};
 
class tree {
  private:
    tree_node * root;
    int size;
    void _recursive_insert(tree_node ** root_ref, int value);
    void _print_preorder(tree_node * root);
    void _print_inorder(tree_node * root);
    void _print_postorder(tree_node * root);
    int _find_size(tree_node * root);
    int _are_identical(tree_node * tn1, tree_node * tn2);
    int _find_height(tree_node * root);
    void _delete_tree(tree_node ** root);
    void _mirror(tree_node * root);
  public:
    tree() {
      root=NULL;
      size=0;
    }
    void insert(int value);
    void recursive_insert(int value);
    void print_preorder();
    void print_inorder();
    void print_postorder();
    int find_size();
    int get_size() {
      return this-&gt;size;
    }
    int are_identical(tree t);
    int find_height();
    void delete_tree();
    void mirror();
};
 
void tree::insert(int value) {
  if(root==NULL) {
    root=new tree_node;
    root-&gt;set_data(value);
  } else {
    tree_node * parent=NULL;
    tree_node * current=root;
    tree_node * new_node=new tree_node;
    new_node-&gt;set_data(value);
    while(current!=NULL) {
      if(value&lt;=current-&gt;get_data()) {
        parent=current;
        current=current-&gt;get_left();
      } else {
        parent=current;
        current=current-&gt;get_right();
      }
    }
    if(value&lt;=parent-&gt;get_data() &amp;&amp; parent-&gt;get_left()==NULL) {
      parent-&gt;set_left(new_node);
    } else if(value&gt;parent-&gt;get_data() &amp;&amp; parent-&gt;get_right()==NULL) {
      parent-&gt;set_right(new_node);
    }
  }
  size++;
}
 
void tree::recursive_insert(int value) {
  _recursive_insert(&amp;root, value);
  size++;
}
 
void tree::_recursive_insert(tree_node ** root_ref, int value) {
  if(*root_ref==NULL) {
    tree_node * new_node=new tree_node;
    new_node-&gt;set_data(value);
    *root_ref=new_node;   
  } else {
    if(value&lt;=(*root_ref)-&gt;get_data()) {
      _recursive_insert((*root_ref)-&gt;get_left_ref(), value);
    } else {
      _recursive_insert((*root_ref)-&gt;get_right_ref(), value);
    }
  }
}
 
void tree::print_preorder() {
  if(root==NULL) {
    return;
  }
  _print_preorder(root);
  cout&lt;&lt;endl;
}
 
void tree::_print_preorder(tree_node * root) {
  if(root==NULL) {
    return;
  }
  cout&lt;&lt;root-&gt;get_data()&lt;&lt;&quot; &quot;;
  if(root-&gt;get_left()!=NULL)
    _print_preorder(root-&gt;get_left());
  if(root-&gt;get_right()!=NULL)
    _print_preorder(root-&gt;get_right());
}
 
void tree::print_inorder() {
  if(root==NULL) {
    return;
  }
  _print_inorder(root);
  cout&lt;&lt;endl;
}
 
void tree::_print_inorder(tree_node * root) {
  if(root==NULL) {
    return;
  }
  if(root-&gt;get_left()!=NULL)
    _print_inorder(root-&gt;get_left());
  cout&lt;&lt;root-&gt;get_data()&lt;&lt;&quot; &quot;;
  if(root-&gt;get_right()!=NULL)
    _print_inorder(root-&gt;get_right());
}
 
void tree::print_postorder() {
  if(root==NULL) {
    return;
  }
  _print_postorder(root);
  cout&lt;&lt;endl;
}
 
void tree::_print_postorder(tree_node * root) {
  if(root==NULL) {
    return;
  }
  if(root-&gt;get_left()!=NULL)
    _print_postorder(root-&gt;get_left());
  if(root-&gt;get_right()!=NULL)
    _print_postorder(root-&gt;get_right());
  cout&lt;&lt;root-&gt;get_data()&lt;&lt;&quot; &quot;;
}

int tree::find_size() {
  return _find_size(root);
}

int tree::_find_size(tree_node * root) {
  if(root==NULL) {
    return 0;
  } else {
    return 1+_find_size(root-&gt;get_left())+_find_size(root-&gt;get_right());
  }
}

int tree::are_identical(tree t) {
  return _are_identical(this-&gt;root, t.root);
}

int tree::_are_identical(tree_node * tn1, tree_node * tn2) {
  if(tn1==NULL &amp;&amp; tn2==NULL) {
    return 1;
  } else if((tn1==NULL &amp;&amp; tn2!=NULL) || (tn1!=NULL &amp;&amp; tn2==NULL) || (tn1-&gt;get_data()!=tn2-&gt;get_data())) {
    return 0;
  } else {
    return _are_identical(tn1-&gt;get_left(), tn2-&gt;get_left()) &amp;&amp; _are_identical(tn1-&gt;get_right(), tn2-&gt;get_right());
  }
}

int tree::find_height() {
  return _find_height(root);
}

int tree::_find_height(tree_node * root) {
  if(root==NULL) {
    return 0;
  }
  else {
    return 1+max(_find_height(root-&gt;get_left()), _find_height(root-&gt;get_right()));
  }
}

void tree::delete_tree() {
  _delete_tree(&amp;root);
  size=0;
}

void tree::_delete_tree(tree_node ** root) {
  if(*root==NULL) {
    return;
  } else {
    if((*root)-&gt;get_left()!=NULL) {
      _delete_tree((*root)-&gt;get_left_ref());
    }
    if((*root)-&gt;get_right()!=NULL) {
      _delete_tree((*root)-&gt;get_right_ref());
    }
    delete(*root);
    *root=NULL;
  }
}

/* alternate _delete_tree */
/*
void tree::_delete_tree(tree_node ** root) {
  if(*root==NULL) {
    return;
  } else {
    if((*root)-&gt;get_left()!=NULL) {
      tree_node * left_ref=(*root)-&gt;get_left();
      _delete_tree(&amp;left_ref);
    }
    if((*root)-&gt;get_right()!=NULL) {
      tree_node * right_ref=(*root)-&gt;get_right();
      _delete_tree(&amp;right_ref);
    }
    delete(*root);
    *root=NULL;
  }
}
*/

void tree::_mirror(tree_node * root) {
  if(root==NULL) {
    return;
  }

  tree_node * temp=root-&gt;get_left();
  root-&gt;set_left(root-&gt;get_right());
  root-&gt;set_right(temp);
  _mirror(root-&gt;get_left());
  _mirror(root-&gt;get_right());
}

void tree::mirror() {
  _mirror(root);
}

int main() {
  tree t1;

  t1.recursive_insert(5);
  t1.recursive_insert(3);
  t1.insert(1);
  t1.insert(7);
  t1.recursive_insert(50);
  t1.recursive_insert(6);

  cout&lt;&lt;&quot;Inorder Traversal&quot;&lt;&lt;endl;
  t1.print_inorder();
  cout&lt;&lt;&quot;Size of the tree is: &quot;&lt;&lt;t1.find_size()&lt;&lt;endl;
  cout&lt;&lt;&quot;Size of the tree is: &quot;&lt;&lt;t1.get_size()&lt;&lt;endl;
  cout&lt;&lt;&quot;Height of the tree is: &quot;&lt;&lt;t1.find_height()&lt;&lt;endl;

  t1.mirror();

  cout&lt;&lt;&quot;Inorder Traversal&quot;&lt;&lt;endl;
  t1.print_inorder();
  cout&lt;&lt;&quot;Size of the tree is: &quot;&lt;&lt;t1.find_size()&lt;&lt;endl;
  cout&lt;&lt;&quot;Size of the tree is: &quot;&lt;&lt;t1.get_size()&lt;&lt;endl;
  cout&lt;&lt;&quot;Height of the tree is: &quot;&lt;&lt;t1.find_height()&lt;&lt;endl;

  return 0;
}
</code> </pre>
<p>Inorder Traversal<br />
1 3 5 6 7 50<br />
Size of the tree is: 6<br />
Size of the tree is: 6<br />
Height of the tree is: 3<br />
Inorder Traversal<br />
50 7 6 5 3 1<br />
Size of the tree is: 6<br />
Size of the tree is: 6<br />
Height of the tree is: 3</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-16612">
        <div id="dsq-comment-header-16612" class="dsq-comment-header">
            <cite id="dsq-cite-16612">
                <span id="dsq-author-user-16612">stupid</span>
            </cite>
        </div>
        <div id="dsq-comment-body-16612" class="dsq-comment-body">
            <div id="dsq-comment-message-16612" class="dsq-comment-message"><pre> <code language="C">
void findmirror(struct node * root){
     if(root == NULL){
             return;
     }
     else{
          findmirror(root-&gt;left);
          findmirror(root-&gt;right);
          struct node * temp = root-&gt;left;
          root-&gt;left = root-&gt;right;
          root-&gt;right = temp;
     }
}
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-15462">
        <div id="dsq-comment-header-15462" class="dsq-comment-header">
            <cite id="dsq-cite-15462">
                <span id="dsq-author-user-15462">Nikin</span>
            </cite>
        </div>
        <div id="dsq-comment-body-15462" class="dsq-comment-body">
            <div id="dsq-comment-message-15462" class="dsq-comment-message"><pre> <code language="C">
void mirror(node *sr)
{
if(sr == NULL ) return;
mirror(sr-&gt;left);
mirror(sr-&gt;right);

int oldData = sr-&gt;left-&gt;data;
sr-&gt;left-&gt;data = sr-&gt;right-&gt;data;
sr-&gt;right-&gt;data = oldData;

}
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-9693">
        <div id="dsq-comment-header-9693" class="dsq-comment-header">
            <cite id="dsq-cite-9693">
                <span id="dsq-author-user-9693">Aashish</span>
            </cite>
        </div>
        <div id="dsq-comment-body-9693" class="dsq-comment-body">
            <div id="dsq-comment-message-9693" class="dsq-comment-message"><p>Code to create a mirror tree without destroying original tree.</p>
<pre> <code language="C">
struct node* foo(struct node* root)
{
        struct node *temp=NULL;
        if(root)
        {
                temp=getNode(root-&gt;data);
                temp-&gt;left=foo(root-&gt;right);
                temp-&gt;right=foo(root-&gt;left);
        }
        return temp;
}
</code> </pre>
<p>Output: <a href="http://ideone.com/jHSgT" rel="nofollow">http://ideone.com/jHSgT</a></p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-30694">
        <div id="dsq-comment-header-30694" class="dsq-comment-header">
            <cite id="dsq-cite-30694">
                <span id="dsq-author-user-30694">Code_Addict</span>
            </cite>
        </div>
        <div id="dsq-comment-body-30694" class="dsq-comment-body">
            <div id="dsq-comment-message-30694" class="dsq-comment-message"><p>Good Work!! Taking mirror image in Different Tree</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-9126">
        <div id="dsq-comment-header-9126" class="dsq-comment-header">
            <cite id="dsq-cite-9126">
                <span id="dsq-author-user-9126">yc</span>
            </cite>
        </div>
        <div id="dsq-comment-body-9126" class="dsq-comment-body">
            <div id="dsq-comment-message-9126" class="dsq-comment-message"><p>Here is the pure iterative tree mirror using no recursion and no stack. This is based on Morris Traversal tweaked to do postorder traversal.  </p>
<pre> <code language="C">
void morrisMirror(node *r){
  node dummy;
  dummy.left=r;
  node *cur=&amp;dummy;
  while(cur){
    if(cur-&gt;left){
      node *p=cur-&gt;left;
      while(p-&gt;right &amp;&amp; (p-&gt;right != cur))       
	p=p-&gt;right;
      
      if(!p-&gt;right){ //go down
	p-&gt;right=cur;
	cur=cur-&gt;left;
      }else{//rewind
	p-&gt;right=0;
	node* tmp=p-&gt;right; //swaping right and left
	p-&gt;right=p-&gt;left;
	p-&gt;left=tmp;
	if(p!=cur-&gt;left){
	  node *pp=cur-&gt;left;
	  while(pp != p){
	    while(pp-&gt;right != p)
	      pp=pp-&gt;right;
	    tmp=pp-&gt;right;
	    pp-&gt;right=pp-&gt;left;
	    pp-&gt;left=tmp;
	    p=pp;
	    pp=cur-&gt;left;	    
	  }
	}
	cur=cur-&gt;right;
      }
    }else
      cur=cur-&gt;right;    
  }
}

</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-32069">
        <div id="dsq-comment-header-32069" class="dsq-comment-header">
            <cite id="dsq-cite-32069">
                <span id="dsq-author-user-32069">Shmulito</span>
            </cite>
        </div>
        <div id="dsq-comment-body-32069" class="dsq-comment-body">
            <div id="dsq-comment-message-32069" class="dsq-comment-message"><p>You have a bug in this code.right is set to 0 and you swap left and right ?why do you need &#8216;tmp&#8217; here ? always equal to true.<br />
        p-&gt;right=0;<br />
	node* tmp=p-&gt;right; //swaping right and left<br />
	p-&gt;right=p-&gt;left;<br />
	p-&gt;left=tmp;</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-9119">
        <div id="dsq-comment-header-9119" class="dsq-comment-header">
            <cite id="dsq-cite-9119">
                <span id="dsq-author-user-9119">anonymous</span>
            </cite>
        </div>
        <div id="dsq-comment-body-9119" class="dsq-comment-body">
            <div id="dsq-comment-message-9119" class="dsq-comment-message"><p>I think this can also be done without recursion. Using Morris Traversal.</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-pphanireddy odd alt thread-odd thread-alt depth-1" id="dsq-comment-6651">
        <div id="dsq-comment-header-6651" class="dsq-comment-header">
            <cite id="dsq-cite-6651">
                <span id="dsq-author-user-6651">pphanireddy</span>
            </cite>
        </div>
        <div id="dsq-comment-body-6651" class="dsq-comment-body">
            <div id="dsq-comment-message-6651" class="dsq-comment-message"><p>    /****************************************************************************<br />
     * Convert a binary tree into its mirror image<br />
     ****************************************************************************/<br />
    public void convertIntoMirrorImage() {<br />
	convertIntoMirrorImage(root);<br />
    }</p>
<p>    private void convertIntoMirrorImage(Node currNode) {<br />
	if(currNode == null) {<br />
	    return;<br />
	}<br />
	Node tempNode = currNode.left;<br />
	currNode.left = currNode.right;<br />
	currNode.right = tempNode;<br />
	convertIntoMirrorImage(currNode.left);<br />
	convertIntoMirrorImage(currNode.right);<br />
    }</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-darkprince even thread-even depth-1" id="dsq-comment-5900">
        <div id="dsq-comment-header-5900" class="dsq-comment-header">
            <cite id="dsq-cite-5900">
                <span id="dsq-author-user-5900">darkprince</span>
            </cite>
        </div>
        <div id="dsq-comment-body-5900" class="dsq-comment-body">
            <div id="dsq-comment-message-5900" class="dsq-comment-message"><p>Non Recursive version &#8230;<br />
Any fallacy , report me ..</p>
<pre> <code language="CPP">
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
using namespace std;

struct tree
{
       int data;
       struct tree *left,*right;
};

struct tree *stack[1000];
int top=0;
void push(struct tree *node)
{ 
  stack[top++]=node;
}

struct tree *makenode()
{
       struct tree *t;
       t=(struct tree*)malloc(sizeof(struct tree));
       t-&gt;data=-9999;
       t-&gt;left=t-&gt;right=NULL;
       
 return(t);      
}

struct tree * pop()
{
 if(top&lt;0) printf(&quot;Underflow&quot;);
 else
{ top--;
 return(stack[top]);
}
       
}
       
int isempty()
{
  if (top &gt; 0) return 1;
  else return 0;
    
}

       
int main()
{
    
    struct tree *p,*temp,*T;
    p=makenode();
    T=p;
    p-&gt;data=11;
    p-&gt;left=makenode();
    p-&gt;left-&gt;data=7;
    p-&gt;right=makenode();
    p-&gt;right-&gt;data=14;
    p-&gt;right-&gt;left=makenode();
    p-&gt;right-&gt;right=makenode();
    p-&gt;right-&gt;left-&gt;data=13;
    p-&gt;right-&gt;right-&gt;data=18;
    p-&gt;left-&gt;left=makenode();
    p-&gt;left-&gt;right=makenode();
    p-&gt;left-&gt;left-&gt;data=5;
    p-&gt;left-&gt;right-&gt;data=9;
    p-&gt;left-&gt;right-&gt;left=makenode();
    p-&gt;left-&gt;right-&gt;right=makenode();    
    p-&gt;left-&gt;right-&gt;left-&gt;data=8;
    p-&gt;left-&gt;right-&gt;right-&gt;data=10;
    
    
    
    while(p!=NULL)
    {
      push(p);
      p=p-&gt;left;  
    }
    
    while(isempty())
    {
      p=pop();
      temp=p-&gt;right;
      p-&gt;right=p-&gt;left;
      p-&gt;left=temp;
    
      if((p-&gt;left)!=NULL) {
                          p=p-&gt;left;
                          while(p!=NULL)
                          {
                                        push(p);
                                        p=p-&gt;left;
                          }
                          }
  //    else printf(&quot;%d &quot;,p-&gt;data);
                
    }
    
//printf(&quot; %d %d %d %d %d %d %d %d&quot;,T-&gt;data,T-&gt;left-&gt;data,T-&gt;left-&gt;left-&gt;data,T-&gt;left-&gt;right-&gt;data,T-&gt;right-&gt;left-&gt;data,T-&gt;right-&gt;right-&gt;data,T-&gt;right-&gt;left-&gt;left-&gt;data,T-&gt;right-&gt;left-&gt;right-&gt;data);
    
    getchar();
    return 0;
}

</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-5665">
        <div id="dsq-comment-header-5665" class="dsq-comment-header">
            <cite id="dsq-cite-5665">
                <span id="dsq-author-user-5665">donbosio</span>
            </cite>
        </div>
        <div id="dsq-comment-body-5665" class="dsq-comment-body">
            <div id="dsq-comment-message-5665" class="dsq-comment-message"><p>Hi,</p>
<p>can any body tell what is the problem with my code, it is not running fine</p>
<p><code></p>
<p>struct node * mirror(struct node * root)<br />
{<br />
struct node* temp;<br />
if(root==NULL)<br />
return NULL;<br />
else<br />
{<br />
struct node * temp;<br />
temp=(struct node*)malloc(sizeof(struct node));<br />
temp-&gt;data=root-&gt;data;<br />
temp-&gt;left=mirror(root-&gt;right);<br />
temp-&gt;right=mirror(root-&gt;left);<br />
}<br />
return temp;<br />
}</p>
<p></code></p>
<p>if inorder traversal of tree is 1 2 3 4 5<br />
the traversal which should have been for the mirror tree 5 4 3 2 1               comes out to be 5 only .</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-2" id="dsq-comment-12809">
        <div id="dsq-comment-header-12809" class="dsq-comment-header">
            <cite id="dsq-cite-12809">
                <span id="dsq-author-user-12809">Aman</span>
            </cite>
        </div>
        <div id="dsq-comment-body-12809" class="dsq-comment-body">
            <div id="dsq-comment-message-12809" class="dsq-comment-message"><p>You are have declared two &#8220;temp&#8221;.<br />
You are allocating memory to inner one, and returning outer one. <img src="http://d2o58evtke57tz.cloudfront.net/wp-includes/images/smilies/icon_biggrin.gif" alt=":D" class="wp-smiley" /></p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-3837">
        <div id="dsq-comment-header-3837" class="dsq-comment-header">
            <cite id="dsq-cite-3837">
                <span id="dsq-author-user-3837">sharat04</span>
            </cite>
        </div>
        <div id="dsq-comment-body-3837" class="dsq-comment-body">
            <div id="dsq-comment-message-3837" class="dsq-comment-message"><p>recently I have seen extensions to this problem, to find out the mirror of a n-ary tree.</p>
<p>Also I request the admin to change the problem statement to clearly state this solution is  for a binary tree only.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-geeksforgeeks bypostauthor even depth-2" id="dsq-comment-3838">
        <div id="dsq-comment-header-3838" class="dsq-comment-header">
            <cite id="dsq-cite-3838">
                <span id="dsq-author-user-3838">GeeksforGeeks</span>
            </cite>
        </div>
        <div id="dsq-comment-body-3838" class="dsq-comment-body">
            <div id="dsq-comment-message-3838" class="dsq-comment-message"><p>@sharat04: thanks for pointing this out, we have updated the post tittle.</p>
<p>For n-ary tree, we need to call recursively for all n children and reverse the array of child pointers.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-3" id="dsq-comment-12015">
        <div id="dsq-comment-header-12015" class="dsq-comment-header">
            <cite id="dsq-cite-12015">
                <span id="dsq-author-user-12015">cheenu</span>
            </cite>
        </div>
        <div id="dsq-comment-body-12015" class="dsq-comment-body">
            <div id="dsq-comment-message-12015" class="dsq-comment-message"><p>can you please briefly explain abt what do you mean by reversing the array of child pointers</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-4" id="dsq-comment-17617">
        <div id="dsq-comment-header-17617" class="dsq-comment-header">
            <cite id="dsq-cite-17617">
                <span id="dsq-author-user-17617">vs</span>
            </cite>
        </div>
        <div id="dsq-comment-body-17617" class="dsq-comment-body">
            <div id="dsq-comment-message-17617" class="dsq-comment-message"><p>e.g
<pre>
    a      

/ / | \ \
b c d f g

will become

   a      

/ / | \ \
g f d c b
</pre>
<p>where the array of child -&gt; b c d f g<br />
has been reversed to -&gt; g f d c b</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-3407">
        <div id="dsq-comment-header-3407" class="dsq-comment-header">
            <cite id="dsq-cite-3407">
http://wgpshashank.co.cc                <span id="dsq-author-user-3407">wgpshashank</span>
            </cite>
        </div>
        <div id="dsq-comment-body-3407" class="dsq-comment-body">
            <div id="dsq-comment-message-3407" class="dsq-comment-message"><pre> <code language="C">
mynode *copy(mynode *root)
{
  mynode *temp;

  if(root==NULL) return(NULL);
  temp = (mynode *) malloc(sizeof(mynode));
  temp-&gt;value = root-&gt;value;

  temp-&gt;left  = copy(root-&gt;left);
  temp-&gt;right = copy(root-&gt;right);

  return(temp);
}
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-2" id="dsq-comment-3790">
        <div id="dsq-comment-header-3790" class="dsq-comment-header">
            <cite id="dsq-cite-3790">
http://ashutosh7s.blogspot.com/                <span id="dsq-author-user-3790">WgpShashank</span>
            </cite>
        </div>
        <div id="dsq-comment-body-3790" class="dsq-comment-body">
            <div id="dsq-comment-message-3790" class="dsq-comment-message"><p>see the working code here <a href="https://ideone.com/GrLU5" rel="nofollow">https://ideone.com/GrLU5</a></p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-3" id="dsq-comment-4046">
        <div id="dsq-comment-header-4046" class="dsq-comment-header">
            <cite id="dsq-cite-4046">
http://ashutosh7s.blogspot.com/                <span id="dsq-author-user-4046">WgpShashank</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4046" class="dsq-comment-body">
            <div id="dsq-comment-message-4046" class="dsq-comment-message"><p>sorry for type..here is exact code </p>
<pre> <code language="C"> 
/* A binary tree node has data, pointer to left child
   and a pointer to right child */
struct node
{
    int data;
    struct node* left;
    struct node* right;
};
 
/* Helper function that allocates a new node with the
   given data and NULL left and right pointers. */
struct node* newNode(int data)
 
{
  struct node* node = (struct node*)
                       malloc(sizeof(struct node));
  node-&gt;data = data;
  node-&gt;left = NULL;
  node-&gt;right = NULL;
 
  return(node);
}
 
/* Change a tree so that the roles of the  left and
    right pointers are swapped at every node.
 
 So the tree...
       4
      / \
     2   5
    / \
   1   3
 
 is changed to...
       4
      / \
     5   2
        / \
       3   1
*/
struct node* copy(struct node *root)
{
  struct node *temp;
 
  if(root==NULL) 
  return(NULL);
  temp = (struct node*) malloc(sizeof(struct node));
  temp-&gt;data= root-&gt;data;
 
  temp-&gt;left  = copy(root-&gt;right);
  temp-&gt;right = copy(root-&gt;left);
 
  return(temp);
}
 
/* Helper function to test mirror(). Given a binary
   search tree, print out its data elements in
   increasing sorted order.*/
void inOrder(struct node* node)
{
  if (node == NULL)
    return;
 
  inOrder(node-&gt;left);
  printf(&quot;%d &quot;, node-&gt;data);
 
  inOrder(node-&gt;right);
}  
 
/* Driver program to test mirror() */
int main()
{
  struct node *root = newNode(1);
  root-&gt;left        = newNode(2);
  root-&gt;right       = newNode(3);
  root-&gt;left-&gt;left  = newNode(4);
  root-&gt;left-&gt;right = newNode(5); 
  root-&gt;left-&gt;left-&gt;left  = newNode(6);
  root-&gt;left-&gt;right-&gt;right = newNode(7); 
  /* Print inorder traversal of the input tree */
  printf(&quot;\n Inorder traversal of the constructed tree is \n&quot;);
  inOrder(root);
 
  /* Convert tree to its mirror */
  root=copy(root); 
 
  /* Print inorder traversal of the mirror tree */
  printf(&quot;\n Inorder traversal of the mirror tree is \n&quot;);
  inOrder(root);
 
  getchar();
  return 0;
}
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even depth-3" id="dsq-comment-8242">
        <div id="dsq-comment-header-8242" class="dsq-comment-header">
            <cite id="dsq-cite-8242">
                <span id="dsq-author-user-8242">lalit kumawat @vit pune</span>
            </cite>
        </div>
        <div id="dsq-comment-body-8242" class="dsq-comment-body">
            <div id="dsq-comment-message-8242" class="dsq-comment-message"><p>mynode *mirror(mynode *root)<br />
{<br />
  mynode *temp;</p>
<p>  if(root==NULL) return(NULL);<br />
  temp = (mynode *) malloc(sizeof(mynode));<br />
  temp-&gt;value = root-&gt;value;</p>
<p>  temp-&gt;left  = mirror(root-&gt;left);<br />
  temp-&gt;right = mirror(root-&gt;right);</p>
<p>  return(temp);<br />
}</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-2454">
        <div id="dsq-comment-header-2454" class="dsq-comment-header">
            <cite id="dsq-cite-2454">
                <span id="dsq-author-user-2454">RAHUL JAIN</span>
            </cite>
        </div>
        <div id="dsq-comment-body-2454" class="dsq-comment-body">
            <div id="dsq-comment-message-2454" class="dsq-comment-message"><p>but this wont work</p>
<pre> <code language="C">
void mirror(struct node* node)
{
  if (node==NULL)
    return;
  else
  {
    struct node* temp;

    /* do the subtrees */
    mirror(node-&gt;left); 
     temp        = node-&gt;left;
    node-&gt;left  = node-&gt;right;
    node-&gt;right = temp;
    mirror(node-&gt;right);
 
    /* swap the pointers in this node */
   
  }
}
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-2" id="dsq-comment-2662">
        <div id="dsq-comment-header-2662" class="dsq-comment-header">
            <cite id="dsq-cite-2662">
                <span id="dsq-author-user-2662">nik</span>
            </cite>
        </div>
        <div id="dsq-comment-body-2662" class="dsq-comment-body">
            <div id="dsq-comment-message-2662" class="dsq-comment-message"><p>I guess this this won&#8217;t work.Either both these mirror of left and right functions must be called before swapping or after swapping.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-3" id="dsq-comment-9943">
        <div id="dsq-comment-header-9943" class="dsq-comment-header">
            <cite id="dsq-cite-9943">
                <span id="dsq-author-user-9943">pankaj</span>
            </cite>
        </div>
        <div id="dsq-comment-body-9943" class="dsq-comment-body">
            <div id="dsq-comment-message-9943" class="dsq-comment-message"><p>To work with that code we need not to call mirror right function after swapping instead we will call mirror left function again. This is because after swapping left &amp; right sub-trees are swapped.</p>
<p>Working code will be..</p>
<p>void mirror(struct node* node)<br />
{<br />
  if (node==NULL)<br />
    return;<br />
  else<br />
  {<br />
    struct node* temp;</p>
<p>    /* do the subtrees */<br />
    mirror(node-&gt;left);<br />
     temp        = node-&gt;left;<br />
    node-&gt;left  = node-&gt;right;<br />
    node-&gt;right = temp;<br />
    mirror(node-&gt;left);<br />
  }<br />
}</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even depth-2" id="dsq-comment-17544">
        <div id="dsq-comment-header-17544" class="dsq-comment-header">
            <cite id="dsq-cite-17544">
                <span id="dsq-author-user-17544">BackBencher</span>
            </cite>
        </div>
        <div id="dsq-comment-body-17544" class="dsq-comment-body">
            <div id="dsq-comment-message-17544" class="dsq-comment-message"><p>Hi, This not working we remain to visit the right subtree, and we changes the ptr left and right and we again visit the left ptr which is currently right.<br />
  Plz.. correct me if i am wrong.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-732">
        <div id="dsq-comment-header-732" class="dsq-comment-header">
            <cite id="dsq-cite-732">
                <span id="dsq-author-user-732">Bandicoot</span>
            </cite>
        </div>
        <div id="dsq-comment-body-732" class="dsq-comment-body">
            <div id="dsq-comment-message-732" class="dsq-comment-message"><p>Will this work ? Swapping the Left and Right subtrees before we do the recursion on Left and Right subtrees:</p>
<p>Mirror(tree):<br />
(1)  Swap left and right subtrees.<br />
          temp = left-subtree<br />
          left-subtree = right-subtree<br />
          right-subtree = temp<br />
(2)  Call Mirror for left-subtree    i.e., Mirror(left-subtree)<br />
(3)  Call Mirror for right-subtree   i.e., Mirror(left-subtree)</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-sandeep even depth-2" id="dsq-comment-733">
        <div id="dsq-comment-header-733" class="dsq-comment-header">
            <cite id="dsq-cite-733">
                <span id="dsq-author-user-733">Sandeep</span>
            </cite>
        </div>
        <div id="dsq-comment-body-733" class="dsq-comment-body">
            <div id="dsq-comment-message-733" class="dsq-comment-message"><p>yes, this will also work.</p>
<p>The method in original post changes tree in bottom up fashion and your algo changes in top down fashion.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt depth-2" id="dsq-comment-10816">
        <div id="dsq-comment-header-10816" class="dsq-comment-header">
            <cite id="dsq-cite-10816">
http://roomforcreativity.wordpress.com                <span id="dsq-author-user-10816">cyclotrojan</span>
            </cite>
        </div>
        <div id="dsq-comment-body-10816" class="dsq-comment-body">
            <div id="dsq-comment-message-10816" class="dsq-comment-message"><p>+1</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
            </ul>


        </div>

    </div>

<script type="text/javascript">
var disqus_url = 'http://www.geeksforgeeks.org/write-an-efficient-c-function-to-convert-a-tree-into-its-mirror-tree/';
var disqus_identifier = '662 http://geeksforgeeks.org/?p=662';
var disqus_container_id = 'disqus_thread';
var disqus_shortname = 'geeksforgeeks';
var disqus_title = "Write an Efficient C Function to Convert a Binary Tree into its Mirror Tree";
var disqus_config_custom = window.disqus_config;
var disqus_config = function () {
    /*
    All currently supported events:
    onReady: fires when everything is ready,
    onNewComment: fires when a new comment is posted,
    onIdentify: fires when user is authenticated
    */
    
    
    this.language = '';
    
    if (disqus_config_custom) {
        disqus_config_custom.call(this);
    }
};

(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>

			</div>
	
					
			
			

		</div> <!-- end post -->	

<br></br>
	
</div> <!-- end content -->

<ul id="sidebar">
	<li id="text-19" class="widget widget_text">			<div class="textwidget"><script>
  (function() {
    var cx = '009682134359037907028:tj6eafkv_be';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//www.google.com/cse/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>

<style type="text/css">
  .gsc-control-cse {
    font-family: "Trebuchet MS", sans-serif;
    border-color: #E1F3DA;
    background-color: #E1F3DA;
  }
  input.gsc-input {
    border-color: #94CC7A;
  }
  input.gsc-search-button {
    border-color: #94CC7A;
    background-color: #AADA92;
  }
  .gsc-tabHeader.gsc-tabhInactive {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gsc-tabHeader.gsc-tabhActive {
    border-color: #A9DA92;
    background-color: #A9DA92;
  }
  .gsc-tabsArea {
    border-color: #A9DA92;
  }
  .gsc-webResult.gsc-result {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gsc-webResult.gsc-result:hover {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gs-webResult.gs-result a.gs-title:link,
  .gs-webResult.gs-result a.gs-title:link b {
    color: #009900;
  }
  .gs-webResult.gs-result a.gs-title:visited,
  .gs-webResult.gs-result a.gs-title:visited b {
    color: #009900;
  }
  .gs-webResult.gs-result a.gs-title:hover,
  .gs-webResult.gs-result a.gs-title:hover b {
    color: #003300;
  }
  .gs-webResult.gs-result a.gs-title:active,
  .gs-webResult.gs-result a.gs-title:active b {
    color: #009900;
  }
  .gsc-cursor-page {
    color: #009900;
  }
  a.gsc-trailing-more-results:link {
    color: #009900;
  }
  .gs-webResult.gs-result .gs-snippet {
    color: #454545;
  }
  .gs-webResult.gs-result .gs-visibleUrl {
    color: #33cc00;
  }
  .gs-webResult.gs-result .gs-visibleUrl-short {
    color: #33cc00;
  }
  .gs-webResult.gs-result .gs-visibleUrl-short {
    display: none;
  }
  .gs-webResult.gs-result .gs-visibleUrl-long {
    display: block;
  }
  .gsc-cursor-box {
    border-color: #A9DA92;
  }
  .gsc-results .gsc-cursor-page {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gsc-results .gsc-cursor-page.gsc-cursor-current-page {
    border-color: #A9DA92;
    background-color: #A9DA92;
  }
  .gs-promotion.gs-result {
    border-color: #94CC7A;
    background-color: #CBE8B4;
  }
  .gs-promotion.gs-result a.gs-title:link {
    color: #0066CC;
  }
  .gs-promotion.gs-result a.gs-title:visited {
    color: #0066CC;
  }
  .gs-promotion.gs-result a.gs-title:hover {
    color: #0066CC;
  }
  .gs-promotion.gs-result a.gs-title:active {
    color: #0066CC;
  }
  .gs-promotion.gs-result .gs-snippet {
    color: #454545;
  }
  .gs-promotion.gs-result .gs-visibleUrl,
  .gs-promotion.gs-result .gs-visibleUrl-short {
    color: #815FA7;
  }
</style>    </div>
		</li>
<li id="text-9" class="widget widget_text">			<div class="textwidget"><div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=138031159685820";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>

<div class="fb-like-box" data-href="https://www.facebook.com/pages/GeeksforGeeks/316764689022" data-width="250" data-height="170" data-colorscheme="light" data-show-faces="true" data-header="false" data-stream="false" data-show-border="false"></div></div>
		</li>
<li id="text-18" class="widget widget_text">			<div class="textwidget"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LargeRectangleSide -->
<ins class="adsbygoogle"
     style="display:inline-block;width:336px;height:280px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="1884636833"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
		</li>
<li id="text-13" class="widget widget_text">			<div class="textwidget"><ul><li><a href="http://www.geeksforgeeks.org/category/interview-experiences/">Interview Experiences</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/advance-data-structures">Advanced Data Structures</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/dynamic-programming">Dynamic Programming</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/Greedy-Algorithm/">Greedy Algorithms</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/backtracking">Backtracking</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/pattern-searching">Pattern Searching</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/divide-and-conquer">Divide & Conquer</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/MathematicalAlgo">Mathematical Algorithms</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/recursion">Recursion</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/geometric-algorithms/">Geometric Algorithms</a></li>
</ul></div>
		</li>
<li id="text-17" class="widget widget_text">			<div class="textwidget"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big 300x600 Sidebar -->
<ins class="adsbygoogle"
     style="display:inline-block;width:300px;height:600px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="4402736037"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
		</li>
<li id="text-14" class="widget widget_text"><h2 class="widgettitle">Popular Posts</h2>
			<div class="textwidget"><ul>
<li><a href="http://www.geeksforgeeks.org/write-a-c-program-to-print-all-permutations-of-a-given-string/">  All permutations of a given string </a></li>
<li><a href="http://www.geeksforgeeks.org/memory-layout-of-c-program/"> Memory Layout of C Programs</a> </li>
<li><a href="http://www.geeksforgeeks.org/understanding-extern-keyword-in-c/"> Understanding “extern” keyword in C</a> </li>
<li><a href="http://www.geeksforgeeks.org/median-of-two-sorted-arrays/">Median of two sorted arrays</a> </li>
<li><a href="http://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/"> Tree traversal without recursion and without stack! </a></li>
<li><a href="http://www.geeksforgeeks.org/structure-member-alignment-padding-and-data-packing/"> Structure Member Alignment, Padding and Data Packing</a> </li>
<li><a href="http://www.geeksforgeeks.org/write-a-function-to-get-the-intersection-point-of-two-linked-lists/"> Intersection point of two Linked Lists</a> </li>
<li><a href="http://www.geeksforgeeks.org/lowest-common-ancestor-in-a-binary-search-tree/"> Lowest Common Ancestor in a BST.</span></a> </li>
<li><a href="http://www.geeksforgeeks.org/a-program-to-check-if-a-binary-tree-is-bst-or-not/"> Check if a binary tree is BST or not</a> </li>
<li><a href="http://www.geeksforgeeks.org/sorted-linked-list-to-balanced-bst/"> Sorted Linked List to Balanced BST</a></li>
</ul></div>
		</li>
<li id="text-3" class="widget widget_text">			<div class="textwidget"><a href="https://twitter.com/GeeksforGeeks" class="twitter-follow-button" data-show-count="false">Follow @GeeksforGeeks</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>         


<!-- GOOGLE FEEDBURNER BUTTON-->
<a href="http://feeds.feedburner.com/Geeksforgeeks" title="Subscribe to my feed" rel="alternate" type="application/rss+xml"><img src="http://www.feedburner.com/fb/images/pub/feed-icon32x32.png" alt="" style="border:0"/></a><a href="http://feeds.feedburner.com/Geeksforgeeks" title="Subscribe to my feed" rel="alternate" type="application/rss+xml">Subscribe</a>

</div>
		</li>
<li id="text-21" class="widget widget_text"><h2 class="widgettitle">Recent Comments</h2>
			<div class="textwidget"><script type="text/javascript" src="http://geeksforgeeks.disqus.com//recent_comments_widget.js?num_items=6&hide_avatars=1&excerpt_length=50&hide_mods=0"></script></div>
		</li>
<li id="text-22" class="widget widget_text">			<div class="textwidget"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LinkAd -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:90px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="2606115235"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LinkAd -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:90px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="2606115235"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LinkAd -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:90px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="2606115235"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
		</li>

</ul>					  
		<div class="clear"></div>

		<div id="footer">
		
		    <div class="xhtml">
                        @geeksforgeeks, <a href="http://creativecommons.org/licenses/by-nc-nd/2.5/in/deed.en_US" title="Valid XHTML Strict 1.0">Some rights reserved</a>  <a href="http://www.geeksforgeeks.org/about/contact-us/"> &nbsp; &nbsp; &nbsp; &nbsp;Contact Us!</a>

		    </div>
		    
		    <div class="credits">
			  Powered by <a href="http://wordpress.org">WordPress </a> &amp; <a href="http://mootools.net/" title="Mootools JavaScript Framework">MooTools</a>, customized by geeksforgeeks team </div>
			  
		   <div class="clear"></div>						                            
		   
		</div> <!--end footer-->  
        
		        <script type="text/javascript">
        // <![CDATA[
        var disqus_shortname = 'geeksforgeeks';
        (function () {
            var nodes = document.getElementsByTagName('span');
            for (var i = 0, url; i < nodes.length; i++) {
                if (nodes[i].className.indexOf('dsq-postid') != -1) {
                    nodes[i].parentNode.setAttribute('data-disqus-identifier', nodes[i].getAttribute('rel'));
                    url = nodes[i].parentNode.href.split('#', 1);
                    if (url.length == 1) { url = url[0]; }
                    else { url = url[1]; }
                    nodes[i].parentNode.href = url + '#disqus_thread';
                }
            }
            var s = document.createElement('script'); 
            s.async = true;
            s.type = 'text/javascript';
            s.src = '//' + disqus_shortname + '.disqus.com/count.js';
            (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
        }());
        // ]]>
        </script>
        <script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/scripts/shCore.js?ver=3.0.9'></script>
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/scripts/shBrushCpp.js?ver=3.0.9'></script>
<script type='text/javascript'>
	(function(){
		var corecss = document.createElement('link');
		var themecss = document.createElement('link');
		var corecssurl = "http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/styles/shCore.css?ver=3.0.9";
		if ( corecss.setAttribute ) {
				corecss.setAttribute( "rel", "stylesheet" );
				corecss.setAttribute( "type", "text/css" );
				corecss.setAttribute( "href", corecssurl );
		} else {
				corecss.rel = "stylesheet";
				corecss.href = corecssurl;
		}
		document.getElementsByTagName("head")[0].insertBefore( corecss, document.getElementById("syntaxhighlighteranchor") );
		var themecssurl = "http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/styles/shThemeDefault.css?ver=3.0.9";
		if ( themecss.setAttribute ) {
				themecss.setAttribute( "rel", "stylesheet" );
				themecss.setAttribute( "type", "text/css" );
				themecss.setAttribute( "href", themecssurl );
		} else {
				themecss.rel = "stylesheet";
				themecss.href = themecssurl;
		}
		//document.getElementById("syntaxhighlighteranchor").appendChild(themecss);
		document.getElementsByTagName("head")[0].insertBefore( themecss, document.getElementById("syntaxhighlighteranchor") );
	})();
	SyntaxHighlighter.config.strings.expandSource = '+ expand source';
	SyntaxHighlighter.config.strings.help = '?';
	SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
	SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
	SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
	SyntaxHighlighter.defaults['gutter'] = false;
	SyntaxHighlighter.defaults['pad-line-numbers'] = true;
	SyntaxHighlighter.defaults['toolbar'] = false;
	SyntaxHighlighter.all();
</script>
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/bbpress/templates/default/js/editor.js?ver=2.5.4-5380'></script>
				  
		</div> <!--end wrapper-->
        <div id="ajaxSpinner"></div> <!--For AJAX spinner holder-->
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-12148232-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
	</body>

</html>
<!-- Dynamic page generated in 0.208 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2014-11-27 23:29:26 -->

<!-- Compression = gzip -->
<!-- super cache -->