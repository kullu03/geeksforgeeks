<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
       <title>A program to check if a binary tree is BST or not - GeeksforGeeks</title>
       <style type="text/css" media="screen">
          @import url('http://d2o58evtke57tz.cloudfront.net/wp-content/themes/minimoo/style.css');
    </style>
      <link href="http://d2o58evtke57tz.cloudfront.net/wp-content/themes/minimoo/favicon.ico" rel="shortcut icon" />    
    
<!-- This site is optimized with the Yoast WordPress SEO plugin v1.7.1 - https://yoast.com/wordpress/plugins/seo/ -->
<link rel="canonical" href="http://www.geeksforgeeks.org/a-program-to-check-if-a-binary-tree-is-bst-or-not/" />
<meta property="og:locale" content="en_US" />
<meta property="og:type" content="article" />
<meta property="og:title" content="A program to check if a binary tree is BST or not - GeeksforGeeks" />
<meta property="og:description" content="A binary search tree (BST) is a node based binary tree data structure which has the following properties. • The left subtree of a node contains only nodes with keys less than the node&#8217;s key. • The right subtree of a node contains only nodes with keys greater than the node&#8217;s key. • Both the &hellip;" />
<meta property="og:url" content="http://www.geeksforgeeks.org/a-program-to-check-if-a-binary-tree-is-bst-or-not/" />
<meta property="og:site_name" content="GeeksforGeeks" />
<meta property="article:section" content="Trees" />
<meta property="article:published_time" content="2009-11-21T02:04:47+00:00" />
<meta property="article:modified_time" content="2012-02-15T00:28:51+00:00" />
<meta property="og:updated_time" content="2012-02-15T00:28:51+00:00" />
<meta property="og:image" content="http://geeksforgeeks.org/wp-content/uploads/2009/11/BST.gif" />
<meta property="og:image" content="http://geeksforgeeks.org/wp-content/uploads/2009/11/tree_bst.gif" />
<!-- / Yoast WordPress SEO plugin. -->

<link rel='stylesheet' id='wp-quicklatex-format-css'  href='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/wp-quicklatex/css/quicklatex-format.css?ver=4.0.1' type='text/css' media='all' />
<link rel='stylesheet' id='bbp-default-css'  href='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/bbpress/templates/default/css/bbpress.css?ver=2.5.4-5380' type='text/css' media='screen' />
<link rel='stylesheet' id='wp-pagenavi-css'  href='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/wp-pagenavi/pagenavi-css.css?ver=2.70' type='text/css' media='all' />
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-includes/js/jquery/jquery.js?ver=1.11.1'></script>
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-includes/js/jquery/jquery-migrate.min.js?ver=1.2.1'></script>
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/wp-quicklatex/js/wp-quicklatex-frontend.js?ver=1.0'></script>

<!-- Bad Behavior 2.2.16 run time: 1.506 ms -->
<script type="text/javascript">
<!--
function bb2_addLoadEvent(func) {
	var oldonload = window.onload;
	if (typeof window.onload != 'function') {
		window.onload = func;
	} else {
		window.onload = function() {
			oldonload();
			func();
		}
	}
}

bb2_addLoadEvent(function() {
	for ( i=0; i < document.forms.length; i++ ) {
		if (document.forms[i].method == 'post') {
			var myElement = document.createElement('input');
			myElement.setAttribute('type', 'hidden');
			myElement.name = 'bb2_screener_';
			myElement.value = '1417110901 177.134.116.133';
			document.forms[i].appendChild(myElement);
		}
	}
});
// --></script>
		<style type="text/css" id="syntaxhighlighteranchor"></style>
   <meta name="google-site-verification" content="rHK2v8_zzuAZQY8JHAzbllDN8u-aQxcn2Kqnp67Old0" />
</head>

<body>
<!-- o4dI0sCXUgoSONabbd8mbZ4SA3E -->    
    <div id="wrapper">
        <div class="blog-info">
                <h1 class="blog-title">
                <a href="http://www.geeksforgeeks.org" title="GeeksforGeeks">GeeksforGeeks</a>
            </h1>
       
            <div class="blog-description">
                A computer science portal for geeks            </div>
        </div>
        <b><p>  <h2 align="right"> <a href="http://geeksquiz.com/">GeeksQuiz</a></h2> 
   <a href="http://www.geeksforgeeks.org/wp-login.php">Login</a> 
         </p></b>  
         
         <div class="clear"></div>         
              
                     
            <div id="menu">   
                 <ul>
 <li><a href="http://www.geeksforgeeks.org">Home</a></li>
  <li><a href="http://www.geeksforgeeks.org/fundamentals-of-algorithms/">Algorithms</a></li>
 <li><a href="http://www.geeksforgeeks.org/data-structures/">DS</a></li>
  <li><a href="http://www.geeksforgeeks.org/gate-corner/">GATE</a></li>
  <li><a href="http://www.geeksforgeeks.org/about/interview-corner/">Interview Corner</a></li>
  <li><a href="http://www.geeksforgeeks.org/forums/">Q&A</a></li>
  <li><a href="http://www.geeksforgeeks.org/c/">C</a></li>
  <li><a href="http://www.geeksforgeeks.org/c-plus-plus/">C++</a></li>
  <li><a href="http://www.geeksforgeeks.org/java/">Java</a></li>
  <li><a href="http://www.geeksforgeeks.org/books/">Books</a></li>
  <li><a href="http://www.geeksforgeeks.org/contribute/">Contribute</a></li>
  <li><a href="http://www.geeksforgeeks.org/contribute/ask-a-question/">Ask a Q</a></li>
  <li><a href="http://www.geeksforgeeks.org/about/">About</a></li>
            </ul>

               
            <div class="clear"></div>     
        </div>
             <div id="navmenu">
				<ul id="menu" style="padding:0; margin:0;">
						<li class="cat-item cat-item-3"><a href="http://www.geeksforgeeks.org/category/c-arrays/" title="Questions regarding Arrays">Array</a>
</li>	

	<li class="cat-item cat-item-17"><a href="http://www.geeksforgeeks.org/category/bit-magic/" title="View all posts filed under Bit Magic">Bit Magic</a>
</li>
	<li class="cat-item cat-item-14"><a href="http://www.geeksforgeeks.org/category/c-puzzles/" title="View all posts filed under C/C++ Puzzles">C/C++</a>
</li>

<li class="cat-item cat-item-18"><a href="http://www.geeksforgeeks.org/category/articles/" title="View all posts filed under Articles">Articles</a>
</li>

	<li class="cat-item cat-item-67"><a href="http://www.geeksforgeeks.org/category/gfact/" title="View all posts filed under GFacts">GFacts</a>
</li>
	<li class="cat-item cat-item-8"><a href="http://www.geeksforgeeks.org/category/linked-list/" title="Linked List problems">Linked List</a>
</li>
	<li class="cat-item cat-item-66"><a href="http://www.geeksforgeeks.org/category/multiple-choice-question/" title="View all posts filed under MCQ">MCQ</a>

</li>
	<li class="cat-item cat-item-4"><a href="http://www.geeksforgeeks.org/category/c-programs/" title="Miscellaneous">Misc</a>
</li>
	<li class="cat-item cat-item-5"><a href="http://www.geeksforgeeks.org/category/program-output/" title="View all posts filed under Output">Output</a>
</li>
	<li class="cat-item cat-item-7"><a href="http://www.geeksforgeeks.org/category/c-strings/" title="Questions related to strings">String</a>
</li>
	<li class="cat-item cat-item-19"><a href="http://www.geeksforgeeks.org/category/tree/" title="View all posts filed under Trees">Tree</a>
</li>
	<li class="cat-item cat-item-19"><a href="http://www.geeksforgeeks.org/category/graph/" title="View all posts filed under Graph">Graph</a>
</li>
</ul>
        </div>
             <div id="content">	   	
	<div class="post" id="post">
							<div class="post-info">			
					<div class="post-title-info">
						<h2 class="post-title">A program to check if a binary tree is BST or not</h2>
					</div>			
					<div class="clear"></div>				  
				<div class="post-content" id="post-content">
					<p>A binary search tree (BST) is a node based binary tree data structure which has the following properties.<span id="more-3042"></span><br />
• The left subtree of a node contains only nodes with keys less than the node&#8217;s key.<br />
• The right subtree of a node contains only nodes with keys greater than the node&#8217;s key.<br />
• Both the left and right subtrees must also be binary search trees.</p>
<p>From the above properties it naturally follows that:<br />
• Each node (item in the tree) has a distinct key.</p>
<p><img src="http://geeksforgeeks.org/wp-content/uploads/2009/11/BST.gif" alt="BST" title="BST" width="259" height="156" class="aligncenter size-full wp-image-3059" /></p>
<p></br><br />
<strong>METHOD 1 (Simple but Wrong)</strong><br />
Following is a simple program. For each node, check if left node of it is smaller than the node and right node of it is greater than the node.</p>
<pre class="brush: cpp; title: ; notranslate" title="">
int isBST(struct node* node) 
{ 
  if (node == NULL) 
    return 1; 
    
  /* false if left is &gt; than node */
  if (node-&gt;left != NULL &amp;&amp; node-&gt;left-&gt;data &gt; node-&gt;data) 
    return 0; 
    
  /* false if right is &lt; than node */
  if (node-&gt;right != NULL &amp;&amp; node-&gt;right-&gt;data &lt; node-&gt;data) 
    return 0; 
  
  /* false if, recursively, the left or right is not a BST */
  if (!isBST(node-&gt;left) || !isBST(node-&gt;right)) 
    return 0; 
    
  /* passing all that, it's a BST */
  return 1; 
}
</pre>
<p><strong>This approach is wrong as this will return true for below binary tree (and below tree is not a BST because 4 is in left subtree of 3)<br />
</strong></p>
<p> <img src="http://geeksforgeeks.org/wp-content/uploads/2009/11/tree_bst.gif" alt="tree_bst" title="tree_bst" width="259" height="156" class="aligncenter size-full wp-image-3060" /></p>
<p></br><br />
<br /></br><br />
<strong>METHOD 2 (Correct but not efficient)</strong><br />
For each node, check if max value in left subtree is smaller than the node and min value in right subtree greater than the node.</p>
<pre class="brush: cpp; title: ; notranslate" title="">
/* Returns true if a binary tree is a binary search tree */ 
int isBST(struct node* node) 
{ 
  if (node == NULL) 
    return(true); 
    
  /* false if the max of the left is &gt; than us */
  if (node-&gt;left!=NULL &amp;&amp; maxValue(node-&gt;left) &gt; node-&gt;data) 
    return(false); 
    
  /* false if the min of the right is &lt;= than us */
  if (node-&gt;right!=NULL &amp;&amp; minValue(node-&gt;right) &lt; node-&gt;data) 
    return(false); 
  
  /* false if, recursively, the left or right is not a BST */
  if (!isBST(node-&gt;left) || !isBST(node-&gt;right)) 
    return(false); 
    
  /* passing all that, it's a BST */
  return(true); 
} 
</pre>
<p>It is assumed that you have helper functions minValue() and maxValue() that return the min or max int value from a non-empty tree</p>
<p></br><br />
<strong>METHOD 3 (Correct and Efficient)</strong><br />
Method 2 above runs slowly since it traverses over some parts of the tree many times. A better solution looks at each node only once. The trick is to write a utility helper function isBSTUtil(struct node* node, int min, int max) that traverses down the tree keeping track of the narrowing min and max allowed values as it goes, looking at each node only once. The initial values for min and max should be INT_MIN and INT_MAX &#8212; they narrow from there. </p>
<pre>
/* Returns true if the given tree is a binary search tree 
 (efficient version). */ 
int isBST(struct node* node) 
{ 
  return(isBSTUtil(node, INT_MIN, INT_MAX)); 
} 

/* Returns true if the given tree is a BST and its 
 values are >= min and <= max. */ 
int isBSTUtil(struct node* node, int min, int max) 
</pre>
<p><strong>Implementation:</strong></p>
<pre class="brush: cpp; title: ; notranslate" title="">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;limits.h&gt;

/* A binary tree node has data, pointer to left child
   and a pointer to right child */
struct node
{
    int data;
    struct node* left;
    struct node* right;
};

int isBSTUtil(struct node* node, int min, int max);

/* Returns true if the given tree is a binary search tree 
 (efficient version). */ 
int isBST(struct node* node) 
{ 
  return(isBSTUtil(node, INT_MIN, INT_MAX)); 
} 

/* Returns true if the given tree is a BST and its 
   values are &gt;= min and &lt;= max. */ 
int isBSTUtil(struct node* node, int min, int max) 
{ 

  /* an empty tree is BST */
  if (node==NULL) 
     return 1;
      
  /* false if this node violates the min/max constraint */  
  if (node-&gt;data &lt; min || node-&gt;data &gt; max) 
     return 0; 

  /* otherwise check the subtrees recursively, 
   tightening the min or max constraint */
  return 
    isBSTUtil(node-&gt;left, min, node-&gt;data-1) &amp;&amp;  // Allow only distinct values
    isBSTUtil(node-&gt;right, node-&gt;data+1, max);  // Allow only distinct values
} 

/* Helper function that allocates a new node with the
   given data and NULL left and right pointers. */
struct node* newNode(int data)
{
  struct node* node = (struct node*)
                       malloc(sizeof(struct node));
  node-&gt;data = data;
  node-&gt;left = NULL;
  node-&gt;right = NULL;

  return(node);
}

/* Driver program to test above functions*/
int main()
{
  struct node *root = newNode(4);
  root-&gt;left        = newNode(2);
  root-&gt;right       = newNode(5);
  root-&gt;left-&gt;left  = newNode(1);
  root-&gt;left-&gt;right = newNode(3); 

  if(isBST(root))
    printf(&quot;Is BST&quot;);
  else
    printf(&quot;Not a BST&quot;);
    
  getchar();
  return 0;
}  
</pre>
<p>Time Complexity: O(n)<br />
Auxiliary Space : O(1) if Function Call Stack size is not considered, otherwise O(n)</p>
<p><strong>METHOD 4(Using In-Order Traversal)</strong><br />
Thanks to <a href="http://www.geeksforgeeks.org/archives/3042/comment-page-1#comment-562">LJW489 </a> for suggesting this method.<br />
1) Do In-Order Traversal of the given tree and store the result in a temp array.<br />
3) Check if the temp array is sorted in ascending order, if it is, then the tree is BST.</p>
<p>Time Complexity: O(n)</p>
<p>We can avoid the use of Auxiliary Array.  While doing In-Order traversal, we can keep track of previously visited node.  If the value of the currently visited node is less than the previous value, then tree is not BST.  Thanks to <a href="http://www.geeksforgeeks.org/archives/3042/comment-page-1#comment-5805">ygos </a>for this space optimization.</p>
<pre class="brush: cpp; title: ; notranslate" title="">
bool isBST(struct node* root)
{
    static struct node *prev = NULL;
    
    // traverse the tree in inorder fashion and keep track of prev node
    if (root)
    {
        if (!isBST(root-&gt;left))
          return false;

        // Allows only distinct valued nodes 
        if (prev != NULL &amp;&amp; root-&gt;data &lt;= prev-&gt;data)
          return false;

        prev = root;

        return isBST(root-&gt;right);
    }

    return true;
}
</pre>
<p>The use of static variable can also be avoided by using reference to prev node as a parameter (Similar to <a href="http://www.geeksforgeeks.org/archives/17358">this </a>post).</p>
<p><strong>Sources:</strong><br />
<a href="http://en.wikipedia.org/wiki/Binary_search_tree">http://en.wikipedia.org/wiki/Binary_search_tree</a><br />
<a href="http://cslibrary.stanford.edu/110/BinaryTrees.html">http://cslibrary.stanford.edu/110/BinaryTrees.html</a></p>
<p>Please write comments if you find any bug in the above programs/algorithms or other ways to solve the same problem. </p>
		
&nbsp;
&nbsp;
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle"
     style="display:inline-block;width:336px;height:280px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="4061219431"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>



&nbsp;
&nbsp;
&nbsp;
<h3>Related Topics:</h3><ul><li><a href="http://www.geeksforgeeks.org/perfect-binary-tree-specific-level-order-traversal/" title="Perfect Binary Tree Specific Level Order Traversal">Perfect Binary Tree Specific Level Order Traversal</a></li><li><a href="http://www.geeksforgeeks.org/print-nodes-top-view-binary-tree/" title="Print Nodes in Top View of Binary Tree">Print Nodes in Top View of Binary Tree</a></li><li><a href="http://www.geeksforgeeks.org/k-dimensional-tree/" title="K Dimensional Tree">K Dimensional Tree</a></li><li><a href="http://www.geeksforgeeks.org/convert-binary-tree-threaded-binary-tree/" title="Convert a Binary Tree to Threaded binary tree">Convert a Binary Tree to Threaded binary tree</a></li><li><a href="http://www.geeksforgeeks.org/serialize-deserialize-n-ary-tree/" title="Serialize and Deserialize an N-ary Tree">Serialize and Deserialize an N-ary Tree</a></li><li><a href="http://www.geeksforgeeks.org/serialize-deserialize-binary-tree/" title="Serialize and Deserialize a Binary Tree">Serialize and Deserialize a Binary Tree</a></li><li><a href="http://www.geeksforgeeks.org/given-binary-tree-print-nodes-two-given-level-numbers/" title="Print nodes between two given level numbers of a binary tree">Print nodes between two given level numbers of a binary tree</a></li><li><a href="http://www.geeksforgeeks.org/find-height-binary-tree-represented-parent-array/" title="Find Height of Binary Tree represented by Parent array">Find Height of Binary Tree represented by Parent array</a></li></ul>
<p></p> 
<div>
<iframe src="http://www.facebook.com/plugins/like.php?href=http%3A%2F%2Fwww.geeksforgeeks.org%2Fa-program-to-check-if-a-binary-tree-is-bst-or-not%2F&layout=button_count&show_faces=false&width=90&action=like&colorscheme=light" scrolling="no" frameborder="0" allowTransparency="true" style="border:none; overflow:hidden; width:90px; height:20px"></iframe>
<a href="http://twitter.com/share" class="twitter-share-button" data-url="http://www.geeksforgeeks.org/a-program-to-check-if-a-binary-tree-is-bst-or-not/" data-text="A program to check if a binary tree is BST or not" data-count="horizontal" data-via="jakerutter">Tweet</a><script type="text/javascript" src="http://platform.twitter.com/widgets.js"></script>
<g:plusone size="medium" href="http://www.geeksforgeeks.org/a-program-to-check-if-a-binary-tree-is-bst-or-not/"></g:plusone>
<!-- Place this render call where appropriate -->
<script type="text/javascript">
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script></div>





				</div>		  
			</div> <!-- end post main -->					
			<div class="post-meta">
				<div class="left"></div>				
				<div class="clear"></div>
			</div>			
        
			<div class="comments-main">		
 <b>Writing code in comment?</b> Please use <b><a href="http://ideone.com/">ideone.com</a></b> and share the link here.
				
<div id="disqus_thread">
            <div id="dsq-content">


            <ul id="dsq-comments">
                    <li class="comment even thread-even depth-1" id="dsq-comment-34393">
        <div id="dsq-comment-header-34393" class="dsq-comment-header">
            <cite id="dsq-cite-34393">
                <span id="dsq-author-user-34393">Anjaneya Alluri</span>
            </cite>
        </div>
        <div id="dsq-comment-body-34393" class="dsq-comment-body">
            <div id="dsq-comment-message-34393" class="dsq-comment-message"><p>I believe we can do either of the Traversals for this problem i.e Inorder, Preorder or Postorder.</p>
<p>And while we are traversing and adding nodes to the stack , we can make comparisons to the key values and return false if any of which breaks it.</p>
<p>Eg: , please find the below using Pre Order traversal.</p>
<p>public boolean BST_check(Node root){<br />
		//check for null</p>
<p>		if(root == null){<br />
			System.out.println(&#8220;sent null , please recheck the BST&#8221;);<br />
			return false;<br />
		}</p>
<p>		Node cur = root;</p>
<p>		//check for right and left sub trees<br />
		boolean done = false;<br />
		Stack&lt;Node&gt; stk = new Stack&lt;Node&gt;();<br />
		stk.push(cur);</p>
<p>		while(!stk.isEmpty()){<br />
     cur = stk.pop();<br />
     if(cur.right != null){<br />
                    if(compare(cur.data,cur.right.data) &gt; 0)return false;<br />
                    stk.push(cur.right);<br />
                 }<br />
     if(cur.left != null){<br />
                      if(compare(cur.data,cur.left.data) &lt; 0)return false;<br />
                     stk.push(cur.left);<br />
               }<br />
		}<br />
		return true;<br />
	}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-33179">
        <div id="dsq-comment-header-33179" class="dsq-comment-header">
            <cite id="dsq-cite-33179">
                <span id="dsq-author-user-33179">Varun</span>
            </cite>
        </div>
        <div id="dsq-comment-body-33179" class="dsq-comment-body">
            <div id="dsq-comment-message-33179" class="dsq-comment-message"><p>should it not be root-&gt;data &gt; prev-&gt;data instead of root-&gt;data data in method 4 ?</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-2" id="dsq-comment-33211">
        <div id="dsq-comment-header-33211" class="dsq-comment-header">
            <cite id="dsq-cite-33211">
                <span id="dsq-author-user-33211">varun</span>
            </cite>
        </div>
        <div id="dsq-comment-body-33211" class="dsq-comment-body">
            <div id="dsq-comment-message-33211" class="dsq-comment-message"><p>my bad !! it is correct only&#8230;</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-33090">
        <div id="dsq-comment-header-33090" class="dsq-comment-header">
            <cite id="dsq-cite-33090">
                <span id="dsq-author-user-33090">Guest</span>
            </cite>
        </div>
        <div id="dsq-comment-body-33090" class="dsq-comment-body">
            <div id="dsq-comment-message-33090" class="dsq-comment-message"><p>Could someone please point out the mistake in this code(if any):<br />
assumption: null tree is not bst</p>
<p>bool is_bst(tree* tree 1)<br />
{<br />
if(tree1==NULL) return false;</p>
<p>if(tree1-&gt;left &amp;&amp; tree1-&gt; right)<br />
return((tree1-&gt;left-&gt;valuevalue) &amp;&amp; (tree1-&gt;right-&gt;value&gt;tree1-&gt;value) &amp;&amp; is_bst(tree1-&gt;left) &amp;&amp; is_bst(tree1-&gt;right));</p>
<p>else if(tree1-&gt;right)<br />
return((tree1-&gt;right-&gt;value&gt;tree1-&gt;value) &amp;&amp; is_bst(tree1-&gt;right));</p>
<p>else if(tree1-&gt;left)<br />
return((tree1-&gt;left-&gt;valuevalue) &amp;&amp; is_bst(tree1-&gt;left));</p>
<p>return true;<br />
}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-31853">
        <div id="dsq-comment-header-31853" class="dsq-comment-header">
            <cite id="dsq-cite-31853">
                <span id="dsq-author-user-31853">dmr</span>
            </cite>
        </div>
        <div id="dsq-comment-body-31853" class="dsq-comment-body">
            <div id="dsq-comment-message-31853" class="dsq-comment-message"><p>A doubt in method 4,  if someone can explain. Why can&#8217;t I replace below lines:<br />
<code><br />
if (!isBST(root-&gt;left))<br />
          return false;<br />
</code><br />
WITH:<br />
<code><br />
return isBST(root-&gt;left)<br />
</code><br />
I get wrong answer if I does so.<br />
But per my understanding, they are same..NO ?</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-32001">
        <div id="dsq-comment-header-32001" class="dsq-comment-header">
            <cite id="dsq-cite-32001">
                <span id="dsq-author-user-32001">gourav pathak</span>
            </cite>
        </div>
        <div id="dsq-comment-body-32001" class="dsq-comment-body">
            <div id="dsq-comment-message-32001" class="dsq-comment-message"><p>No they are different<br />
When you write &#8220;if(!isBST(root-&gt;left) return false&#8221;<br />
it means if left subtree is not a bst then return false(if left subtree is a bst then it returns nothing,it checks further if right subtree is also a bst)</p>
<p>But when you write return isBST(root-&gt;left) it returns true if left subtree is a bst&#8230;.which is wrong as we have to further check whether right subtree is a bst or not</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-3" id="dsq-comment-32052">
        <div id="dsq-comment-header-32052" class="dsq-comment-header">
            <cite id="dsq-cite-32052">
                <span id="dsq-author-user-32052">dmr</span>
            </cite>
        </div>
        <div id="dsq-comment-body-32052" class="dsq-comment-body">
            <div id="dsq-comment-message-32052" class="dsq-comment-message"><p>ok&#8230;.i get your point. But when then we write &#8220;return isBST(root-&gt;right);&#8221; for the right subtree case. Shouldn&#8217;t it be handled like left subtree case ? like: if(!isBST(root-&gt;right)) {return;}</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-4" id="dsq-comment-32386">
        <div id="dsq-comment-header-32386" class="dsq-comment-header">
            <cite id="dsq-cite-32386">
                <span id="dsq-author-user-32386">gourav pathak</span>
            </cite>
        </div>
        <div id="dsq-comment-body-32386" class="dsq-comment-body">
            <div id="dsq-comment-message-32386" class="dsq-comment-message"><p>No it need not be&#8230;.. We will reach there only if the left subtree is a BST(otherwise the function would return false)&#8230;..Now since we know that left subtree is a bst &#8230;&#8230;we only need to check whether right subtree is a BST or not&#8230;.if(isBST(root-&gt;right)) is true then root is also a BST</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-31179">
        <div id="dsq-comment-header-31179" class="dsq-comment-header">
            <cite id="dsq-cite-31179">
                <span id="dsq-author-user-31179">123</span>
            </cite>
        </div>
        <div id="dsq-comment-body-31179" class="dsq-comment-body">
            <div id="dsq-comment-message-31179" class="dsq-comment-message"><p>Won&#8217;t the method 3 fail when one of the nodes have value either INT_MIN or INT_MAX ? please correct me if I am wrong</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-30815">
        <div id="dsq-comment-header-30815" class="dsq-comment-header">
            <cite id="dsq-cite-30815">
                <span id="dsq-author-user-30815">Nikhil Agrawal</span>
            </cite>
        </div>
        <div id="dsq-comment-body-30815" class="dsq-comment-body">
            <div id="dsq-comment-message-30815" class="dsq-comment-message"><p>In Method 3:<br />
There is no need to subtract and add 1 from root.data because in comparison we are not using equal sign which itself will differentiate values resulting in unique values.<br />
Correct me if I am wrong</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-30487">
        <div id="dsq-comment-header-30487" class="dsq-comment-header">
            <cite id="dsq-cite-30487">
                <span id="dsq-author-user-30487">Mukesh</span>
            </cite>
        </div>
        <div id="dsq-comment-body-30487" class="dsq-comment-body">
            <div id="dsq-comment-message-30487" class="dsq-comment-message"><p>Method-4 is not good for above example. just replace 6 with 1. If last leave node is greater than the parent then not working.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-30484">
        <div id="dsq-comment-header-30484" class="dsq-comment-header">
            <cite id="dsq-cite-30484">
                <span id="dsq-author-user-30484">RASHMIBS</span>
            </cite>
        </div>
        <div id="dsq-comment-body-30484" class="dsq-comment-body">
            <div id="dsq-comment-message-30484" class="dsq-comment-message"><p>can anybody tell me here how to check for negative condition???  say suppose it should print it is not a BST</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-2" id="dsq-comment-30485">
        <div id="dsq-comment-header-30485" class="dsq-comment-header">
            <cite id="dsq-cite-30485">
                <span id="dsq-author-user-30485">Zeest</span>
            </cite>
        </div>
        <div id="dsq-comment-body-30485" class="dsq-comment-body">
            <div id="dsq-comment-message-30485" class="dsq-comment-message"><p>Common man isnt that really a trivial thing.. </p>
<p>isNotBst(sturct node* root){<br />
return 1^(isBst(root))<br />
}</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-3" id="dsq-comment-30486">
        <div id="dsq-comment-header-30486" class="dsq-comment-header">
            <cite id="dsq-cite-30486">
                <span id="dsq-author-user-30486">RASHMIBS</span>
            </cite>
        </div>
        <div id="dsq-comment-body-30486" class="dsq-comment-body">
            <div id="dsq-comment-message-30486" class="dsq-comment-message"><p>ok thanks Zeest ,will check once in my code</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-29614">
        <div id="dsq-comment-header-29614" class="dsq-comment-header">
            <cite id="dsq-cite-29614">
                <span id="dsq-author-user-29614">shruthi</span>
            </cite>
        </div>
        <div id="dsq-comment-body-29614" class="dsq-comment-body">
            <div id="dsq-comment-message-29614" class="dsq-comment-message"><p>While implementing method 3</p>
<p>Shouldn&#8217;t it be isBSTUtil(node-&gt;left, min, node-&gt;data) and not node-&gt;data -1 because it is a BST if left is lesser than or equal to the node and not just lesser.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-30354">
        <div id="dsq-comment-header-30354" class="dsq-comment-header">
            <cite id="dsq-cite-30354">
                <span id="dsq-author-user-30354">Joao Brunet</span>
            </cite>
        </div>
        <div id="dsq-comment-body-30354" class="dsq-comment-body">
            <div id="dsq-comment-message-30354" class="dsq-comment-message"><p>No. A binary search tree does not contains duplicate elements. The left must be less than root, while the right must be greater than root.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-3" id="dsq-comment-30355">
        <div id="dsq-comment-header-30355" class="dsq-comment-header">
            <cite id="dsq-cite-30355">
                <span id="dsq-author-user-30355">João Brunet</span>
            </cite>
        </div>
        <div id="dsq-comment-body-30355" class="dsq-comment-body">
            <div id="dsq-comment-message-30355" class="dsq-comment-message"><p>*does not contain.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-4" id="dsq-comment-33356">
        <div id="dsq-comment-header-33356" class="dsq-comment-header">
            <cite id="dsq-cite-33356">
                <span id="dsq-author-user-33356">Victor</span>
            </cite>
        </div>
        <div id="dsq-comment-body-33356" class="dsq-comment-body">
            <div id="dsq-comment-message-33356" class="dsq-comment-message"><p>That&#8217;s actually not true. All nodes in the left subtree must less than or EQUAL to the root and the root is less than all nodes in the right subtree</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-5" id="dsq-comment-33357">
        <div id="dsq-comment-header-33357" class="dsq-comment-header">
            <cite id="dsq-cite-33357">
                <span id="dsq-author-user-33357">Victor</span>
            </cite>
        </div>
        <div id="dsq-comment-body-33357" class="dsq-comment-body">
            <div id="dsq-comment-message-33357" class="dsq-comment-message"><p>must be*</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-29464">
        <div id="dsq-comment-header-29464" class="dsq-comment-header">
            <cite id="dsq-cite-29464">
                <span id="dsq-author-user-29464">Mahendra</span>
            </cite>
        </div>
        <div id="dsq-comment-body-29464" class="dsq-comment-body">
            <div id="dsq-comment-message-29464" class="dsq-comment-message"><p>I think here is a simple logic/solution to the given problem:</p>
<p>int isBST(struct node* root){</p>
<p>	if(root){</p>
<p>		if((root-&gt;left==NULL || root-&gt;left-&gt;datadata)&amp;&amp;(root-&gt;right==NULL || root-&gt;right-&gt;data&gt;root-&gt;data)){</p>
<p>			if((root-&gt;left==0 || root-&gt;left-&gt;right==0 || root-&gt;left-&gt;right-&gt;datadata) &amp;&amp; (root-&gt;right==0 || root-&gt;right-&gt;left==0 || root-&gt;right-&gt;left-&gt;data&gt;root-&gt;data))</p>
<p>				return isBST(root-&gt;left)&amp;&amp;isBST(root-&gt;right);</p>
<p>			else</p>
<p>				return 0;</p>
<p>		}</p>
<p>		else</p>
<p>			return 0;</p>
<p>	}</p>
<p>	return 1;</p>
<p>}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-29286">
        <div id="dsq-comment-header-29286" class="dsq-comment-header">
            <cite id="dsq-cite-29286">
                <span id="dsq-author-user-29286">GuestPost</span>
            </cite>
        </div>
        <div id="dsq-comment-body-29286" class="dsq-comment-body">
            <div id="dsq-comment-message-29286" class="dsq-comment-message"><p>using in order traversal is good.. a little more optimization is possible<br />
1) no need to have a temp array.<br />
2) have two variables previous and present<br />
3) each time check previous &lt; present. Else break + stop in order traversal </p>
<p>will be a little more space and time optimized.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-29004">
        <div id="dsq-comment-header-29004" class="dsq-comment-header">
            <cite id="dsq-cite-29004">
                <span id="dsq-author-user-29004">Sameer</span>
            </cite>
        </div>
        <div id="dsq-comment-body-29004" class="dsq-comment-body">
            <div id="dsq-comment-message-29004" class="dsq-comment-message"><p><a href="http://codingrecipies.blogspot.in/2013/10/tree-operations.html" rel="nofollow">http://codingrecipies.blogspot.in/2013/10/tree-operations.html</a><br />
Very well explained binary search tree</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-28516">
        <div id="dsq-comment-header-28516" class="dsq-comment-header">
            <cite id="dsq-cite-28516">
                <span id="dsq-author-user-28516">pavansrinivas</span>
            </cite>
        </div>
        <div id="dsq-comment-body-28516" class="dsq-comment-body">
            <div id="dsq-comment-message-28516" class="dsq-comment-message"><p>Code in Java using InOrder Traversal</p>
<p><code></p>
<p>	boolean isBst(){</p>
<p>		Stack s = new Stack();</p>
<p>		Node temp = root;</p>
<p>		boolean isFirst = true;</p>
<p>		int cur=root.i,prev=-1;</p>
<p>		while(true){</p>
<p>			while(temp!=null){<br />
				s.push(temp);<br />
				temp = temp.left;<br />
			}<br />
			if(s.isEmpty()){<br />
				break;<br />
			}<br />
			temp = s.pop();<br />
			if(isFirst){<br />
				cur = temp.i;<br />
				isFirst = false;<br />
			}<br />
			else{<br />
				prev = cur;<br />
				cur = temp.i;<br />
			}<br />
			if(prev&gt;cur){<br />
				return false;<br />
			}<br />
			temp = temp.right;<br />
		}<br />
return true;<br />
	}</p>
<p></code></p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-28323">
        <div id="dsq-comment-header-28323" class="dsq-comment-header">
            <cite id="dsq-cite-28323">
                <span id="dsq-author-user-28323">Kuldeep Kumar</span>
            </cite>
        </div>
        <div id="dsq-comment-body-28323" class="dsq-comment-body">
            <div id="dsq-comment-message-28323" class="dsq-comment-message"><p><code><br />
#include<br />
#include<br />
using namespace std;<br />
int flag=1;<br />
//int prev=INT_MIN;<br />
int current=INT_MIN;<br />
void checkBst(node *t){<br />
	if(t){<br />
		checkBst(t-&gt;left);<br />
		if(t-&gt;data data;<br />
checkBst(t-&gt;right);<br />
			}<br />
	}<br />
int main(){<br />
node *t=NULL,*root;<br />
root = (node*)malloc(sizeof(node));<br />
root-&gt;data=8;<br />
t = (node*)malloc(sizeof(node));<br />
t-&gt;left=NULL;<br />
t-&gt;right=NULL;<br />
t-&gt;data=4;<br />
root-&gt;left=t;<br />
t = (node*)malloc(sizeof(node));<br />
t-&gt;left=NULL;<br />
t-&gt;right=NULL;<br />
t-&gt;data=14;<br />
root-&gt;right=t;<br />
t = (node*)malloc(sizeof(node));<br />
t-&gt;left=NULL;<br />
t-&gt;right=NULL;<br />
t-&gt;data=2;<br />
root-&gt;left-&gt;left=t;<br />
t = (node*)malloc(sizeof(node));<br />
t-&gt;left=NULL;<br />
t-&gt;right=NULL;<br />
t-&gt;data=10;<br />
root-&gt;right-&gt;left=t;<br />
preorder(root);<br />
checkBst(root);<br />
if(flag)<br />
	cout&lt;&lt;&quot;nIs a BST:n&quot;;<br />
else<br />
	cout&lt;&lt;&quot;nNot a BST:n&quot;;<br />
return 0;<br />
}</p>
<p></code></p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-27988">
        <div id="dsq-comment-header-27988" class="dsq-comment-header">
            <cite id="dsq-cite-27988">
                <span id="dsq-author-user-27988">praveen kumar</span>
            </cite>
        </div>
        <div id="dsq-comment-body-27988" class="dsq-comment-body">
            <div id="dsq-comment-message-27988" class="dsq-comment-message"><p>in method if given tree has root 100 and right child of root is also 100 then it not return false &#8230;,but the tree is not a binary tree &#8230;its not a good method in that case&#8230;..am i correct??</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-27989">
        <div id="dsq-comment-header-27989" class="dsq-comment-header">
            <cite id="dsq-cite-27989">
                <span id="dsq-author-user-27989">kp</span>
            </cite>
        </div>
        <div id="dsq-comment-body-27989" class="dsq-comment-body">
            <div id="dsq-comment-message-27989" class="dsq-comment-message"><p>which one method..??</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-3" id="dsq-comment-27990">
        <div id="dsq-comment-header-27990" class="dsq-comment-header">
            <cite id="dsq-cite-27990">
                <span id="dsq-author-user-27990">praveen</span>
            </cite>
        </div>
        <div id="dsq-comment-body-27990" class="dsq-comment-body">
            <div id="dsq-comment-message-27990" class="dsq-comment-message"><p>method 4&#8230;using in-order traversal</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-4" id="dsq-comment-27991">
        <div id="dsq-comment-header-27991" class="dsq-comment-header">
            <cite id="dsq-cite-27991">
                <span id="dsq-author-user-27991">praveen kumar</span>
            </cite>
        </div>
        <div id="dsq-comment-body-27991" class="dsq-comment-body">
            <div id="dsq-comment-message-27991" class="dsq-comment-message"><p>yaah  i  also agree with yamini..its not a good method in that case</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even depth-2" id="dsq-comment-30228">
        <div id="dsq-comment-header-30228" class="dsq-comment-header">
            <cite id="dsq-cite-30228">
                <span id="dsq-author-user-30228">bakwasscoder</span>
            </cite>
        </div>
        <div id="dsq-comment-body-30228" class="dsq-comment-body">
            <div id="dsq-comment-message-30228" class="dsq-comment-message"><p>Method is correct&#8230;..it&#8217;s returning false: <a href="http://ideone.com/UDKcW9" rel="nofollow">http://ideone.com/UDKcW9</a></p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-27387">
        <div id="dsq-comment-header-27387" class="dsq-comment-header">
            <cite id="dsq-cite-27387">
                <span id="dsq-author-user-27387">viki</span>
            </cite>
        </div>
        <div id="dsq-comment-body-27387" class="dsq-comment-body">
            <div id="dsq-comment-message-27387" class="dsq-comment-message"><p>//Will this solution work ??</p>
<p>int isBST(node *root)</p>
<p>{</p>
<p>    if(!root)return 1;</p>
<p>    if(root-&gt;left &amp;&amp; root-&gt;data left-&gt;data)return 0;</p>
<p>    if(root-&gt;right &amp;&amp; root-&gt;data &gt; root-&gt;right-&gt;data)return 0;</p>
<p>    if(root-&gt;left &amp;&amp;root-&gt;left-&gt;right &amp;&amp; root-&gt;data left-&gt;right-&gt;data)return 0;</p>
<p>    if(root-&gt;right &amp;&amp;root-&gt;right-&gt;left &amp;&amp; root-&gt;data &gt;root-&gt;right-&gt;left-&gt;data)return 0;</p>
<p>    if(isBST(root-&gt;left)&amp;&amp;isBST(root-&gt;right))return 1;</p>
<p>    return 0;</p>
<p>}</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-2" id="dsq-comment-28160">
        <div id="dsq-comment-header-28160" class="dsq-comment-header">
            <cite id="dsq-cite-28160">
                <span id="dsq-author-user-28160">Shiwakant Bharti</span>
            </cite>
        </div>
        <div id="dsq-comment-body-28160" class="dsq-comment-body">
            <div id="dsq-comment-message-28160" class="dsq-comment-message"><p>The trick looks good to me at least on below test case. Is it inspired from AVL Tree rotation?<br />
<code><br />
                        50<br />
                       /<br />
                     40       60<br />
                    /<br />
                   30            70<br />
                                 /<br />
                     35         65<br />
</code><br />
What about this? Looks like this logic also works on min and max bounding, what say?<br />
<code></p>
<p>                 280</p>
<p>                    410<br />
                    /<br />
                  290</p>
<p>                     400<br />
                    /<br />
                   300          </p>
<p>                     350<br />
                      /<br />
                      310</p>
<p></code></p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</li><!-- #comment-## -->
<ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-28164">
        <div id="dsq-comment-header-28164" class="dsq-comment-header">
            <cite id="dsq-cite-28164">
                <span id="dsq-author-user-28164">Shiwakant Bharti</span>
            </cite>
        </div>
        <div id="dsq-comment-body-28164" class="dsq-comment-body">
            <div id="dsq-comment-message-28164" class="dsq-comment-message"><p>@7665663779954a93b5fdbdf8e4f33dd7:disqus I checked on my machine and it returns false. Can you please recheck?</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-21259">
        <div id="dsq-comment-header-21259" class="dsq-comment-header">
            <cite id="dsq-cite-21259">
                <span id="dsq-author-user-21259">rohit</span>
            </cite>
        </div>
        <div id="dsq-comment-body-21259" class="dsq-comment-body">
            <div id="dsq-comment-message-21259" class="dsq-comment-message"><p>What will be the time complexity of method 2.Will it be O(NlogN)??</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-28165">
        <div id="dsq-comment-header-28165" class="dsq-comment-header">
            <cite id="dsq-cite-28165">
                <span id="dsq-author-user-28165">Shiwakant Bharti</span>
            </cite>
        </div>
        <div id="dsq-comment-body-28165" class="dsq-comment-body">
            <div id="dsq-comment-message-28165" class="dsq-comment-message"><p>Only if the tree is balanced. Or else either of the minValue() or maxValue may take O(N) resulting in O(N^2) worst case.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</li><!-- #comment-## -->
<ul class="children">
    <li class="comment even depth-2" id="dsq-comment-28166">
        <div id="dsq-comment-header-28166" class="dsq-comment-header">
            <cite id="dsq-cite-28166">
                <span id="dsq-author-user-28166">Shiwakant Bharti</span>
            </cite>
        </div>
        <div id="dsq-comment-body-28166" class="dsq-comment-body">
            <div id="dsq-comment-message-28166" class="dsq-comment-message"><p>Is it even possible do so in worst case without even visiting all nodes O(N)?</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-19865">
        <div id="dsq-comment-header-19865" class="dsq-comment-header">
            <cite id="dsq-cite-19865">
                <span id="dsq-author-user-19865">innosam</span>
            </cite>
        </div>
        <div id="dsq-comment-body-19865" class="dsq-comment-body">
            <div id="dsq-comment-message-19865" class="dsq-comment-message"><p><a href="http://innosamcodes.wordpress.com/2013/06/16/is-the-tree-a-bst/" rel="nofollow">http://innosamcodes.wordpress.com/2013/06/16/is-the-tree-a-bst/</a><br />
Check out this simple program, just introduced bool for checking if max/min exist or not.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-abhishek08aug even thread-even depth-1" id="dsq-comment-18067">
        <div id="dsq-comment-header-18067" class="dsq-comment-header">
            <cite id="dsq-cite-18067">
                <span id="dsq-author-user-18067">abhishek08aug</span>
            </cite>
        </div>
        <div id="dsq-comment-body-18067" class="dsq-comment-body">
            <div id="dsq-comment-message-18067" class="dsq-comment-message"><p>C++ code:</p>
<pre> <code language="C">
#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;
using namespace std;
 
class tree_node {
  private:
    int data;
    tree_node * left;
    tree_node * right;
  public:
    tree_node() {
      left=NULL;
      right=NULL;
    }
    void set_data(int data) {
      this-&gt;data=data;
    }
    int get_data() {
      return this-&gt;data;
    }
    void set_left(tree_node * left) {
      this-&gt;left=left;
    }
    tree_node * get_left() {
      return this-&gt;left;
    }
    void set_right(tree_node * right) {
      this-&gt;right=right;
    }
    tree_node * get_right() {
      return this-&gt;right;
    }
    tree_node ** get_left_ref() {
      return &amp;(this-&gt;left);
    }
    tree_node ** get_right_ref() {
      return &amp;(this-&gt;right);
    }
};
 
class tree {
  private:
    tree_node * root;
    int size;
    void _recursive_insert(tree_node ** root_ref, int value);
    void _print_preorder(tree_node * root);
    void _print_inorder(tree_node * root);
    void _print_postorder(tree_node * root);
    int _find_size(tree_node * root);
    int _are_identical(tree_node * tn1, tree_node * tn2);
    int _find_height(tree_node * root);
    void _delete_tree(tree_node ** root);
    void _mirror(tree_node * root);
    void _print_paths(tree_node * root, int * path_nodes, int next_vacant_position);
    void _print_array(int * array, int len);
    tree_node * _lowest_common_ancestor(tree_node * parent, tree_node * root, int a, int b);
    tree_node * _find_node(tree_node * root, int value);
    tree_node * _min_node(tree_node * root);
    void _print_level_order(tree_node * root);
    int _count_leaf_nodes(tree_node * root);
    int _is_bst(tree_node * root);
  public:
    tree() {
      root=NULL;
      size=0;
    }
    void insert(int value);
    void recursive_insert(int value);
    void print_preorder();
    void print_inorder();
    void print_postorder();
    int find_size();
    int get_size() {
      return this-&gt;size;
    }
    int are_identical(tree t);
    int find_height();
    void delete_tree();
    void mirror();
    void print_paths();
    tree_node * lowest_common_ancestor(int a, int b);
    tree_node * find_node(int value);
    tree_node * min_node();
    void print_level_order();
    int count_leaf_nodes();
    int is_bst();
};
 
void tree::insert(int value) {
  if(root==NULL) {
    root=new tree_node;
    root-&gt;set_data(value);
  } else {
    tree_node * parent=NULL;
    tree_node * current=root;
    tree_node * new_node=new tree_node;
    new_node-&gt;set_data(value);
    while(current!=NULL) {
      if(value&lt;=current-&gt;get_data()) {
        parent=current;
        current=current-&gt;get_left();
      } else {
        parent=current;
        current=current-&gt;get_right();
      }
    }
    if(value&lt;=parent-&gt;get_data() &amp;&amp; parent-&gt;get_left()==NULL) {
      parent-&gt;set_left(new_node);
    } else if(value&gt;parent-&gt;get_data() &amp;&amp; parent-&gt;get_right()==NULL) {
      parent-&gt;set_right(new_node);
    }
  }
  size++;
}
 
void tree::recursive_insert(int value) {
  _recursive_insert(&amp;root, value);
  size++;
}
 
void tree::_recursive_insert(tree_node ** root_ref, int value) {
  if(*root_ref==NULL) {
    tree_node * new_node=new tree_node;
    new_node-&gt;set_data(value);
    *root_ref=new_node;   
  } else {
    if(value&lt;=(*root_ref)-&gt;get_data()) {
      _recursive_insert((*root_ref)-&gt;get_left_ref(), value);
    } else {
      _recursive_insert((*root_ref)-&gt;get_right_ref(), value);
    }
  }
}
 
void tree::print_preorder() {
  if(root==NULL) {
    return;
  }
  _print_preorder(root);
  cout&lt;&lt;endl;
}
 
void tree::_print_preorder(tree_node * root) {
  if(root==NULL) {
    return;
  }
  cout&lt;&lt;root-&gt;get_data()&lt;&lt;&quot; &quot;;
  if(root-&gt;get_left()!=NULL)
    _print_preorder(root-&gt;get_left());
  if(root-&gt;get_right()!=NULL)
    _print_preorder(root-&gt;get_right());
}
 
void tree::print_inorder() {
  if(root==NULL) {
    return;
  }
  _print_inorder(root);
  cout&lt;&lt;endl;
}
 
void tree::_print_inorder(tree_node * root) {
  if(root==NULL) {
    return;
  }
  if(root-&gt;get_left()!=NULL)
    _print_inorder(root-&gt;get_left());
  cout&lt;&lt;root-&gt;get_data()&lt;&lt;&quot; &quot;;
  if(root-&gt;get_right()!=NULL)
    _print_inorder(root-&gt;get_right());
}
 
void tree::print_postorder() {
  if(root==NULL) {
    return;
  }
  _print_postorder(root);
  cout&lt;&lt;endl;
}
 
void tree::_print_postorder(tree_node * root) {
  if(root==NULL) {
    return;
  }
  if(root-&gt;get_left()!=NULL)
    _print_postorder(root-&gt;get_left());
  if(root-&gt;get_right()!=NULL)
    _print_postorder(root-&gt;get_right());
  cout&lt;&lt;root-&gt;get_data()&lt;&lt;&quot; &quot;;
}

int tree::find_size() {
  return _find_size(root);
}

int tree::_find_size(tree_node * root) {
  if(root==NULL) {
    return 0;
  } else {
    return 1+_find_size(root-&gt;get_left())+_find_size(root-&gt;get_right());
  }
}

int tree::are_identical(tree t) {
  return _are_identical(this-&gt;root, t.root);
}

int tree::_are_identical(tree_node * tn1, tree_node * tn2) {
  if(tn1==NULL &amp;&amp; tn2==NULL) {
    return 1;
  } else if((tn1==NULL &amp;&amp; tn2!=NULL) || (tn1!=NULL &amp;&amp; tn2==NULL) || (tn1-&gt;get_data()!=tn2-&gt;get_data())) {
    return 0;
  } else {
    return _are_identical(tn1-&gt;get_left(), tn2-&gt;get_left()) &amp;&amp; _are_identical(tn1-&gt;get_right(), tn2-&gt;get_right());
  }
}

int tree::find_height() {
  return _find_height(root);
}

int tree::_find_height(tree_node * root) {
  if(root==NULL) {
    return 0;
  }
  else {
    return 1+max(_find_height(root-&gt;get_left()), _find_height(root-&gt;get_right()));
  }
}

void tree::delete_tree() {
  _delete_tree(&amp;root);
  size=0;
}

void tree::_delete_tree(tree_node ** root) {
  if(*root==NULL) {
    return;
  } else {
    if((*root)-&gt;get_left()!=NULL) {
      _delete_tree((*root)-&gt;get_left_ref());
    }
    if((*root)-&gt;get_right()!=NULL) {
      _delete_tree((*root)-&gt;get_right_ref());
    }
    delete(*root);
    *root=NULL;
  }
}

/* alternate _delete_tree */
/*
void tree::_delete_tree(tree_node ** root) {
  if(*root==NULL) {
    return;
  } else {
    if((*root)-&gt;get_left()!=NULL) {
      tree_node * left_ref=(*root)-&gt;get_left();
      _delete_tree(&amp;left_ref);
    }
    if((*root)-&gt;get_right()!=NULL) {
      tree_node * right_ref=(*root)-&gt;get_right();
      _delete_tree(&amp;right_ref);
    }
    delete(*root);
    *root=NULL;
  }
}
*/

void tree::mirror() {
  _mirror(root);
}

void tree::_mirror(tree_node * root) {
  if(root==NULL) {
    return;
  }

  tree_node * temp=root-&gt;get_left();
  root-&gt;set_left(root-&gt;get_right());
  root-&gt;set_right(temp);
  _mirror(root-&gt;get_left());
  _mirror(root-&gt;get_right());
}

void tree::print_paths(){
   int max_path_length=find_height();
   int * path_nodes=(int *)calloc(sizeof(int), max_path_length);
  _print_paths(root, path_nodes, 0);
}

void tree::_print_paths(tree_node * root, int * path_nodes, int next_vacant_position){
  if(root==NULL) {
    return;
  } else if(root-&gt;get_left()==NULL &amp;&amp; root-&gt;get_right()==NULL) {
    *(path_nodes+next_vacant_position)=root-&gt;get_data();
    _print_array(path_nodes, next_vacant_position);
  } else {
    *(path_nodes+next_vacant_position)=root-&gt;get_data();
    _print_paths(root-&gt;get_left(), path_nodes, next_vacant_position+1);
    _print_paths(root-&gt;get_right(), path_nodes, next_vacant_position+1);
  }
}

void tree::_print_array(int * array, int len) {
  int i;
  for(i=0; i&lt;=len; i++) {
    cout&lt;&lt;*(array+i)&lt;&lt;&quot; &quot;;
  }
  cout&lt;&lt;endl;
}

tree_node * tree::find_node(int value) {
  return _find_node(root, value);
}

tree_node * tree::_find_node(tree_node * root, int value) {
  if(root==NULL || root-&gt;get_data()==value) {
    return root;
  } else if(value&lt;=root-&gt;get_data()) {
    return _find_node(root-&gt;get_left(), value);
  } else {
    return _find_node(root-&gt;get_right(), value);
  }
}

tree_node * tree::lowest_common_ancestor(int a, int b) {
  return _lowest_common_ancestor(NULL, root, a, b);
}

tree_node * tree::_lowest_common_ancestor(tree_node * parent, tree_node * root, int a, int b) {
  if(root==NULL) {
    return root;
  } else if((root-&gt;get_data()==a &amp;&amp; (root-&gt;get_left()-&gt;get_data()==b || root-&gt;get_right()-&gt;get_data()==b))
             || (root-&gt;get_data()==b &amp;&amp; (root-&gt;get_left()-&gt;get_data()==a || root-&gt;get_right()-&gt;get_data()==a))) {
    return parent;
  } else if((_find_node(root-&gt;get_left(), a)!=NULL &amp;&amp; _find_node(root-&gt;get_right(), b)!=NULL)
        || (_find_node(root-&gt;get_left(), b)!=NULL &amp;&amp; _find_node(root-&gt;get_right(), a)!=NULL)) {
    return root; 
  } else if(_find_node(root-&gt;get_left(), a)!=NULL &amp;&amp; _find_node(root-&gt;get_left(), b)!=NULL) {
    return _lowest_common_ancestor(root, root-&gt;get_left(), a, b);
  } else if(_find_node(root-&gt;get_right(), a)!=NULL &amp;&amp; _find_node(root-&gt;get_right(), b)!=NULL) {
    return _lowest_common_ancestor(root, root-&gt;get_right(), a, b);
  } else {
    return NULL;
  }
}

tree_node * tree::min_node() {
  return _min_node(root);
}

tree_node * tree::_min_node(tree_node * root) {
  if(root==NULL || root-&gt;get_left()==NULL) {
    return root;
  } else {
    return _min_node(root-&gt;get_left());
  }
}

int tree::count_leaf_nodes() {
  return _count_leaf_nodes(root);
}

int tree::_count_leaf_nodes(tree_node * root) {
  if(root==NULL) {
    return 0;
  } else if(root-&gt;get_left()==NULL &amp;&amp; root-&gt;get_right()==NULL) {
    return 1;
  } else {
    return _count_leaf_nodes(root-&gt;get_left())+_count_leaf_nodes(root-&gt;get_right());
  }
}


int tree::is_bst() {
  return _is_bst(root);
}

int tree::_is_bst(tree_node * root) {
  static tree_node * previous=NULL;
  if(root==NULL) {
    return 1;
  } else {
    if(!_is_bst(root-&gt;get_left())) {
      return 0;
    }
    if(previous!=NULL &amp;&amp; (previous-&gt;get_data())&gt;(root-&gt;get_data())) {
      return 0;
    }
    previous=root;
    if(!_is_bst(root-&gt;get_right())) {
      return 0;
    }    
  }
}

int main() {
  tree t1;

  t1.recursive_insert(5);
  t1.recursive_insert(3);
  t1.insert(10);
  t1.insert(7);
  t1.recursive_insert(50);
  t1.recursive_insert(6);
  t1.recursive_insert(1);
  t1.recursive_insert(45);
  t1.recursive_insert(55);
  t1.recursive_insert(4);

  if(t1.is_bst()) {
    cout&lt;&lt;&quot;Tree is a BST&quot;&lt;&lt;endl;
  }

  return 0;
}
</code> </pre>
<p>Tree is a BST</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-aman1234 odd alt depth-2" id="dsq-comment-19742">
        <div id="dsq-comment-header-19742" class="dsq-comment-header">
            <cite id="dsq-cite-19742">
                <span id="dsq-author-user-19742">aman1234</span>
            </cite>
        </div>
        <div id="dsq-comment-body-19742" class="dsq-comment-body">
            <div id="dsq-comment-message-19742" class="dsq-comment-message"><p>intelligent <img src="http://d2o58evtke57tz.cloudfront.net/wp-includes/images/smilies/icon_biggrin.gif" alt=":D" class="wp-smiley" /></p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-3" id="dsq-comment-22459">
        <div id="dsq-comment-header-22459" class="dsq-comment-header">
            <cite id="dsq-cite-22459">
                <span id="dsq-author-user-22459">prity</span>
            </cite>
        </div>
        <div id="dsq-comment-body-22459" class="dsq-comment-body">
            <div id="dsq-comment-message-22459" class="dsq-comment-message"><p>Geek <img src="http://d2o58evtke57tz.cloudfront.net/wp-includes/images/smilies/icon_smile.gif" alt=":)" class="wp-smiley" /></p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment byuser comment-author-rudra odd alt depth-2" id="dsq-comment-25091">
        <div id="dsq-comment-header-25091" class="dsq-comment-header">
            <cite id="dsq-cite-25091">
                <span id="dsq-author-user-25091">Rudra</span>
            </cite>
        </div>
        <div id="dsq-comment-body-25091" class="dsq-comment-body">
            <div id="dsq-comment-message-25091" class="dsq-comment-message"><p>Great <img src="http://d2o58evtke57tz.cloudfront.net/wp-includes/images/smilies/icon_biggrin.gif" alt=":D" class="wp-smiley" /></p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-17568">
        <div id="dsq-comment-header-17568" class="dsq-comment-header">
            <cite id="dsq-cite-17568">
                <span id="dsq-author-user-17568">Pradeep</span>
            </cite>
        </div>
        <div id="dsq-comment-body-17568" class="dsq-comment-body">
            <div id="dsq-comment-message-17568" class="dsq-comment-message"><p>Another solution (in C#) using Inorder using a stack</p>
<p>/*<br />
public bool IsBstInorder()<br />
{<br />
  if (root == null) return true;<br />
  Stack&lt;BinaryTreeNode&lt;T&gt;&gt; stack = new Stack&lt;BinaryTreeNode&lt;T&gt;&gt;();<br />
            BinaryTreeNode&lt;T&gt; temp = root;<br />
            while (true)<br />
            {<br />
                for (; temp != null; temp = temp.Left)<br />
                {<br />
                    if ((stack.IsEmpty()) ||((!stack.IsEmpty())&amp;&amp; (temp.item.CompareTo(stack.Top().item) &lt; 0)))//Since we are traversing in inorder, item going to push<br />
                        stack.Push(temp);//should be greater than all the processed items<br />
                    else<br />
                        return false;<br />
                }</p>
<p>                if (stack.IsEmpty()) return true;<br />
                BinaryTreeNode&lt;T&gt; node = stack.Pop();<br />
                temp = node.Right;<br />
            }<br />
        }*/</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-17469">
        <div id="dsq-comment-header-17469" class="dsq-comment-header">
            <cite id="dsq-cite-17469">
                <span id="dsq-author-user-17469">Anish P</span>
            </cite>
        </div>
        <div id="dsq-comment-body-17469" class="dsq-comment-body">
            <div id="dsq-comment-message-17469" class="dsq-comment-message"><pre> <code language="Java">
public class Node {
 private Node leftChild;
 private int data;
 private Node rightChild;
}
private boolean isBST(Node node){ //Here node is the root when //this function is invoked for the first time
 if (node != null) {
  isBST(node.lefChild);
  if (previous != null &amp;&amp; previous.data &gt;= node.data) {
   return false;
  }
  return isBST(node.rightChild); 
 } 
 return true;
}
</code> </pre>
<p>Hi All, Please let me know if the above solution works.Have used the same method as in method-4.</p>
<p>Thanks<br />
Anish P</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-2" id="dsq-comment-28167">
        <div id="dsq-comment-header-28167" class="dsq-comment-header">
            <cite id="dsq-cite-28167">
                <span id="dsq-author-user-28167">Shiwakant Bharti</span>
            </cite>
        </div>
        <div id="dsq-comment-body-28167" class="dsq-comment-body">
            <div id="dsq-comment-message-28167" class="dsq-comment-message"><p>The contribution of the bst checking of the left child is missing in the final answer which will result in wrong answer(s).</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-17325">
        <div id="dsq-comment-header-17325" class="dsq-comment-header">
            <cite id="dsq-cite-17325">
                <span id="dsq-author-user-17325">adsf</span>
            </cite>
        </div>
        <div id="dsq-comment-body-17325" class="dsq-comment-body">
            <div id="dsq-comment-message-17325" class="dsq-comment-message"><p>void CheckBST(struct node* root)<br />
{<br />
	int flag=1,min=-32768;<br />
	if(root==null)<br />
	{<br />
		printf(&#8220;Empty Tree&#8221;);<br />
		return;<br />
	}<br />
	IsBst(root,&amp;min,&amp;flag);<br />
	if(flag==1)<br />
		printf(&#8220;Binary Search Tree&#8221;);<br />
	else<br />
		printf(&#8220;Not a Binary Search Tree&#8221;);</p>
<p>}</p>
<p>void IsBst(struct node* node,int *min,int *flag)<br />
{<br />
	if(node!=null)<br />
	{<br />
		IsBst(node-&gt;left,min,flag);<br />
		if(node-&gt;data data;<br />
		IsBst(node-&gt;right,min,flag);<br />
	}</p>
<p>}</p>
<p>simple and efficient<br />
Correct me if  i am wrong</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-adityasraf even thread-even depth-1" id="dsq-comment-16963">
        <div id="dsq-comment-header-16963" class="dsq-comment-header">
            <cite id="dsq-cite-16963">
                <span id="dsq-author-user-16963">AdityaSraf</span>
            </cite>
        </div>
        <div id="dsq-comment-body-16963" class="dsq-comment-body">
            <div id="dsq-comment-message-16963" class="dsq-comment-message"><p>Lots of typing errors in my last comment. Here it is again: Traverse all nodes starting from the root. For any current node, temporarily store the value of its parent also(obviously except for root), then 2 cases exist:<br />
Case1: current node < parent<br />
2 checks:<br />
1)left child <current node  2)right child>current node &#038;&#038; right child
<parent Case2: current node > parent<br />
2 checks:<br />
1)	left child <current node  &#038;&#038; left child>parent<br />
2)	right child>current node</current></parent>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-adityasraf odd alt thread-odd thread-alt depth-1" id="dsq-comment-16961">
        <div id="dsq-comment-header-16961" class="dsq-comment-header">
            <cite id="dsq-cite-16961">
                <span id="dsq-author-user-16961">AdityaSraf</span>
            </cite>
        </div>
        <div id="dsq-comment-body-16961" class="dsq-comment-body">
            <div id="dsq-comment-message-16961" class="dsq-comment-message"><p>Method 4 is cool but isnt the best if there is a non-bst arrangement near the root, and the tree is big. Then we might try this:Traverse all nodes starting from the root. For any current node, temporarily store the value of its parent also(obviously except for root), then 2 cases exist:<br />
Case1: CN(current node) < parent<br />
2 checks:<br />
1)	left node <current node<br />
2)	right node>current node  &#038;&#038; right node>
<parent Case2: current node(current node) >parent<br />
2 checks:<br />
1)	left node <current node  &#038;&#038; left node>parent<br />
2)	right node>>current node</current></parent>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-adityasraf even thread-even depth-1" id="dsq-comment-16960">
        <div id="dsq-comment-header-16960" class="dsq-comment-header">
            <cite id="dsq-cite-16960">
                <span id="dsq-author-user-16960">AdityaSraf</span>
            </cite>
        </div>
        <div id="dsq-comment-body-16960" class="dsq-comment-body">
            <div id="dsq-comment-message-16960" class="dsq-comment-message"><pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-gupt odd alt thread-odd thread-alt depth-1" id="dsq-comment-16835">
        <div id="dsq-comment-header-16835" class="dsq-comment-header">
            <cite id="dsq-cite-16835">
                <span id="dsq-author-user-16835">Gupt</span>
            </cite>
        </div>
        <div id="dsq-comment-body-16835" class="dsq-comment-body">
            <div id="dsq-comment-message-16835" class="dsq-comment-message"><p>method 4 is just awesome</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-15465">
        <div id="dsq-comment-header-15465" class="dsq-comment-header">
            <cite id="dsq-cite-15465">
                <span id="dsq-author-user-15465">Nikin</span>
            </cite>
        </div>
        <div id="dsq-comment-body-15465" class="dsq-comment-body">
            <div id="dsq-comment-message-15465" class="dsq-comment-message"><pre> <code language="C">

bool isBST(node *sr)
{
   static node *prev = NULL;

if(sr)
{
if(!isBST(sr-&gt;left))
return false;

if(prev!=NULL &amp;&amp; prev-&gt;data &gt; sr-&gt;data)
return false;

return isBST(sr-&gt;right);

}
return true;

}

</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-rameshdasari odd alt depth-2" id="dsq-comment-16138">
        <div id="dsq-comment-header-16138" class="dsq-comment-header">
            <cite id="dsq-cite-16138">
                <span id="dsq-author-user-16138">rameshdasari</span>
            </cite>
        </div>
        <div id="dsq-comment-body-16138" class="dsq-comment-body">
            <div id="dsq-comment-message-16138" class="dsq-comment-message"><p>hi can i have display function for binary tree<br />
that looks like<br />
                   1<br />
                  / \<br />
                 /   \<br />
                2     3<br />
               / \   / \<br />
              5   6 7   8</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-10682">
        <div id="dsq-comment-header-10682" class="dsq-comment-header">
            <cite id="dsq-cite-10682">
http://www.geeksforgeeks.org/archives/3042                <span id="dsq-author-user-10682">deep</span>
            </cite>
        </div>
        <div id="dsq-comment-body-10682" class="dsq-comment-body">
            <div id="dsq-comment-message-10682" class="dsq-comment-message"><p>i think how we will deal wid BST containing similar elements depends on biasing.<br />
wiki is using right biasing.</p>
<p>while StandFord is using left biasing.<br />
(for each node, all elements in its left subtree are less-or-equal to the node (). )</p>
<p>use the code will depends on wich alignment we are using.</p>
<p>dan if we are given a random BST wid equal elements dan how we will detect.</p>
<p>is dere any standard convention ?</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-10681">
        <div id="dsq-comment-header-10681" class="dsq-comment-header">
            <cite id="dsq-cite-10681">
http://www.geeksforgeeks.org/archives/3042                <span id="dsq-author-user-10681">deep</span>
            </cite>
        </div>
        <div id="dsq-comment-body-10681" class="dsq-comment-body">
            <div id="dsq-comment-message-10681" class="dsq-comment-message"><p>i think dealing with equal vales in BST is totally convention(left biasing or right biasing) dependent.<br />
 becoz on wiki right biasing is used (The right subtree of a node contains only nodes with keys greater than or equal to the node&#8217;s key.)</p>
<p>while on StandFord Page left biasing is used (for each node, all elements in its left subtree are less-or-equal to the node ().)</p>
<p>i think the result of whether a BT containing equal elements is BST or not totally depends on wich biasing we used in our code.</p>
<p>dan when we hav given a random BST, how will predict it correctly?</p>
<p>it will  vary from program to program.</p>
<p>Is dere any standard convention?</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-2" id="dsq-comment-27992">
        <div id="dsq-comment-header-27992" class="dsq-comment-header">
            <cite id="dsq-cite-27992">
                <span id="dsq-author-user-27992">Praveen kumar Meena</span>
            </cite>
        </div>
        <div id="dsq-comment-body-27992" class="dsq-comment-body">
            <div id="dsq-comment-message-27992" class="dsq-comment-message"><p>//this travesal is using thread in_order. this is work easily the case of same right node of a tree and it return false. if any default then tell me?? </p>
<p>bool is_Bst(node* root)</p>
<p>{</p>
<p>    if(root==NULL)</p>
<p>      return true;</p>
<p>     else</p>
<p>     {</p>
<p>          node *p,*p1;</p>
<p>          p=root;</p>
<p>          int min=0;</p>
<p>          while(p)</p>
<p>           {</p>
<p>                   if(p-&gt;left==NULL)</p>
<p>                   {<br />
 //check for left value of root is less then root<br />
                        if(p-&gt;val&gt;=min)</p>
<p>                         {</p>
<p> //this part  is handle equal root and right chaild problem.<br />
                              if(p-&gt;right!=NULL &amp;&amp; p-&gt;value==(p-&gt;right)-&gt;val)    </p>
<p>                                {</p>
<p>                                       return false ;                       </p>
<p>                                 }</p>
<p>                                 min=p-&gt;val;</p>
<p>                                       p=p-&gt;right;</p>
<p>                          }</p>
<p>                    }<br />
else </p>
<p>{</p>
<p>  p1=p-&gt;left;<br />
//find right most node<br />
while(p1-&gt;right!=NULL &amp;&amp; p1-&gt;right!=p)</p>
<p>{</p>
<p>   p1=p1-&gt;right;</p>
<p>}</p>
<p>if(p1-&gt;right==NULL)<br />
{</p>
<p>    p1-&gt;right=p; //makes thread with its inorder pre_node.</p>
<p>    p=p-&gt;left;</p>
<p>}</p>
<p>else if (p1-&gt;right==p)</p>
<p>{</p>
<p>      p1-&gt;right=NULL;   //again makes the tree unthreaded&#8230;&#8230;</p>
<p>     if(p-&gt;val&gt;=min)<br />
{</p>
<p>if(p-&gt;right!=NULL &amp;&amp; p-&gt;value==(p-&gt;right)-&gt;val)</p>
<p>{</p>
<p>return false;</p>
<p>}</p>
<p>min=p-&gt;val;</p>
<p>p=p-&gt;right;</p>
<p>}</p>
<p>}</p>
<p>            }<br />
       }<br />
return true;<br />
}</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-9580">
        <div id="dsq-comment-header-9580" class="dsq-comment-header">
            <cite id="dsq-cite-9580">
                <span id="dsq-author-user-9580">suresh</span>
            </cite>
        </div>
        <div id="dsq-comment-body-9580" class="dsq-comment-body">
            <div id="dsq-comment-message-9580" class="dsq-comment-message"><pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
Auxiliary Space : O(1) if Function Call Stack size is not considered, otherwise O(n)
can u explain this?
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-9046">
        <div id="dsq-comment-header-9046" class="dsq-comment-header">
            <cite id="dsq-cite-9046">
http://vfdvd                <span id="dsq-author-user-9046">!(geek)</span>
            </cite>
        </div>
        <div id="dsq-comment-body-9046" class="dsq-comment-body">
            <div id="dsq-comment-message-9046" class="dsq-comment-message"><p>i think this will work&#8230;.correck me if iam wrong&#8230;</p>
<p>int check(struct node* root)<br />
{<br />
if(root==NULL)<br />
return 1;<br />
if(root-&gt;leftright)<br />
return 1;<br />
else<br />
return 0;<br />
return check(root-&gt;left)||check(root-&gt;right);<br />
}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-8630">
        <div id="dsq-comment-header-8630" class="dsq-comment-header">
            <cite id="dsq-cite-8630">
                <span id="dsq-author-user-8630">durgesh</span>
            </cite>
        </div>
        <div id="dsq-comment-body-8630" class="dsq-comment-body">
            <div id="dsq-comment-message-8630" class="dsq-comment-message"><pre> <code language="C">
/* I think this version will work. Please correct if anything goes wrong */

bool isBST(struct	Node*	start)
{
	bool	ltree	=	true;
	bool	rtree	=	true;
	if(start	==	NULL)
		return	true;
	else	if(start-&gt;left	==	NULL	&amp;&amp;	start-&gt;right	==	NULL)
		return	true;
	else	if(start-&gt;left	!=	NULL)
	{
		isBST(start-&gt;left);
		ltree	=	(start-&gt;left-&gt;value	&lt;	start-&gt;value);		
	}
	else	if(start-&gt;right	!=	NULL)
	{
		isBST(start-&gt;right);
		rtree	=	(start-&gt;right-&gt;value	&gt;=	start-&gt;value);		
	}
	return	ltree	&amp;&amp;	rtree;
}

Call the above function with root node of the tree and if it return true then the tree is bst else not.

</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-2" id="dsq-comment-14330">
        <div id="dsq-comment-header-14330" class="dsq-comment-header">
            <cite id="dsq-cite-14330">
http://siddhantsharma91.blogspot.in                <span id="dsq-author-user-14330">siddhant</span>
            </cite>
        </div>
        <div id="dsq-comment-body-14330" class="dsq-comment-body">
            <div id="dsq-comment-message-14330" class="dsq-comment-message"><p>will not work for
<pre>
     5
    / \
   4   8
  / \ / \
 3  6 10 9</pre>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-8231">
        <div id="dsq-comment-header-8231" class="dsq-comment-header">
            <cite id="dsq-cite-8231">
                <span id="dsq-author-user-8231">sachin</span>
            </cite>
        </div>
        <div id="dsq-comment-body-8231" class="dsq-comment-body">
            <div id="dsq-comment-message-8231" class="dsq-comment-message"><p>In method 3 it is not testing tree with a single child, however BST should have either 0 or 1 child.<br />
Updated tested code is below for this &#8211; </p>
<p>#include<br />
#include<br />
#include</p>
<p>struct node<br />
{<br />
	int data;<br />
	struct node *left;<br />
	struct node *right;<br />
};</p>
<p>struct node * newNode(int data)<br />
{<br />
        struct node *temp=(struct node *)malloc(sizeof(struct node));<br />
        temp-&gt;data=data;<br />
        temp-&gt;left=NULL;<br />
        temp-&gt;right=NULL;<br />
        return temp;<br />
}</p>
<p>bool isBSTutil(struct node *node,int min,int max)<br />
{<br />
	if(node==NULL)<br />
		return true;<br />
	if((node-&gt;left!=NULL &amp;&amp; node-&gt;right==NULL) || (node-&gt;left==NULL &amp;&amp; node-&gt;right!=NULL))<br />
		return false;<br />
	if(node-&gt;data data &gt; max)<br />
		return false;</p>
<p>	return (isBSTutil(node-&gt;left,min,node-&gt;data-1) &amp;&amp; isBSTutil(node-&gt;right,node-&gt;data+1,max));</p>
<p>}</p>
<p>bool isBST(struct node *root)<br />
{<br />
	return isBSTutil(root,INT_MIN,INT_MAX);<br />
}</p>
<p>int main()<br />
{</p>
<p>	struct node *root;<br />
        root = newNode(10);<br />
        root-&gt;left=newNode(5);<br />
        root-&gt;right=newNode(17);<br />
        (root-&gt;left)-&gt;left=newNode(3);<br />
        (root-&gt;left)-&gt;right=newNode(8);<br />
	(root-&gt;right)-&gt;left=newNode(13);</p>
<p>	bool status = isBST(root);<br />
	if(status)<br />
		printf(&#8221; TREE is BST &#8220;);<br />
	else<br />
		printf(&#8221; TREE is not a BST &#8220;);<br />
	return 0;<br />
}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-laddoo even thread-odd thread-alt depth-1" id="dsq-comment-7531">
        <div id="dsq-comment-header-7531" class="dsq-comment-header">
            <cite id="dsq-cite-7531">
                <span id="dsq-author-user-7531">laddoo</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7531" class="dsq-comment-body">
            <div id="dsq-comment-message-7531" class="dsq-comment-message"><p>In method 4: rather than</p>
<p>If the value of the currently visited node is greater than the previous value then tree is not BST.</p>
<p>it should be:</p>
<p>If the value of the currently visited node is lesser than the previous value then tree is not BST.</p>
<p>Am I Right?</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-geeksforgeeks bypostauthor odd alt depth-2" id="dsq-comment-7538">
        <div id="dsq-comment-header-7538" class="dsq-comment-header">
            <cite id="dsq-cite-7538">
                <span id="dsq-author-user-7538">GeeksforGeeks</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7538" class="dsq-comment-body">
            <div id="dsq-comment-message-7538" class="dsq-comment-message"><p>@laddoo: Thanks for pointing this out.  We have updated the post.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment byuser comment-author-laddoo even thread-even depth-1" id="dsq-comment-7530">
        <div id="dsq-comment-header-7530" class="dsq-comment-header">
            <cite id="dsq-cite-7530">
                <span id="dsq-author-user-7530">laddoo</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7530" class="dsq-comment-body">
            <div id="dsq-comment-message-7530" class="dsq-comment-message"><p>Guyz,<br />
in Method 4 : Rather than<br />
&#8220;If the value of the currently visited node is greater than the previous value then tree is not BST.&#8221;</p>
<p>I think,it should be written as :<br />
&#8220;If the value of the currently visited node is lesser than the previous value then tree is not BST.&#8221;</p>
<p>Am i right?</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-9926">
        <div id="dsq-comment-header-9926" class="dsq-comment-header">
            <cite id="dsq-cite-9926">
                <span id="dsq-author-user-9926">saibharath</span>
            </cite>
        </div>
        <div id="dsq-comment-body-9926" class="dsq-comment-body">
            <div id="dsq-comment-message-9926" class="dsq-comment-message"><p>YEAH DUDE U R RIGHT</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment byuser comment-author-psychocoder even thread-odd thread-alt depth-1" id="dsq-comment-7355">
        <div id="dsq-comment-header-7355" class="dsq-comment-header">
            <cite id="dsq-cite-7355">
                <span id="dsq-author-user-7355">PsychoCoder</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7355" class="dsq-comment-body">
            <div id="dsq-comment-message-7355" class="dsq-comment-message"><p>If the 3rd method,</p>
<p>If we do this at the last step it will be better,</p>
<p>return (isBSTUtil(node->left, min, (node->data-1)) &#038;&#038;<br />
    isBSTUtil(node->right, node->data+1, max));</p>
<p>In the sense that in BST all nodes are distinct. So it is better to do this. Otherwise it may conclude a given BST as true where a root&#8217;s left node has same value as the root node.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-geeksforgeeks bypostauthor odd alt depth-2" id="dsq-comment-7358">
        <div id="dsq-comment-header-7358" class="dsq-comment-header">
            <cite id="dsq-cite-7358">
                <span id="dsq-author-user-7358">GeeksforGeeks</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7358" class="dsq-comment-body">
            <div id="dsq-comment-message-7358" class="dsq-comment-message"><p>@PsychoCoder: Thanks for pointing this out.  We have modified all the methods so that trees with same keys are not considered as BST (as given in the problem statement). Keep it up!</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-7131">
        <div id="dsq-comment-header-7131" class="dsq-comment-header">
            <cite id="dsq-cite-7131">
                <span id="dsq-author-user-7131">Lakshmanan</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7131" class="dsq-comment-body">
            <div id="dsq-comment-message-7131" class="dsq-comment-message"><p>How about this ?<br />
Over all idea:<br />
Perform Recursive in-oder traversal<br />
Store the in-order predecessor and check if the predecessor is greater than the current element</p>
<p>#define NEG_INFINITY 1&lt;left) == NO) return NO;<br />
        if (prev &gt; p-&gt;data)<br />
        {<br />
                return NO;<br />
        }<br />
        else prev = p-&gt;data;<br />
        if (isBST(p-&gt;right) == NO) return NO;<br />
        return YES;<br />
}</p>
<p>Complexity : Time &#8211; O(n) &#8211; Complexity of inorder traversal. Space O(1), 1 static/ global variable to store the in-order predecessor.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-7133">
        <div id="dsq-comment-header-7133" class="dsq-comment-header">
            <cite id="dsq-cite-7133">
                <span id="dsq-author-user-7133">Lakshmanan</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7133" class="dsq-comment-body">
            <div id="dsq-comment-message-7133" class="dsq-comment-message"><p>The code is messed up due to html decoding.</p>
<p>#define YES 0<br />
#define NO 1</p>
<p>int isBST(struct node *p)<br />
{<br />
        static int prev = NEG_INFINITY;<br />
        if (p == NULL) return YES;<br />
        if (isBST(p-&gt;left) == NO) return NO;<br />
        if (prev &gt; p-&gt;data)<br />
        {<br />
                return NO;<br />
        }<br />
        else prev = p-&gt;data;<br />
        if (isBST(p-&gt;right) == NO) return NO;<br />
        return YES;<br />
}</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-geeksforgeeks bypostauthor even depth-3" id="dsq-comment-7135">
        <div id="dsq-comment-header-7135" class="dsq-comment-header">
            <cite id="dsq-cite-7135">
                <span id="dsq-author-user-7135">GeeksforGeeks</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7135" class="dsq-comment-body">
            <div id="dsq-comment-message-7135" class="dsq-comment-message"><p>@Lakshmanan: To retain formatting and for syntax highlighting, please paste your code between sourcecode tags</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-7017">
        <div id="dsq-comment-header-7017" class="dsq-comment-header">
            <cite id="dsq-cite-7017">
                <span id="dsq-author-user-7017">Ahmad Mansoor</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7017" class="dsq-comment-body">
            <div id="dsq-comment-message-7017" class="dsq-comment-message"><p>I&#8217;ve solved this problem with two functions..<br />
the first one to check the root..<br />
the second to check the rest of the tree..<br />
the code below is a little bit hideous (stupid variable names)..<br />
but it will do the job <img src="http://d2o58evtke57tz.cloudfront.net/wp-includes/images/smilies/icon_smile.gif" alt=":)" class="wp-smiley" /></p>
<pre> <code language="C">
bool isBST()
    {
        Node *ptr=root;
        bool L=false;
        bool R=false;
        int left, right;

        if(ptr-&gt;left!=NULL){left=ptr-&gt;left-&gt;data; L=true;}
        if(ptr-&gt;right!=NULL){right = ptr-&gt;right-&gt;data; R=true;}

        if(!L &amp;&amp; !R)return true;

        if(L &amp;&amp; ptr-&gt;data&lt;left)return false;
        if(R &amp;&amp; ptr-&gt;data&gt;=right)return false;

        bool LL=true, RR=true;
        if(L)LL=isBST(ptr-&gt;left, ptr-&gt;data, true);
        if(R)RR=isBST(ptr-&gt;right, ptr-&gt;data, false);

        return LL&amp;&amp;RR;
    }

    bool isBST(Node* ptr, int parent, bool status)
    {
        bool L=false;
        bool R=false;
        int left, right;

        if(ptr-&gt;left!=NULL){left=ptr-&gt;left-&gt;data; L=true;}
        if(ptr-&gt;right!=NULL){right = ptr-&gt;right-&gt;data; R=true;}

        if(!L &amp;&amp; !R)return true;

        if(status)
        {
            if(L &amp;&amp; ptr-&gt;data&lt;left)return false;
            if(R &amp;&amp; (ptr-&gt;data&gt;=right || right&gt;parent))return false;
        }

        else
        {
            if(L &amp;&amp; (ptr-&gt;data&lt;left || left&lt;=parent))return false;
            if(R &amp;&amp; ptr-&gt;data&gt;=right)return false;
        }

        bool LL=true, RR=true;
        if(L)LL=isBST(ptr-&gt;left, ptr-&gt;data, true);
        if(R)RR=isBST(ptr-&gt;right, ptr-&gt;data, false);

        return LL&amp;&amp;RR;
    }
</code> </pre>
<p>The main idea here is to check (Is the parent the left child of the grandparent or the right one?)</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-6970">
        <div id="dsq-comment-header-6970" class="dsq-comment-header">
            <cite id="dsq-cite-6970">
                <span id="dsq-author-user-6970">Abhimanyu Vohra</span>
            </cite>
        </div>
        <div id="dsq-comment-body-6970" class="dsq-comment-body">
            <div id="dsq-comment-message-6970" class="dsq-comment-message"><p>I am not able to get why +1 is added in the below line of method 3, can you please specify the logic behind this, thanks.<br />
isBSTUtil(node-&gt;right, node-&gt;data+1, max);</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-abhinav_arora odd alt thread-odd thread-alt depth-1" id="dsq-comment-6881">
        <div id="dsq-comment-header-6881" class="dsq-comment-header">
            <cite id="dsq-cite-6881">
                <span id="dsq-author-user-6881">Abhinav</span>
            </cite>
        </div>
        <div id="dsq-comment-body-6881" class="dsq-comment-body">
            <div id="dsq-comment-message-6881" class="dsq-comment-message"><p>Hi Please check this method&#8230;.I have used an approach similar to the optimized version of the diameter and the isBalancedTree Questions. Here I am recursively able to keep track of the minimum and the maximum element of each subtree. Using this I check whether the value at root is greater than the Max of the left subtree and is less than the Min of the Right SUbtree..</p>
<pre> <code language="C">

int isBST(struct node *root, int *min,int *max)
{
    int lmin=0,lmax=0,rmin=0,rmax=0,l=0,r=0;

/*lmin and lmax keep track of min and max of left subtree */    
/*rmin and rmax  keep track of min and max of right tree */

    if(root==NULL)
    {
                  *min=-12345678; /* Used to indicate Null*/ 
                  *max=12345678;
                  return 1;
                  }
    
    if(root-&gt;left==NULL &amp;&amp; root-&gt;right==NULL)
    {
                        *min=*max=root-&gt;data;
                        return 1;
                        }
    l=isBST(root-&gt;left,&amp;lmin,&amp;lmax);
    r=isBST(root-&gt;right,&amp;rmin,&amp;rmax);

    *min=(lmin==-12345678)?root-&gt;data:lmin;
    *max=(rmax==12345678)?root-&gt;data:rmax;
    lmax=(lmax==12345678)?-lmax:lmax;
    rmin=(rmin==-12345678)?-rmin:rmin;
    return (l &amp;&amp; r &amp;&amp; root-&gt;data&gt;=lmax &amp;&amp; root-&gt;data&lt;=rmin);
    }
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-ygos even thread-even depth-1" id="dsq-comment-5805">
        <div id="dsq-comment-header-5805" class="dsq-comment-header">
            <cite id="dsq-cite-5805">
                <span id="dsq-author-user-5805">ygos</span>
            </cite>
        </div>
        <div id="dsq-comment-body-5805" class="dsq-comment-body">
            <div id="dsq-comment-message-5805" class="dsq-comment-message"><p>Method 4: Inorder Traversal<br />
It can be done  with O(1) auxiliary storage. No need to store the entire tree in array. Just need to store previous node to compare with the current node.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-kartik odd alt depth-2" id="dsq-comment-5820">
        <div id="dsq-comment-header-5820" class="dsq-comment-header">
            <cite id="dsq-cite-5820">
                <span id="dsq-author-user-5820">kartik</span>
            </cite>
        </div>
        <div id="dsq-comment-body-5820" class="dsq-comment-body">
            <div id="dsq-comment-message-5820" class="dsq-comment-message"><p>@ygos: Agree with you.  The post will be updated accordingly.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-3" id="dsq-comment-6433">
        <div id="dsq-comment-header-6433" class="dsq-comment-header">
            <cite id="dsq-cite-6433">
                <span id="dsq-author-user-6433">ar</span>
            </cite>
        </div>
        <div id="dsq-comment-body-6433" class="dsq-comment-body">
            <div id="dsq-comment-message-6433" class="dsq-comment-message"><p>Not yet updated</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-geeksforgeeks bypostauthor odd alt depth-4" id="dsq-comment-6455">
        <div id="dsq-comment-header-6455" class="dsq-comment-header">
            <cite id="dsq-cite-6455">
                <span id="dsq-author-user-6455">GeeksforGeeks</span>
            </cite>
        </div>
        <div id="dsq-comment-body-6455" class="dsq-comment-body">
            <div id="dsq-comment-message-6455" class="dsq-comment-message"><p>@ar: This has been updated now.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-5" id="dsq-comment-7001">
        <div id="dsq-comment-header-7001" class="dsq-comment-header">
            <cite id="dsq-cite-7001">
                <span id="dsq-author-user-7001">FlawLess</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7001" class="dsq-comment-body">
            <div id="dsq-comment-message-7001" class="dsq-comment-message"><p>can you please give a sample of implementation for your suggested method? that would be much appraised!</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-5600">
        <div id="dsq-comment-header-5600" class="dsq-comment-header">
            <cite id="dsq-cite-5600">
https://www.facebook.com/profile.php?id=100000362926576                <span id="dsq-author-user-5600">levis</span>
            </cite>
        </div>
        <div id="dsq-comment-body-5600" class="dsq-comment-body">
            <div id="dsq-comment-message-5600" class="dsq-comment-message"><p>we can use the following method keeping track of the inorder predecessor</p>
<p>int num=-99999999;</p>
<p>void isBstutility(struct node *root)<br />
{<br />
int true=1;<br />
true =isBst(root,&amp;num);<br />
if(true)<br />
printf(&#8220;it is a binary search tree&#8221;);<br />
else<br />
printf(&#8220;not a binary search tree&#8221;);<br />
}</p>
<p>int num=-99999999;<br />
int  isBst(struct node *root,int *pred)<br />
{<br />
if(root==NULL)<br />
return 1 ;<br />
if(root-&gt;left!=NULL)<br />
{<br />
isBst(root-&gt;left,red);<br />
}<br />
if(root-&gt;data&gt;*pred)<br />
*pred=root-&gt;data;<br />
else{return 0;}<br />
isBst(root-&gt;right,pred);<br />
}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-5447">
        <div id="dsq-comment-header-5447" class="dsq-comment-header">
            <cite id="dsq-cite-5447">
                <span id="dsq-author-user-5447">someUser</span>
            </cite>
        </div>
        <div id="dsq-comment-body-5447" class="dsq-comment-body">
            <div id="dsq-comment-message-5447" class="dsq-comment-message"><p>//Initially predecessor = NULL</p>
<p>int isBst(tree* root, tree** predecessor){</p>
<p>  if(!root)<br />
    return 1;</p>
<p>  if(!root-&gt; left &amp;&amp; !root -&gt; right){<br />
    if(*predecessor){<br />
      if((*predecessor) -&gt; data &gt; root -&gt; data)<br />
	return 0;<br />
    }<br />
    *predecessor = root;<br />
    return 1;<br />
  }<br />
  if(isBst(root -&gt;left, predecessor)){<br />
    if(*predecessor){<br />
      if ((*predecessor) -&gt; data &gt; root -&gt; data){ return 0;}<br />
    }<br />
    *predecessor = root;<br />
    return isBst(root -&gt; right, predecessor);<br />
  }</p>
<p>  return 0;<br />
}</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-5448">
        <div id="dsq-comment-header-5448" class="dsq-comment-header">
            <cite id="dsq-cite-5448">
                <span id="dsq-author-user-5448">someUser</span>
            </cite>
        </div>
        <div id="dsq-comment-body-5448" class="dsq-comment-body">
            <div id="dsq-comment-message-5448" class="dsq-comment-message"><p>This works in all cases.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-4910">
        <div id="dsq-comment-header-4910" class="dsq-comment-header">
            <cite id="dsq-cite-4910">
                <span id="dsq-author-user-4910">varun sharma</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4910" class="dsq-comment-body">
            <div id="dsq-comment-message-4910" class="dsq-comment-message"><p>This is how I did it without using a stack or an array or INT_MIN &amp; INT_MAX</p>
<p>     bool flag=1;<br />
     int previous=&#8221;;</p>
<p>bool Detect_BST(struct node* node)<br />
{<br />
     if (node == NULL)<br />
      return flag;      </p>
<p>      flag = Detect_BST(node-&gt;left);</p>
<p>      if(previous==&#8221;)<br />
      previous = node-&gt;data-1;<br />
	  if(node-&gt;data data;<br />
      printf(&#8220;%d\n&#8221;, node-&gt;data); </p>
<p>      flag = Detect_BST(node-&gt;right);</p>
<p>     return flag;<br />
}</p>
<p>It works.. <img src="http://d2o58evtke57tz.cloudfront.net/wp-includes/images/smilies/icon_smile.gif" alt=":)" class="wp-smiley" /></p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-agniswar odd alt depth-2" id="dsq-comment-5599">
        <div id="dsq-comment-header-5599" class="dsq-comment-header">
            <cite id="dsq-cite-5599">
                <span id="dsq-author-user-5599">Agniswar</span>
            </cite>
        </div>
        <div id="dsq-comment-body-5599" class="dsq-comment-body">
            <div id="dsq-comment-message-5599" class="dsq-comment-message"><p>@Varun: I did not get your algorithm..could you please explain me your algo ??</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-4743">
        <div id="dsq-comment-header-4743" class="dsq-comment-header">
            <cite id="dsq-cite-4743">
http://www.jugadengg.com                <span id="dsq-author-user-4743">Tushar</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4743" class="dsq-comment-body">
            <div id="dsq-comment-message-4743" class="dsq-comment-message"><p>in method 3 if we have a tree like:<br />
       5<br />
      / \<br />
     /   \<br />
    4     5<br />
   / \     \<br />
  3   4     6</p>
<p>Then, the answer will be false as from node containing the first 4 we will send a value of min to right tree as 4+1,i.e.,5<br />
on checking in the right child of this node, 4&lt;5 &#8211; the min value, we return 0.<br />
This means we are strictly saying that right subtree cannot have a value equal to a node. I think that equal values are allowed in both right as well as left subtrees</p>
<p>There can be another clash in the two 5&#039;s but we won&#039;t get to that place as we get a false before that is evaluated.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-kartik odd alt depth-2" id="dsq-comment-4745">
        <div id="dsq-comment-header-4745" class="dsq-comment-header">
            <cite id="dsq-cite-4745">
                <span id="dsq-author-user-4745">kartik</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4745" class="dsq-comment-body">
            <div id="dsq-comment-message-4745" class="dsq-comment-message"><p>@Tushar: Take a close look at the definition of the BST given at the begining of the post (Also see <a href="http://en.wikipedia.org/wiki/Binary_search_tree" rel="nofollow">http://en.wikipedia.org/wiki/Binary_search_tree</a>).  The definition says greater than or less than, not &#8220;greater than equal to&#8221; or &#8220;less than equal to&#8221;.  So your tree is not a valid BST.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-3" id="dsq-comment-4748">
        <div id="dsq-comment-header-4748" class="dsq-comment-header">
            <cite id="dsq-cite-4748">
http://www.jugadengg.com                <span id="dsq-author-user-4748">Tushar</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4748" class="dsq-comment-body">
            <div id="dsq-comment-message-4748" class="dsq-comment-message"><p>I am sorry for missing out on the explanation at the top.<br />
But, then in left subtree, there will be a problem.</p>
<p>Since the value of max sent wil be node-&gt;data, if we have a node on left contaning the same value, it will have node-&gt;data==max and not node-&gt;data&gt;max, so we will not return 0 for that case. However, according to above explanation this case should not be allowed as well.</p>
<p>we should call:</p>
<pre> <code language="C">isBSTUtil(node-&gt;left, min, node-&gt;data-1)</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt depth-3" id="dsq-comment-10680">
        <div id="dsq-comment-header-10680" class="dsq-comment-header">
            <cite id="dsq-cite-10680">
http://www.geeksforgeeks.org/archives/3042                <span id="dsq-author-user-10680">deep</span>
            </cite>
        </div>
        <div id="dsq-comment-body-10680" class="dsq-comment-body">
            <div id="dsq-comment-message-10680" class="dsq-comment-message"><p>@kartik<br />
from above provided links, <a href="http://en.wikipedia.org/wiki/Binary_search_tree" rel="nofollow">http://en.wikipedia.org/wiki/Binary_search_tree</a><br />
is using right biasing<br />
according to wiki  &#8220;The left subtree of a node contains only nodes with keys less than the node&#8217;s key.<br />
The right subtree of a node contains only nodes with keys greater than or equal to the node&#8217;s key.&#8221;</p>
<p>while Stanford University is using left biasing<br />
nd according to them<br />
&#8220;for each node, all elements in its left subtree are less-or-equal to the node ().&#8221;</p>
<p>i think implementation is totally biasing dependent</p>
<p>if we have given a random tree dan how will we detect whether it is BST or not??</p>
<p>correct me&#8230;.</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-4613">
        <div id="dsq-comment-header-4613" class="dsq-comment-header">
            <cite id="dsq-cite-4613">
                <span id="dsq-author-user-4613">kapil</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4613" class="dsq-comment-body">
            <div id="dsq-comment-message-4613" class="dsq-comment-message"><p>The Maxvalue() and Minvalue() methods can return wrong value as if a tree is not a BST the leftmost node and rightmost node will not give correct min and max value.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-kartik odd alt depth-2" id="dsq-comment-4746">
        <div id="dsq-comment-header-4746" class="dsq-comment-header">
            <cite id="dsq-cite-4746">
                <span id="dsq-author-user-4746">kartik</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4746" class="dsq-comment-body">
            <div id="dsq-comment-message-4746" class="dsq-comment-message"><p>We can wrtie a MinValue function that does Inorder traversal of a Binary Tree and returns Minimum Value.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-4482">
        <div id="dsq-comment-header-4482" class="dsq-comment-header">
            <cite id="dsq-cite-4482">
                <span id="dsq-author-user-4482">Sourav</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4482" class="dsq-comment-body">
            <div id="dsq-comment-message-4482" class="dsq-comment-message"><p>Stack st;</p>
<pre> <code language="C">
boolean InOrder( node * t) 
{
  InOrder(t-&gt;left);
  //Use stack instead of temp array
   if( st.empty())
     push(t-&gt;data);
   else if( st.getTop()&gt; t-&gt;data )
     return false;
   else
    {
      st.pop();
      st.push(t-&gt;data);
    }
     // Any time only 1 element in Stack
  InOrder(t-&gt;right);
}
</code> </pre>
<p>Time: O(n)<br />
Space: O(1)..as only 1 element in stack..<br />
hoe i made my point!</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-maverick odd alt thread-odd thread-alt depth-1" id="dsq-comment-4205">
        <div id="dsq-comment-header-4205" class="dsq-comment-header">
            <cite id="dsq-cite-4205">
                <span id="dsq-author-user-4205">maverick</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4205" class="dsq-comment-body">
            <div id="dsq-comment-message-4205" class="dsq-comment-message"><p>can  anyone please explain why  the value of the MIN is incremented by 1 in method-3 each time a call is made to right sub-tree?? i think the program works fine without incrementing min by 1 in each recursive call.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-4179">
        <div id="dsq-comment-header-4179" class="dsq-comment-header">
            <cite id="dsq-cite-4179">
                <span id="dsq-author-user-4179">Dreamer</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4179" class="dsq-comment-body">
            <div id="dsq-comment-message-4179" class="dsq-comment-message"><p>isBSTUtil(node-&gt;right, node-&gt;data+1, max) should be<br />
isBSTUtil(node-&gt;right, node-&gt;data, max)</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-3612">
        <div id="dsq-comment-header-3612" class="dsq-comment-header">
            <cite id="dsq-cite-3612">
                <span id="dsq-author-user-3612">guest123</span>
            </cite>
        </div>
        <div id="dsq-comment-body-3612" class="dsq-comment-body">
            <div id="dsq-comment-message-3612" class="dsq-comment-message"><p>Hi all,</p>
<p>Here is one solution let me know if its correct or not:<br />
I am not writing exact code its a kind of pseudo code:</p>
<pre> <code language="C">
checkBST(node *root)
{

 if(root==NULL)
  {
   return 0;
  }
else
 if(root-&gt;left!=NULL &amp;&amp; root-&gt;left-&gt;data data)
  {
   node *l=root-&gt;left;
   node *ll=l-&gt;left, *rr=l-&gt;right;
   if( (ll!=NULL &amp;&amp; ll-&gt;data &gt; l-&gt;data )|| (rr!=NULL &amp;&amp;           (rr-&gt;datadata || rr-&gt;data &gt; root-&gt;data)) )
   return &quot;NOT A BST&quot;
 else if (root-&gt;left !=NULL) checkBst(root-&gt;left)

//similarly for right node

if(root-&gt;right!=NULL &amp;&amp; root-&gt;right-&gt;data &gt; root-&gt;data)
  {
   node *r=root-&gt;right;
   node *ll=r-&gt;left, *rr=r-&gt;right;
   if( (rr!=NULL &amp;&amp; rr-&gt;data data )|| (ll!=NULL &amp;&amp;           (ll-&gt;data &gt; r-&gt;data || ll-&gt;data data)) )
   return &quot;NOT A BST&quot;
 else if (root-&gt;right !=NULL) checkBst(root-&gt;right)
</code> </pre>
<p>Please let me know if any mistake.<br />
Thanks.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-2" id="dsq-comment-3621">
        <div id="dsq-comment-header-3621" class="dsq-comment-header">
            <cite id="dsq-cite-3621">
                <span id="dsq-author-user-3621">guest123</span>
            </cite>
        </div>
        <div id="dsq-comment-body-3621" class="dsq-comment-body">
            <div id="dsq-comment-message-3621" class="dsq-comment-message"><p>there is mistake in the above code I am writing corrected code:<br />
 if(root-&gt;left!=NULL &amp;&amp; root-&gt;left-&gt;data data)</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-3031">
        <div id="dsq-comment-header-3031" class="dsq-comment-header">
            <cite id="dsq-cite-3031">
                <span id="dsq-author-user-3031">SG ..</span>
            </cite>
        </div>
        <div id="dsq-comment-body-3031" class="dsq-comment-body">
            <div id="dsq-comment-message-3031" class="dsq-comment-message"><p>If I am not wrong then third method is not logically correct</p>
<pre> <code language="C">
    Tree *node = newNode(40);
    node-&gt;left        = newNode(20);
    node-&gt;right       = newNode(60);
    node-&gt;left-&gt;left  = newNode(10);
    node-&gt;left-&gt;right = newNode(30); 
    node-&gt;right-&gt;left = newNode(35);
</code> </pre>
<p>this one is not bst but it returns 1</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-sandeep even depth-2" id="dsq-comment-3033">
        <div id="dsq-comment-header-3033" class="dsq-comment-header">
            <cite id="dsq-cite-3033">
                <span id="dsq-author-user-3033">Sandeep</span>
            </cite>
        </div>
        <div id="dsq-comment-body-3033" class="dsq-comment-body">
            <div id="dsq-comment-message-3033" class="dsq-comment-message"><p>@SG ..<br />
It worked fine for me.  Try following program, it prints &#8220;Not a BST&#8221;.</p>
<pre> <code language="C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;limits.h&gt;
 
/* A binary tree node has data, pointer to left child
   and a pointer to right child */
struct node
{
    int data;
    struct node* left;
    struct node* right;
};
 
int isBSTUtil(struct node* node, int min, int max);
 
/* Returns true if the given tree is a binary search tree
 (efficient version). */
int isBST(struct node* node)
{
  return(isBSTUtil(node, INT_MIN, INT_MAX));
} 
 
/* Returns true if the given tree is a BST and its
   values are &gt;= min and &lt;= max. */
int isBSTUtil(struct node* node, int min, int max)
{ 
 
  /* an empty tree is BST */
  if (node==NULL)
     return 1;
 
  /* false if this node violates the min/max constraint */
  if (node-&gt;data &lt; min || node-&gt;data &gt; max)
     return 0; 
 
  /* otherwise check the subtrees recursively,
   tightening the min or max constraint */
  return
    isBSTUtil(node-&gt;left, min, node-&gt;data) &amp;&amp;
    isBSTUtil(node-&gt;right, node-&gt;data+1, max);
} 
 
/* Helper function that allocates a new node with the
   given data and NULL left and right pointers. */
struct node* newNode(int data)
{
  struct node* node = (struct node*)
                       malloc(sizeof(struct node));
  node-&gt;data = data;
  node-&gt;left = NULL;
  node-&gt;right = NULL;
 
  return(node);
}
 
/* Driver program to test above functions*/
int main()
{
  struct node *node = newNode(40);
  node-&gt;left        = newNode(20);
  node-&gt;right       = newNode(60);
  node-&gt;left-&gt;left  = newNode(10);
  node-&gt;left-&gt;right = newNode(30);
  node-&gt;right-&gt;left = newNode(35);
 
  if(isBST(node))
    printf(&quot;Is BST&quot;);
  else
    printf(&quot;Not a BST&quot;);
 
  getchar();
  return 0;
}
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-3" id="dsq-comment-3034">
        <div id="dsq-comment-header-3034" class="dsq-comment-header">
            <cite id="dsq-cite-3034">
                <span id="dsq-author-user-3034">SG ..</span>
            </cite>
        </div>
        <div id="dsq-comment-body-3034" class="dsq-comment-body">
            <div id="dsq-comment-message-3034" class="dsq-comment-message"><p>ohk .. i guess i made some blunder &#8230; yup its working fine for me &#8230;</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-2985">
        <div id="dsq-comment-header-2985" class="dsq-comment-header">
            <cite id="dsq-cite-2985">
                <span id="dsq-author-user-2985">unique72</span>
            </cite>
        </div>
        <div id="dsq-comment-body-2985" class="dsq-comment-body">
            <div id="dsq-comment-message-2985" class="dsq-comment-message"><p>Method 4 doesn&#8217;t require an array (see Vicas post above). Here&#8217;s an OOP version.</p>
<p>final class BSTChecker&lt;T extends Comparable&lt;? super T&gt;&gt; {<br />
  private T last = null;</p>
<p>  public static &lt;T extends Comparable&lt;? super T&gt;&gt; boolean check(Node&lt;T&gt; root) {<br />
    return new BSTChecker&lt;T&gt;().isSorted(root);<br />
  }</p>
<p>  private boolean isSorted(Node&lt;T&gt; root) {<br />
    if(null == root) {<br />
      return true;<br />
    }<br />
    if(isSorted(root.getLeft()) &amp;&amp; (null == last || 0 &gt; last.compareTo(root.getData()))) {<br />
      last = root.getData();<br />
      return isSorted(root.getRight());<br />
    }<br />
    return false;<br />
  }<br />
}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-2601">
        <div id="dsq-comment-header-2601" class="dsq-comment-header">
            <cite id="dsq-cite-2601">
                <span id="dsq-author-user-2601">Maulish S Soni</span>
            </cite>
        </div>
        <div id="dsq-comment-body-2601" class="dsq-comment-body">
            <div id="dsq-comment-message-2601" class="dsq-comment-message"><p>What if Tree contains data other then INT then INT_MIN and INT_MAX will not work. So what is the generic solution for any type of BST?</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-2075">
        <div id="dsq-comment-header-2075" class="dsq-comment-header">
            <cite id="dsq-cite-2075">
                <span id="dsq-author-user-2075">Harshit</span>
            </cite>
        </div>
        <div id="dsq-comment-body-2075" class="dsq-comment-body">
            <div id="dsq-comment-message-2075" class="dsq-comment-message"><pre> <code language="C">
Method 4 can be corrected by :

bool flag=true;
int previous=INT_MIN;
void inorder(node *nd,bool fromleft){
  if(flag==false)return;
  if(nd){
     inorder(nd-&gt;left, true);
     if(node-&gt;data &gt; previous &amp; fromleft){
           previous=node-&gt;data;
     }
     else if(node-&gt;data &gt;= previous &amp; !fromleft){
           previous=node-&gt;data;
     }
     else flag=false;
     if(flag)
     inorder(nd-&gt;right, false);
     else return;
   }
}
</code> </pre>
<p>call : inorder(root, left)</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-ravikant odd alt thread-even depth-1" id="dsq-comment-1809">
        <div id="dsq-comment-header-1809" class="dsq-comment-header">
            <cite id="dsq-cite-1809">
                <span id="dsq-author-user-1809">ravikant</span>
            </cite>
        </div>
        <div id="dsq-comment-body-1809" class="dsq-comment-body">
            <div id="dsq-comment-message-1809" class="dsq-comment-message"><p>Awesome is an understatement for this site !!!!!</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-1774">
        <div id="dsq-comment-header-1774" class="dsq-comment-header">
            <cite id="dsq-cite-1774">
                <span id="dsq-author-user-1774">AD</span>
            </cite>
        </div>
        <div id="dsq-comment-body-1774" class="dsq-comment-body">
            <div id="dsq-comment-message-1774" class="dsq-comment-message"><p>For the Inorder traversal you don&#8217;t have to save all the values. You can just save the last value in a static variable or pass in an int by value and then compare with the last value: E.g:</p>
<pre> <code language="C">
Function Call = check_BST(root, INT_MIN, true)

void check_BST(node* root, int&amp; last_data, bool&amp; status)
{
	if(node != NULL)
	{
		check_BST(node-&gt;rchild, last_data, status);

		if(node-&gt;data data;
		
		check_BST(node-&gt;lchild, last_data, status);

	}
}

OR
Function Call = check_BST(root, true)

void check_BST(node* root, bool&amp; last_data)
{
        static int last_data = INT_MIN;
	if(node != NULL)
	{
		check_BST(node-&gt;rchild, status);

		if(node-&gt;data data;
		
		check_BST(node-&gt;lchild, status);
	}
}
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-1587">
        <div id="dsq-comment-header-1587" class="dsq-comment-header">
            <cite id="dsq-cite-1587">
                <span id="dsq-author-user-1587">Anish</span>
            </cite>
        </div>
        <div id="dsq-comment-body-1587" class="dsq-comment-body">
            <div id="dsq-comment-message-1587" class="dsq-comment-message"><p>The above method given in forum will fail for the following:</p>
<p>&#8230;..100<br />
&#8230;../..\<br />
&#8230;.50&#8230;120<br />
../&#8230;\<br />
.60&#8230; 82<br />
./.\<br />
45 81</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-shekhu even depth-2" id="dsq-comment-1592">
        <div id="dsq-comment-header-1592" class="dsq-comment-header">
            <cite id="dsq-cite-1592">
                <span id="dsq-author-user-1592">Shekhu</span>
            </cite>
        </div>
        <div id="dsq-comment-body-1592" class="dsq-comment-body">
            <div id="dsq-comment-message-1592" class="dsq-comment-message"><p>which method?</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-3" id="dsq-comment-1594">
        <div id="dsq-comment-header-1594" class="dsq-comment-header">
            <cite id="dsq-cite-1594">
                <span id="dsq-author-user-1594">Anish</span>
            </cite>
        </div>
        <div id="dsq-comment-body-1594" class="dsq-comment-body">
            <div id="dsq-comment-message-1594" class="dsq-comment-message"><p>Mehod Two..</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment byuser comment-author-geeksforgeeks bypostauthor even depth-2" id="dsq-comment-1595">
        <div id="dsq-comment-header-1595" class="dsq-comment-header">
            <cite id="dsq-cite-1595">
                <span id="dsq-author-user-1595">GeeksforGeeks</span>
            </cite>
        </div>
        <div id="dsq-comment-body-1595" class="dsq-comment-body">
            <div id="dsq-comment-message-1595" class="dsq-comment-message"><p>@Anish: Thanks for reporting the issue.  There was a typo in below line (there was false instead of true)   </p>
<pre> <code language="C">if (node == NULL)  
return(false); </code> </pre>
<p>We have corrected it.  It works now.</p>
<pre> <code language="C">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;limits.h&gt;
#define true 1
#define false 0
#define bool int 
 
/* A binary tree node has data, pointer to left child
   and a pointer to right child */
struct node
{
    int data;
    struct node* left;
    struct node* right;
};

int minValue(struct node* node) {
  struct node* current = node;
 
  /* loop down to find the leftmost leaf */
  while (current-&gt;left != NULL) {
    current = current-&gt;left;
  }
  return(current-&gt;data);
}

int maxValue(struct node* node) {
  struct node* current = node;
 
  /* loop down to find the leftmost leaf */
  while (current-&gt;right != NULL) {
    current = current-&gt;right;
  }
  return(current-&gt;data);
}

/* Returns true if a binary tree is a binary search tree */
int isBST(struct node* node)
{
  if (node == NULL)
    return(true); 

  /* false if the max of the left is &gt; than us */
  if (node-&gt;left!=NULL &amp;&amp; maxValue(node-&gt;left) &gt; node-&gt;data)
    return(false); 

  /* false if the min of the right is &lt;= than us */
  if (node-&gt;right!=NULL &amp;&amp; minValue(node-&gt;right) &lt;= node-&gt;data)
    return(false); 

  /* false if, recursively, the left or right is not a BST */
  if (!isBST(node-&gt;left) || !isBST(node-&gt;right))
    return(false); 

  /* passing all that, it's a BST */
  return(true);
}

/* Helper function that allocates a new node with the
   given data and NULL left and right pointers. */
struct node* newNode(int data)
{
  struct node* node = (struct node*)
                       malloc(sizeof(struct node));
  node-&gt;data = data;
  node-&gt;left = NULL;
  node-&gt;right = NULL;
 
  return(node);
}
 
/* Driver program to test above functions*/
int main()
{
  struct node *root = newNode(100);
  root-&gt;left        = newNode(50);
  root-&gt;right       = newNode(120);
  root-&gt;left-&gt;left  = newNode(60);
  root-&gt;left-&gt;right = newNode(82);
  root-&gt;left-&gt;left-&gt;left  = newNode(45);
  root-&gt;left-&gt;left-&gt;right = newNode(81);  
 
  if(isBST(root))
    printf(&quot;Is BST&quot;);
  else
    printf(&quot;Not a BST&quot;);
 
  getchar();
  return 0;
}
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-3" id="dsq-comment-1596">
        <div id="dsq-comment-header-1596" class="dsq-comment-header">
            <cite id="dsq-cite-1596">
                <span id="dsq-author-user-1596">Anish</span>
            </cite>
        </div>
        <div id="dsq-comment-body-1596" class="dsq-comment-body">
            <div id="dsq-comment-message-1596" class="dsq-comment-message"><p>ok but still I think the problem persists. I don&#8217;t know I may be wrong. Here is what I think:</p>
<p>In reference to above problem..<br />
first node 100,<br />
its left tree!= Null. and min function gives u 45. and max function gives u 82. for this iteration this function is not going to return 0.<br />
Next 50 is passed.<br />
min gives 45 and max will give 81. for this iteration this function is not going to return 0.<br />
Next 60 is passed. No issues with that also,<br />
&#8230; Similarly I think this function will return u true. that this is BST. But it is not..</p>
<p>Correct me If i m wrong..</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-sandeep even depth-4" id="dsq-comment-1603">
        <div id="dsq-comment-header-1603" class="dsq-comment-header">
            <cite id="dsq-cite-1603">
                <span id="dsq-author-user-1603">Sandeep</span>
            </cite>
        </div>
        <div id="dsq-comment-body-1603" class="dsq-comment-body">
            <div id="dsq-comment-message-1603" class="dsq-comment-message"><p>@Ashish:  I think you are considering min and max of left only, but the code compares max of left and min of right.  Try running the above code, it prints &#8220;Not a BST&#8221;</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-5" id="dsq-comment-1605">
        <div id="dsq-comment-header-1605" class="dsq-comment-header">
            <cite id="dsq-cite-1605">
                <span id="dsq-author-user-1605">Anish</span>
            </cite>
        </div>
        <div id="dsq-comment-body-1605" class="dsq-comment-body">
            <div id="dsq-comment-message-1605" class="dsq-comment-message"><p>ya i understood.. Thanks.:-)</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-1223">
        <div id="dsq-comment-header-1223" class="dsq-comment-header">
            <cite id="dsq-cite-1223">
                <span id="dsq-author-user-1223">Vikas</span>
            </cite>
        </div>
        <div id="dsq-comment-body-1223" class="dsq-comment-body">
            <div id="dsq-comment-message-1223" class="dsq-comment-message"><p>In method 4,<br />
I think we can do it with O(1) space complexity.<br />
,ie, we don&#8217;t need array.<br />
initialize &#8216;previous&#8217; with say INT_MIN</p>
<pre> <code language="C">
bool flag=true;
int previous=INT_MIN;
void inorder(node *nd){
  if(flag==false)return;
  if(nd){
     inorder(nd-&gt;left); 
     if(node-&gt;data &gt; previous){
           previous=node-&gt;data;
     }
     else flag=false;
     if(flag)
     inorder(nd-&gt;right);
     else return;
   }
}</code> </pre>
<p>// check if flag=false,then not BST, else BST</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-1224">
        <div id="dsq-comment-header-1224" class="dsq-comment-header">
            <cite id="dsq-cite-1224">
                <span id="dsq-author-user-1224">Vikas</span>
            </cite>
        </div>
        <div id="dsq-comment-body-1224" class="dsq-comment-body">
            <div id="dsq-comment-message-1224" class="dsq-comment-message"><p>in check condition we can have equality also if not strictly ascending.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-geek4u even depth-2" id="dsq-comment-1655">
        <div id="dsq-comment-header-1655" class="dsq-comment-header">
            <cite id="dsq-cite-1655">
                <span id="dsq-author-user-1655">geek4u</span>
            </cite>
        </div>
        <div id="dsq-comment-body-1655" class="dsq-comment-body">
            <div id="dsq-comment-message-1655" class="dsq-comment-message"><p>This doesn&#8217;t look like O(1) space complexity solution as you have recursion in the function.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt depth-2" id="dsq-comment-2480">
        <div id="dsq-comment-header-2480" class="dsq-comment-header">
            <cite id="dsq-cite-2480">
                <span id="dsq-author-user-2480">Abhirup Ghosh</span>
            </cite>
        </div>
        <div id="dsq-comment-body-2480" class="dsq-comment-body">
            <div id="dsq-comment-message-2480" class="dsq-comment-message"><p>I think the solution is fine.</p>
<p>@geek4u even if recursion space is considered, number of recursive call can not exceed number of nodes in the tree.</p>
<p>@Vikas In a BST there can not be duplicate elements. Its by definition of BST. It is is a ordered set. And set can not have duplicate element. So equality is unnecessary.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment byuser comment-author-geeksforgeeks bypostauthor even thread-even depth-1" id="dsq-comment-563">
        <div id="dsq-comment-header-563" class="dsq-comment-header">
            <cite id="dsq-cite-563">
                <span id="dsq-author-user-563">GeeksforGeeks</span>
            </cite>
        </div>
        <div id="dsq-comment-body-563" class="dsq-comment-body">
            <div id="dsq-comment-message-563" class="dsq-comment-message"><p>@LJW489: Thanks for suggesting a new method. We have added it to the original post. Keep it up!</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-1572">
        <div id="dsq-comment-header-1572" class="dsq-comment-header">
            <cite id="dsq-cite-1572">
                <span id="dsq-author-user-1572">foobar</span>
            </cite>
        </div>
        <div id="dsq-comment-body-1572" class="dsq-comment-body">
            <div id="dsq-comment-message-1572" class="dsq-comment-message"><p>Method4 will not work if the BST has duplicate elements. As per definition of a BST left &lt; root and root&lt;=right</p>
<p>So duplicate elements should be present only in the right subtree and not in the left subtree.</p>
<p>If we perform an inorder traversal we can never find this out. So method 4 is flawed.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-562">
        <div id="dsq-comment-header-562" class="dsq-comment-header">
            <cite id="dsq-cite-562">
                <span id="dsq-author-user-562">LJW489</span>
            </cite>
        </div>
        <div id="dsq-comment-body-562" class="dsq-comment-body">
            <div id="dsq-comment-message-562" class="dsq-comment-message"><p>can i just traverse the tree in in-order, and store the values in an array. after which i check that the array is in ascending order. if it is, then the tree is a BST.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-4197">
        <div id="dsq-comment-header-4197" class="dsq-comment-header">
            <cite id="dsq-cite-4197">
                <span id="dsq-author-user-4197">Terminal</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4197" class="dsq-comment-body">
            <div id="dsq-comment-message-4197" class="dsq-comment-message"><p>I think this method will have issue for a this tree:</p>
<p>     20<br />
    /   \<br />
  20    20<br />
This is an invalid binary tree but above method will fail.<br />
If the method will result in an invalid tree it will also have wrong result for<br />
     20<br />
    /  \<br />
   19  20.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-516">
        <div id="dsq-comment-header-516" class="dsq-comment-header">
            <cite id="dsq-cite-516">
                <span id="dsq-author-user-516">Sandeep</span>
            </cite>
        </div>
        <div id="dsq-comment-body-516" class="dsq-comment-body">
            <div id="dsq-comment-message-516" class="dsq-comment-message"><p>@nesamani1822: Your approach suffers from the same problem as method 1(simple but wrong) in the post.  It will not work for trees like below:</p>
<pre>
        3
      /   \
    /       \
   2        5
  / \
/     \
1      4
</pre>
<p>Let me know if I have missed something.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-2392">
        <div id="dsq-comment-header-2392" class="dsq-comment-header">
            <cite id="dsq-cite-2392">
                <span id="dsq-author-user-2392">Mansoor</span>
            </cite>
        </div>
        <div id="dsq-comment-body-2392" class="dsq-comment-body">
            <div id="dsq-comment-message-2392" class="dsq-comment-message"><p><del>True</del></p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment byuser comment-author-nesamani1822 even thread-odd thread-alt depth-1" id="dsq-comment-508">
        <div id="dsq-comment-header-508" class="dsq-comment-header">
            <cite id="dsq-cite-508">
                <span id="dsq-author-user-508">nesamani1822</span>
            </cite>
        </div>
        <div id="dsq-comment-body-508" class="dsq-comment-body">
            <div id="dsq-comment-message-508" class="dsq-comment-message"><p>Please find the code with typo correction.</p>
<pre> <code language="C">
bool isBinarySearchTree = false;
 
bool isBST(struct *node, int data)
{
if(node!=null &amp;&amp; node-&gt;left !=null &amp;&amp; node -&gt;right !=null)
{
    if(node-&gt;left-&gt;element right-&gt;element &gt; data)
    {
        isBinarySearchTree = true;
        isBST(node-&gt;left, node-&gt;left-&gt;element);
        isBST(node-&gt;right, node-&gt;right-&gt;element);
    }
    else
    {
        isBinarySearchTree = false;
        return;
    }
 
}
else if(node!=null &amp;&amp; (node-&gt;left!=null || node-&gt;right!=null))
{
    if(node-&gt;left!=null &amp;&amp; node-&gt;left-&gt;element right,node-&gt;right-&gt;element);
        }
    else if (node-&gt;right!=null &amp;&amp; node-&gt;right-&gt;element &gt; data)
        {
            isBinarySearchTree = true;
            isBST(node-&gt;right,node-&gt;right-&gt;element);
        }
    else
        {
            isBinarySearchTree =false;
            return;
        }
}
else
{
isBinarySearchTree = true;
return;
}
 
return isBinarySearchTree;
}
</code> </pre>
<p>Call : isBST(head, head-&gt;data)</p>
<p>Explanation:<br />
1) Traverse the tree in preorder and check for each node whether its left &amp; right child statisfies the BST rule( left-&gt;element element &gt; data)<br />
2) This code handles for all the scenario like only child (left / right) and both child(left &amp; right)<br />
3) It is recursive function and if it reaches the leaf node then that subtree statisfies the BST rule and it returns after setting the boolean variable to true.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-geeksforgeeks bypostauthor odd alt thread-even depth-1" id="dsq-comment-506">
        <div id="dsq-comment-header-506" class="dsq-comment-header">
            <cite id="dsq-cite-506">
                <span id="dsq-author-user-506">GeeksforGeeks</span>
            </cite>
        </div>
        <div id="dsq-comment-body-506" class="dsq-comment-body">
            <div id="dsq-comment-message-506" class="dsq-comment-message"><p>@nesamani1822: Thanks for sharing the code. </p>
<p>There are some typos in below lines.</p>
<pre> <code language="C">
  if(node-&gt;left-&gt;element right-&gt;element &gt; data)
  if(node-&gt;left!=null &amp;&amp; node-&gt;left-&gt;element left,node-&gt;left-&gt;element);
</code> </pre>
<p>Also, could you please add few words about the approach?</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-nesamani1822 even thread-odd thread-alt depth-1" id="dsq-comment-501">
        <div id="dsq-comment-header-501" class="dsq-comment-header">
            <cite id="dsq-cite-501">
                <span id="dsq-author-user-501">nesamani1822</span>
            </cite>
        </div>
        <div id="dsq-comment-body-501" class="dsq-comment-body">
            <div id="dsq-comment-message-501" class="dsq-comment-message"><p>I think the following code will also work</p>
<pre> <code language="C">
bool isBinarySearchTree = false;

bool isBST(struct *node, int data)
{
if(node!=null &amp;&amp; node-&gt;left !=null &amp;&amp; node -&gt;right !=null)
{
	if(node-&gt;left-&gt;element right-&gt;element &gt; data)
	{
		isBinarySearchTree = true;
		isBST(node-&gt;left, node-&gt;left-&gt;element);
		isBST(node-&gt;right, node-&gt;right-&gt;element);
	}
	else
	{
		isBinarySearchTree = false;
		return;
	}

}
else if(node!=null &amp;&amp; (node-&gt;left!=null || node-&gt;right!=null))
{
	if(node-&gt;left!=null &amp;&amp; node-&gt;left-&gt;element left,node-&gt;left-&gt;element);
		}
	else if (node-&gt;right!=null &amp;&amp; node-&gt;right-&gt;element &gt; data)
		{
			isBinarySearchTree = true;
			isBST(node-&gt;right,node-&gt;right-&gt;element);
		}
	else
		{
			isBinarySearchTree =false;
			return;
		}
}
else
{
isBinarySearchTree = true;
return;
}

return isBinarySearchTree;
}
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
            </ul>


        </div>

    </div>

<script type="text/javascript">
var disqus_url = 'http://www.geeksforgeeks.org/a-program-to-check-if-a-binary-tree-is-bst-or-not/';
var disqus_identifier = '3042 http://geeksforgeeks.org/?p=3042';
var disqus_container_id = 'disqus_thread';
var disqus_shortname = 'geeksforgeeks';
var disqus_title = "A program to check if a binary tree is BST or not";
var disqus_config_custom = window.disqus_config;
var disqus_config = function () {
    /*
    All currently supported events:
    onReady: fires when everything is ready,
    onNewComment: fires when a new comment is posted,
    onIdentify: fires when user is authenticated
    */
    
    
    this.language = '';
    
    if (disqus_config_custom) {
        disqus_config_custom.call(this);
    }
};

(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>

			</div>
	
					
			
			

		</div> <!-- end post -->	

<br></br>
	
</div> <!-- end content -->

<ul id="sidebar">
	<li id="text-19" class="widget widget_text">			<div class="textwidget"><script>
  (function() {
    var cx = '009682134359037907028:tj6eafkv_be';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//www.google.com/cse/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>

<style type="text/css">
  .gsc-control-cse {
    font-family: "Trebuchet MS", sans-serif;
    border-color: #E1F3DA;
    background-color: #E1F3DA;
  }
  input.gsc-input {
    border-color: #94CC7A;
  }
  input.gsc-search-button {
    border-color: #94CC7A;
    background-color: #AADA92;
  }
  .gsc-tabHeader.gsc-tabhInactive {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gsc-tabHeader.gsc-tabhActive {
    border-color: #A9DA92;
    background-color: #A9DA92;
  }
  .gsc-tabsArea {
    border-color: #A9DA92;
  }
  .gsc-webResult.gsc-result {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gsc-webResult.gsc-result:hover {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gs-webResult.gs-result a.gs-title:link,
  .gs-webResult.gs-result a.gs-title:link b {
    color: #009900;
  }
  .gs-webResult.gs-result a.gs-title:visited,
  .gs-webResult.gs-result a.gs-title:visited b {
    color: #009900;
  }
  .gs-webResult.gs-result a.gs-title:hover,
  .gs-webResult.gs-result a.gs-title:hover b {
    color: #003300;
  }
  .gs-webResult.gs-result a.gs-title:active,
  .gs-webResult.gs-result a.gs-title:active b {
    color: #009900;
  }
  .gsc-cursor-page {
    color: #009900;
  }
  a.gsc-trailing-more-results:link {
    color: #009900;
  }
  .gs-webResult.gs-result .gs-snippet {
    color: #454545;
  }
  .gs-webResult.gs-result .gs-visibleUrl {
    color: #33cc00;
  }
  .gs-webResult.gs-result .gs-visibleUrl-short {
    color: #33cc00;
  }
  .gs-webResult.gs-result .gs-visibleUrl-short {
    display: none;
  }
  .gs-webResult.gs-result .gs-visibleUrl-long {
    display: block;
  }
  .gsc-cursor-box {
    border-color: #A9DA92;
  }
  .gsc-results .gsc-cursor-page {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gsc-results .gsc-cursor-page.gsc-cursor-current-page {
    border-color: #A9DA92;
    background-color: #A9DA92;
  }
  .gs-promotion.gs-result {
    border-color: #94CC7A;
    background-color: #CBE8B4;
  }
  .gs-promotion.gs-result a.gs-title:link {
    color: #0066CC;
  }
  .gs-promotion.gs-result a.gs-title:visited {
    color: #0066CC;
  }
  .gs-promotion.gs-result a.gs-title:hover {
    color: #0066CC;
  }
  .gs-promotion.gs-result a.gs-title:active {
    color: #0066CC;
  }
  .gs-promotion.gs-result .gs-snippet {
    color: #454545;
  }
  .gs-promotion.gs-result .gs-visibleUrl,
  .gs-promotion.gs-result .gs-visibleUrl-short {
    color: #815FA7;
  }
</style>    </div>
		</li>
<li id="text-9" class="widget widget_text">			<div class="textwidget"><div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=138031159685820";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>

<div class="fb-like-box" data-href="https://www.facebook.com/pages/GeeksforGeeks/316764689022" data-width="250" data-height="170" data-colorscheme="light" data-show-faces="true" data-header="false" data-stream="false" data-show-border="false"></div></div>
		</li>
<li id="text-18" class="widget widget_text">			<div class="textwidget"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LargeRectangleSide -->
<ins class="adsbygoogle"
     style="display:inline-block;width:336px;height:280px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="1884636833"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
		</li>
<li id="text-13" class="widget widget_text">			<div class="textwidget"><ul><li><a href="http://www.geeksforgeeks.org/category/interview-experiences/">Interview Experiences</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/advance-data-structures">Advanced Data Structures</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/dynamic-programming">Dynamic Programming</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/Greedy-Algorithm/">Greedy Algorithms</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/backtracking">Backtracking</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/pattern-searching">Pattern Searching</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/divide-and-conquer">Divide & Conquer</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/MathematicalAlgo">Mathematical Algorithms</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/recursion">Recursion</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/geometric-algorithms/">Geometric Algorithms</a></li>
</ul></div>
		</li>
<li id="text-17" class="widget widget_text">			<div class="textwidget"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big 300x600 Sidebar -->
<ins class="adsbygoogle"
     style="display:inline-block;width:300px;height:600px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="4402736037"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
		</li>
<li id="text-14" class="widget widget_text"><h2 class="widgettitle">Popular Posts</h2>
			<div class="textwidget"><ul>
<li><a href="http://www.geeksforgeeks.org/write-a-c-program-to-print-all-permutations-of-a-given-string/">  All permutations of a given string </a></li>
<li><a href="http://www.geeksforgeeks.org/memory-layout-of-c-program/"> Memory Layout of C Programs</a> </li>
<li><a href="http://www.geeksforgeeks.org/understanding-extern-keyword-in-c/"> Understanding “extern” keyword in C</a> </li>
<li><a href="http://www.geeksforgeeks.org/median-of-two-sorted-arrays/">Median of two sorted arrays</a> </li>
<li><a href="http://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/"> Tree traversal without recursion and without stack! </a></li>
<li><a href="http://www.geeksforgeeks.org/structure-member-alignment-padding-and-data-packing/"> Structure Member Alignment, Padding and Data Packing</a> </li>
<li><a href="http://www.geeksforgeeks.org/write-a-function-to-get-the-intersection-point-of-two-linked-lists/"> Intersection point of two Linked Lists</a> </li>
<li><a href="http://www.geeksforgeeks.org/lowest-common-ancestor-in-a-binary-search-tree/"> Lowest Common Ancestor in a BST.</span></a> </li>
<li><a href="http://www.geeksforgeeks.org/a-program-to-check-if-a-binary-tree-is-bst-or-not/"> Check if a binary tree is BST or not</a> </li>
<li><a href="http://www.geeksforgeeks.org/sorted-linked-list-to-balanced-bst/"> Sorted Linked List to Balanced BST</a></li>
</ul></div>
		</li>
<li id="text-3" class="widget widget_text">			<div class="textwidget"><a href="https://twitter.com/GeeksforGeeks" class="twitter-follow-button" data-show-count="false">Follow @GeeksforGeeks</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>         


<!-- GOOGLE FEEDBURNER BUTTON-->
<a href="http://feeds.feedburner.com/Geeksforgeeks" title="Subscribe to my feed" rel="alternate" type="application/rss+xml"><img src="http://www.feedburner.com/fb/images/pub/feed-icon32x32.png" alt="" style="border:0"/></a><a href="http://feeds.feedburner.com/Geeksforgeeks" title="Subscribe to my feed" rel="alternate" type="application/rss+xml">Subscribe</a>

</div>
		</li>
<li id="text-21" class="widget widget_text"><h2 class="widgettitle">Recent Comments</h2>
			<div class="textwidget"><script type="text/javascript" src="http://geeksforgeeks.disqus.com//recent_comments_widget.js?num_items=6&hide_avatars=1&excerpt_length=50&hide_mods=0"></script></div>
		</li>
<li id="text-22" class="widget widget_text">			<div class="textwidget"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LinkAd -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:90px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="2606115235"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LinkAd -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:90px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="2606115235"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LinkAd -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:90px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="2606115235"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
		</li>

</ul>					  
		<div class="clear"></div>

		<div id="footer">
		
		    <div class="xhtml">
                        @geeksforgeeks, <a href="http://creativecommons.org/licenses/by-nc-nd/2.5/in/deed.en_US" title="Valid XHTML Strict 1.0">Some rights reserved</a>  <a href="http://www.geeksforgeeks.org/about/contact-us/"> &nbsp; &nbsp; &nbsp; &nbsp;Contact Us!</a>

		    </div>
		    
		    <div class="credits">
			  Powered by <a href="http://wordpress.org">WordPress </a> &amp; <a href="http://mootools.net/" title="Mootools JavaScript Framework">MooTools</a>, customized by geeksforgeeks team </div>
			  
		   <div class="clear"></div>						                            
		   
		</div> <!--end footer-->  
        
		        <script type="text/javascript">
        // <![CDATA[
        var disqus_shortname = 'geeksforgeeks';
        (function () {
            var nodes = document.getElementsByTagName('span');
            for (var i = 0, url; i < nodes.length; i++) {
                if (nodes[i].className.indexOf('dsq-postid') != -1) {
                    nodes[i].parentNode.setAttribute('data-disqus-identifier', nodes[i].getAttribute('rel'));
                    url = nodes[i].parentNode.href.split('#', 1);
                    if (url.length == 1) { url = url[0]; }
                    else { url = url[1]; }
                    nodes[i].parentNode.href = url + '#disqus_thread';
                }
            }
            var s = document.createElement('script'); 
            s.async = true;
            s.type = 'text/javascript';
            s.src = '//' + disqus_shortname + '.disqus.com/count.js';
            (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
        }());
        // ]]>
        </script>
        <script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/scripts/shCore.js?ver=3.0.9'></script>
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/scripts/shBrushCpp.js?ver=3.0.9'></script>
<script type='text/javascript'>
	(function(){
		var corecss = document.createElement('link');
		var themecss = document.createElement('link');
		var corecssurl = "http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/styles/shCore.css?ver=3.0.9";
		if ( corecss.setAttribute ) {
				corecss.setAttribute( "rel", "stylesheet" );
				corecss.setAttribute( "type", "text/css" );
				corecss.setAttribute( "href", corecssurl );
		} else {
				corecss.rel = "stylesheet";
				corecss.href = corecssurl;
		}
		document.getElementsByTagName("head")[0].insertBefore( corecss, document.getElementById("syntaxhighlighteranchor") );
		var themecssurl = "http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/styles/shThemeDefault.css?ver=3.0.9";
		if ( themecss.setAttribute ) {
				themecss.setAttribute( "rel", "stylesheet" );
				themecss.setAttribute( "type", "text/css" );
				themecss.setAttribute( "href", themecssurl );
		} else {
				themecss.rel = "stylesheet";
				themecss.href = themecssurl;
		}
		//document.getElementById("syntaxhighlighteranchor").appendChild(themecss);
		document.getElementsByTagName("head")[0].insertBefore( themecss, document.getElementById("syntaxhighlighteranchor") );
	})();
	SyntaxHighlighter.config.strings.expandSource = '+ expand source';
	SyntaxHighlighter.config.strings.help = '?';
	SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
	SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
	SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
	SyntaxHighlighter.defaults['gutter'] = false;
	SyntaxHighlighter.defaults['pad-line-numbers'] = true;
	SyntaxHighlighter.defaults['toolbar'] = false;
	SyntaxHighlighter.all();
</script>
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/bbpress/templates/default/js/editor.js?ver=2.5.4-5380'></script>
				  
		</div> <!--end wrapper-->
        <div id="ajaxSpinner"></div> <!--For AJAX spinner holder-->
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-12148232-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
	</body>

</html>
<!-- Dynamic page generated in 0.278 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2014-11-27 23:25:01 -->

<!-- Compression = gzip -->
<!-- super cache -->