<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
       <title>Check if a binary tree is subtree of another binary tree | Set 1 - GeeksforGeeks</title>
       <style type="text/css" media="screen">
          @import url('http://d2o58evtke57tz.cloudfront.net/wp-content/themes/minimoo/style.css');
    </style>
      <link href="http://d2o58evtke57tz.cloudfront.net/wp-content/themes/minimoo/favicon.ico" rel="shortcut icon" />    
    
<!-- This site is optimized with the Yoast WordPress SEO plugin v1.7.1 - https://yoast.com/wordpress/plugins/seo/ -->
<link rel="canonical" href="http://www.geeksforgeeks.org/check-if-a-binary-tree-is-subtree-of-another-binary-tree/" />
<meta property="og:locale" content="en_US" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Check if a binary tree is subtree of another binary tree | Set 1 - GeeksforGeeks" />
<meta property="og:description" content="Given two binary trees, check if the first tree is subtree of the second one. A subtree of a tree T is a tree S consisting of a node in T and all of its descendants in T. The subtree corresponding to the root node is the entire tree; the subtree corresponding to any other &hellip;" />
<meta property="og:url" content="http://www.geeksforgeeks.org/check-if-a-binary-tree-is-subtree-of-another-binary-tree/" />
<meta property="og:site_name" content="GeeksforGeeks" />
<meta property="article:section" content="Trees" />
<meta property="article:published_time" content="2011-08-15T21:40:20+00:00" />
<meta property="article:modified_time" content="2014-07-26T17:39:24+00:00" />
<meta property="og:updated_time" content="2014-07-26T17:39:24+00:00" />
<!-- / Yoast WordPress SEO plugin. -->

<link rel='stylesheet' id='wp-quicklatex-format-css'  href='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/wp-quicklatex/css/quicklatex-format.css?ver=4.0.1' type='text/css' media='all' />
<link rel='stylesheet' id='bbp-default-css'  href='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/bbpress/templates/default/css/bbpress.css?ver=2.5.4-5380' type='text/css' media='screen' />
<link rel='stylesheet' id='wp-pagenavi-css'  href='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/wp-pagenavi/pagenavi-css.css?ver=2.70' type='text/css' media='all' />
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-includes/js/jquery/jquery.js?ver=1.11.1'></script>
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-includes/js/jquery/jquery-migrate.min.js?ver=1.2.1'></script>
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/wp-quicklatex/js/wp-quicklatex-frontend.js?ver=1.0'></script>

<!-- Bad Behavior 2.2.16 run time: 1.394 ms -->
<script type="text/javascript">
<!--
function bb2_addLoadEvent(func) {
	var oldonload = window.onload;
	if (typeof window.onload != 'function') {
		window.onload = func;
	} else {
		window.onload = function() {
			oldonload();
			func();
		}
	}
}

bb2_addLoadEvent(function() {
	for ( i=0; i < document.forms.length; i++ ) {
		if (document.forms[i].method == 'post') {
			var myElement = document.createElement('input');
			myElement.setAttribute('type', 'hidden');
			myElement.name = 'bb2_screener_';
			myElement.value = '1417110821 69.196.253.30';
			document.forms[i].appendChild(myElement);
		}
	}
});
// --></script>
		<style type="text/css" id="syntaxhighlighteranchor"></style>
   <meta name="google-site-verification" content="rHK2v8_zzuAZQY8JHAzbllDN8u-aQxcn2Kqnp67Old0" />
</head>

<body>
<!-- o4dI0sCXUgoSONabbd8mbZ4SA3E -->    
    <div id="wrapper">
        <div class="blog-info">
                <h1 class="blog-title">
                <a href="http://www.geeksforgeeks.org" title="GeeksforGeeks">GeeksforGeeks</a>
            </h1>
       
            <div class="blog-description">
                A computer science portal for geeks            </div>
        </div>
        <b><p>  <h2 align="right"> <a href="http://geeksquiz.com/">GeeksQuiz</a></h2> 
   <a href="http://www.geeksforgeeks.org/wp-login.php">Login</a> 
         </p></b>  
         
         <div class="clear"></div>         
              
                     
            <div id="menu">   
                 <ul>
 <li><a href="http://www.geeksforgeeks.org">Home</a></li>
  <li><a href="http://www.geeksforgeeks.org/fundamentals-of-algorithms/">Algorithms</a></li>
 <li><a href="http://www.geeksforgeeks.org/data-structures/">DS</a></li>
  <li><a href="http://www.geeksforgeeks.org/gate-corner/">GATE</a></li>
  <li><a href="http://www.geeksforgeeks.org/about/interview-corner/">Interview Corner</a></li>
  <li><a href="http://www.geeksforgeeks.org/forums/">Q&A</a></li>
  <li><a href="http://www.geeksforgeeks.org/c/">C</a></li>
  <li><a href="http://www.geeksforgeeks.org/c-plus-plus/">C++</a></li>
  <li><a href="http://www.geeksforgeeks.org/java/">Java</a></li>
  <li><a href="http://www.geeksforgeeks.org/books/">Books</a></li>
  <li><a href="http://www.geeksforgeeks.org/contribute/">Contribute</a></li>
  <li><a href="http://www.geeksforgeeks.org/contribute/ask-a-question/">Ask a Q</a></li>
  <li><a href="http://www.geeksforgeeks.org/about/">About</a></li>
            </ul>

               
            <div class="clear"></div>     
        </div>
             <div id="navmenu">
				<ul id="menu" style="padding:0; margin:0;">
						<li class="cat-item cat-item-3"><a href="http://www.geeksforgeeks.org/category/c-arrays/" title="Questions regarding Arrays">Array</a>
</li>	

	<li class="cat-item cat-item-17"><a href="http://www.geeksforgeeks.org/category/bit-magic/" title="View all posts filed under Bit Magic">Bit Magic</a>
</li>
	<li class="cat-item cat-item-14"><a href="http://www.geeksforgeeks.org/category/c-puzzles/" title="View all posts filed under C/C++ Puzzles">C/C++</a>
</li>

<li class="cat-item cat-item-18"><a href="http://www.geeksforgeeks.org/category/articles/" title="View all posts filed under Articles">Articles</a>
</li>

	<li class="cat-item cat-item-67"><a href="http://www.geeksforgeeks.org/category/gfact/" title="View all posts filed under GFacts">GFacts</a>
</li>
	<li class="cat-item cat-item-8"><a href="http://www.geeksforgeeks.org/category/linked-list/" title="Linked List problems">Linked List</a>
</li>
	<li class="cat-item cat-item-66"><a href="http://www.geeksforgeeks.org/category/multiple-choice-question/" title="View all posts filed under MCQ">MCQ</a>

</li>
	<li class="cat-item cat-item-4"><a href="http://www.geeksforgeeks.org/category/c-programs/" title="Miscellaneous">Misc</a>
</li>
	<li class="cat-item cat-item-5"><a href="http://www.geeksforgeeks.org/category/program-output/" title="View all posts filed under Output">Output</a>
</li>
	<li class="cat-item cat-item-7"><a href="http://www.geeksforgeeks.org/category/c-strings/" title="Questions related to strings">String</a>
</li>
	<li class="cat-item cat-item-19"><a href="http://www.geeksforgeeks.org/category/tree/" title="View all posts filed under Trees">Tree</a>
</li>
	<li class="cat-item cat-item-19"><a href="http://www.geeksforgeeks.org/category/graph/" title="View all posts filed under Graph">Graph</a>
</li>
</ul>
        </div>
             <div id="content">	   	
	<div class="post" id="post">
							<div class="post-info">			
					<div class="post-title-info">
						<h2 class="post-title">Check if a binary tree is subtree of another binary tree | Set 1</h2>
					</div>			
					<div class="clear"></div>				  
				<div class="post-content" id="post-content">
					<p>Given two binary trees, check if the first tree is subtree of the second one.<span id="more-13942"></span>  A subtree of a tree T is a tree S consisting of a node in T and all of its descendants in T. The subtree corresponding to the root node is the entire tree; the subtree corresponding to any other node is called a proper subtree.</p>
<p>For example, in the following case, tree S is a subtree of tree T.</p>
<pre>
       <strong> Tree S</strong>
          10  
        /    \ 
      4       6
       \
        30

</pre>
<pre>

        <strong>Tree T</strong>
              26
            /   \
          10     3
        /    \     \
      4       6      3
       \
        30
</pre>
<p><strong>Solution:</strong>  Traverse the tree T in preorder fashion.  For every visited node in the traversal, see if the subtree rooted with this node is identical to S.  </p>
<p>Following is C implementation for this.</p>
<pre class="brush: cpp; highlight: [31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49]; title: ; notranslate" title="">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

/* A binary tree node has data, left child and right child */
struct node
{
    int data;
    struct node* left;
    struct node* right;
};

/* A utility function to check whether trees with roots as root1 and
   root2 are identical or not */
bool areIdentical(struct node * root1, struct node *root2)
{
    /* base cases */
    if (root1 == NULL &amp;&amp; root2 == NULL)
        return true;

    if (root1 == NULL || root2 == NULL)
        return false;

    /* Check if the data of both roots is same and data of left and right
       subtrees are also same */
    return (root1-&gt;data == root2-&gt;data   &amp;&amp;
            areIdentical(root1-&gt;left, root2-&gt;left) &amp;&amp;
            areIdentical(root1-&gt;right, root2-&gt;right) );
}


/* This function returns true if S is a subtree of T, otherwise false */
bool isSubtree(struct node *T, struct node *S)
{
    /* base cases */
    if (S == NULL)
        return true;

    if (T == NULL)
        return false;

    /* Check the tree with root as current node */
    if (areIdentical(T, S))
        return true;

    /* If the tree with root as current node doesn't match then
       try left and right subtrees one by one */
    return isSubtree(T-&gt;left, S) ||
           isSubtree(T-&gt;right, S);
}


/* Helper function that allocates a new node with the given data
   and NULL left and right pointers. */
struct node* newNode(int data)
{
    struct node* node =
        (struct node*)malloc(sizeof(struct node));
    node-&gt;data  = data;
    node-&gt;left  = NULL;
    node-&gt;right = NULL;
    return(node);
}

/* Driver program to test above function */
int main()
{
    /* Construct the following tree
              26
            /   \
          10     3
        /    \     \
      4      6      3
       \
        30
    */
    struct node *T        = newNode(26);
    T-&gt;right              = newNode(3);
    T-&gt;right-&gt;right       = newNode(3);
    T-&gt;left               = newNode(10);
    T-&gt;left-&gt;left         = newNode(4);
    T-&gt;left-&gt;left-&gt;right  = newNode(30);
    T-&gt;left-&gt;right        = newNode(6);

    /* Construct the following tree
          10
        /    \
      4      6
       \
        30
    */
    struct node *S    = newNode(10);
    S-&gt;right          = newNode(6);
    S-&gt;left           = newNode(4);
    S-&gt;left-&gt;right    = newNode(30);


    if (isSubtree(T, S))
        printf(&quot;Tree S is subtree of tree T&quot;);
    else
        printf(&quot;Tree S is not a subtree of tree T&quot;);

    getchar();
    return 0;
}
</pre>
<p>Output:
<pre>
Tree S is subtree of tree T </pre>
<p>Time Complexity: Time worst case complexity of above solution is O(mn) where m and n are number of nodes in given two trees. </p>
<p>We can solve the above problem in O(n) time.  Please refer <a href="http://www.geeksforgeeks.org/check-binary-tree-subtree-another-binary-tree-set-2/" target="_blank">Check if a binary tree is subtree of another binary tree | Set 2 fo</a>r O(n) solution.</p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
		
&nbsp;
&nbsp;
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle"
     style="display:inline-block;width:336px;height:280px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="4061219431"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>



&nbsp;
&nbsp;
&nbsp;
<h3>Related Topics:</h3><ul><li><a href="http://www.geeksforgeeks.org/perfect-binary-tree-specific-level-order-traversal/" title="Perfect Binary Tree Specific Level Order Traversal">Perfect Binary Tree Specific Level Order Traversal</a></li><li><a href="http://www.geeksforgeeks.org/print-nodes-top-view-binary-tree/" title="Print Nodes in Top View of Binary Tree">Print Nodes in Top View of Binary Tree</a></li><li><a href="http://www.geeksforgeeks.org/k-dimensional-tree/" title="K Dimensional Tree">K Dimensional Tree</a></li><li><a href="http://www.geeksforgeeks.org/convert-binary-tree-threaded-binary-tree/" title="Convert a Binary Tree to Threaded binary tree">Convert a Binary Tree to Threaded binary tree</a></li><li><a href="http://www.geeksforgeeks.org/serialize-deserialize-n-ary-tree/" title="Serialize and Deserialize an N-ary Tree">Serialize and Deserialize an N-ary Tree</a></li><li><a href="http://www.geeksforgeeks.org/serialize-deserialize-binary-tree/" title="Serialize and Deserialize a Binary Tree">Serialize and Deserialize a Binary Tree</a></li><li><a href="http://www.geeksforgeeks.org/given-binary-tree-print-nodes-two-given-level-numbers/" title="Print nodes between two given level numbers of a binary tree">Print nodes between two given level numbers of a binary tree</a></li><li><a href="http://www.geeksforgeeks.org/find-height-binary-tree-represented-parent-array/" title="Find Height of Binary Tree represented by Parent array">Find Height of Binary Tree represented by Parent array</a></li></ul>
<p></p> 
<div>
<iframe src="http://www.facebook.com/plugins/like.php?href=http%3A%2F%2Fwww.geeksforgeeks.org%2Fcheck-if-a-binary-tree-is-subtree-of-another-binary-tree%2F&layout=button_count&show_faces=false&width=90&action=like&colorscheme=light" scrolling="no" frameborder="0" allowTransparency="true" style="border:none; overflow:hidden; width:90px; height:20px"></iframe>
<a href="http://twitter.com/share" class="twitter-share-button" data-url="http://www.geeksforgeeks.org/check-if-a-binary-tree-is-subtree-of-another-binary-tree/" data-text="Check if a binary tree is subtree of another binary tree | Set 1" data-count="horizontal" data-via="jakerutter">Tweet</a><script type="text/javascript" src="http://platform.twitter.com/widgets.js"></script>
<g:plusone size="medium" href="http://www.geeksforgeeks.org/check-if-a-binary-tree-is-subtree-of-another-binary-tree/"></g:plusone>
<!-- Place this render call where appropriate -->
<script type="text/javascript">
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script></div>





				</div>		  
			</div> <!-- end post main -->					
			<div class="post-meta">
				<div class="left"></div>				
				<div class="clear"></div>
			</div>			
        
			<div class="comments-main">		
 <b>Writing code in comment?</b> Please use <b><a href="http://ideone.com/">ideone.com</a></b> and share the link here.
				
<div id="disqus_thread">
            <div id="dsq-content">


            <ul id="dsq-comments">
                    <li class="comment even thread-even depth-1" id="dsq-comment-34631">
        <div id="dsq-comment-header-34631" class="dsq-comment-header">
            <cite id="dsq-cite-34631">
                <span id="dsq-author-user-34631">alien</span>
            </cite>
        </div>
        <div id="dsq-comment-body-34631" class="dsq-comment-body">
            <div id="dsq-comment-message-34631" class="dsq-comment-message"><p>This solution will take o(n^2) in worst case. Is there any o(n) solution?</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-33808">
        <div id="dsq-comment-header-33808" class="dsq-comment-header">
            <cite id="dsq-cite-33808">
                <span id="dsq-author-user-33808">kingfed</span>
            </cite>
        </div>
        <div id="dsq-comment-body-33808" class="dsq-comment-body">
            <div id="dsq-comment-message-33808" class="dsq-comment-message"><p>The above code doesnt work in the case when we simply add a extra node to S.</p>
<p> S-&gt;left-&gt;right-&gt;left    = newNode(24);</p>
<p>or infact any node to a leaf of S even now S is a subtree of T.<br />
What I mean is that in the code checking if two subtrees are identical would not suffice . Kindly resolve my doubt</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-32553">
        <div id="dsq-comment-header-32553" class="dsq-comment-header">
            <cite id="dsq-cite-32553">
                <span id="dsq-author-user-32553">Archit</span>
            </cite>
        </div>
        <div id="dsq-comment-body-32553" class="dsq-comment-body">
            <div id="dsq-comment-message-32553" class="dsq-comment-message"><p>#include<br />
#include<br />
using namespace std;</p>
<p>struct node<br />
{<br />
    int data;<br />
    node *left;<br />
    node *right;<br />
};</p>
<p>node *newNode(int data)<br />
{<br />
    node *tmp=new node;<br />
    tmp-&gt;data=data;<br />
    tmp-&gt;left=NULL;<br />
    tmp-&gt;right=NULL;<br />
    return tmp;<br />
}</p>
<p>int isIdentical(node *T,node *S)<br />
{<br />
    if(S==NULL&amp;&amp;T==NULL)<br />
    return 1;<br />
    if(S==NULL)<br />
    return 1;<br />
    if(T==NULL)<br />
    return 0;<br />
    if(T-&gt;data!=S-&gt;data)<br />
    return 0;<br />
    return(isIdentical(T-&gt;left,S-&gt;left)&amp;&amp;isIdentical(T-&gt;right,S-&gt;right));<br />
}</p>
<p>int isSubtree(node *T,node *S)<br />
{<br />
    if(T==NULL&amp;&amp;S==NULL)<br />
    return 1;<br />
    if(T==NULL||S==NULL)<br />
    return 0;<br />
    if(T-&gt;data==S-&gt;data)<br />
    {<br />
        if(isIdentical(T,S))<br />
        return 1;<br />
    }<br />
    return(isSubtree(T-&gt;left,S)||isSubtree(T-&gt;right,S));<br />
}</p>
<p>int main()<br />
{<br />
    struct node *T        = newNode(26);<br />
    T-&gt;right              = newNode(3);<br />
    T-&gt;right-&gt;right       = newNode(3);<br />
    //T-&gt;left               = newNode(10);<br />
    //T-&gt;left-&gt;left         = newNode(10);<br />
    //T-&gt;left-&gt;left-&gt;left  = newNode(4);<br />
    //T-&gt;left-&gt;left-&gt;right = newNode(6);<br />
    //T-&gt;left-&gt;left-&gt;left-&gt;right=newNode(30);<br />
     T-&gt;right-&gt;right=newNode(10);<br />
     T-&gt;right-&gt;right-&gt;left=newNode(4);<br />
     T-&gt;right-&gt;right-&gt;right=newNode(6);<br />
     T-&gt;right-&gt;right-&gt;left-&gt;right=newNode(30);</p>
<p>     struct node *S    = newNode(10);<br />
    S-&gt;right          = newNode(6);<br />
    S-&gt;left           = newNode(4);<br />
    S-&gt;left-&gt;right    = newNode(30);</p>
<p>    if( isSubtree(T, S) )<br />
        printf(&#8220;Tree S is subtree of tree T&#8221;);<br />
    else<br />
        printf(&#8220;Tree S is not a subtree of tree T&#8221;);</p>
<p>    return 0;<br />
}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-32552">
        <div id="dsq-comment-header-32552" class="dsq-comment-header">
            <cite id="dsq-cite-32552">
                <span id="dsq-author-user-32552">Archit</span>
            </cite>
        </div>
        <div id="dsq-comment-body-32552" class="dsq-comment-body">
            <div id="dsq-comment-message-32552" class="dsq-comment-message"><p>#include<br />
#include<br />
using namespace std;</p>
<p>struct node<br />
{<br />
    int data;<br />
    node *left;<br />
    node *right;<br />
};</p>
<p>node *newNode(int data)<br />
{<br />
    node *tmp=new node;<br />
    tmp-&gt;data=data;<br />
    tmp-&gt;left=NULL;<br />
    tmp-&gt;right=NULL;<br />
    return tmp;<br />
}</p>
<p>int isIdentical(node *T,node *S)<br />
{<br />
    if(S==NULL&amp;&amp;T==NULL)<br />
    return 1;<br />
    if(S==NULL)<br />
    return 1;<br />
    if(T==NULL)<br />
    return 0;<br />
    if(T-&gt;data!=S-&gt;data)<br />
    return 0;<br />
    return(isIdentical(T-&gt;left,S-&gt;left)&amp;&amp;isIdentical(T-&gt;right,S-&gt;right));<br />
}</p>
<p>int isSubtree(node *T,node *S)<br />
{<br />
    if(T==NULL&amp;&amp;S==NULL)<br />
    return 1;<br />
    if(T==NULL||S==NULL)<br />
    return 0;<br />
    if(T-&gt;data==S-&gt;data)<br />
    {<br />
        if(isIdentical(T,S))<br />
        return 1;<br />
    }<br />
    return(isSubtree(T-&gt;left,S)||isSubtree(T-&gt;right,S));<br />
}</p>
<p>int main()<br />
{<br />
    struct node *T        = newNode(26);<br />
    T-&gt;right              = newNode(3);<br />
    T-&gt;right-&gt;right       = newNode(3);<br />
    //T-&gt;left               = newNode(10);<br />
    //T-&gt;left-&gt;left         = newNode(10);<br />
    //T-&gt;left-&gt;left-&gt;left  = newNode(4);<br />
    //T-&gt;left-&gt;left-&gt;right = newNode(6);<br />
    //T-&gt;left-&gt;left-&gt;left-&gt;right=newNode(30);<br />
     T-&gt;right-&gt;right=newNode(10);<br />
     T-&gt;right-&gt;right-&gt;left=newNode(4);<br />
     T-&gt;right-&gt;right-&gt;right=newNode(6);<br />
     T-&gt;right-&gt;right-&gt;left-&gt;right=newNode(30);</p>
<p>     struct node *S    = newNode(10);<br />
    S-&gt;right          = newNode(6);<br />
    S-&gt;left           = newNode(4);<br />
    S-&gt;left-&gt;right    = newNode(30);</p>
<p>    if( isSubtree(T, S) )<br />
        printf(&#8220;Tree S is subtree of tree T&#8221;);<br />
    else<br />
        printf(&#8220;Tree S is not a subtree of tree T&#8221;);</p>
<p>    return 0;<br />
}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-32358">
        <div id="dsq-comment-header-32358" class="dsq-comment-header">
            <cite id="dsq-cite-32358">
                <span id="dsq-author-user-32358">sp</span>
            </cite>
        </div>
        <div id="dsq-comment-body-32358" class="dsq-comment-body">
            <div id="dsq-comment-message-32358" class="dsq-comment-message"><p>With just one traversal you cannot reconstruct a tree. So only preorder is not sufficient to determine if the tree is subtree or not.<br />
<a href="http://stackoverflow.com/questions/12880718/how-many-traversals-need-to-be-known-to-construct-a-bst" rel="nofollow">http://stackoverflow.com/questions/12880718/how-many-traversals-need-to-be-known-to-construct-a-bst</a></p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-32296">
        <div id="dsq-comment-header-32296" class="dsq-comment-header">
            <cite id="dsq-cite-32296">
                <span id="dsq-author-user-32296">sassy</span>
            </cite>
        </div>
        <div id="dsq-comment-body-32296" class="dsq-comment-body">
            <div id="dsq-comment-message-32296" class="dsq-comment-message"><p>In your code checking first if the data at the node = data at the root of the smaller tree and then recursing if they are equal would reduce the no. of recursion calls massively.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-31335">
        <div id="dsq-comment-header-31335" class="dsq-comment-header">
            <cite id="dsq-cite-31335">
                <span id="dsq-author-user-31335">Guru</span>
            </cite>
        </div>
        <div id="dsq-comment-body-31335" class="dsq-comment-body">
            <div id="dsq-comment-message-31335" class="dsq-comment-message"><p>Please suggest comments over this code</p>
<p>public boolean isSubTree(BinaryTreeNode T, BinaryTreeNode S) {</p>
<p>		if (S == null) {</p>
<p>			return true;</p>
<p>		}</p>
<p>		if (T == null) {</p>
<p>			return false;</p>
<p>		}</p>
<p>		if (T.getData() == S.getData()) {</p>
<p>			return (isSubTree(T.getLeft(), S.getLeft()) &amp;&amp; isSubTree(</p>
<p>					T.getRight(), S.getRight()));</p>
<p>		} else {</p>
<p>			return (isSubTree(T.getLeft(), S) || isSubTree(T.getRight(), S));</p>
<p>		}</p>
<p>	}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-30458">
        <div id="dsq-comment-header-30458" class="dsq-comment-header">
            <cite id="dsq-cite-30458">
                <span id="dsq-author-user-30458">vamsi varanasi</span>
            </cite>
        </div>
        <div id="dsq-comment-body-30458" class="dsq-comment-body">
            <div id="dsq-comment-message-30458" class="dsq-comment-message"><p>What if we could find the root of the tree S in the Tree T and then check if the trees are identical it would reduce the complexity of checking for each and every node in tree T, assuming there are no duplicate values. would this approach work or am I missing something. </p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-30243">
        <div id="dsq-comment-header-30243" class="dsq-comment-header">
            <cite id="dsq-cite-30243">
                <span id="dsq-author-user-30243">pavansrinivas</span>
            </cite>
        </div>
        <div id="dsq-comment-body-30243" class="dsq-comment-body">
            <div id="dsq-comment-message-30243" class="dsq-comment-message"><p>Using level order in JAVA</p>
<p>Time complexity(O(m+n))</p>
<p>Space Complexity(O(m+n))</p>
<p><code><br />
boolean isSubtree(Node r2){<br />
		Node temp1 = root;<br />
		Queue q1 = new LinkedList();<br />
		q1.add(temp1);<br />
		while(!q1.isEmpty()){<br />
			temp1  = q1.poll();<br />
			if(temp1.i==r2.i){<br />
				return areIdentical(temp1, r2);<br />
			}<br />
			if(temp1.left!=null){<br />
				q1.add(temp1.left);<br />
			}<br />
			if(temp1.right!=null){<br />
				q1.add(temp1.right);<br />
			}<br />
		}<br />
		return false;<br />
	}<br />
	private boolean areIdentical(Node t1, Node t2){</p>
<p>		Queue q1 = new LinkedList();</p>
<p>		Queue q2 = new LinkedList();<br />
		Node temp1 = t1;<br />
		Node temp2 = t2;<br />
		q1.add(t1);<br />
		q2.add(t2);<br />
		while(!q1.isEmpty()&amp;!q2.isEmpty()){<br />
			temp1 = q1.poll();<br />
			temp2 = q2.poll();<br />
			if(temp1.i!=temp2.i){<br />
				return false;<br />
			}<br />
			else if(temp1.left==null&amp;&amp;temp2.left!=null||temp1.right==null&amp;&amp;temp2.right!=null){<br />
				return false;<br />
			}<br />
			if(temp1.left!=null){<br />
				q1.add(temp1.left);<br />
			}<br />
			if(temp1.right!=null){<br />
				q1.add(temp1.right);<br />
			}<br />
			if(temp2.left!=null){<br />
				q2.add(temp2.left);<br />
			}<br />
			if(temp2.right!=null){<br />
				q1.add(temp2.right);<br />
			}<br />
		}<br />
		if(q1.isEmpty()&amp;&amp;q2.isEmpty()){<br />
			return true;<br />
		}<br />
		else if(q1.isEmpty()&amp;&amp;!q2.isEmpty()){<br />
			return false;<br />
		}<br />
		else{<br />
			return true;<br />
		}<br />
	}<br />
</code></p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-30234">
        <div id="dsq-comment-header-30234" class="dsq-comment-header">
            <cite id="dsq-cite-30234">
                <span id="dsq-author-user-30234">Sambhav Sharma</span>
            </cite>
        </div>
        <div id="dsq-comment-body-30234" class="dsq-comment-body">
            <div id="dsq-comment-message-30234" class="dsq-comment-message"><p>In function areIdentical</p>
<p>shouldn&#8217;t the following code </p>
<p> return (root1-&gt;data == root2-&gt;data &amp;&amp; areIdentical(root1-&gt;left, root2-&gt;left) &amp;&amp; areIdentical(root1-&gt;right, root2-&gt;right) );</p>
<p>be changed to this:<br />
if(root1-&gt;data = root2-&gt;data)<br />
  {<br />
     if(areIdentical(root1-&gt;left,root2-&gt;left))<br />
        return areIdentical(root1-&gt;right,root2-&gt;right);<br />
     else<br />
        return 0;<br />
  }<br />
  else<br />
   return 0; </p>
<p>Maybe may understanding of the return statement is not clear, but I feel it will call for all the three statements and then do the AND of their results&#8230;</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-2" id="dsq-comment-30378">
        <div id="dsq-comment-header-30378" class="dsq-comment-header">
            <cite id="dsq-cite-30378">
                <span id="dsq-author-user-30378">Kk</span>
            </cite>
        </div>
        <div id="dsq-comment-body-30378" class="dsq-comment-body">
            <div id="dsq-comment-message-30378" class="dsq-comment-message"><p>The &amp;&amp; operator does not work that way. I think the name of the concept is short-circuit evaluation, where it will evaluate root1-&gt;data == root2-&gt;data first. If this is false, then it will not call areIdentical on root1 and root2&#8217;s children.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-28814">
        <div id="dsq-comment-header-28814" class="dsq-comment-header">
            <cite id="dsq-cite-28814">
                <span id="dsq-author-user-28814">Vivek</span>
            </cite>
        </div>
        <div id="dsq-comment-body-28814" class="dsq-comment-body">
            <div id="dsq-comment-message-28814" class="dsq-comment-message"><p>hi geeksforgeeks..</p>
<p>below is an optimized solution in O(n)..(not O(m*n).)</p>
<p>where is the size of the larger tree.</p>
<p>please go through this solution.</p>
<p><code></p>
<p>#include </p>
<p>#include </p>
<p>/* A binary tree node has data, left child and right child */</p>
<p>struct node</p>
<p>{</p>
<p>    int data;</p>
<p>    struct node* left;</p>
<p>    struct node* right;</p>
<p>};</p>
<p>int check_subtree(struct node *root1, struct node *root2, int *count)</p>
<p>{</p>
<p>	if(!root1 &amp;&amp; !root2)</p>
<p>	return 1;</p>
<p>	if(!root1 || !root2)</p>
<p>	return 0;</p>
<p>	if(*count == 0)</p>
<p>	{</p>
<p>		if(root1-&gt;data == root2-&gt;data )</p>
<p>		{</p>
<p>			*count= *count +1;</p>
<p>			return 1 &amp;&amp; check_subtree(root1-&gt;left,root2-&gt;left, count) &amp;&amp; check_subtree(root1-&gt;right, root2-&gt;right, count);</p>
<p>		}</p>
<p>		else</p>
<p>		 return check_subtree(root1-&gt;left, root2, count) || check_subtree(root1-&gt;right, root2, count);</p>
<p>	}</p>
<p>	else if(*count &gt; 0)</p>
<p>	{</p>
<p>		if(root1-&gt;data == root2-&gt;data)</p>
<p>		{</p>
<p>			*count= *count +1;</p>
<p>			return 1 &amp;&amp; check_subtree(root1-&gt;left, root2-&gt;left, count) &amp;&amp; check_subtree(root1-&gt;right, root2-&gt;right, count);</p>
<p>		}</p>
<p>		else</p>
<p>		 return 0;</p>
<p>    }</p>
<p>}</p>
<p>int isSubtree(struct node *root1, struct node *root2)</p>
<p>{</p>
<p>	int count = 0;</p>
<p>	return check_subtree(root1, root2, &amp;count);</p>
<p>}</p>
<p>struct node* newNode(int data)</p>
<p>{</p>
<p>    struct node* node =</p>
<p>        (struct node*)malloc(sizeof(struct node));</p>
<p>    node-&gt;data  = data;</p>
<p>    node-&gt;left  = NULL;</p>
<p>    node-&gt;right = NULL;</p>
<p>    return(node);</p>
<p>}</p>
<p>/* Driver program to test above function */</p>
<p>int main()</p>
<p>{</p>
<p>    /* Construct the following tree</p>
<p>              26</p>
<p>            /   </p>
<p>          10     3</p>
<p>        /         </p>
<p>      4      6      3</p>
<p>        30</p>
<p>    */</p>
<p>    struct node *T        = newNode(26);</p>
<p>    T-&gt;right              = newNode(3);</p>
<p>    T-&gt;right-&gt;right       = newNode(3);</p>
<p>    T-&gt;left               = newNode(10);</p>
<p>    T-&gt;left-&gt;left         = newNode(4);</p>
<p>    T-&gt;left-&gt;left-&gt;right  = newNode(30);</p>
<p>    T-&gt;left-&gt;right        = newNode(6);</p>
<p>    /* Construct the following tree</p>
<p>          10</p>
<p>        /    </p>
<p>      4      6</p>
<p>        30</p>
<p>    */</p>
<p>    struct node *S    = newNode(10);</p>
<p>    S-&gt;right          = newNode(6);</p>
<p>    S-&gt;left           = newNode(4);</p>
<p>    S-&gt;left-&gt;right    = newNode(30);</p>
<p>    int count =0;</p>
<p>    if( isSubtree(T, S) )</p>
<p>        printf("Tree S is subtree of tree T");</p>
<p>    else</p>
<p>        printf("Tree S is not a subtree of tree T");</p>
<p>    getchar();</p>
<p>    return 0;</p>
<p>}</p>
<p></code></p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-2" id="dsq-comment-30080">
        <div id="dsq-comment-header-30080" class="dsq-comment-header">
            <cite id="dsq-cite-30080">
                <span id="dsq-author-user-30080">dag</span>
            </cite>
        </div>
        <div id="dsq-comment-body-30080" class="dsq-comment-body">
            <div id="dsq-comment-message-30080" class="dsq-comment-message"><p>I think the complexity will be exponential because you are checking each permutation in recursive call.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-3" id="dsq-comment-30591">
        <div id="dsq-comment-header-30591" class="dsq-comment-header">
            <cite id="dsq-cite-30591">
                <span id="dsq-author-user-30591">Vivek</span>
            </cite>
        </div>
        <div id="dsq-comment-body-30591" class="dsq-comment-body">
            <div id="dsq-comment-message-30591" class="dsq-comment-message"><p>complexity is not exponential as each node is visited only once</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even depth-2" id="dsq-comment-30379">
        <div id="dsq-comment-header-30379" class="dsq-comment-header">
            <cite id="dsq-cite-30379">
                <span id="dsq-author-user-30379">Kk</span>
            </cite>
        </div>
        <div id="dsq-comment-body-30379" class="dsq-comment-body">
            <div id="dsq-comment-message-30379" class="dsq-comment-message"><p>You are not resetting the count. If you have a partial match, you should reset the count before returning false. Anyways, the reason g4g wrote the code in that particular way is to avoid maintaining another state variable. That is why they split the responsibility as:<br />
1) Checking if subtrees rooted at root1 and root2 are identical<br />
2) checking if T contains S as a subtree.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt depth-2" id="dsq-comment-34793">
        <div id="dsq-comment-header-34793" class="dsq-comment-header">
            <cite id="dsq-cite-34793">
                <span id="dsq-author-user-34793">nik</span>
            </cite>
        </div>
        <div id="dsq-comment-body-34793" class="dsq-comment-body">
            <div id="dsq-comment-message-34793" class="dsq-comment-message"><p>U are assuming that no value is repeating..which isn&#8217;t right</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-28677">
        <div id="dsq-comment-header-28677" class="dsq-comment-header">
            <cite id="dsq-cite-28677">
                <span id="dsq-author-user-28677">DarkProtocol</span>
            </cite>
        </div>
        <div id="dsq-comment-body-28677" class="dsq-comment-body">
            <div id="dsq-comment-message-28677" class="dsq-comment-message"><p>1) Check if root of subtree(S) found in Tree(T), if not found return false,or else proceed<br />
2) take two pointers, p1 points to root of S and p2 pointing to T, Check isidentical(p1,p2).</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-27849">
        <div id="dsq-comment-header-27849" class="dsq-comment-header">
            <cite id="dsq-cite-27849">
                <span id="dsq-author-user-27849">Bohemia</span>
            </cite>
        </div>
        <div id="dsq-comment-body-27849" class="dsq-comment-body">
            <div id="dsq-comment-message-27849" class="dsq-comment-message"><p>How&#8217;s this one ?<br />
1)get the Inorder of BST1=In1[]<br />
2)get the Inorder of BST2=In2[]<br />
3)Find occurence of In1[1] in In2[] (Binary Search) and Match the subsequent Values of Nodes: IF ALL MATCHED return TRUE else FALSE</p>
<p>should be O(n) n is no of nodes in larger BST</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-2" id="dsq-comment-29165">
        <div id="dsq-comment-header-29165" class="dsq-comment-header">
            <cite id="dsq-cite-29165">
                <span id="dsq-author-user-29165">Mammamia</span>
            </cite>
        </div>
        <div id="dsq-comment-body-29165" class="dsq-comment-body">
            <div id="dsq-comment-message-29165" class="dsq-comment-message"><p>Approach won&#8217;t work in all cases, as inorder of two different trees can be same.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt depth-2" id="dsq-comment-30203">
        <div id="dsq-comment-header-30203" class="dsq-comment-header">
            <cite id="dsq-cite-30203">
                <span id="dsq-author-user-30203">xxmajia</span>
            </cite>
        </div>
        <div id="dsq-comment-body-30203" class="dsq-comment-body">
            <div id="dsq-comment-message-30203" class="dsq-comment-message"><p>you need at least 2 order to construct a tree,<br />
so you can get inorder of both, then preorder or postorder of them again, then check 4 arrays</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-3" id="dsq-comment-30306">
        <div id="dsq-comment-header-30306" class="dsq-comment-header">
            <cite id="dsq-cite-30306">
                <span id="dsq-author-user-30306">Bohemia</span>
            </cite>
        </div>
        <div id="dsq-comment-body-30306" class="dsq-comment-body">
            <div id="dsq-comment-message-30306" class="dsq-comment-message"><p>yes ! if inorder and either pre or post order (one of these two ) are found in the bigger tree&#8217;s corresponding traversals, we can say that the smaller tree is contained in the larger tree .</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-27761">
        <div id="dsq-comment-header-27761" class="dsq-comment-header">
            <cite id="dsq-cite-27761">
                <span id="dsq-author-user-27761">zedus</span>
            </cite>
        </div>
        <div id="dsq-comment-body-27761" class="dsq-comment-body">
            <div id="dsq-comment-message-27761" class="dsq-comment-message"><p>Hmmm&#8230; I think there&#8217;s an issue with this solution.<br />
Inside the &#8220;areIdentical&#8221; function,<br />
there&#8217;s<br />
 &#8212;&#8211;<br />
if(root1 == NULL || root2 == NULL)<br />
return false;<br />
&#8212;&#8211;</p>
<p>which isn&#8217;t correct imho.</p>
<p>the big tree that we are testing &#8220;against&#8221; may contain MORE than the tree we are searching for.</p>
<p>for example, it&#8217;s fine if the tree &#8220;pattern&#8221; contains NULL at a certain node,<br />
but the big tree contains a real node there.<br />
We should return true in that case.</p>
<p>Might be an issue of definition, but that&#8217;s the only definition of subtree that i know.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-27399">
        <div id="dsq-comment-header-27399" class="dsq-comment-header">
            <cite id="dsq-cite-27399">
                <span id="dsq-author-user-27399">Whiskers</span>
            </cite>
        </div>
        <div id="dsq-comment-body-27399" class="dsq-comment-body">
            <div id="dsq-comment-message-27399" class="dsq-comment-message"><p>what if we do a traversal to find the root of S in T and then do a kind of inorder traversal to check ?<br />
T=node of where it the data equal to data of the root in tree S<br />
visit(t,s)<br />
{<br />
if(t-&gt;data!=s-&gt;data)<br />
return 0;<br />
if(s==null &amp;&amp; t==null)<br />
return 1;<br />
if(t==null)<br />
return 0;<br />
if(s==null)<br />
return true;<br />
if(visit(t-&gt;l,s-&gt;l))<br />
return (visit(t-&gt;r,s-&gt;r));<br />
}<br />
}<br />
main()<br />
{<br />
if(visit(t,s))<br />
cout&lt;&lt;&quot;its a subtree&quot;;<br />
else<br />
cout&lt;&lt;&quot;no subtree&quot;;<br />
}</p>
</div>
        </div>

    </li><!-- #comment-## -->
</li><!-- #comment-## -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-18732">
        <div id="dsq-comment-header-18732" class="dsq-comment-header">
            <cite id="dsq-cite-18732">
                <span id="dsq-author-user-18732">vivek</span>
            </cite>
        </div>
        <div id="dsq-comment-body-18732" class="dsq-comment-body">
            <div id="dsq-comment-message-18732" class="dsq-comment-message"><p>Code is doing the Pre Order traversal not In order Travel, correct?</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-geeksforgeeks bypostauthor even depth-2" id="dsq-comment-18733">
        <div id="dsq-comment-header-18733" class="dsq-comment-header">
            <cite id="dsq-cite-18733">
                <span id="dsq-author-user-18733">GeeksforGeeks</span>
            </cite>
        </div>
        <div id="dsq-comment-body-18733" class="dsq-comment-body">
            <div id="dsq-comment-message-18733" class="dsq-comment-message"><p>Thanks for pointing this out.  We have updated explanation.  Keep it up!</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment byuser comment-author-abhishek08aug odd alt thread-even depth-1" id="dsq-comment-18308">
        <div id="dsq-comment-header-18308" class="dsq-comment-header">
            <cite id="dsq-cite-18308">
                <span id="dsq-author-user-18308">abhishek08aug</span>
            </cite>
        </div>
        <div id="dsq-comment-body-18308" class="dsq-comment-body">
            <div id="dsq-comment-message-18308" class="dsq-comment-message"><p>Intelligent <img src="http://d2o58evtke57tz.cloudfront.net/wp-includes/images/smilies/icon_biggrin.gif" alt=":D" class="wp-smiley" /></p>
</div>
        </div>

    </li><!-- #comment-## -->
</li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-12004">
        <div id="dsq-comment-header-12004" class="dsq-comment-header">
            <cite id="dsq-cite-12004">
                <span id="dsq-author-user-12004">vaibhavbright</span>
            </cite>
        </div>
        <div id="dsq-comment-body-12004" class="dsq-comment-body">
            <div id="dsq-comment-message-12004" class="dsq-comment-message"><p>This solution takes O(n^2) time in worst case. We can simply store inorder and preorder traversals of both the trees and use KMP algorithm for pattern matching. Thus it would have time complexity of O(n).</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-12005">
        <div id="dsq-comment-header-12005" class="dsq-comment-header">
            <cite id="dsq-cite-12005">
                <span id="dsq-author-user-12005">vaibhavbright</span>
            </cite>
        </div>
        <div id="dsq-comment-body-12005" class="dsq-comment-body">
            <div id="dsq-comment-message-12005" class="dsq-comment-message"><p>okay.. the current solution is taking O(n * m) time with the two trees of n &amp; m no. of nodes</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-akshat215 even depth-2" id="dsq-comment-20050">
        <div id="dsq-comment-header-20050" class="dsq-comment-header">
            <cite id="dsq-cite-20050">
                <span id="dsq-author-user-20050">akshat gupta</span>
            </cite>
        </div>
        <div id="dsq-comment-body-20050" class="dsq-comment-body">
            <div id="dsq-comment-message-20050" class="dsq-comment-message"><p>&#8212;&#8212;&#8211; T&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211; S<br />
&#8212;&#8212;&#8211; 0&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212; 12<br />
&#8212;&#8212;-/&#8212;\&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-/&#8212;\<br />
&#8212;&#8212;0&#8212;&#8211;12&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-11&#8212;9<br />
&#8212;&#8211;/-.&#8212;/&#8212;\&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;/<br />
&#8212;-.&#8211;. 11&#8212;-9&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;8<br />
&#8212;-.&#8211;.&#8212;&#8212;/&#8212;\&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;- &#8211;<br />
&#8212;-.&#8211;.&#8212;&#8211;8&#8212;&#8211;1&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;<br />
  T<br />
Preorder: &#8230;.. 12,11,9,8,1<br />
Inorder: &#8230;&#8230; 11,12,8,9,1<br />
  S<br />
Preorder: 12,11,9,8<br />
Inorder: 11,12,8,9</p>
<p> your Idea will Show S as a subtree of T<br />
  But,the tree structure Conradicts it..<br />
  Hence,it FAILS</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-3" id="dsq-comment-27457">
        <div id="dsq-comment-header-27457" class="dsq-comment-header">
            <cite id="dsq-cite-27457">
                <span id="dsq-author-user-27457">Siddharth Bora</span>
            </cite>
        </div>
        <div id="dsq-comment-body-27457" class="dsq-comment-body">
            <div id="dsq-comment-message-27457" class="dsq-comment-message"><p>I think we can do this by KMPing on all the 3 orders &#8211; inorder, preorder, postorder.<br />
In that way this should succeed</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-4" id="dsq-comment-27614">
        <div id="dsq-comment-header-27614" class="dsq-comment-header">
            <cite id="dsq-cite-27614">
                <span id="dsq-author-user-27614">Jatin Kumar</span>
            </cite>
        </div>
        <div id="dsq-comment-body-27614" class="dsq-comment-body">
            <div id="dsq-comment-message-27614" class="dsq-comment-message"><p>No, I guess it won&#8217;t work. For example the bigger tree is node(a, node(a, a, a), node(a, a, a)) and the smaller tree is simply node(a, null, node(a, null, a))</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-11311">
        <div id="dsq-comment-header-11311" class="dsq-comment-header">
            <cite id="dsq-cite-11311">
                <span id="dsq-author-user-11311">Doctor</span>
            </cite>
        </div>
        <div id="dsq-comment-body-11311" class="dsq-comment-body">
            <div id="dsq-comment-message-11311" class="dsq-comment-message"><pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
<p>int areIdentical(node* root1,node* root2)<br />
{<br />
    if(root1==NULL&amp;&amp;root2==NULL)<br />
    return 1;</p>
<p>    if(root1==NULL||root2==NULL)<br />
    return 0;</p>
<p>    return (root1-&gt;data==root2-&gt;data<br />
            &amp;&amp; areIdentical(root1-&gt;lchild,root2-&gt;lchild)|| areIdentical(root1-&gt;rchild,root2-&gt;rchild));<br />
}<br />
/*</p>
<p>           26                         26                 10<br />
         /    \                        \                /  \<br />
        10     29          or           29       or    4    16<br />
       /  \   /  \                     /  \<br />
      4    16 28  35                  28   35<br />
       \<br />
        8<br />
           T                            s1               s2</p>
<p>I think s1 and s2 are subtree of T:If yes then your code doesnot give write answer and suggested code for right answer is shown above.<br />
*/</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-10035">
        <div id="dsq-comment-header-10035" class="dsq-comment-header">
            <cite id="dsq-cite-10035">
                <span id="dsq-author-user-10035">Pavan Dittakavi</span>
            </cite>
        </div>
        <div id="dsq-comment-body-10035" class="dsq-comment-body">
            <div id="dsq-comment-message-10035" class="dsq-comment-message"><p>How about the below piece of code, this is just a pseudo code, but it should work. If you guys find anything wrong or require any clarifications..please drop by <img src="http://d2o58evtke57tz.cloudfront.net/wp-includes/images/smilies/icon_smile.gif" alt=":)" class="wp-smiley" /></p>
<pre> <code language="C">
logical isSubset( root , root' )
{
  if( root == NULL &amp;&amp; root' == NULL )
  return true;


  if( root == NULL || root' == NULL )
  return true;

  if( root-&gt;data == root'-&gt;data )
  return true &amp;&amp; isSubset( root-&gt;left,root'-&gt;left ) &amp;&amp; isSubset(root-&gt;right,root'-&gt;right );

  return isSubset( root-&gt;left,root' ) || isSubset( root-&gt;right,root' );
}
}
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-25307">
        <div id="dsq-comment-header-25307" class="dsq-comment-header">
            <cite id="dsq-cite-25307">
                <span id="dsq-author-user-25307">Pawan</span>
            </cite>
        </div>
        <div id="dsq-comment-body-25307" class="dsq-comment-body">
            <div id="dsq-comment-message-25307" class="dsq-comment-message"><p>if( root-&gt;data == root&#8217;-&gt;data )<br />
return true &amp;&amp; isSubset( root-&gt;left,root&#8217;-&gt;left ) &amp;&amp; isSubset(root-&gt;right,root&#8217;-&gt;right );<br />
<br />
yes, this sounds correct to me, because and operator will not check the further condition if the first condition itself is wrong.</p>
<p>Sorry I could not understand the below condition. Why we require this one?<br />
return isSubset( root-&gt;left,root&#8217; ) || isSubset( root-&gt;right,root&#8217; );</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-8313">
        <div id="dsq-comment-header-8313" class="dsq-comment-header">
            <cite id="dsq-cite-8313">
                <span id="dsq-author-user-8313">rocky</span>
            </cite>
        </div>
        <div id="dsq-comment-body-8313" class="dsq-comment-body">
            <div id="dsq-comment-message-8313" class="dsq-comment-message"><p>(1) Do serialization of both the trees (using preorder traversal). O(n)<br />
(2) Then apply KMP algorithm to find if a substring exists. O(n)</p>
<p>Total Time Complexity : O(n)</p>
<pre> <code language="C">
void serialize(tree *t, string &amp;s) {
       if(!t) { s = s + &quot;#&quot;; return; } 
       s = s + t-&gt;val + '0';
       serialize(t-&gt;left, s);
       serialize(t-&gt;right, s);
       return; 
}
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-7200">
        <div id="dsq-comment-header-7200" class="dsq-comment-header">
            <cite id="dsq-cite-7200">
                <span id="dsq-author-user-7200">Bharti</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7200" class="dsq-comment-body">
            <div id="dsq-comment-message-7200" class="dsq-comment-message"><p>Why do we need to go through all the nodes and not stop at first match. As we also have the addresses of the nodes , we can always compare the addresses. For eg: lets say value at root of S is 10, now we started traversing T(any method) and as soon as we find 10 we will check whether pointers current.left and current.right matches to nodes S.left and S.right.<br />
Moreover, solution suggested by you can be used to check whether a tree (S here) is equivalent to any subtree of tree T or not.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-2" id="dsq-comment-32295">
        <div id="dsq-comment-header-32295" class="dsq-comment-header">
            <cite id="dsq-cite-32295">
                <span id="dsq-author-user-32295">mccullum</span>
            </cite>
        </div>
        <div id="dsq-comment-body-32295" class="dsq-comment-body">
            <div id="dsq-comment-message-32295" class="dsq-comment-message"><p>i got the same doubt if a tree is a subtree why not just compare pointers!! traverse T and look for a node with same pointer as S..!!</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt thread-even depth-1" id="dsq-comment-6887">
        <div id="dsq-comment-header-6887" class="dsq-comment-header">
            <cite id="dsq-cite-6887">
                <span id="dsq-author-user-6887">Himanshu</span>
            </cite>
        </div>
        <div id="dsq-comment-body-6887" class="dsq-comment-body">
            <div id="dsq-comment-message-6887" class="dsq-comment-message"><p>I think I have a better time complexity algo.<br />
If the bigger tree has n elements and smaller(potential subtree of the bigger one) has m elements, then the algo stated here is of O(m*n) time complexity.</p>
<p>Now what we can do is define a modified pre-order as follows:<br />
print root<br />
if(left) : go to left recursively<br />
else : print &#8216;L'(or any other thing to notify left null reached)   //for leaf<br />
if(right) : go to right recursively<br />
else : print &#8216;R'(any other thing to notify right null reached)   //for leaf</p>
<p>This makes sure that no two different trees will have same modified-pre order output</p>
<p>or looking it the other way , given a modified pre-order output I can uniquely define my binary tree.</p>
<p>So algo is as follows :<br />
1) Store the modified pre-order of both the trees inside a string. space will be O(m) &amp; O(n)<br />
2)Do a Knuth Morris Pratt (KMP) algo to find is smaller string a sub-string of bigger.</p>
<p>Thus the algo is basically convert each tree as a string and finding if smaller is sub-string of bigger or not.  time complexity O(m+n)<br />
Please let me know if I am making any mistake any where <img src="http://d2o58evtke57tz.cloudfront.net/wp-includes/images/smilies/icon_smile.gif" alt=":)" class="wp-smiley" /></p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-2" id="dsq-comment-6917">
        <div id="dsq-comment-header-6917" class="dsq-comment-header">
            <cite id="dsq-cite-6917">
                <span id="dsq-author-user-6917">dejavu</span>
            </cite>
        </div>
        <div id="dsq-comment-body-6917" class="dsq-comment-body">
            <div id="dsq-comment-message-6917" class="dsq-comment-message"><p>/* Consider the following trees<br />
              26<br />
            /   \<br />
          10     3<br />
        /         \        pre-order: 26 10 4 3 8 5 7<br />
      4            8<br />
                  / \<br />
                 5   7</p>
<p>             and</p>
<p>             26<br />
            /<br />
          10             pre-order: 26 10 4 3<br />
        /    \<br />
      4        3</p>
<p>Although the smaller string is a sub-string of the bigger one, the Tree is not sub-tree of another. </p>
<p>But I think it will work with BST.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-3" id="dsq-comment-6918">
        <div id="dsq-comment-header-6918" class="dsq-comment-header">
            <cite id="dsq-cite-6918">
                <span id="dsq-author-user-6918">dejavu</span>
            </cite>
        </div>
        <div id="dsq-comment-body-6918" class="dsq-comment-body">
            <div id="dsq-comment-message-6918" class="dsq-comment-message"><p>err. the trees did not appear properly.<br />
tree 1:<br />
root = 26<br />
left child of root = 10<br />
left child of 10 = 4<br />
right child of 26 = 3</p>
<p>tree 2:<br />
root = 26<br />
left child of root = 10<br />
left child of 10 = 4<br />
right child of 10 = 3</p>
<p>the two trees are not same but their pre-order traversals are same.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-4" id="dsq-comment-6927">
        <div id="dsq-comment-header-6927" class="dsq-comment-header">
            <cite id="dsq-cite-6927">
                <span id="dsq-author-user-6927">Himanshu</span>
            </cite>
        </div>
        <div id="dsq-comment-body-6927" class="dsq-comment-body">
            <div id="dsq-comment-message-6927" class="dsq-comment-message"><p>You probably did not get the meaning of &#8220;modified&#8221; pre-order, as I have written in my post, the mod pre-order of 1st would be : 26 10 4 L R R 3 L 8 5 L R 7 L R</p>
<p>and for the second would be :<br />
26 10 4 L R 3 L R R</p>
<p>So the smaller is not sub tree of bigger.</p>
<p>If however your second tree was :<br />
root = 3<br />
right child of root = 8<br />
left child of 8 = 5<br />
right child of 8 = 7</p>
<p>The &#8220;modified&#8221; pre-order would then be :<br />
3 L 8 5 L R 7 L R<br />
Now this clearly is a substring of the main tree.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-5" id="dsq-comment-7895">
        <div id="dsq-comment-header-7895" class="dsq-comment-header">
            <cite id="dsq-cite-7895">
                <span id="dsq-author-user-7895">brinpage</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7895" class="dsq-comment-body">
            <div id="dsq-comment-message-7895" class="dsq-comment-message"><p>@himanshu: just consider this case</p>
<p>      4<br />
     / \<br />
    3   5<br />
   /<br />
  6<br />
(436LR5LR)<br />
and<br />
    3<br />
   / \<br />
  6   5<br />
(36LR5LR)<br />
but its not a subtree of the first one.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even depth-5" id="dsq-comment-7896">
        <div id="dsq-comment-header-7896" class="dsq-comment-header">
            <cite id="dsq-cite-7896">
                <span id="dsq-author-user-7896">brinpage</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7896" class="dsq-comment-body">
            <div id="dsq-comment-message-7896" class="dsq-comment-message"><p>i was wrong.. for first tree its<br />
436LRR5LR..<br />
i think ur approach is CORRECT!</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt depth-2" id="dsq-comment-7122">
        <div id="dsq-comment-header-7122" class="dsq-comment-header">
            <cite id="dsq-cite-7122">
                <span id="dsq-author-user-7122">James Bond</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7122" class="dsq-comment-body">
            <div id="dsq-comment-message-7122" class="dsq-comment-message"><p>One small note : the characters representing L &amp; R here should be different from any data in the trees considered.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-3" id="dsq-comment-7123">
        <div id="dsq-comment-header-7123" class="dsq-comment-header">
            <cite id="dsq-cite-7123">
                <span id="dsq-author-user-7123">James Bond</span>
            </cite>
        </div>
        <div id="dsq-comment-body-7123" class="dsq-comment-body">
            <div id="dsq-comment-message-7123" class="dsq-comment-message"><p>Also, inorder and postorder should also work.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt depth-2" id="dsq-comment-11906">
        <div id="dsq-comment-header-11906" class="dsq-comment-header">
            <cite id="dsq-cite-11906">
                <span id="dsq-author-user-11906">Tushar</span>
            </cite>
        </div>
        <div id="dsq-comment-body-11906" class="dsq-comment-body">
            <div id="dsq-comment-message-11906" class="dsq-comment-message"><p>This approach is perfect. Moderator pls put this as a standard solution</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-3" id="dsq-comment-11908">
        <div id="dsq-comment-header-11908" class="dsq-comment-header">
            <cite id="dsq-cite-11908">
                <span id="dsq-author-user-11908">Kartik</span>
            </cite>
        </div>
        <div id="dsq-comment-body-11908" class="dsq-comment-body">
            <div id="dsq-comment-message-11908" class="dsq-comment-message"><p>@Tushar: Thanks for providing inputs. We will take  look into this approach and add it to the original post.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt depth-2" id="dsq-comment-13805">
        <div id="dsq-comment-header-13805" class="dsq-comment-header">
            <cite id="dsq-cite-13805">
                <span id="dsq-author-user-13805">Anuj</span>
            </cite>
        </div>
        <div id="dsq-comment-body-13805" class="dsq-comment-body">
            <div id="dsq-comment-message-13805" class="dsq-comment-message"><p>I am not able to make out correct output in this case:</p>
<p>tree 1:<br />
root = 1<br />
L(1) = 2<br />
R(1) = 3<br />
L(2) = 4<br />
R(2) = 5<br />
L(4) = 6<br />
R(4) = 7<br />
L(5) = 8<br />
R(5) = 9</p>
<p>Tree 2:<br />
root = 2<br />
L(2) = 4<br />
L(4) = 6<br />
R(5) = 7</p>
<p>I think the output as per your suggested  algo would be:<br />
tree 1:<br />
1246LR7LR58LR9LR3LR</p>
<p>tree 2:<br />
246LR7LRR</p>
<p>These doesn&#8217;t match&#8230;please explain if there is any mistake</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-aygul even depth-3" id="dsq-comment-15666">
        <div id="dsq-comment-header-15666" class="dsq-comment-header">
            <cite id="dsq-cite-15666">
                <span id="dsq-author-user-15666">aygul</span>
            </cite>
        </div>
        <div id="dsq-comment-body-15666" class="dsq-comment-body">
            <div id="dsq-comment-message-15666" class="dsq-comment-message"><p>These should not match!<br />
tree2 is not a sub tree of tree1. Because</p>
<p>&#8220;A subtree of a tree T is a tree S consisting of a node in T and all of its descendants in T.&#8221;</p>
<p>tree2 is consistinf of a node in tree 1 but not all ofits descandants&#8230;</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment odd alt depth-2" id="dsq-comment-18317">
        <div id="dsq-comment-header-18317" class="dsq-comment-header">
            <cite id="dsq-cite-18317">
http://www.cse.iitb.ac.in/~saha/                <span id="dsq-author-user-18317">subhasish</span>
            </cite>
        </div>
        <div id="dsq-comment-body-18317" class="dsq-comment-body">
            <div id="dsq-comment-message-18317" class="dsq-comment-message"><p>If the subtree appears at the bottom of original tree then this (or any traversal) will work. But if the subtree appears in the internal structure of the original tree, then this will not work.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-5498">
        <div id="dsq-comment-header-5498" class="dsq-comment-header">
            <cite id="dsq-cite-5498">
                <span id="dsq-author-user-5498">Srava Vurapalli</span>
            </cite>
        </div>
        <div id="dsq-comment-body-5498" class="dsq-comment-body">
            <div id="dsq-comment-message-5498" class="dsq-comment-message"><p>bool BinarySearchTree::ISSubTree(BinarySearchTree&amp; rootMainTree, BinarySearchTree&amp; rootSubTree)<br />
{<br />
    if(rootMainTree.Root() == NULL || rootSubTree.Root() == NULL)<br />
    {<br />
        return false;<br />
    }</p>
<p>    Node* p = rootMainTree.Search(rootSubTree.Root()-&gt;value);</p>
<p>    if(p == NULL)<br />
    {<br />
        return false;<br />
    }<br />
    else<br />
    {<br />
        return Compare(p,rootSubTree.Root());<br />
    }<br />
}</p>
<p>bool BinarySearchTree::Compare(Node* rootMainTree, Node* rootSubTree)<br />
{<br />
    if(rootMainTree == NULL &amp;&amp; rootSubTree == NULL)<br />
    {<br />
        return true;<br />
    }<br />
    else if( (rootMainTree == NULL || rootSubTree)<br />
    {<br />
        return false;<br />
    }<br />
    else<br />
    {<br />
        if(rootMainTree-&gt;value == rootSubTree-&gt;value)<br />
        {<br />
            return BinarySearchTree::Compare(rootMainTree-&gt;left,rootSubTree-&gt;left) &amp;&amp;<br />
                  BinarySearchTree::Compare(rootMainTree-&gt;right,rootSubTree-&gt;right);<br />
        }</p>
<p>        return false;</p>
<p>    }</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-5499">
        <div id="dsq-comment-header-5499" class="dsq-comment-header">
            <cite id="dsq-cite-5499">
                <span id="dsq-author-user-5499">Sravan Vurapalli</span>
            </cite>
        </div>
        <div id="dsq-comment-body-5499" class="dsq-comment-body">
            <div id="dsq-comment-message-5499" class="dsq-comment-message"><p>bool BinarySearchTree::ISSubTree(BinarySearchTree&amp; rootMainTree, BinarySearchTree&amp; rootSubTree)<br />
{<br />
    if(rootMainTree.Root() == NULL || rootSubTree.Root() == NULL)<br />
    {<br />
        return false;<br />
    }</p>
<p>   //Search for the element and stop if you find that if first tree.<br />
    Node* p = rootMainTree.Search(rootSubTree.Root()-&gt;value);</p>
<p>    if(p == NULL)<br />
    {<br />
        return false;<br />
    }<br />
    else<br />
    {<br />
        return Compare(p,rootSubTree.Root());<br />
    }<br />
}</p>
<p>bool BinarySearchTree::Compare(Node* rootMainTree, Node* rootSubTree)<br />
{<br />
    if(rootMainTree == NULL &amp;&amp; rootSubTree == NULL)<br />
    {<br />
        return true;<br />
    }<br />
    else if( (rootMainTree == NULL || rootSubTree == NULL)<br />
    {<br />
        return false;<br />
    }<br />
    else<br />
    {<br />
        if(rootMainTree-&gt;value == rootSubTree-&gt;value)<br />
        {<br />
            return BinarySearchTree::Compare(rootMainTree-&gt;left,rootSubTree-&gt;left) &amp;&amp;<br />
                  BinarySearchTree::Compare(rootMainTree-&gt;right,rootSubTree-&gt;right);<br />
        }</p>
<p>        return false;</p>
<p>    }<br />
}<br />
Thanks And Regards,<br />
Sravan Vurapalli.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-5468">
        <div id="dsq-comment-header-5468" class="dsq-comment-header">
            <cite id="dsq-cite-5468">
                <span id="dsq-author-user-5468">Algorist</span>
            </cite>
        </div>
        <div id="dsq-comment-body-5468" class="dsq-comment-body">
            <div id="dsq-comment-message-5468" class="dsq-comment-message"><p>Please find below my code, and I find it really clean. Please let me know on this.</p>
<p>Also, i have one query and that is if the small tree is NULL(i.e. no nodes) and Big tree contains some nodes, then the the function should return true or false.. Please comment.</p>
<p>Thanks.</p>
<pre> <code language="C"></code> </pre>
<p>int isSubTree(Node* bRoot, Node* sRoot)<br />
{<br />
	if (bRoot == NULL &amp;&amp; sRoot == NULL) //If both the trees are NULL<br />
		return 1;</p>
<p>	if (bRoot == NULL &amp;&amp; sRoot != NULL)	//If Big Tree is NULL and Small Tree is not NULL<br />
		return 0;</p>
<p>	if (bRoot != NULL &amp;&amp; sRoot == NULL) // If Big Tree has some nodes, and small tree is null, then small tree is a subtree of that kind of trees.<br />
		return 1;</p>
<p>	if(bRoot-&gt;info == sRoot-&gt;info)	// if same nodes found, then left and right subtrees should also be a SUBTREE<br />
		return isSubTree(bRoot-&gt;left, sRoot-&gt;left) &amp;&amp; isSubTree(bRoot-&gt;right, sRoot-&gt;right);</p>
<p>//Else Either left or right of that node is a SUBTREE<br />
	return (isSubTree(bRoot-&gt;left, sRoot) || isSubTree(bRoot-&gt;right, sRoot));<br />
}</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt thread-odd thread-alt depth-1" id="dsq-comment-4978">
        <div id="dsq-comment-header-4978" class="dsq-comment-header">
            <cite id="dsq-cite-4978">
                <span id="dsq-author-user-4978">viji</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4978" class="dsq-comment-body">
            <div id="dsq-comment-message-4978" class="dsq-comment-message"><pre> <code language="C">
#include &quot;malloc.h&quot;
#include &quot;stdio.h&quot;
#include &quot;conio.h&quot;
struct node
{
    node *left;
    node *right;
    int data;
};
void insert(node **p, int d)
{
    if(*p == NULL)
    {
        *p = (node *)malloc(sizeof(node));
        (*p)-&gt;left = NULL;
        (*p)-&gt;right = NULL;
        (*p)-&gt;data = d;
    }
    else
    {
        if((*p)-&gt;data &gt;= d)
            insert(&amp;((*p)-&gt;left), d);
        else
            insert(&amp;((*p)-&gt;right), d);
    }
}
void check(node *p, node *q, int *is)
{
    if(*is)
    {
    if((p == NULL) &amp;&amp; (q == NULL))
    {  
        return;
    }
    else if((p == NULL) || (q==NULL))
    {
        *is = 0;
        return;
    }
    if(p-&gt;data == q-&gt;data)
    {
        check(p-&gt;left, q-&gt;left, is);
        check(p-&gt;right, q-&gt;right, is);
    }
    else
    {
        *is = 0;
    }
    }
}
void sub_tree(node *p, node *q)
{
    int issubtree = 1;
    if(p == NULL)
        return;
    if(p-&gt;data == q-&gt;data)
    {
        check(p, q, &amp;issubtree);
        if(issubtree == 1)
        {
            printf(&quot;the tree is subtree&quot;);
            return;
        }
        
    }
    else
    {
        sub_tree(p-&gt;left, q); 
        sub_tree(p-&gt;right, q);
    }
}
int main(int argc, _TCHAR* argv[])
{

    node *p = NULL;
    node *q = NULL;
    insert(&amp;p, 7);
    insert(&amp;p, 4);
    insert(&amp;p, 10);
    insert(&amp;p, 3);
    insert(&amp;p, 6);
    insert(&amp;p, 9);
    insert(&amp;p, 11);
    insert(&amp;p, 5);
    insert(&amp;q, 10);
    insert(&amp;q, 9);
    insert(&amp;q, 11);
    sub_tree(p, q);
    return 0;
}
</code> </pre>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-4958">
        <div id="dsq-comment-header-4958" class="dsq-comment-header">
            <cite id="dsq-cite-4958">
http://ahmetalpbalkan.com                <span id="dsq-author-user-4958">ahmet alp balkan</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4958" class="dsq-comment-body">
            <div id="dsq-comment-message-4958" class="dsq-comment-message"><p>Another awesome solution, write preorder traversal of a tree as &#8220;string&#8221;  (I am serious) and then do it for parent tree to. then use String.contains method! </p>
<p>Liked it? (:</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-5792">
        <div id="dsq-comment-header-5792" class="dsq-comment-header">
            <cite id="dsq-cite-5792">
                <span id="dsq-author-user-5792">Mohit Ahuja</span>
            </cite>
        </div>
        <div id="dsq-comment-body-5792" class="dsq-comment-body">
            <div id="dsq-comment-message-5792" class="dsq-comment-message"><p>That might work for Binary Search Trees but not for Binary Trees:for e.g.-</p>
<p>S=3<br />
   \<br />
    3<br />
and<br />
T=  3<br />
   /<br />
  3<br />
would generate same string on preorder traversal but they surely S is not a subtree of T.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-4952">
        <div id="dsq-comment-header-4952" class="dsq-comment-header">
            <cite id="dsq-cite-4952">
                <span id="dsq-author-user-4952">viresh</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4952" class="dsq-comment-body">
            <div id="dsq-comment-message-4952" class="dsq-comment-message"><p>u could improvise the code by finding the root of subtree in the given tree and then using isIndentical() function&#8230;</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-5296">
        <div id="dsq-comment-header-5296" class="dsq-comment-header">
            <cite id="dsq-cite-5296">
                <span id="dsq-author-user-5296">Dreamer</span>
            </cite>
        </div>
        <div id="dsq-comment-body-5296" class="dsq-comment-body">
            <div id="dsq-comment-message-5296" class="dsq-comment-message"><p>This logic seems correct to me. Any reason why can&#8217;t we use this.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-even depth-1" id="dsq-comment-4938">
        <div id="dsq-comment-header-4938" class="dsq-comment-header">
            <cite id="dsq-cite-4938">
                <span id="dsq-author-user-4938">guest</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4938" class="dsq-comment-body">
            <div id="dsq-comment-message-4938" class="dsq-comment-message"><p>The algorithm&#8217;s time complexity is linear to the number of nodes. Another linear algorithm can be printing nodes of both trees in preorder into two arrays and check if one array if subarray of another using dynamic programming.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-kartik odd alt depth-2" id="dsq-comment-4942">
        <div id="dsq-comment-header-4942" class="dsq-comment-header">
            <cite id="dsq-cite-4942">
                <span id="dsq-author-user-4942">kartik</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4942" class="dsq-comment-body">
            <div id="dsq-comment-message-4942" class="dsq-comment-message"><p>Time complexity of the solution given in post is O(mn) where m is the number of nodes in S and n is the number of nodes in T.</p>
<p>Time complexity of the inorder and postorder matching solution is O(n), but this solution doesn&#8217;t handle the case of duplicates.  See following comments SDiZ and me.  Please correct me if I am wrong.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment even thread-odd thread-alt depth-1" id="dsq-comment-4923">
        <div id="dsq-comment-header-4923" class="dsq-comment-header">
            <cite id="dsq-cite-4923">
                <span id="dsq-author-user-4923">SDiZ</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4923" class="dsq-comment-body">
            <div id="dsq-comment-message-4923" class="dsq-comment-message"><p>I guess you can print both trees in both inorder and postorder, and check if those of tree S are substring of tree T.</p>
<p>generate inorder/postorder &#8211; O(n)<br />
substring using KMP &#8211; O(n)</p>
</div>
        </div>

    <ul class="children">
    <li class="comment odd alt depth-2" id="dsq-comment-4924">
        <div id="dsq-comment-header-4924" class="dsq-comment-header">
            <cite id="dsq-cite-4924">
                <span id="dsq-author-user-4924">SDiZ</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4924" class="dsq-comment-body">
            <div id="dsq-comment-message-4924" class="dsq-comment-message"><p>provided that no tree nodes have duplicated label, that is.<br />
Your tree have two &#8220;3&#8221;, so it does not work.</p>
<p>Sorry.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment even depth-3" id="dsq-comment-4929">
        <div id="dsq-comment-header-4929" class="dsq-comment-header">
            <cite id="dsq-cite-4929">
                <span id="dsq-author-user-4929">Bugaboo</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4929" class="dsq-comment-body">
            <div id="dsq-comment-message-4929" class="dsq-comment-message"><p>Why would a duplicated node label fail? Woudn&#8217;t a string matching algorithm work nevertheless?</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-kartik odd alt depth-4" id="dsq-comment-4930">
        <div id="dsq-comment-header-4930" class="dsq-comment-header">
            <cite id="dsq-cite-4930">
                <span id="dsq-author-user-4930">kartik</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4930" class="dsq-comment-body">
            <div id="dsq-comment-message-4930" class="dsq-comment-message"><p>Consider the following example.  </p>
<p>Main Tree T</p>
<pre>
              26
            /   \
          10     3
        /    \     \
      4       6      3
       \
        30
</pre>
<p>Tree S</p>
<pre>
    3
   /
  3 
</pre>
<p>The inorder and postorder traversals of S are substrings of inorder and postorder traversals of T, but S is not a subtree of T.</p>
<p>If we don&#8217;t have duplciates then this is a nice O(N) approach.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-mb even depth-5" id="dsq-comment-5016">
        <div id="dsq-comment-header-5016" class="dsq-comment-header">
            <cite id="dsq-cite-5016">
                <span id="dsq-author-user-5016">MB</span>
            </cite>
        </div>
        <div id="dsq-comment-body-5016" class="dsq-comment-body">
            <div id="dsq-comment-message-5016" class="dsq-comment-message"><p>kartik,<br />
Even without duplicates the inorder and postorder traversal strings will fail, in some cases.<br />
You should use the preorder and inorder traversals to test for equivalence.<br />
The constraint of no duplicates still applies. Using preorder and inorder still fails with duplicates.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment byuser comment-author-mb odd alt depth-2" id="dsq-comment-4963">
        <div id="dsq-comment-header-4963" class="dsq-comment-header">
            <cite id="dsq-cite-4963">
                <span id="dsq-author-user-4963">MB</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4963" class="dsq-comment-body">
            <div id="dsq-comment-message-4963" class="dsq-comment-message"><p>SDiZ,</p>
<p>You cant use the inorder and postorder traversal strings of a binary tree to test for equivalence. Consider the following binary trees.</p>
<p>Tree T</p>
<pre>
        26
        / 
       10
       / \
      4   6
      /
     30
</pre>
<p>Tree S</p>
<pre>
       10
       / \
      4   6

Tree T                       Tree S
inorder:   30,4,10,6,26     4,10,6
postorder: 30,4,6,10,26     4,6,10
</pre>
<p>A substring comparison is going to return true, which is not correct. Tree S is not a subtree of Tree T. You need to use the preorder and inorder traversals. Plus, as already noted, each node needs to be uniquely labeled. You can&#8217;t have duplicate values in the binary tree.</p>
<pre>
Tree T                  Tree S
preorder: 26,10,4,30,6   10,4,6
</pre>
<p>So a substring search of the preorder string of T with the preorder string of S correctly returns false.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment byuser comment-author-mb even thread-even depth-1" id="dsq-comment-4921">
        <div id="dsq-comment-header-4921" class="dsq-comment-header">
            <cite id="dsq-cite-4921">
                <span id="dsq-author-user-4921">MB</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4921" class="dsq-comment-body">
            <div id="dsq-comment-message-4921" class="dsq-comment-message"><p>Your areIdentical(struct node * root1, struct node *root2) function has a subtle bug in it. The easiest way to see it is to build a truth table:</p>
<p>  r1    r2        action<br />
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-<br />
1  true  true    continue<br />
2  false true    return false &#8211; r1 has terminated before r2<br />
3  true  false   return true  &#8211; r2 has terminated before r1<br />
4  false false   return true  &#8211; r2 and r1 have terminated </p>
<p>Your logic covers cases 1,2 and 4 but misses the third case. This can happen when the r1 tree has more nodes, but all of the nodes of r2 have matched up to that point, so you have a match, the r1 tree just has more nodes, which is ok. It is also seems this would be the more common case. Your logic is only going to match sub-trees that have the same number of leaf nodes.</p>
<pre> <code language="C">
bool areIdentical(struct node * root1, struct node *root2) {
    if (!root2) return true;
    if (!root1) return false
 
    return (root1-&gt;data == root2-&gt;data   &amp;&amp;
            areIdentical(root1-&gt;left, root2-&gt;left) &amp;&amp;
            areIdentical(root1-&gt;right, root2-&gt;right) );
}
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-sandeep odd alt depth-2" id="dsq-comment-4922">
        <div id="dsq-comment-header-4922" class="dsq-comment-header">
            <cite id="dsq-cite-4922">
http://geeksforgeeks.org/                <span id="dsq-author-user-4922">Sandeep</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4922" class="dsq-comment-body">
            <div id="dsq-comment-message-4922" class="dsq-comment-message"><p>@MB:  I think the following condition handles the case 3 as well.</p>
<pre> <code language="C">
    if(root1 == NULL || root2 == NULL)
        return false;</code> </pre>
<p>Could you please provide an example tree for which it doesn&#8217;t seem to work.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-mb even depth-3" id="dsq-comment-4931">
        <div id="dsq-comment-header-4931" class="dsq-comment-header">
            <cite id="dsq-cite-4931">
                <span id="dsq-author-user-4931">MB</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4931" class="dsq-comment-body">
            <div id="dsq-comment-message-4931" class="dsq-comment-message"><p>It doesn&#8217;t take a complex tree to show where this fails. For case 3, root1=true and root2=false, which should return true, not false as you have indicated. </p>
<pre> <code language="C">
/* 
example tree that returns false incorrectly,
the root2 tree is obviously a subtree of  the  root1 tree.

       root1          root2
       A              A
      /
     B 
*/
if (root1==NULL || root2==NULL)
  return false;
</code> </pre>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-sandeep odd alt depth-4" id="dsq-comment-4932">
        <div id="dsq-comment-header-4932" class="dsq-comment-header">
            <cite id="dsq-cite-4932">
http://geeksforgeeks.org/                <span id="dsq-author-user-4932">Sandeep</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4932" class="dsq-comment-body">
            <div id="dsq-comment-message-4932" class="dsq-comment-message"><p>@MB:  Please take a closer look at the definition of subtree.  In your example, root2 is not a subtree of root1.</p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-mb even depth-5" id="dsq-comment-4939">
        <div id="dsq-comment-header-4939" class="dsq-comment-header">
            <cite id="dsq-cite-4939">
                <span id="dsq-author-user-4939">MB</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4939" class="dsq-comment-body">
            <div id="dsq-comment-message-4939" class="dsq-comment-message"><p>Sandeep, the definition says, </p>
<p>&#8220;A subtree of a tree T is a tree S consisting of a node in T and all of its descendants in T.&#8221; </p>
<p>The root node of root2, or A, and all of its descendants are in the root1 tree, which makes it a subtree of root1.</p>
<p>What am I missing? How is the tree root2 not a subtree of root1?</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-kartik odd alt depth-5" id="dsq-comment-4940">
        <div id="dsq-comment-header-4940" class="dsq-comment-header">
            <cite id="dsq-cite-4940">
                <span id="dsq-author-user-4940">kartik</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4940" class="dsq-comment-body">
            <div id="dsq-comment-message-4940" class="dsq-comment-message"><p>@MB: root2 doesn&#8217;t contain the descendant B of A in root1.  So it is not a subtree.  Following are the only possible subtrees of root1.</p>
<p>  A<br />
 /<br />
B</p>
<p>  B</p>
<p>  NULL (Empty Tree)</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-mb even depth-5" id="dsq-comment-4943">
        <div id="dsq-comment-header-4943" class="dsq-comment-header">
            <cite id="dsq-cite-4943">
                <span id="dsq-author-user-4943">MB</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4943" class="dsq-comment-body">
            <div id="dsq-comment-message-4943" class="dsq-comment-message"><p>Kartik, </p>
<p>If you have the set {A,B}, you&#8217;re saying that {B} and {null} are subsets but {A} isn&#8217;t a subset?</p>
<p>That is not correct,{A},{B} and {null} are all subsets of the set {A,B}. </p>
<p>Which is similar to saying that if you have the string &#8220;AB&#8221; The string &#8220;B&#8221; is a substring of &#8220;AB&#8221; but the string &#8220;A&#8221; is not a substring of &#8220;AB&#8221;</p>
<p>Mmmmmm, interesting.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt depth-5" id="dsq-comment-5035">
        <div id="dsq-comment-header-5035" class="dsq-comment-header">
            <cite id="dsq-cite-5035">
                <span id="dsq-author-user-5035">Bugaboo</span>
            </cite>
        </div>
        <div id="dsq-comment-body-5035" class="dsq-comment-body">
            <div id="dsq-comment-message-5035" class="dsq-comment-message"><p>Sorry, if my previous post did not have the figure right. This is what I meant:<br />
&#8211; Tree &#8216;T&#8217; has &#8216;A&#8217; as root and &#8216;B&#8217; as its left child<br />
&#8211; Tree &#8216;S&#8217; has &#8216;A&#8217; as root and &#8216;B&#8217; as its right child</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
    <li class="comment byuser comment-author-kartik even depth-4" id="dsq-comment-4947">
        <div id="dsq-comment-header-4947" class="dsq-comment-header">
            <cite id="dsq-cite-4947">
                <span id="dsq-author-user-4947">kartik</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4947" class="dsq-comment-body">
            <div id="dsq-comment-message-4947" class="dsq-comment-message"><p>@MB:  Subsets and subtrees are different things.  Sets don&#8217;t have structure or hierarchy, but trees do have.  And if you look at the definition, it says </p>
<p>&#8220;A subtree of a tree T is a tree S consisting of a node in T <strong>and all of its descendants in T</strong>.&#8221; </p>
<p>In case of &#8220;A&#8221;, its descendant &#8220;B&#8221; is not present, so only &#8220;A&#8221; cannot be a subtree.  I hope I clarified this time <img src="http://d2o58evtke57tz.cloudfront.net/wp-includes/images/smilies/icon_smile.gif" alt=":)" class="wp-smiley" /></p>
</div>
        </div>

    <ul class="children">
    <li class="comment byuser comment-author-mb odd alt depth-5" id="dsq-comment-4949">
        <div id="dsq-comment-header-4949" class="dsq-comment-header">
            <cite id="dsq-cite-4949">
                <span id="dsq-author-user-4949">MB</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4949" class="dsq-comment-body">
            <div id="dsq-comment-message-4949" class="dsq-comment-message"><p>Kartik,</p>
<p>You&#8217;re correct sets don&#8217;t have structure or hierarchy, but they do have well defined rules about what is and isn&#8217;t a subset.</p>
<p>Let&#8217;s try this. The definition says:</p>
<p>Let T == root1 and S == root2</p>
<p>Break it down statement by statement:</p>
<p>&#8220;A subtree of a tree T is a tree S consisting of a node in T&#8221;</p>
<p>Does the node A in S exist in T? YES</p>
<p>&#8220;and all of its descendants in T&#8221;</p>
<p>Do all of the descendants of A in S exist in T? YES </p>
<p>So root2 is a subtree of root1.</p>
<p>Based on that simple definition I don&#8217;t see how you could logically come to any other conclusion.<br />
I guess will just have to agree to disagree. Best of luck to you.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-kartik even depth-5" id="dsq-comment-4950">
        <div id="dsq-comment-header-4950" class="dsq-comment-header">
            <cite id="dsq-cite-4950">
                <span id="dsq-author-user-4950">kartik</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4950" class="dsq-comment-body">
            <div id="dsq-comment-message-4950" class="dsq-comment-message"><p>@MB:<br />
Read the definition following way:</p>
<p>&#8220;A subtree of a tree T is a tree S consisting of a node of T and all of the node&#8217;s descendants which are there in T&#8221;  </p>
<p>In the example, S contains A but not descendatnts of A which are there in T.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-mb odd alt depth-5" id="dsq-comment-4961">
        <div id="dsq-comment-header-4961" class="dsq-comment-header">
            <cite id="dsq-cite-4961">
                <span id="dsq-author-user-4961">MB</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4961" class="dsq-comment-body">
            <div id="dsq-comment-message-4961" class="dsq-comment-message"><p>Kartik</p>
<p>I took a closer look at this and I now concur with you. I came across a couple of alternate definitions that helped me to understand. The first is, &#8220;Two trees are equivalent if they both have the same topology and if the objects contained in corresponding nodes are equal&#8221; and &#8220;The collection of nodes that become unreachable from the root when an edge is cut is called a subtree. In addition the entire tree is considered as a subtree. As a consequence there is one subtree associated with each node in the tree.&#8221; </p>
<p>One interesting thing came from this. I don&#8217;t think you can use a preorder and postorder traversal string to compare binary trees for equivalence. You need the preorder and inorder, plus the nodes need to be uniquely labeled, no duplicate keys</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-mb even depth-5" id="dsq-comment-4962">
        <div id="dsq-comment-header-4962" class="dsq-comment-header">
            <cite id="dsq-cite-4962">
                <span id="dsq-author-user-4962">MB</span>
            </cite>
        </div>
        <div id="dsq-comment-body-4962" class="dsq-comment-body">
            <div id="dsq-comment-message-4962" class="dsq-comment-message"><p>Kartik,</p>
<p>What I intended to say was that was that I don&#8217;t think you can use the inorder and postorder traversals to test binary trees for equivalence, you need to use the preorder and inorder traversals.</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment odd alt depth-5" id="dsq-comment-5034">
        <div id="dsq-comment-header-5034" class="dsq-comment-header">
            <cite id="dsq-cite-5034">
                <span id="dsq-author-user-5034">Bugaboo</span>
            </cite>
        </div>
        <div id="dsq-comment-body-5034" class="dsq-comment-body">
            <div id="dsq-comment-message-5034" class="dsq-comment-message"><p>I am confused. Does a sub-tree mean it preserves the structure as well?</p>
<pre>
   A (T)       A (S)
  /             \
 B               B
</pre>
<p>Is &#8216;S&#8217; a sub-tree of &#8216;T&#8217;?</p>
<p>&#8211; The above code would say it is not (which I feel is correct)<br />
&#8211; Doing an in-order and pre-order traversal would say it is (which I feel is incorrect)</p>
</div>
        </div>

    </li><!-- #comment-## -->
    <li class="comment byuser comment-author-mb even depth-5" id="dsq-comment-5036">
        <div id="dsq-comment-header-5036" class="dsq-comment-header">
            <cite id="dsq-cite-5036">
                <span id="dsq-author-user-5036">MB</span>
            </cite>
        </div>
        <div id="dsq-comment-body-5036" class="dsq-comment-body">
            <div id="dsq-comment-message-5036" class="dsq-comment-message"><p>Bugaboo,</p>
<p>Yes, subtrees preserve structure, they are topologically equivalent.</p>
<p>You apparently didn&#8217;t do the traversals correctly.</p>
<p>Tree T<br />
preorder:  a,b<br />
inorder:   b,a</p>
<p>Tree S<br />
preorder:  a,b<br />
inorder:   a,b</p>
<p>Once you have the correct traversals it&#8217;s obvious that Tree S is not a subtree of Tree T.</p>
</div>
        </div>

    </li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
            </ul>


        </div>

    </div>

<script type="text/javascript">
var disqus_url = 'http://www.geeksforgeeks.org/check-if-a-binary-tree-is-subtree-of-another-binary-tree/';
var disqus_identifier = '13942 http://geeksforgeeks.org/?p=13942';
var disqus_container_id = 'disqus_thread';
var disqus_shortname = 'geeksforgeeks';
var disqus_title = "Check if a binary tree is subtree of another binary tree | Set 1";
var disqus_config_custom = window.disqus_config;
var disqus_config = function () {
    /*
    All currently supported events:
    onReady: fires when everything is ready,
    onNewComment: fires when a new comment is posted,
    onIdentify: fires when user is authenticated
    */
    
    
    this.language = '';
    
    if (disqus_config_custom) {
        disqus_config_custom.call(this);
    }
};

(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>

			</div>
	
					
			
			

		</div> <!-- end post -->	

<br></br>
	
</div> <!-- end content -->

<ul id="sidebar">
	<li id="text-19" class="widget widget_text">			<div class="textwidget"><script>
  (function() {
    var cx = '009682134359037907028:tj6eafkv_be';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//www.google.com/cse/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>

<style type="text/css">
  .gsc-control-cse {
    font-family: "Trebuchet MS", sans-serif;
    border-color: #E1F3DA;
    background-color: #E1F3DA;
  }
  input.gsc-input {
    border-color: #94CC7A;
  }
  input.gsc-search-button {
    border-color: #94CC7A;
    background-color: #AADA92;
  }
  .gsc-tabHeader.gsc-tabhInactive {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gsc-tabHeader.gsc-tabhActive {
    border-color: #A9DA92;
    background-color: #A9DA92;
  }
  .gsc-tabsArea {
    border-color: #A9DA92;
  }
  .gsc-webResult.gsc-result {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gsc-webResult.gsc-result:hover {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gs-webResult.gs-result a.gs-title:link,
  .gs-webResult.gs-result a.gs-title:link b {
    color: #009900;
  }
  .gs-webResult.gs-result a.gs-title:visited,
  .gs-webResult.gs-result a.gs-title:visited b {
    color: #009900;
  }
  .gs-webResult.gs-result a.gs-title:hover,
  .gs-webResult.gs-result a.gs-title:hover b {
    color: #003300;
  }
  .gs-webResult.gs-result a.gs-title:active,
  .gs-webResult.gs-result a.gs-title:active b {
    color: #009900;
  }
  .gsc-cursor-page {
    color: #009900;
  }
  a.gsc-trailing-more-results:link {
    color: #009900;
  }
  .gs-webResult.gs-result .gs-snippet {
    color: #454545;
  }
  .gs-webResult.gs-result .gs-visibleUrl {
    color: #33cc00;
  }
  .gs-webResult.gs-result .gs-visibleUrl-short {
    color: #33cc00;
  }
  .gs-webResult.gs-result .gs-visibleUrl-short {
    display: none;
  }
  .gs-webResult.gs-result .gs-visibleUrl-long {
    display: block;
  }
  .gsc-cursor-box {
    border-color: #A9DA92;
  }
  .gsc-results .gsc-cursor-page {
    border-color: #A9DA92;
    background-color: #FFFFFF;
  }
  .gsc-results .gsc-cursor-page.gsc-cursor-current-page {
    border-color: #A9DA92;
    background-color: #A9DA92;
  }
  .gs-promotion.gs-result {
    border-color: #94CC7A;
    background-color: #CBE8B4;
  }
  .gs-promotion.gs-result a.gs-title:link {
    color: #0066CC;
  }
  .gs-promotion.gs-result a.gs-title:visited {
    color: #0066CC;
  }
  .gs-promotion.gs-result a.gs-title:hover {
    color: #0066CC;
  }
  .gs-promotion.gs-result a.gs-title:active {
    color: #0066CC;
  }
  .gs-promotion.gs-result .gs-snippet {
    color: #454545;
  }
  .gs-promotion.gs-result .gs-visibleUrl,
  .gs-promotion.gs-result .gs-visibleUrl-short {
    color: #815FA7;
  }
</style>    </div>
		</li>
<li id="text-9" class="widget widget_text">			<div class="textwidget"><div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=138031159685820";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>

<div class="fb-like-box" data-href="https://www.facebook.com/pages/GeeksforGeeks/316764689022" data-width="250" data-height="170" data-colorscheme="light" data-show-faces="true" data-header="false" data-stream="false" data-show-border="false"></div></div>
		</li>
<li id="text-18" class="widget widget_text">			<div class="textwidget"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LargeRectangleSide -->
<ins class="adsbygoogle"
     style="display:inline-block;width:336px;height:280px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="1884636833"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
		</li>
<li id="text-13" class="widget widget_text">			<div class="textwidget"><ul><li><a href="http://www.geeksforgeeks.org/category/interview-experiences/">Interview Experiences</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/advance-data-structures">Advanced Data Structures</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/dynamic-programming">Dynamic Programming</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/Greedy-Algorithm/">Greedy Algorithms</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/backtracking">Backtracking</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/pattern-searching">Pattern Searching</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/divide-and-conquer">Divide & Conquer</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/MathematicalAlgo">Mathematical Algorithms</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/recursion">Recursion</a></li>
<li><a href="http://www.geeksforgeeks.org/tag/geometric-algorithms/">Geometric Algorithms</a></li>
</ul></div>
		</li>
<li id="text-17" class="widget widget_text">			<div class="textwidget"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big 300x600 Sidebar -->
<ins class="adsbygoogle"
     style="display:inline-block;width:300px;height:600px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="4402736037"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
		</li>
<li id="text-14" class="widget widget_text"><h2 class="widgettitle">Popular Posts</h2>
			<div class="textwidget"><ul>
<li><a href="http://www.geeksforgeeks.org/write-a-c-program-to-print-all-permutations-of-a-given-string/">  All permutations of a given string </a></li>
<li><a href="http://www.geeksforgeeks.org/memory-layout-of-c-program/"> Memory Layout of C Programs</a> </li>
<li><a href="http://www.geeksforgeeks.org/understanding-extern-keyword-in-c/"> Understanding extern keyword in C</a> </li>
<li><a href="http://www.geeksforgeeks.org/median-of-two-sorted-arrays/">Median of two sorted arrays</a> </li>
<li><a href="http://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/"> Tree traversal without recursion and without stack! </a></li>
<li><a href="http://www.geeksforgeeks.org/structure-member-alignment-padding-and-data-packing/"> Structure Member Alignment, Padding and Data Packing</a> </li>
<li><a href="http://www.geeksforgeeks.org/write-a-function-to-get-the-intersection-point-of-two-linked-lists/"> Intersection point of two Linked Lists</a> </li>
<li><a href="http://www.geeksforgeeks.org/lowest-common-ancestor-in-a-binary-search-tree/"> Lowest Common Ancestor in a BST.</span></a> </li>
<li><a href="http://www.geeksforgeeks.org/a-program-to-check-if-a-binary-tree-is-bst-or-not/"> Check if a binary tree is BST or not</a> </li>
<li><a href="http://www.geeksforgeeks.org/sorted-linked-list-to-balanced-bst/"> Sorted Linked List to Balanced BST</a></li>
</ul></div>
		</li>
<li id="text-3" class="widget widget_text">			<div class="textwidget"><a href="https://twitter.com/GeeksforGeeks" class="twitter-follow-button" data-show-count="false">Follow @GeeksforGeeks</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>         


<!-- GOOGLE FEEDBURNER BUTTON-->
<a href="http://feeds.feedburner.com/Geeksforgeeks" title="Subscribe to my feed" rel="alternate" type="application/rss+xml"><img src="http://www.feedburner.com/fb/images/pub/feed-icon32x32.png" alt="" style="border:0"/></a><a href="http://feeds.feedburner.com/Geeksforgeeks" title="Subscribe to my feed" rel="alternate" type="application/rss+xml">Subscribe</a>

</div>
		</li>
<li id="text-21" class="widget widget_text"><h2 class="widgettitle">Recent Comments</h2>
			<div class="textwidget"><script type="text/javascript" src="http://geeksforgeeks.disqus.com//recent_comments_widget.js?num_items=6&hide_avatars=1&excerpt_length=50&hide_mods=0"></script></div>
		</li>
<li id="text-22" class="widget widget_text">			<div class="textwidget"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LinkAd -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:90px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="2606115235"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LinkAd -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:90px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="2606115235"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- LinkAd -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:90px"
     data-ad-client="ca-pub-9465609616171866"
     data-ad-slot="2606115235"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
		</li>

</ul>					  
		<div class="clear"></div>

		<div id="footer">
		
		    <div class="xhtml">
                        @geeksforgeeks, <a href="http://creativecommons.org/licenses/by-nc-nd/2.5/in/deed.en_US" title="Valid XHTML Strict 1.0">Some rights reserved</a>  <a href="http://www.geeksforgeeks.org/about/contact-us/"> &nbsp; &nbsp; &nbsp; &nbsp;Contact Us!</a>

		    </div>
		    
		    <div class="credits">
			  Powered by <a href="http://wordpress.org">WordPress </a> &amp; <a href="http://mootools.net/" title="Mootools JavaScript Framework">MooTools</a>, customized by geeksforgeeks team </div>
			  
		   <div class="clear"></div>						                            
		   
		</div> <!--end footer-->  
        
		        <script type="text/javascript">
        // <![CDATA[
        var disqus_shortname = 'geeksforgeeks';
        (function () {
            var nodes = document.getElementsByTagName('span');
            for (var i = 0, url; i < nodes.length; i++) {
                if (nodes[i].className.indexOf('dsq-postid') != -1) {
                    nodes[i].parentNode.setAttribute('data-disqus-identifier', nodes[i].getAttribute('rel'));
                    url = nodes[i].parentNode.href.split('#', 1);
                    if (url.length == 1) { url = url[0]; }
                    else { url = url[1]; }
                    nodes[i].parentNode.href = url + '#disqus_thread';
                }
            }
            var s = document.createElement('script'); 
            s.async = true;
            s.type = 'text/javascript';
            s.src = '//' + disqus_shortname + '.disqus.com/count.js';
            (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
        }());
        // ]]>
        </script>
        <script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/scripts/shCore.js?ver=3.0.9'></script>
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/scripts/shBrushCpp.js?ver=3.0.9'></script>
<script type='text/javascript'>
	(function(){
		var corecss = document.createElement('link');
		var themecss = document.createElement('link');
		var corecssurl = "http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/styles/shCore.css?ver=3.0.9";
		if ( corecss.setAttribute ) {
				corecss.setAttribute( "rel", "stylesheet" );
				corecss.setAttribute( "type", "text/css" );
				corecss.setAttribute( "href", corecssurl );
		} else {
				corecss.rel = "stylesheet";
				corecss.href = corecssurl;
		}
		document.getElementsByTagName("head")[0].insertBefore( corecss, document.getElementById("syntaxhighlighteranchor") );
		var themecssurl = "http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/styles/shThemeDefault.css?ver=3.0.9";
		if ( themecss.setAttribute ) {
				themecss.setAttribute( "rel", "stylesheet" );
				themecss.setAttribute( "type", "text/css" );
				themecss.setAttribute( "href", themecssurl );
		} else {
				themecss.rel = "stylesheet";
				themecss.href = themecssurl;
		}
		//document.getElementById("syntaxhighlighteranchor").appendChild(themecss);
		document.getElementsByTagName("head")[0].insertBefore( themecss, document.getElementById("syntaxhighlighteranchor") );
	})();
	SyntaxHighlighter.config.strings.expandSource = '+ expand source';
	SyntaxHighlighter.config.strings.help = '?';
	SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
	SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
	SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
	SyntaxHighlighter.defaults['gutter'] = false;
	SyntaxHighlighter.defaults['pad-line-numbers'] = true;
	SyntaxHighlighter.defaults['toolbar'] = false;
	SyntaxHighlighter.all();
</script>
<script type='text/javascript' src='http://d2o58evtke57tz.cloudfront.net/wp-content/plugins/bbpress/templates/default/js/editor.js?ver=2.5.4-5380'></script>
				  
		</div> <!--end wrapper-->
        <div id="ajaxSpinner"></div> <!--For AJAX spinner holder-->
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-12148232-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
	</body>

</html>
<!-- Dynamic page generated in 0.244 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2014-11-27 23:23:41 -->

<!-- Compression = gzip -->
<!-- super cache -->